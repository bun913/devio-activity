{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACllCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACppBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACj+EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5OA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACngBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzlCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACh6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACraA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7lDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACl9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACppCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7qEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5FA;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACRA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;;;;ACAA;AACA;;;;AEDA;AACA;AACA;AACA","sources":["../webpack://lapras-card-readme/./lib/lib/fetchActivity.js","../webpack://lapras-card-readme/./lib/lib/getActionParams.js","../webpack://lapras-card-readme/./lib/lib/updateContent.js","../webpack://lapras-card-readme/./lib/main.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/command.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/core.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/file-command.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/path-utils.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/summary.js","../webpack://lapras-card-readme/./node_modules/@actions/core/lib/utils.js","../webpack://lapras-card-readme/./node_modules/@actions/github/lib/context.js","../webpack://lapras-card-readme/./node_modules/@actions/github/lib/github.js","../webpack://lapras-card-readme/./node_modules/@actions/github/lib/internal/utils.js","../webpack://lapras-card-readme/./node_modules/@actions/github/lib/utils.js","../webpack://lapras-card-readme/./node_modules/@actions/http-client/lib/auth.js","../webpack://lapras-card-readme/./node_modules/@actions/http-client/lib/index.js","../webpack://lapras-card-readme/./node_modules/@actions/http-client/lib/proxy.js","../webpack://lapras-card-readme/./node_modules/@octokit/auth-token/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/core/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/endpoint/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/graphql/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/plugin-paginate-rest/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/request-error/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/@octokit/request/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/before-after-hook/index.js","../webpack://lapras-card-readme/./node_modules/before-after-hook/lib/add.js","../webpack://lapras-card-readme/./node_modules/before-after-hook/lib/register.js","../webpack://lapras-card-readme/./node_modules/before-after-hook/lib/remove.js","../webpack://lapras-card-readme/./node_modules/deprecation/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/is-plain-object/dist/is-plain-object.js","../webpack://lapras-card-readme/./node_modules/node-fetch/lib/index.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/tr46/index.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js","../webpack://lapras-card-readme/./node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js","../webpack://lapras-card-readme/./node_modules/once/once.js","../webpack://lapras-card-readme/./node_modules/playwright-core/index.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/androidServerImpl.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/browserServerImpl.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/accessibility.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/android.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/artifact.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/browser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/browserContext.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/browserType.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/cdpSession.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/channelOwner.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/clientHelper.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/clientInstrumentation.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/connection.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/consoleMessage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/coverage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/dialog.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/download.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/electron.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/elementHandle.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/events.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/fetch.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/fileChooser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/frame.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/harRouter.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/input.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/jsHandle.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/jsonPipe.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/localUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/locator.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/network.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/page.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/playwright.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/selectors.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/stream.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/tracing.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/types.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/video.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/waiter.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/worker.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/client/writableStream.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/common/debugLogger.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/common/errors.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/common/socksProxy.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/common/timeoutSettings.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/generated/consoleApiSource.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/generated/injectedScriptSource.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/generated/recorderSource.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/generated/utilityScriptSource.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/image_tools/colorUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/image_tools/compare.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/image_tools/imageChannel.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/image_tools/stats.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/inProcessFactory.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/inprocess.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/protocol/debug.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/protocol/serializers.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/protocol/transport.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/protocol/validator.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/protocol/validatorPrimitives.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/remote/playwrightConnection.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/remote/playwrightServer.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/accessibility.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/android/android.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/android/backendAdb.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/artifact.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/browser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/browserContext.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/browserType.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/chromium.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/chromiumSwitches.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crAccessibility.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crApp.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crBrowser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crConnection.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crCoverage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crDevTools.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crDragDrop.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crExecutionContext.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crInput.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crNetworkManager.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crPage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crPdf.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/crServiceWorker.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/defaultFontFamilies.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/chromium/videoRecorder.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/console.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/cookieStore.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/debugController.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/debugger.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/deviceDescriptors.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dialog.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/androidDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/artifactDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/browserContextDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/browserDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/browserTypeDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/cdpSessionDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/consoleMessageDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/debugControllerDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/dialogDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/dispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/electronDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/elementHandlerDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/frameDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/jsHandleDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/jsonPipeDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/localUtilsDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/networkDispatchers.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/pageDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/playwrightDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/selectorsDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/streamDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/tracingDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dispatchers/writableStreamDispatcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/dom.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/download.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/electron/electron.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/electron/loader.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/fetch.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/fileChooser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffAccessibility.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffBrowser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffConnection.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffInput.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/ffPage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/firefox/firefox.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/formData.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/frames.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/happy-eyeballs.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/har/harRecorder.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/har/harTracer.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/helper.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/index.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/input.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/instrumentation.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/isomorphic/cssParser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/isomorphic/cssTokenizer.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/isomorphic/locatorGenerators.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/isomorphic/locatorParser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/isomorphic/selectorParser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/isomorphic/utilityScriptSerializers.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/javascript.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/macEditingCommands.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/network.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/page.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/pipeTransport.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/playwright.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/progress.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/protocolError.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/codeGenerator.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/csharp.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/java.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/javascript.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/language.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/python.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/recorderApp.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/recorderUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/recorder/utils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/registry/browserFetcher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/registry/dependencies.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/registry/index.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/registry/nativeDeps.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/screenshotter.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/selectors.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/socksInterceptor.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/trace/recorder/tracing.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/transport.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/types.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/usKeyboardLayout.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/webkit.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkAccessibility.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkBrowser.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkConnection.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkInput.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkPage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/webkit/wkWorkers.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/third_party/diff_match_patch.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/third_party/pixelmatch.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/ascii.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/comparators.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/crypto.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/debug.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/env.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/eventsHelper.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/fileUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/glob.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/headers.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/hostPlatform.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/httpServer.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/index.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/isomorphic/locatorUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/isomorphic/stringUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/linuxUtils.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/manualPromise.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/mimeType.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/multimap.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/network.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/processLauncher.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/rtti.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/spawnAsync.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/stackTrace.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/task.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/time.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/timeoutRunner.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/userAgent.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/zipFile.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utils/zones.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utilsBundle.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/utilsBundleImpl.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/zipBundle.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/zipBundleImpl.js","../webpack://lapras-card-readme/./node_modules/playwright/index.js","../webpack://lapras-card-readme/./node_modules/tunnel/index.js","../webpack://lapras-card-readme/./node_modules/tunnel/lib/tunnel.js","../webpack://lapras-card-readme/./node_modules/universal-user-agent/dist-node/index.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/index.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/md5.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/nil.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/parse.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/regex.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/rng.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/sha1.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/stringify.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/v1.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/v3.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/v35.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/v4.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/v5.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/validate.js","../webpack://lapras-card-readme/./node_modules/uuid/dist/version.js","../webpack://lapras-card-readme/./node_modules/wrappy/wrappy.js","../webpack://lapras-card-readme/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://lapras-card-readme/./node_modules/playwright-core/lib/server/registry/ sync","../webpack://lapras-card-readme/external node-commonjs \"assert\"","../webpack://lapras-card-readme/external node-commonjs \"buffer\"","../webpack://lapras-card-readme/external node-commonjs \"child_process\"","../webpack://lapras-card-readme/external node-commonjs \"constants\"","../webpack://lapras-card-readme/external node-commonjs \"crypto\"","../webpack://lapras-card-readme/external node-commonjs \"dns\"","../webpack://lapras-card-readme/external node-commonjs \"events\"","../webpack://lapras-card-readme/external node-commonjs \"fs\"","../webpack://lapras-card-readme/external node-commonjs \"http\"","../webpack://lapras-card-readme/external node-commonjs \"https\"","../webpack://lapras-card-readme/external node-commonjs \"inspector\"","../webpack://lapras-card-readme/external node-commonjs \"module\"","../webpack://lapras-card-readme/external node-commonjs \"net\"","../webpack://lapras-card-readme/external node-commonjs \"os\"","../webpack://lapras-card-readme/external node-commonjs \"path\"","../webpack://lapras-card-readme/external node-commonjs \"punycode\"","../webpack://lapras-card-readme/external node-commonjs \"readline\"","../webpack://lapras-card-readme/external node-commonjs \"stream\"","../webpack://lapras-card-readme/external node-commonjs \"tls\"","../webpack://lapras-card-readme/external node-commonjs \"tty\"","../webpack://lapras-card-readme/external node-commonjs \"url\"","../webpack://lapras-card-readme/external node-commonjs \"util\"","../webpack://lapras-card-readme/external node-commonjs \"zlib\"","../webpack://lapras-card-readme/webpack/bootstrap","../webpack://lapras-card-readme/webpack/runtime/hasOwnProperty shorthand","../webpack://lapras-card-readme/webpack/runtime/compat","../webpack://lapras-card-readme/webpack/before-startup","../webpack://lapras-card-readme/webpack/startup","../webpack://lapras-card-readme/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Activity = void 0;\nconst path_1 = require(\"path\");\nconst fs_1 = require(\"fs\");\nconst playwright_1 = require(\"playwright\");\nclass Activity {\n    constructor(authorID) {\n        this.URL = 'https://dev.classmethod.jp/author';\n        this.SAVE_DIR = 'developersio';\n        this.authorID = authorID;\n    }\n    download() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `${this.URL}/${this.authorID}`;\n            const browser = yield playwright_1.chromium.launch({ headless: true });\n            const page = yield browser.newPage();\n            yield page.goto(url);\n            yield page.locator('.apexcharts-menu-icon').click();\n            const downloadPromise = page.waitForEvent('download');\n            yield page.locator('.exportSVG').click();\n            const download = yield downloadPromise;\n            (0, fs_1.mkdirSync)(this.SAVE_DIR, { recursive: true });\n            const savePath = (0, path_1.join)(this.SAVE_DIR, `${this.authorID}.svg`);\n            yield download.saveAs(savePath);\n            yield browser.close();\n            return savePath;\n        });\n    }\n}\nexports.Activity = Activity;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getActionParams = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nfunction getActionParams() {\n    const authorID = core.getInput('AUTHOR_ID');\n    const token = core.getInput('GH_TOKEN');\n    return {\n        authorID,\n        token\n    };\n}\nexports.getActionParams = getActionParams;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateContent = void 0;\nconst github = __importStar(require(\"@actions/github\"));\nconst updateContent = (params) => __awaiter(void 0, void 0, void 0, function* () {\n    const octokit = github.getOctokit(params.ghToken);\n    yield octokit.rest.repos.createOrUpdateFileContents({\n        repo: github.context.repo.repo,\n        owner: github.context.repo.owner,\n        path: params.filePath,\n        message: `update ${params.filePath}`,\n        content: Buffer.from(params.filePath).toString('base64'),\n        committer: {\n            name: 'github-actions[bot]',\n            email: '41898282+github-actions[bot]@users.noreply.github.com'\n        },\n    });\n});\nexports.updateContent = updateContent;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst getActionParams_1 = require(\"./lib/getActionParams\");\nconst fetchActivity_1 = require(\"./lib/fetchActivity\");\nconst updateContent_1 = require(\"./lib/updateContent\");\nconst core = __importStar(require(\"@actions/core\"));\nfunction run() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const actionParams = (0, getActionParams_1.getActionParams)();\n            const activity = new fetchActivity_1.Activity(actionParams.authorID);\n            const filePath = yield activity.download();\n            (0, updateContent_1.updateContent)({ ghToken: actionParams.token, filePath });\n        }\n        catch (error) {\n            if (error instanceof Error)\n                core.setFailed(error);\n        }\n    });\n}\nrun();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst uuid_1 = require(\"uuid\");\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst fs_1 = require(\"fs\");\nconst os_1 = require(\"os\");\nclass Context {\n    /**\n     * Hydrate the context from the environment\n     */\n    constructor() {\n        var _a, _b, _c;\n        this.payload = {};\n        if (process.env.GITHUB_EVENT_PATH) {\n            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {\n                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));\n            }\n            else {\n                const path = process.env.GITHUB_EVENT_PATH;\n                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);\n            }\n        }\n        this.eventName = process.env.GITHUB_EVENT_NAME;\n        this.sha = process.env.GITHUB_SHA;\n        this.ref = process.env.GITHUB_REF;\n        this.workflow = process.env.GITHUB_WORKFLOW;\n        this.action = process.env.GITHUB_ACTION;\n        this.actor = process.env.GITHUB_ACTOR;\n        this.job = process.env.GITHUB_JOB;\n        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);\n        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);\n        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;\n        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;\n        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;\n    }\n    get issue() {\n        const payload = this.payload;\n        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });\n    }\n    get repo() {\n        if (process.env.GITHUB_REPOSITORY) {\n            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');\n            return { owner, repo };\n        }\n        if (this.payload.repository) {\n            return {\n                owner: this.payload.repository.owner.login,\n                repo: this.payload.repository.name\n            };\n        }\n        throw new Error(\"context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'\");\n    }\n}\nexports.Context = Context;\n//# sourceMappingURL=context.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOctokit = exports.context = void 0;\nconst Context = __importStar(require(\"./context\"));\nconst utils_1 = require(\"./utils\");\nexports.context = new Context.Context();\n/**\n * Returns a hydrated octokit ready to use for GitHub Actions\n *\n * @param     token    the repo PAT or GITHUB_TOKEN\n * @param     options  other options to set\n */\nfunction getOctokit(token, options, ...additionalPlugins) {\n    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);\n    return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));\n}\nexports.getOctokit = getOctokit;\n//# sourceMappingURL=github.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;\nconst httpClient = __importStar(require(\"@actions/http-client\"));\nfunction getAuthString(token, options) {\n    if (!token && !options.auth) {\n        throw new Error('Parameter token or opts.auth is required');\n    }\n    else if (token && options.auth) {\n        throw new Error('Parameters token and opts.auth may not both be specified');\n    }\n    return typeof options.auth === 'string' ? options.auth : `token ${token}`;\n}\nexports.getAuthString = getAuthString;\nfunction getProxyAgent(destinationUrl) {\n    const hc = new httpClient.HttpClient();\n    return hc.getAgent(destinationUrl);\n}\nexports.getProxyAgent = getProxyAgent;\nfunction getApiBaseUrl() {\n    return process.env['GITHUB_API_URL'] || 'https://api.github.com';\n}\nexports.getApiBaseUrl = getApiBaseUrl;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;\nconst Context = __importStar(require(\"./context\"));\nconst Utils = __importStar(require(\"./internal/utils\"));\n// octokit + plugins\nconst core_1 = require(\"@octokit/core\");\nconst plugin_rest_endpoint_methods_1 = require(\"@octokit/plugin-rest-endpoint-methods\");\nconst plugin_paginate_rest_1 = require(\"@octokit/plugin-paginate-rest\");\nexports.context = new Context.Context();\nconst baseUrl = Utils.getApiBaseUrl();\nexports.defaults = {\n    baseUrl,\n    request: {\n        agent: Utils.getProxyAgent(baseUrl)\n    }\n};\nexports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);\n/**\n * Convience function to correctly format Octokit Options to pass into the constructor.\n *\n * @param     token    the repo PAT or GITHUB_TOKEN\n * @param     options  other options to set\n */\nfunction getOctokitOptions(token, options) {\n    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller\n    // Auth\n    const auth = Utils.getAuthString(token, opts);\n    if (auth) {\n        opts.auth = auth;\n    }\n    return opts;\n}\nexports.getOctokitOptions = getOctokitOptions;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n//# sourceMappingURL=proxy.js.map","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst REGEX_IS_INSTALLATION_LEGACY = /^v1\\./;\nconst REGEX_IS_INSTALLATION = /^ghs_/;\nconst REGEX_IS_USER_TO_SERVER = /^ghu_/;\nasync function auth(token) {\n  const isApp = token.split(/\\./).length === 3;\n  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);\n  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);\n  const tokenType = isApp ? \"app\" : isInstallation ? \"installation\" : isUserToServer ? \"user-to-server\" : \"oauth\";\n  return {\n    type: \"token\",\n    token: token,\n    tokenType\n  };\n}\n\n/**\n * Prefix token for usage in the Authorization header\n *\n * @param token OAuth token or JSON Web Token\n */\nfunction withAuthorizationPrefix(token) {\n  if (token.split(/\\./).length === 3) {\n    return `bearer ${token}`;\n  }\n\n  return `token ${token}`;\n}\n\nasync function hook(token, request, route, parameters) {\n  const endpoint = request.endpoint.merge(route, parameters);\n  endpoint.headers.authorization = withAuthorizationPrefix(token);\n  return request(endpoint);\n}\n\nconst createTokenAuth = function createTokenAuth(token) {\n  if (!token) {\n    throw new Error(\"[@octokit/auth-token] No token passed to createTokenAuth\");\n  }\n\n  if (typeof token !== \"string\") {\n    throw new Error(\"[@octokit/auth-token] Token passed to createTokenAuth is not a string\");\n  }\n\n  token = token.replace(/^(token|bearer) +/i, \"\");\n  return Object.assign(auth.bind(null, token), {\n    hook: hook.bind(null, token)\n  });\n};\n\nexports.createTokenAuth = createTokenAuth;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar universalUserAgent = require('universal-user-agent');\nvar beforeAfterHook = require('before-after-hook');\nvar request = require('@octokit/request');\nvar graphql = require('@octokit/graphql');\nvar authToken = require('@octokit/auth-token');\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst VERSION = \"3.6.0\";\n\nconst _excluded = [\"authStrategy\"];\nclass Octokit {\n  constructor(options = {}) {\n    const hook = new beforeAfterHook.Collection();\n    const requestDefaults = {\n      baseUrl: request.request.endpoint.DEFAULTS.baseUrl,\n      headers: {},\n      request: Object.assign({}, options.request, {\n        // @ts-ignore internal usage only, no need to type\n        hook: hook.bind(null, \"request\")\n      }),\n      mediaType: {\n        previews: [],\n        format: \"\"\n      }\n    }; // prepend default user agent with `options.userAgent` if set\n\n    requestDefaults.headers[\"user-agent\"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(\" \");\n\n    if (options.baseUrl) {\n      requestDefaults.baseUrl = options.baseUrl;\n    }\n\n    if (options.previews) {\n      requestDefaults.mediaType.previews = options.previews;\n    }\n\n    if (options.timeZone) {\n      requestDefaults.headers[\"time-zone\"] = options.timeZone;\n    }\n\n    this.request = request.request.defaults(requestDefaults);\n    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);\n    this.log = Object.assign({\n      debug: () => {},\n      info: () => {},\n      warn: console.warn.bind(console),\n      error: console.error.bind(console)\n    }, options.log);\n    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance\n    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.\n    // (2) If only `options.auth` is set, use the default token authentication strategy.\n    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.\n    // TODO: type `options.auth` based on `options.authStrategy`.\n\n    if (!options.authStrategy) {\n      if (!options.auth) {\n        // (1)\n        this.auth = async () => ({\n          type: \"unauthenticated\"\n        });\n      } else {\n        // (2)\n        const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  ¯\\_(ツ)_/¯\n\n        hook.wrap(\"request\", auth.hook);\n        this.auth = auth;\n      }\n    } else {\n      const {\n        authStrategy\n      } = options,\n            otherOptions = _objectWithoutProperties(options, _excluded);\n\n      const auth = authStrategy(Object.assign({\n        request: this.request,\n        log: this.log,\n        // we pass the current octokit instance as well as its constructor options\n        // to allow for authentication strategies that return a new octokit instance\n        // that shares the same internal state as the current one. The original\n        // requirement for this was the \"event-octokit\" authentication strategy\n        // of https://github.com/probot/octokit-auth-probot.\n        octokit: this,\n        octokitOptions: otherOptions\n      }, options.auth)); // @ts-ignore  ¯\\_(ツ)_/¯\n\n      hook.wrap(\"request\", auth.hook);\n      this.auth = auth;\n    } // apply plugins\n    // https://stackoverflow.com/a/16345172\n\n\n    const classConstructor = this.constructor;\n    classConstructor.plugins.forEach(plugin => {\n      Object.assign(this, plugin(this, options));\n    });\n  }\n\n  static defaults(defaults) {\n    const OctokitWithDefaults = class extends this {\n      constructor(...args) {\n        const options = args[0] || {};\n\n        if (typeof defaults === \"function\") {\n          super(defaults(options));\n          return;\n        }\n\n        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {\n          userAgent: `${options.userAgent} ${defaults.userAgent}`\n        } : null));\n      }\n\n    };\n    return OctokitWithDefaults;\n  }\n  /**\n   * Attach a plugin (or many) to your Octokit instance.\n   *\n   * @example\n   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)\n   */\n\n\n  static plugin(...newPlugins) {\n    var _a;\n\n    const currentPlugins = this.plugins;\n    const NewOctokit = (_a = class extends this {}, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);\n    return NewOctokit;\n  }\n\n}\nOctokit.VERSION = VERSION;\nOctokit.plugins = [];\n\nexports.Octokit = Octokit;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar isPlainObject = require('is-plain-object');\nvar universalUserAgent = require('universal-user-agent');\n\nfunction lowercaseKeys(object) {\n  if (!object) {\n    return {};\n  }\n\n  return Object.keys(object).reduce((newObj, key) => {\n    newObj[key.toLowerCase()] = object[key];\n    return newObj;\n  }, {});\n}\n\nfunction mergeDeep(defaults, options) {\n  const result = Object.assign({}, defaults);\n  Object.keys(options).forEach(key => {\n    if (isPlainObject.isPlainObject(options[key])) {\n      if (!(key in defaults)) Object.assign(result, {\n        [key]: options[key]\n      });else result[key] = mergeDeep(defaults[key], options[key]);\n    } else {\n      Object.assign(result, {\n        [key]: options[key]\n      });\n    }\n  });\n  return result;\n}\n\nfunction removeUndefinedProperties(obj) {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      delete obj[key];\n    }\n  }\n\n  return obj;\n}\n\nfunction merge(defaults, route, options) {\n  if (typeof route === \"string\") {\n    let [method, url] = route.split(\" \");\n    options = Object.assign(url ? {\n      method,\n      url\n    } : {\n      url: method\n    }, options);\n  } else {\n    options = Object.assign({}, route);\n  } // lowercase header names before merging with defaults to avoid duplicates\n\n\n  options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging\n\n  removeUndefinedProperties(options);\n  removeUndefinedProperties(options.headers);\n  const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten\n\n  if (defaults && defaults.mediaType.previews.length) {\n    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);\n  }\n\n  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, \"\"));\n  return mergedOptions;\n}\n\nfunction addQueryParameters(url, parameters) {\n  const separator = /\\?/.test(url) ? \"&\" : \"?\";\n  const names = Object.keys(parameters);\n\n  if (names.length === 0) {\n    return url;\n  }\n\n  return url + separator + names.map(name => {\n    if (name === \"q\") {\n      return \"q=\" + parameters.q.split(\"+\").map(encodeURIComponent).join(\"+\");\n    }\n\n    return `${name}=${encodeURIComponent(parameters[name])}`;\n  }).join(\"&\");\n}\n\nconst urlVariableRegex = /\\{[^}]+\\}/g;\n\nfunction removeNonChars(variableName) {\n  return variableName.replace(/^\\W+|\\W+$/g, \"\").split(/,/);\n}\n\nfunction extractUrlVariableNames(url) {\n  const matches = url.match(urlVariableRegex);\n\n  if (!matches) {\n    return [];\n  }\n\n  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);\n}\n\nfunction omit(object, keysToOmit) {\n  return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {\n    obj[key] = object[key];\n    return obj;\n  }, {});\n}\n\n// Based on https://github.com/bramstein/url-template, licensed under BSD\n// TODO: create separate package.\n//\n// Copyright (c) 2012-2014, Bram Stein\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  1. Redistributions of source code must retain the above copyright\n//     notice, this list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright\n//     notice, this list of conditions and the following disclaimer in the\n//     documentation and/or other materials provided with the distribution.\n//  3. The name of the author may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR \"AS IS\" AND ANY EXPRESS OR IMPLIED\n// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/* istanbul ignore file */\nfunction encodeReserved(str) {\n  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n    if (!/%[0-9A-Fa-f]/.test(part)) {\n      part = encodeURI(part).replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n    }\n\n    return part;\n  }).join(\"\");\n}\n\nfunction encodeUnreserved(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n    return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\nfunction encodeValue(operator, value, key) {\n  value = operator === \"+\" || operator === \"#\" ? encodeReserved(value) : encodeUnreserved(value);\n\n  if (key) {\n    return encodeUnreserved(key) + \"=\" + value;\n  } else {\n    return value;\n  }\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n  return operator === \";\" || operator === \"&\" || operator === \"?\";\n}\n\nfunction getValues(context, operator, key, modifier) {\n  var value = context[key],\n      result = [];\n\n  if (isDefined(value) && value !== \"\") {\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      value = value.toString();\n\n      if (modifier && modifier !== \"*\") {\n        value = value.substring(0, parseInt(modifier, 10));\n      }\n\n      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : \"\"));\n    } else {\n      if (modifier === \"*\") {\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function (value) {\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : \"\"));\n          });\n        } else {\n          Object.keys(value).forEach(function (k) {\n            if (isDefined(value[k])) {\n              result.push(encodeValue(operator, value[k], k));\n            }\n          });\n        }\n      } else {\n        const tmp = [];\n\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function (value) {\n            tmp.push(encodeValue(operator, value));\n          });\n        } else {\n          Object.keys(value).forEach(function (k) {\n            if (isDefined(value[k])) {\n              tmp.push(encodeUnreserved(k));\n              tmp.push(encodeValue(operator, value[k].toString()));\n            }\n          });\n        }\n\n        if (isKeyOperator(operator)) {\n          result.push(encodeUnreserved(key) + \"=\" + tmp.join(\",\"));\n        } else if (tmp.length !== 0) {\n          result.push(tmp.join(\",\"));\n        }\n      }\n    }\n  } else {\n    if (operator === \";\") {\n      if (isDefined(value)) {\n        result.push(encodeUnreserved(key));\n      }\n    } else if (value === \"\" && (operator === \"&\" || operator === \"?\")) {\n      result.push(encodeUnreserved(key) + \"=\");\n    } else if (value === \"\") {\n      result.push(\"\");\n    }\n  }\n\n  return result;\n}\n\nfunction parseUrl(template) {\n  return {\n    expand: expand.bind(null, template)\n  };\n}\n\nfunction expand(template, context) {\n  var operators = [\"+\", \"#\", \".\", \"/\", \";\", \"?\", \"&\"];\n  return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n    if (expression) {\n      let operator = \"\";\n      const values = [];\n\n      if (operators.indexOf(expression.charAt(0)) !== -1) {\n        operator = expression.charAt(0);\n        expression = expression.substr(1);\n      }\n\n      expression.split(/,/g).forEach(function (variable) {\n        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n      });\n\n      if (operator && operator !== \"+\") {\n        var separator = \",\";\n\n        if (operator === \"?\") {\n          separator = \"&\";\n        } else if (operator !== \"#\") {\n          separator = operator;\n        }\n\n        return (values.length !== 0 ? operator : \"\") + values.join(separator);\n      } else {\n        return values.join(\",\");\n      }\n    } else {\n      return encodeReserved(literal);\n    }\n  });\n}\n\nfunction parse(options) {\n  // https://fetch.spec.whatwg.org/#methods\n  let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible\n\n  let url = (options.url || \"/\").replace(/:([a-z]\\w+)/g, \"{$1}\");\n  let headers = Object.assign({}, options.headers);\n  let body;\n  let parameters = omit(options, [\"method\", \"baseUrl\", \"url\", \"headers\", \"request\", \"mediaType\"]); // extract variable names from URL to calculate remaining variables later\n\n  const urlVariableNames = extractUrlVariableNames(url);\n  url = parseUrl(url).expand(parameters);\n\n  if (!/^http/.test(url)) {\n    url = options.baseUrl + url;\n  }\n\n  const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat(\"baseUrl\");\n  const remainingParameters = omit(parameters, omittedParameters);\n  const isBinaryRequest = /application\\/octet-stream/i.test(headers.accept);\n\n  if (!isBinaryRequest) {\n    if (options.mediaType.format) {\n      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw\n      headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\\/vnd(\\.\\w+)(\\.v3)?(\\.\\w+)?(\\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(\",\");\n    }\n\n    if (options.mediaType.previews.length) {\n      const previewsFromAcceptHeader = headers.accept.match(/[\\w-]+(?=-preview)/g) || [];\n      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {\n        const format = options.mediaType.format ? `.${options.mediaType.format}` : \"+json\";\n        return `application/vnd.github.${preview}-preview${format}`;\n      }).join(\",\");\n    }\n  } // for GET/HEAD requests, set URL query parameters from remaining parameters\n  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters\n\n\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    url = addQueryParameters(url, remainingParameters);\n  } else {\n    if (\"data\" in remainingParameters) {\n      body = remainingParameters.data;\n    } else {\n      if (Object.keys(remainingParameters).length) {\n        body = remainingParameters;\n      } else {\n        headers[\"content-length\"] = 0;\n      }\n    }\n  } // default content-type for JSON if body is set\n\n\n  if (!headers[\"content-type\"] && typeof body !== \"undefined\") {\n    headers[\"content-type\"] = \"application/json; charset=utf-8\";\n  } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.\n  // fetch does not allow to set `content-length` header, but we can set body to an empty string\n\n\n  if ([\"PATCH\", \"PUT\"].includes(method) && typeof body === \"undefined\") {\n    body = \"\";\n  } // Only return body/request keys if present\n\n\n  return Object.assign({\n    method,\n    url,\n    headers\n  }, typeof body !== \"undefined\" ? {\n    body\n  } : null, options.request ? {\n    request: options.request\n  } : null);\n}\n\nfunction endpointWithDefaults(defaults, route, options) {\n  return parse(merge(defaults, route, options));\n}\n\nfunction withDefaults(oldDefaults, newDefaults) {\n  const DEFAULTS = merge(oldDefaults, newDefaults);\n  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);\n  return Object.assign(endpoint, {\n    DEFAULTS,\n    defaults: withDefaults.bind(null, DEFAULTS),\n    merge: merge.bind(null, DEFAULTS),\n    parse\n  });\n}\n\nconst VERSION = \"6.0.12\";\n\nconst userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.\n// So we use RequestParameters and add method as additional required property.\n\nconst DEFAULTS = {\n  method: \"GET\",\n  baseUrl: \"https://api.github.com\",\n  headers: {\n    accept: \"application/vnd.github.v3+json\",\n    \"user-agent\": userAgent\n  },\n  mediaType: {\n    format: \"\",\n    previews: []\n  }\n};\n\nconst endpoint = withDefaults(null, DEFAULTS);\n\nexports.endpoint = endpoint;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar request = require('@octokit/request');\nvar universalUserAgent = require('universal-user-agent');\n\nconst VERSION = \"4.8.0\";\n\nfunction _buildMessageForResponseErrors(data) {\n  return `Request failed due to following response errors:\\n` + data.errors.map(e => ` - ${e.message}`).join(\"\\n\");\n}\n\nclass GraphqlResponseError extends Error {\n  constructor(request, headers, response) {\n    super(_buildMessageForResponseErrors(response));\n    this.request = request;\n    this.headers = headers;\n    this.response = response;\n    this.name = \"GraphqlResponseError\"; // Expose the errors and response data in their shorthand properties.\n\n    this.errors = response.errors;\n    this.data = response.data; // Maintains proper stack trace (only available on V8)\n\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n}\n\nconst NON_VARIABLE_OPTIONS = [\"method\", \"baseUrl\", \"url\", \"headers\", \"request\", \"query\", \"mediaType\"];\nconst FORBIDDEN_VARIABLE_OPTIONS = [\"query\", \"method\", \"url\"];\nconst GHES_V3_SUFFIX_REGEX = /\\/api\\/v3\\/?$/;\nfunction graphql(request, query, options) {\n  if (options) {\n    if (typeof query === \"string\" && \"query\" in options) {\n      return Promise.reject(new Error(`[@octokit/graphql] \"query\" cannot be used as variable name`));\n    }\n\n    for (const key in options) {\n      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;\n      return Promise.reject(new Error(`[@octokit/graphql] \"${key}\" cannot be used as variable name`));\n    }\n  }\n\n  const parsedOptions = typeof query === \"string\" ? Object.assign({\n    query\n  }, options) : query;\n  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {\n    if (NON_VARIABLE_OPTIONS.includes(key)) {\n      result[key] = parsedOptions[key];\n      return result;\n    }\n\n    if (!result.variables) {\n      result.variables = {};\n    }\n\n    result.variables[key] = parsedOptions[key];\n    return result;\n  }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix\n  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451\n\n  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;\n\n  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {\n    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, \"/api/graphql\");\n  }\n\n  return request(requestOptions).then(response => {\n    if (response.data.errors) {\n      const headers = {};\n\n      for (const key of Object.keys(response.headers)) {\n        headers[key] = response.headers[key];\n      }\n\n      throw new GraphqlResponseError(requestOptions, headers, response.data);\n    }\n\n    return response.data.data;\n  });\n}\n\nfunction withDefaults(request$1, newDefaults) {\n  const newRequest = request$1.defaults(newDefaults);\n\n  const newApi = (query, options) => {\n    return graphql(newRequest, query, options);\n  };\n\n  return Object.assign(newApi, {\n    defaults: withDefaults.bind(null, newRequest),\n    endpoint: request.request.endpoint\n  });\n}\n\nconst graphql$1 = withDefaults(request.request, {\n  headers: {\n    \"user-agent\": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`\n  },\n  method: \"POST\",\n  url: \"/graphql\"\n});\nfunction withCustomRequest(customRequest) {\n  return withDefaults(customRequest, {\n    method: \"POST\",\n    url: \"/graphql\"\n  });\n}\n\nexports.GraphqlResponseError = GraphqlResponseError;\nexports.graphql = graphql$1;\nexports.withCustomRequest = withCustomRequest;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst VERSION = \"2.21.3\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/**\n * Some “list” response that can be paginated have a different response structure\n *\n * They have a `total_count` key in the response (search also has `incomplete_results`,\n * /installation/repositories also has `repository_selection`), as well as a key with\n * the list of the items which name varies from endpoint to endpoint.\n *\n * Octokit normalizes these responses so that paginated results are always returned following\n * the same structure. One challenge is that if the list response has only one page, no Link\n * header is provided, so this header alone is not sufficient to check wether a response is\n * paginated or not.\n *\n * We check if a \"total_count\" key is present in the response data, but also make sure that\n * a \"url\" property is not, as the \"Get the combined status for a specific ref\" endpoint would\n * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref\n */\nfunction normalizePaginatedListResponse(response) {\n  // endpoints can respond with 204 if repository is empty\n  if (!response.data) {\n    return _objectSpread2(_objectSpread2({}, response), {}, {\n      data: []\n    });\n  }\n\n  const responseNeedsNormalization = \"total_count\" in response.data && !(\"url\" in response.data);\n  if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way\n  // to retrieve the same information.\n\n  const incompleteResults = response.data.incomplete_results;\n  const repositorySelection = response.data.repository_selection;\n  const totalCount = response.data.total_count;\n  delete response.data.incomplete_results;\n  delete response.data.repository_selection;\n  delete response.data.total_count;\n  const namespaceKey = Object.keys(response.data)[0];\n  const data = response.data[namespaceKey];\n  response.data = data;\n\n  if (typeof incompleteResults !== \"undefined\") {\n    response.data.incomplete_results = incompleteResults;\n  }\n\n  if (typeof repositorySelection !== \"undefined\") {\n    response.data.repository_selection = repositorySelection;\n  }\n\n  response.data.total_count = totalCount;\n  return response;\n}\n\nfunction iterator(octokit, route, parameters) {\n  const options = typeof route === \"function\" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);\n  const requestMethod = typeof route === \"function\" ? route : octokit.request;\n  const method = options.method;\n  const headers = options.headers;\n  let url = options.url;\n  return {\n    [Symbol.asyncIterator]: () => ({\n      async next() {\n        if (!url) return {\n          done: true\n        };\n\n        try {\n          const response = await requestMethod({\n            method,\n            url,\n            headers\n          });\n          const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:\n          // '<https://api.github.com/users/aseemk/followers?page=2>; rel=\"next\", <https://api.github.com/users/aseemk/followers?page=2>; rel=\"last\"'\n          // sets `url` to undefined if \"next\" URL is not present or `link` header is not set\n\n          url = ((normalizedResponse.headers.link || \"\").match(/<([^>]+)>;\\s*rel=\"next\"/) || [])[1];\n          return {\n            value: normalizedResponse\n          };\n        } catch (error) {\n          if (error.status !== 409) throw error;\n          url = \"\";\n          return {\n            value: {\n              status: 200,\n              headers: {},\n              data: []\n            }\n          };\n        }\n      }\n\n    })\n  };\n}\n\nfunction paginate(octokit, route, parameters, mapFn) {\n  if (typeof parameters === \"function\") {\n    mapFn = parameters;\n    parameters = undefined;\n  }\n\n  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);\n}\n\nfunction gather(octokit, results, iterator, mapFn) {\n  return iterator.next().then(result => {\n    if (result.done) {\n      return results;\n    }\n\n    let earlyExit = false;\n\n    function done() {\n      earlyExit = true;\n    }\n\n    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);\n\n    if (earlyExit) {\n      return results;\n    }\n\n    return gather(octokit, results, iterator, mapFn);\n  });\n}\n\nconst composePaginateRest = Object.assign(paginate, {\n  iterator\n});\n\nconst paginatingEndpoints = [\"GET /app/hook/deliveries\", \"GET /app/installations\", \"GET /applications/grants\", \"GET /authorizations\", \"GET /enterprises/{enterprise}/actions/permissions/organizations\", \"GET /enterprises/{enterprise}/actions/runner-groups\", \"GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations\", \"GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners\", \"GET /enterprises/{enterprise}/actions/runners\", \"GET /enterprises/{enterprise}/audit-log\", \"GET /enterprises/{enterprise}/secret-scanning/alerts\", \"GET /enterprises/{enterprise}/settings/billing/advanced-security\", \"GET /events\", \"GET /gists\", \"GET /gists/public\", \"GET /gists/starred\", \"GET /gists/{gist_id}/comments\", \"GET /gists/{gist_id}/commits\", \"GET /gists/{gist_id}/forks\", \"GET /installation/repositories\", \"GET /issues\", \"GET /licenses\", \"GET /marketplace_listing/plans\", \"GET /marketplace_listing/plans/{plan_id}/accounts\", \"GET /marketplace_listing/stubbed/plans\", \"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\", \"GET /networks/{owner}/{repo}/events\", \"GET /notifications\", \"GET /organizations\", \"GET /orgs/{org}/actions/cache/usage-by-repository\", \"GET /orgs/{org}/actions/permissions/repositories\", \"GET /orgs/{org}/actions/runner-groups\", \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories\", \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners\", \"GET /orgs/{org}/actions/runners\", \"GET /orgs/{org}/actions/secrets\", \"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\", \"GET /orgs/{org}/audit-log\", \"GET /orgs/{org}/blocks\", \"GET /orgs/{org}/code-scanning/alerts\", \"GET /orgs/{org}/codespaces\", \"GET /orgs/{org}/credential-authorizations\", \"GET /orgs/{org}/dependabot/secrets\", \"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\", \"GET /orgs/{org}/events\", \"GET /orgs/{org}/external-groups\", \"GET /orgs/{org}/failed_invitations\", \"GET /orgs/{org}/hooks\", \"GET /orgs/{org}/hooks/{hook_id}/deliveries\", \"GET /orgs/{org}/installations\", \"GET /orgs/{org}/invitations\", \"GET /orgs/{org}/invitations/{invitation_id}/teams\", \"GET /orgs/{org}/issues\", \"GET /orgs/{org}/members\", \"GET /orgs/{org}/migrations\", \"GET /orgs/{org}/migrations/{migration_id}/repositories\", \"GET /orgs/{org}/outside_collaborators\", \"GET /orgs/{org}/packages\", \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\", \"GET /orgs/{org}/projects\", \"GET /orgs/{org}/public_members\", \"GET /orgs/{org}/repos\", \"GET /orgs/{org}/secret-scanning/alerts\", \"GET /orgs/{org}/settings/billing/advanced-security\", \"GET /orgs/{org}/team-sync/groups\", \"GET /orgs/{org}/teams\", \"GET /orgs/{org}/teams/{team_slug}/discussions\", \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\", \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\", \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\", \"GET /orgs/{org}/teams/{team_slug}/invitations\", \"GET /orgs/{org}/teams/{team_slug}/members\", \"GET /orgs/{org}/teams/{team_slug}/projects\", \"GET /orgs/{org}/teams/{team_slug}/repos\", \"GET /orgs/{org}/teams/{team_slug}/teams\", \"GET /projects/columns/{column_id}/cards\", \"GET /projects/{project_id}/collaborators\", \"GET /projects/{project_id}/columns\", \"GET /repos/{owner}/{repo}/actions/artifacts\", \"GET /repos/{owner}/{repo}/actions/caches\", \"GET /repos/{owner}/{repo}/actions/runners\", \"GET /repos/{owner}/{repo}/actions/runs\", \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\", \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\", \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\", \"GET /repos/{owner}/{repo}/actions/secrets\", \"GET /repos/{owner}/{repo}/actions/workflows\", \"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\", \"GET /repos/{owner}/{repo}/assignees\", \"GET /repos/{owner}/{repo}/branches\", \"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\", \"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\", \"GET /repos/{owner}/{repo}/code-scanning/alerts\", \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\", \"GET /repos/{owner}/{repo}/code-scanning/analyses\", \"GET /repos/{owner}/{repo}/codespaces\", \"GET /repos/{owner}/{repo}/codespaces/devcontainers\", \"GET /repos/{owner}/{repo}/codespaces/secrets\", \"GET /repos/{owner}/{repo}/collaborators\", \"GET /repos/{owner}/{repo}/comments\", \"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\", \"GET /repos/{owner}/{repo}/commits\", \"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\", \"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\", \"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\", \"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\", \"GET /repos/{owner}/{repo}/commits/{ref}/status\", \"GET /repos/{owner}/{repo}/commits/{ref}/statuses\", \"GET /repos/{owner}/{repo}/contributors\", \"GET /repos/{owner}/{repo}/dependabot/secrets\", \"GET /repos/{owner}/{repo}/deployments\", \"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\", \"GET /repos/{owner}/{repo}/environments\", \"GET /repos/{owner}/{repo}/events\", \"GET /repos/{owner}/{repo}/forks\", \"GET /repos/{owner}/{repo}/git/matching-refs/{ref}\", \"GET /repos/{owner}/{repo}/hooks\", \"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\", \"GET /repos/{owner}/{repo}/invitations\", \"GET /repos/{owner}/{repo}/issues\", \"GET /repos/{owner}/{repo}/issues/comments\", \"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\", \"GET /repos/{owner}/{repo}/issues/events\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/events\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\", \"GET /repos/{owner}/{repo}/keys\", \"GET /repos/{owner}/{repo}/labels\", \"GET /repos/{owner}/{repo}/milestones\", \"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\", \"GET /repos/{owner}/{repo}/notifications\", \"GET /repos/{owner}/{repo}/pages/builds\", \"GET /repos/{owner}/{repo}/projects\", \"GET /repos/{owner}/{repo}/pulls\", \"GET /repos/{owner}/{repo}/pulls/comments\", \"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\", \"GET /repos/{owner}/{repo}/releases\", \"GET /repos/{owner}/{repo}/releases/{release_id}/assets\", \"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\", \"GET /repos/{owner}/{repo}/secret-scanning/alerts\", \"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\", \"GET /repos/{owner}/{repo}/stargazers\", \"GET /repos/{owner}/{repo}/subscribers\", \"GET /repos/{owner}/{repo}/tags\", \"GET /repos/{owner}/{repo}/teams\", \"GET /repos/{owner}/{repo}/topics\", \"GET /repositories\", \"GET /repositories/{repository_id}/environments/{environment_name}/secrets\", \"GET /search/code\", \"GET /search/commits\", \"GET /search/issues\", \"GET /search/labels\", \"GET /search/repositories\", \"GET /search/topics\", \"GET /search/users\", \"GET /teams/{team_id}/discussions\", \"GET /teams/{team_id}/discussions/{discussion_number}/comments\", \"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions\", \"GET /teams/{team_id}/discussions/{discussion_number}/reactions\", \"GET /teams/{team_id}/invitations\", \"GET /teams/{team_id}/members\", \"GET /teams/{team_id}/projects\", \"GET /teams/{team_id}/repos\", \"GET /teams/{team_id}/teams\", \"GET /user/blocks\", \"GET /user/codespaces\", \"GET /user/codespaces/secrets\", \"GET /user/emails\", \"GET /user/followers\", \"GET /user/following\", \"GET /user/gpg_keys\", \"GET /user/installations\", \"GET /user/installations/{installation_id}/repositories\", \"GET /user/issues\", \"GET /user/keys\", \"GET /user/marketplace_purchases\", \"GET /user/marketplace_purchases/stubbed\", \"GET /user/memberships/orgs\", \"GET /user/migrations\", \"GET /user/migrations/{migration_id}/repositories\", \"GET /user/orgs\", \"GET /user/packages\", \"GET /user/packages/{package_type}/{package_name}/versions\", \"GET /user/public_emails\", \"GET /user/repos\", \"GET /user/repository_invitations\", \"GET /user/starred\", \"GET /user/subscriptions\", \"GET /user/teams\", \"GET /users\", \"GET /users/{username}/events\", \"GET /users/{username}/events/orgs/{org}\", \"GET /users/{username}/events/public\", \"GET /users/{username}/followers\", \"GET /users/{username}/following\", \"GET /users/{username}/gists\", \"GET /users/{username}/gpg_keys\", \"GET /users/{username}/keys\", \"GET /users/{username}/orgs\", \"GET /users/{username}/packages\", \"GET /users/{username}/projects\", \"GET /users/{username}/received_events\", \"GET /users/{username}/received_events/public\", \"GET /users/{username}/repos\", \"GET /users/{username}/starred\", \"GET /users/{username}/subscriptions\"];\n\nfunction isPaginatingEndpoint(arg) {\n  if (typeof arg === \"string\") {\n    return paginatingEndpoints.includes(arg);\n  } else {\n    return false;\n  }\n}\n\n/**\n * @param octokit Octokit instance\n * @param options Options passed to Octokit constructor\n */\n\nfunction paginateRest(octokit) {\n  return {\n    paginate: Object.assign(paginate.bind(null, octokit), {\n      iterator: iterator.bind(null, octokit)\n    })\n  };\n}\npaginateRest.VERSION = VERSION;\n\nexports.composePaginateRest = composePaginateRest;\nexports.isPaginatingEndpoint = isPaginatingEndpoint;\nexports.paginateRest = paginateRest;\nexports.paginatingEndpoints = paginatingEndpoints;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst Endpoints = {\n  actions: {\n    addCustomLabelsToSelfHostedRunnerForOrg: [\"POST /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    addCustomLabelsToSelfHostedRunnerForRepo: [\"POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    addSelectedRepoToOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}\"],\n    approveWorkflowRun: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve\"],\n    cancelWorkflowRun: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel\"],\n    createOrUpdateEnvironmentSecret: [\"PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}\"],\n    createOrUpdateOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}\"],\n    createOrUpdateRepoSecret: [\"PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    createRegistrationTokenForOrg: [\"POST /orgs/{org}/actions/runners/registration-token\"],\n    createRegistrationTokenForRepo: [\"POST /repos/{owner}/{repo}/actions/runners/registration-token\"],\n    createRemoveTokenForOrg: [\"POST /orgs/{org}/actions/runners/remove-token\"],\n    createRemoveTokenForRepo: [\"POST /repos/{owner}/{repo}/actions/runners/remove-token\"],\n    createWorkflowDispatch: [\"POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches\"],\n    deleteActionsCacheById: [\"DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}\"],\n    deleteActionsCacheByKey: [\"DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}\"],\n    deleteArtifact: [\"DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}\"],\n    deleteEnvironmentSecret: [\"DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}\"],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/actions/secrets/{secret_name}\"],\n    deleteRepoSecret: [\"DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    deleteSelfHostedRunnerFromOrg: [\"DELETE /orgs/{org}/actions/runners/{runner_id}\"],\n    deleteSelfHostedRunnerFromRepo: [\"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}\"],\n    deleteWorkflowRun: [\"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}\"],\n    deleteWorkflowRunLogs: [\"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs\"],\n    disableSelectedRepositoryGithubActionsOrganization: [\"DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}\"],\n    disableWorkflow: [\"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable\"],\n    downloadArtifact: [\"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}\"],\n    downloadJobLogsForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs\"],\n    downloadWorkflowRunAttemptLogs: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs\"],\n    downloadWorkflowRunLogs: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs\"],\n    enableSelectedRepositoryGithubActionsOrganization: [\"PUT /orgs/{org}/actions/permissions/repositories/{repository_id}\"],\n    enableWorkflow: [\"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable\"],\n    getActionsCacheList: [\"GET /repos/{owner}/{repo}/actions/caches\"],\n    getActionsCacheUsage: [\"GET /repos/{owner}/{repo}/actions/cache/usage\"],\n    getActionsCacheUsageByRepoForOrg: [\"GET /orgs/{org}/actions/cache/usage-by-repository\"],\n    getActionsCacheUsageForEnterprise: [\"GET /enterprises/{enterprise}/actions/cache/usage\"],\n    getActionsCacheUsageForOrg: [\"GET /orgs/{org}/actions/cache/usage\"],\n    getAllowedActionsOrganization: [\"GET /orgs/{org}/actions/permissions/selected-actions\"],\n    getAllowedActionsRepository: [\"GET /repos/{owner}/{repo}/actions/permissions/selected-actions\"],\n    getArtifact: [\"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}\"],\n    getEnvironmentPublicKey: [\"GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key\"],\n    getEnvironmentSecret: [\"GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}\"],\n    getGithubActionsDefaultWorkflowPermissionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions/workflow\"],\n    getGithubActionsDefaultWorkflowPermissionsOrganization: [\"GET /orgs/{org}/actions/permissions/workflow\"],\n    getGithubActionsDefaultWorkflowPermissionsRepository: [\"GET /repos/{owner}/{repo}/actions/permissions/workflow\"],\n    getGithubActionsPermissionsOrganization: [\"GET /orgs/{org}/actions/permissions\"],\n    getGithubActionsPermissionsRepository: [\"GET /repos/{owner}/{repo}/actions/permissions\"],\n    getJobForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/jobs/{job_id}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/actions/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/actions/secrets/{secret_name}\"],\n    getPendingDeploymentsForRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\"],\n    getRepoPermissions: [\"GET /repos/{owner}/{repo}/actions/permissions\", {}, {\n      renamed: [\"actions\", \"getGithubActionsPermissionsRepository\"]\n    }],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/actions/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    getReviewsForRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals\"],\n    getSelfHostedRunnerForOrg: [\"GET /orgs/{org}/actions/runners/{runner_id}\"],\n    getSelfHostedRunnerForRepo: [\"GET /repos/{owner}/{repo}/actions/runners/{runner_id}\"],\n    getWorkflow: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}\"],\n    getWorkflowAccessToRepository: [\"GET /repos/{owner}/{repo}/actions/permissions/access\"],\n    getWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}\"],\n    getWorkflowRunAttempt: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}\"],\n    getWorkflowRunUsage: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing\"],\n    getWorkflowUsage: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing\"],\n    listArtifactsForRepo: [\"GET /repos/{owner}/{repo}/actions/artifacts\"],\n    listEnvironmentSecrets: [\"GET /repositories/{repository_id}/environments/{environment_name}/secrets\"],\n    listJobsForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\"],\n    listJobsForWorkflowRunAttempt: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\"],\n    listLabelsForSelfHostedRunnerForOrg: [\"GET /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    listLabelsForSelfHostedRunnerForRepo: [\"GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    listOrgSecrets: [\"GET /orgs/{org}/actions/secrets\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/actions/secrets\"],\n    listRepoWorkflows: [\"GET /repos/{owner}/{repo}/actions/workflows\"],\n    listRunnerApplicationsForOrg: [\"GET /orgs/{org}/actions/runners/downloads\"],\n    listRunnerApplicationsForRepo: [\"GET /repos/{owner}/{repo}/actions/runners/downloads\"],\n    listSelectedReposForOrgSecret: [\"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\"],\n    listSelectedRepositoriesEnabledGithubActionsOrganization: [\"GET /orgs/{org}/actions/permissions/repositories\"],\n    listSelfHostedRunnersForOrg: [\"GET /orgs/{org}/actions/runners\"],\n    listSelfHostedRunnersForRepo: [\"GET /repos/{owner}/{repo}/actions/runners\"],\n    listWorkflowRunArtifacts: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\"],\n    listWorkflowRuns: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\"],\n    listWorkflowRunsForRepo: [\"GET /repos/{owner}/{repo}/actions/runs\"],\n    reRunJobForWorkflowRun: [\"POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun\"],\n    reRunWorkflow: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun\"],\n    reRunWorkflowFailedJobs: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs\"],\n    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [\"DELETE /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [\"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    removeCustomLabelFromSelfHostedRunnerForOrg: [\"DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}\"],\n    removeCustomLabelFromSelfHostedRunnerForRepo: [\"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}\"],\n    removeSelectedRepoFromOrgSecret: [\"DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}\"],\n    reviewPendingDeploymentsForRun: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\"],\n    setAllowedActionsOrganization: [\"PUT /orgs/{org}/actions/permissions/selected-actions\"],\n    setAllowedActionsRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions/selected-actions\"],\n    setCustomLabelsForSelfHostedRunnerForOrg: [\"PUT /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    setCustomLabelsForSelfHostedRunnerForRepo: [\"PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    setGithubActionsDefaultWorkflowPermissionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/workflow\"],\n    setGithubActionsDefaultWorkflowPermissionsOrganization: [\"PUT /orgs/{org}/actions/permissions/workflow\"],\n    setGithubActionsDefaultWorkflowPermissionsRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions/workflow\"],\n    setGithubActionsPermissionsOrganization: [\"PUT /orgs/{org}/actions/permissions\"],\n    setGithubActionsPermissionsRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions\"],\n    setSelectedReposForOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories\"],\n    setSelectedRepositoriesEnabledGithubActionsOrganization: [\"PUT /orgs/{org}/actions/permissions/repositories\"],\n    setWorkflowAccessToRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions/access\"]\n  },\n  activity: {\n    checkRepoIsStarredByAuthenticatedUser: [\"GET /user/starred/{owner}/{repo}\"],\n    deleteRepoSubscription: [\"DELETE /repos/{owner}/{repo}/subscription\"],\n    deleteThreadSubscription: [\"DELETE /notifications/threads/{thread_id}/subscription\"],\n    getFeeds: [\"GET /feeds\"],\n    getRepoSubscription: [\"GET /repos/{owner}/{repo}/subscription\"],\n    getThread: [\"GET /notifications/threads/{thread_id}\"],\n    getThreadSubscriptionForAuthenticatedUser: [\"GET /notifications/threads/{thread_id}/subscription\"],\n    listEventsForAuthenticatedUser: [\"GET /users/{username}/events\"],\n    listNotificationsForAuthenticatedUser: [\"GET /notifications\"],\n    listOrgEventsForAuthenticatedUser: [\"GET /users/{username}/events/orgs/{org}\"],\n    listPublicEvents: [\"GET /events\"],\n    listPublicEventsForRepoNetwork: [\"GET /networks/{owner}/{repo}/events\"],\n    listPublicEventsForUser: [\"GET /users/{username}/events/public\"],\n    listPublicOrgEvents: [\"GET /orgs/{org}/events\"],\n    listReceivedEventsForUser: [\"GET /users/{username}/received_events\"],\n    listReceivedPublicEventsForUser: [\"GET /users/{username}/received_events/public\"],\n    listRepoEvents: [\"GET /repos/{owner}/{repo}/events\"],\n    listRepoNotificationsForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/notifications\"],\n    listReposStarredByAuthenticatedUser: [\"GET /user/starred\"],\n    listReposStarredByUser: [\"GET /users/{username}/starred\"],\n    listReposWatchedByUser: [\"GET /users/{username}/subscriptions\"],\n    listStargazersForRepo: [\"GET /repos/{owner}/{repo}/stargazers\"],\n    listWatchedReposForAuthenticatedUser: [\"GET /user/subscriptions\"],\n    listWatchersForRepo: [\"GET /repos/{owner}/{repo}/subscribers\"],\n    markNotificationsAsRead: [\"PUT /notifications\"],\n    markRepoNotificationsAsRead: [\"PUT /repos/{owner}/{repo}/notifications\"],\n    markThreadAsRead: [\"PATCH /notifications/threads/{thread_id}\"],\n    setRepoSubscription: [\"PUT /repos/{owner}/{repo}/subscription\"],\n    setThreadSubscription: [\"PUT /notifications/threads/{thread_id}/subscription\"],\n    starRepoForAuthenticatedUser: [\"PUT /user/starred/{owner}/{repo}\"],\n    unstarRepoForAuthenticatedUser: [\"DELETE /user/starred/{owner}/{repo}\"]\n  },\n  apps: {\n    addRepoToInstallation: [\"PUT /user/installations/{installation_id}/repositories/{repository_id}\", {}, {\n      renamed: [\"apps\", \"addRepoToInstallationForAuthenticatedUser\"]\n    }],\n    addRepoToInstallationForAuthenticatedUser: [\"PUT /user/installations/{installation_id}/repositories/{repository_id}\"],\n    checkToken: [\"POST /applications/{client_id}/token\"],\n    createFromManifest: [\"POST /app-manifests/{code}/conversions\"],\n    createInstallationAccessToken: [\"POST /app/installations/{installation_id}/access_tokens\"],\n    deleteAuthorization: [\"DELETE /applications/{client_id}/grant\"],\n    deleteInstallation: [\"DELETE /app/installations/{installation_id}\"],\n    deleteToken: [\"DELETE /applications/{client_id}/token\"],\n    getAuthenticated: [\"GET /app\"],\n    getBySlug: [\"GET /apps/{app_slug}\"],\n    getInstallation: [\"GET /app/installations/{installation_id}\"],\n    getOrgInstallation: [\"GET /orgs/{org}/installation\"],\n    getRepoInstallation: [\"GET /repos/{owner}/{repo}/installation\"],\n    getSubscriptionPlanForAccount: [\"GET /marketplace_listing/accounts/{account_id}\"],\n    getSubscriptionPlanForAccountStubbed: [\"GET /marketplace_listing/stubbed/accounts/{account_id}\"],\n    getUserInstallation: [\"GET /users/{username}/installation\"],\n    getWebhookConfigForApp: [\"GET /app/hook/config\"],\n    getWebhookDelivery: [\"GET /app/hook/deliveries/{delivery_id}\"],\n    listAccountsForPlan: [\"GET /marketplace_listing/plans/{plan_id}/accounts\"],\n    listAccountsForPlanStubbed: [\"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\"],\n    listInstallationReposForAuthenticatedUser: [\"GET /user/installations/{installation_id}/repositories\"],\n    listInstallations: [\"GET /app/installations\"],\n    listInstallationsForAuthenticatedUser: [\"GET /user/installations\"],\n    listPlans: [\"GET /marketplace_listing/plans\"],\n    listPlansStubbed: [\"GET /marketplace_listing/stubbed/plans\"],\n    listReposAccessibleToInstallation: [\"GET /installation/repositories\"],\n    listSubscriptionsForAuthenticatedUser: [\"GET /user/marketplace_purchases\"],\n    listSubscriptionsForAuthenticatedUserStubbed: [\"GET /user/marketplace_purchases/stubbed\"],\n    listWebhookDeliveries: [\"GET /app/hook/deliveries\"],\n    redeliverWebhookDelivery: [\"POST /app/hook/deliveries/{delivery_id}/attempts\"],\n    removeRepoFromInstallation: [\"DELETE /user/installations/{installation_id}/repositories/{repository_id}\", {}, {\n      renamed: [\"apps\", \"removeRepoFromInstallationForAuthenticatedUser\"]\n    }],\n    removeRepoFromInstallationForAuthenticatedUser: [\"DELETE /user/installations/{installation_id}/repositories/{repository_id}\"],\n    resetToken: [\"PATCH /applications/{client_id}/token\"],\n    revokeInstallationAccessToken: [\"DELETE /installation/token\"],\n    scopeToken: [\"POST /applications/{client_id}/token/scoped\"],\n    suspendInstallation: [\"PUT /app/installations/{installation_id}/suspended\"],\n    unsuspendInstallation: [\"DELETE /app/installations/{installation_id}/suspended\"],\n    updateWebhookConfigForApp: [\"PATCH /app/hook/config\"]\n  },\n  billing: {\n    getGithubActionsBillingOrg: [\"GET /orgs/{org}/settings/billing/actions\"],\n    getGithubActionsBillingUser: [\"GET /users/{username}/settings/billing/actions\"],\n    getGithubAdvancedSecurityBillingGhe: [\"GET /enterprises/{enterprise}/settings/billing/advanced-security\"],\n    getGithubAdvancedSecurityBillingOrg: [\"GET /orgs/{org}/settings/billing/advanced-security\"],\n    getGithubPackagesBillingOrg: [\"GET /orgs/{org}/settings/billing/packages\"],\n    getGithubPackagesBillingUser: [\"GET /users/{username}/settings/billing/packages\"],\n    getSharedStorageBillingOrg: [\"GET /orgs/{org}/settings/billing/shared-storage\"],\n    getSharedStorageBillingUser: [\"GET /users/{username}/settings/billing/shared-storage\"]\n  },\n  checks: {\n    create: [\"POST /repos/{owner}/{repo}/check-runs\"],\n    createSuite: [\"POST /repos/{owner}/{repo}/check-suites\"],\n    get: [\"GET /repos/{owner}/{repo}/check-runs/{check_run_id}\"],\n    getSuite: [\"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}\"],\n    listAnnotations: [\"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\"],\n    listForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\"],\n    listForSuite: [\"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\"],\n    listSuitesForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\"],\n    rerequestRun: [\"POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest\"],\n    rerequestSuite: [\"POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest\"],\n    setSuitesPreferences: [\"PATCH /repos/{owner}/{repo}/check-suites/preferences\"],\n    update: [\"PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}\"]\n  },\n  codeScanning: {\n    deleteAnalysis: [\"DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}\"],\n    getAlert: [\"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}\", {}, {\n      renamedParameters: {\n        alert_id: \"alert_number\"\n      }\n    }],\n    getAnalysis: [\"GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}\"],\n    getSarif: [\"GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}\"],\n    listAlertInstances: [\"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\"],\n    listAlertsForOrg: [\"GET /orgs/{org}/code-scanning/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/code-scanning/alerts\"],\n    listAlertsInstances: [\"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\", {}, {\n      renamed: [\"codeScanning\", \"listAlertInstances\"]\n    }],\n    listRecentAnalyses: [\"GET /repos/{owner}/{repo}/code-scanning/analyses\"],\n    updateAlert: [\"PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}\"],\n    uploadSarif: [\"POST /repos/{owner}/{repo}/code-scanning/sarifs\"]\n  },\n  codesOfConduct: {\n    getAllCodesOfConduct: [\"GET /codes_of_conduct\"],\n    getConductCode: [\"GET /codes_of_conduct/{key}\"]\n  },\n  codespaces: {\n    addRepositoryForSecretForAuthenticatedUser: [\"PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}\"],\n    codespaceMachinesForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}/machines\"],\n    createForAuthenticatedUser: [\"POST /user/codespaces\"],\n    createOrUpdateRepoSecret: [\"PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"],\n    createOrUpdateSecretForAuthenticatedUser: [\"PUT /user/codespaces/secrets/{secret_name}\"],\n    createWithPrForAuthenticatedUser: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces\"],\n    createWithRepoForAuthenticatedUser: [\"POST /repos/{owner}/{repo}/codespaces\"],\n    deleteForAuthenticatedUser: [\"DELETE /user/codespaces/{codespace_name}\"],\n    deleteFromOrganization: [\"DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}\"],\n    deleteRepoSecret: [\"DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"],\n    deleteSecretForAuthenticatedUser: [\"DELETE /user/codespaces/secrets/{secret_name}\"],\n    exportForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/exports\"],\n    getExportDetailsForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}/exports/{export_id}\"],\n    getForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}\"],\n    getPublicKeyForAuthenticatedUser: [\"GET /user/codespaces/secrets/public-key\"],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/codespaces/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"],\n    getSecretForAuthenticatedUser: [\"GET /user/codespaces/secrets/{secret_name}\"],\n    listDevcontainersInRepositoryForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/codespaces/devcontainers\"],\n    listForAuthenticatedUser: [\"GET /user/codespaces\"],\n    listInOrganization: [\"GET /orgs/{org}/codespaces\", {}, {\n      renamedParameters: {\n        org_id: \"org\"\n      }\n    }],\n    listInRepositoryForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/codespaces\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/codespaces/secrets\"],\n    listRepositoriesForSecretForAuthenticatedUser: [\"GET /user/codespaces/secrets/{secret_name}/repositories\"],\n    listSecretsForAuthenticatedUser: [\"GET /user/codespaces/secrets\"],\n    removeRepositoryForSecretForAuthenticatedUser: [\"DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}\"],\n    repoMachinesForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/codespaces/machines\"],\n    setRepositoriesForSecretForAuthenticatedUser: [\"PUT /user/codespaces/secrets/{secret_name}/repositories\"],\n    startForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/start\"],\n    stopForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/stop\"],\n    stopInOrganization: [\"POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop\"],\n    updateForAuthenticatedUser: [\"PATCH /user/codespaces/{codespace_name}\"]\n  },\n  dependabot: {\n    addSelectedRepoToOrgSecret: [\"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}\"],\n    createOrUpdateOrgSecret: [\"PUT /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    createOrUpdateRepoSecret: [\"PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    deleteRepoSecret: [\"DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/dependabot/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/dependabot/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"],\n    listOrgSecrets: [\"GET /orgs/{org}/dependabot/secrets\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/dependabot/secrets\"],\n    listSelectedReposForOrgSecret: [\"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\"],\n    removeSelectedRepoFromOrgSecret: [\"DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}\"],\n    setSelectedReposForOrgSecret: [\"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories\"]\n  },\n  dependencyGraph: {\n    createRepositorySnapshot: [\"POST /repos/{owner}/{repo}/dependency-graph/snapshots\"],\n    diffRange: [\"GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}\"]\n  },\n  emojis: {\n    get: [\"GET /emojis\"]\n  },\n  enterpriseAdmin: {\n    addCustomLabelsToSelfHostedRunnerForEnterprise: [\"POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    disableSelectedOrganizationGithubActionsEnterprise: [\"DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}\"],\n    enableSelectedOrganizationGithubActionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}\"],\n    getAllowedActionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions/selected-actions\"],\n    getGithubActionsPermissionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions\"],\n    getServerStatistics: [\"GET /enterprise-installation/{enterprise_or_org}/server-statistics\"],\n    listLabelsForSelfHostedRunnerForEnterprise: [\"GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    listSelectedOrganizationsEnabledGithubActionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions/organizations\"],\n    removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: [\"DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    removeCustomLabelFromSelfHostedRunnerForEnterprise: [\"DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}\"],\n    setAllowedActionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/selected-actions\"],\n    setCustomLabelsForSelfHostedRunnerForEnterprise: [\"PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    setGithubActionsPermissionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions\"],\n    setSelectedOrganizationsEnabledGithubActionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/organizations\"]\n  },\n  gists: {\n    checkIsStarred: [\"GET /gists/{gist_id}/star\"],\n    create: [\"POST /gists\"],\n    createComment: [\"POST /gists/{gist_id}/comments\"],\n    delete: [\"DELETE /gists/{gist_id}\"],\n    deleteComment: [\"DELETE /gists/{gist_id}/comments/{comment_id}\"],\n    fork: [\"POST /gists/{gist_id}/forks\"],\n    get: [\"GET /gists/{gist_id}\"],\n    getComment: [\"GET /gists/{gist_id}/comments/{comment_id}\"],\n    getRevision: [\"GET /gists/{gist_id}/{sha}\"],\n    list: [\"GET /gists\"],\n    listComments: [\"GET /gists/{gist_id}/comments\"],\n    listCommits: [\"GET /gists/{gist_id}/commits\"],\n    listForUser: [\"GET /users/{username}/gists\"],\n    listForks: [\"GET /gists/{gist_id}/forks\"],\n    listPublic: [\"GET /gists/public\"],\n    listStarred: [\"GET /gists/starred\"],\n    star: [\"PUT /gists/{gist_id}/star\"],\n    unstar: [\"DELETE /gists/{gist_id}/star\"],\n    update: [\"PATCH /gists/{gist_id}\"],\n    updateComment: [\"PATCH /gists/{gist_id}/comments/{comment_id}\"]\n  },\n  git: {\n    createBlob: [\"POST /repos/{owner}/{repo}/git/blobs\"],\n    createCommit: [\"POST /repos/{owner}/{repo}/git/commits\"],\n    createRef: [\"POST /repos/{owner}/{repo}/git/refs\"],\n    createTag: [\"POST /repos/{owner}/{repo}/git/tags\"],\n    createTree: [\"POST /repos/{owner}/{repo}/git/trees\"],\n    deleteRef: [\"DELETE /repos/{owner}/{repo}/git/refs/{ref}\"],\n    getBlob: [\"GET /repos/{owner}/{repo}/git/blobs/{file_sha}\"],\n    getCommit: [\"GET /repos/{owner}/{repo}/git/commits/{commit_sha}\"],\n    getRef: [\"GET /repos/{owner}/{repo}/git/ref/{ref}\"],\n    getTag: [\"GET /repos/{owner}/{repo}/git/tags/{tag_sha}\"],\n    getTree: [\"GET /repos/{owner}/{repo}/git/trees/{tree_sha}\"],\n    listMatchingRefs: [\"GET /repos/{owner}/{repo}/git/matching-refs/{ref}\"],\n    updateRef: [\"PATCH /repos/{owner}/{repo}/git/refs/{ref}\"]\n  },\n  gitignore: {\n    getAllTemplates: [\"GET /gitignore/templates\"],\n    getTemplate: [\"GET /gitignore/templates/{name}\"]\n  },\n  interactions: {\n    getRestrictionsForAuthenticatedUser: [\"GET /user/interaction-limits\"],\n    getRestrictionsForOrg: [\"GET /orgs/{org}/interaction-limits\"],\n    getRestrictionsForRepo: [\"GET /repos/{owner}/{repo}/interaction-limits\"],\n    getRestrictionsForYourPublicRepos: [\"GET /user/interaction-limits\", {}, {\n      renamed: [\"interactions\", \"getRestrictionsForAuthenticatedUser\"]\n    }],\n    removeRestrictionsForAuthenticatedUser: [\"DELETE /user/interaction-limits\"],\n    removeRestrictionsForOrg: [\"DELETE /orgs/{org}/interaction-limits\"],\n    removeRestrictionsForRepo: [\"DELETE /repos/{owner}/{repo}/interaction-limits\"],\n    removeRestrictionsForYourPublicRepos: [\"DELETE /user/interaction-limits\", {}, {\n      renamed: [\"interactions\", \"removeRestrictionsForAuthenticatedUser\"]\n    }],\n    setRestrictionsForAuthenticatedUser: [\"PUT /user/interaction-limits\"],\n    setRestrictionsForOrg: [\"PUT /orgs/{org}/interaction-limits\"],\n    setRestrictionsForRepo: [\"PUT /repos/{owner}/{repo}/interaction-limits\"],\n    setRestrictionsForYourPublicRepos: [\"PUT /user/interaction-limits\", {}, {\n      renamed: [\"interactions\", \"setRestrictionsForAuthenticatedUser\"]\n    }]\n  },\n  issues: {\n    addAssignees: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/assignees\"],\n    addLabels: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    checkUserCanBeAssigned: [\"GET /repos/{owner}/{repo}/assignees/{assignee}\"],\n    create: [\"POST /repos/{owner}/{repo}/issues\"],\n    createComment: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/comments\"],\n    createLabel: [\"POST /repos/{owner}/{repo}/labels\"],\n    createMilestone: [\"POST /repos/{owner}/{repo}/milestones\"],\n    deleteComment: [\"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    deleteLabel: [\"DELETE /repos/{owner}/{repo}/labels/{name}\"],\n    deleteMilestone: [\"DELETE /repos/{owner}/{repo}/milestones/{milestone_number}\"],\n    get: [\"GET /repos/{owner}/{repo}/issues/{issue_number}\"],\n    getComment: [\"GET /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    getEvent: [\"GET /repos/{owner}/{repo}/issues/events/{event_id}\"],\n    getLabel: [\"GET /repos/{owner}/{repo}/labels/{name}\"],\n    getMilestone: [\"GET /repos/{owner}/{repo}/milestones/{milestone_number}\"],\n    list: [\"GET /issues\"],\n    listAssignees: [\"GET /repos/{owner}/{repo}/assignees\"],\n    listComments: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\"],\n    listCommentsForRepo: [\"GET /repos/{owner}/{repo}/issues/comments\"],\n    listEvents: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/events\"],\n    listEventsForRepo: [\"GET /repos/{owner}/{repo}/issues/events\"],\n    listEventsForTimeline: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\"],\n    listForAuthenticatedUser: [\"GET /user/issues\"],\n    listForOrg: [\"GET /orgs/{org}/issues\"],\n    listForRepo: [\"GET /repos/{owner}/{repo}/issues\"],\n    listLabelsForMilestone: [\"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\"],\n    listLabelsForRepo: [\"GET /repos/{owner}/{repo}/labels\"],\n    listLabelsOnIssue: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    listMilestones: [\"GET /repos/{owner}/{repo}/milestones\"],\n    lock: [\"PUT /repos/{owner}/{repo}/issues/{issue_number}/lock\"],\n    removeAllLabels: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    removeAssignees: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees\"],\n    removeLabel: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}\"],\n    setLabels: [\"PUT /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    unlock: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock\"],\n    update: [\"PATCH /repos/{owner}/{repo}/issues/{issue_number}\"],\n    updateComment: [\"PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    updateLabel: [\"PATCH /repos/{owner}/{repo}/labels/{name}\"],\n    updateMilestone: [\"PATCH /repos/{owner}/{repo}/milestones/{milestone_number}\"]\n  },\n  licenses: {\n    get: [\"GET /licenses/{license}\"],\n    getAllCommonlyUsed: [\"GET /licenses\"],\n    getForRepo: [\"GET /repos/{owner}/{repo}/license\"]\n  },\n  markdown: {\n    render: [\"POST /markdown\"],\n    renderRaw: [\"POST /markdown/raw\", {\n      headers: {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }\n    }]\n  },\n  meta: {\n    get: [\"GET /meta\"],\n    getOctocat: [\"GET /octocat\"],\n    getZen: [\"GET /zen\"],\n    root: [\"GET /\"]\n  },\n  migrations: {\n    cancelImport: [\"DELETE /repos/{owner}/{repo}/import\"],\n    deleteArchiveForAuthenticatedUser: [\"DELETE /user/migrations/{migration_id}/archive\"],\n    deleteArchiveForOrg: [\"DELETE /orgs/{org}/migrations/{migration_id}/archive\"],\n    downloadArchiveForOrg: [\"GET /orgs/{org}/migrations/{migration_id}/archive\"],\n    getArchiveForAuthenticatedUser: [\"GET /user/migrations/{migration_id}/archive\"],\n    getCommitAuthors: [\"GET /repos/{owner}/{repo}/import/authors\"],\n    getImportStatus: [\"GET /repos/{owner}/{repo}/import\"],\n    getLargeFiles: [\"GET /repos/{owner}/{repo}/import/large_files\"],\n    getStatusForAuthenticatedUser: [\"GET /user/migrations/{migration_id}\"],\n    getStatusForOrg: [\"GET /orgs/{org}/migrations/{migration_id}\"],\n    listForAuthenticatedUser: [\"GET /user/migrations\"],\n    listForOrg: [\"GET /orgs/{org}/migrations\"],\n    listReposForAuthenticatedUser: [\"GET /user/migrations/{migration_id}/repositories\"],\n    listReposForOrg: [\"GET /orgs/{org}/migrations/{migration_id}/repositories\"],\n    listReposForUser: [\"GET /user/migrations/{migration_id}/repositories\", {}, {\n      renamed: [\"migrations\", \"listReposForAuthenticatedUser\"]\n    }],\n    mapCommitAuthor: [\"PATCH /repos/{owner}/{repo}/import/authors/{author_id}\"],\n    setLfsPreference: [\"PATCH /repos/{owner}/{repo}/import/lfs\"],\n    startForAuthenticatedUser: [\"POST /user/migrations\"],\n    startForOrg: [\"POST /orgs/{org}/migrations\"],\n    startImport: [\"PUT /repos/{owner}/{repo}/import\"],\n    unlockRepoForAuthenticatedUser: [\"DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock\"],\n    unlockRepoForOrg: [\"DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock\"],\n    updateImport: [\"PATCH /repos/{owner}/{repo}/import\"]\n  },\n  orgs: {\n    blockUser: [\"PUT /orgs/{org}/blocks/{username}\"],\n    cancelInvitation: [\"DELETE /orgs/{org}/invitations/{invitation_id}\"],\n    checkBlockedUser: [\"GET /orgs/{org}/blocks/{username}\"],\n    checkMembershipForUser: [\"GET /orgs/{org}/members/{username}\"],\n    checkPublicMembershipForUser: [\"GET /orgs/{org}/public_members/{username}\"],\n    convertMemberToOutsideCollaborator: [\"PUT /orgs/{org}/outside_collaborators/{username}\"],\n    createInvitation: [\"POST /orgs/{org}/invitations\"],\n    createWebhook: [\"POST /orgs/{org}/hooks\"],\n    deleteWebhook: [\"DELETE /orgs/{org}/hooks/{hook_id}\"],\n    get: [\"GET /orgs/{org}\"],\n    getMembershipForAuthenticatedUser: [\"GET /user/memberships/orgs/{org}\"],\n    getMembershipForUser: [\"GET /orgs/{org}/memberships/{username}\"],\n    getWebhook: [\"GET /orgs/{org}/hooks/{hook_id}\"],\n    getWebhookConfigForOrg: [\"GET /orgs/{org}/hooks/{hook_id}/config\"],\n    getWebhookDelivery: [\"GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}\"],\n    list: [\"GET /organizations\"],\n    listAppInstallations: [\"GET /orgs/{org}/installations\"],\n    listBlockedUsers: [\"GET /orgs/{org}/blocks\"],\n    listCustomRoles: [\"GET /organizations/{organization_id}/custom_roles\"],\n    listFailedInvitations: [\"GET /orgs/{org}/failed_invitations\"],\n    listForAuthenticatedUser: [\"GET /user/orgs\"],\n    listForUser: [\"GET /users/{username}/orgs\"],\n    listInvitationTeams: [\"GET /orgs/{org}/invitations/{invitation_id}/teams\"],\n    listMembers: [\"GET /orgs/{org}/members\"],\n    listMembershipsForAuthenticatedUser: [\"GET /user/memberships/orgs\"],\n    listOutsideCollaborators: [\"GET /orgs/{org}/outside_collaborators\"],\n    listPendingInvitations: [\"GET /orgs/{org}/invitations\"],\n    listPublicMembers: [\"GET /orgs/{org}/public_members\"],\n    listWebhookDeliveries: [\"GET /orgs/{org}/hooks/{hook_id}/deliveries\"],\n    listWebhooks: [\"GET /orgs/{org}/hooks\"],\n    pingWebhook: [\"POST /orgs/{org}/hooks/{hook_id}/pings\"],\n    redeliverWebhookDelivery: [\"POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts\"],\n    removeMember: [\"DELETE /orgs/{org}/members/{username}\"],\n    removeMembershipForUser: [\"DELETE /orgs/{org}/memberships/{username}\"],\n    removeOutsideCollaborator: [\"DELETE /orgs/{org}/outside_collaborators/{username}\"],\n    removePublicMembershipForAuthenticatedUser: [\"DELETE /orgs/{org}/public_members/{username}\"],\n    setMembershipForUser: [\"PUT /orgs/{org}/memberships/{username}\"],\n    setPublicMembershipForAuthenticatedUser: [\"PUT /orgs/{org}/public_members/{username}\"],\n    unblockUser: [\"DELETE /orgs/{org}/blocks/{username}\"],\n    update: [\"PATCH /orgs/{org}\"],\n    updateMembershipForAuthenticatedUser: [\"PATCH /user/memberships/orgs/{org}\"],\n    updateWebhook: [\"PATCH /orgs/{org}/hooks/{hook_id}\"],\n    updateWebhookConfigForOrg: [\"PATCH /orgs/{org}/hooks/{hook_id}/config\"]\n  },\n  packages: {\n    deletePackageForAuthenticatedUser: [\"DELETE /user/packages/{package_type}/{package_name}\"],\n    deletePackageForOrg: [\"DELETE /orgs/{org}/packages/{package_type}/{package_name}\"],\n    deletePackageForUser: [\"DELETE /users/{username}/packages/{package_type}/{package_name}\"],\n    deletePackageVersionForAuthenticatedUser: [\"DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    deletePackageVersionForOrg: [\"DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    deletePackageVersionForUser: [\"DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    getAllPackageVersionsForAPackageOwnedByAnOrg: [\"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\", {}, {\n      renamed: [\"packages\", \"getAllPackageVersionsForPackageOwnedByOrg\"]\n    }],\n    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}/versions\", {}, {\n      renamed: [\"packages\", \"getAllPackageVersionsForPackageOwnedByAuthenticatedUser\"]\n    }],\n    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}/versions\"],\n    getAllPackageVersionsForPackageOwnedByOrg: [\"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\"],\n    getAllPackageVersionsForPackageOwnedByUser: [\"GET /users/{username}/packages/{package_type}/{package_name}/versions\"],\n    getPackageForAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}\"],\n    getPackageForOrganization: [\"GET /orgs/{org}/packages/{package_type}/{package_name}\"],\n    getPackageForUser: [\"GET /users/{username}/packages/{package_type}/{package_name}\"],\n    getPackageVersionForAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    getPackageVersionForOrganization: [\"GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    getPackageVersionForUser: [\"GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    listPackagesForAuthenticatedUser: [\"GET /user/packages\"],\n    listPackagesForOrganization: [\"GET /orgs/{org}/packages\"],\n    listPackagesForUser: [\"GET /users/{username}/packages\"],\n    restorePackageForAuthenticatedUser: [\"POST /user/packages/{package_type}/{package_name}/restore{?token}\"],\n    restorePackageForOrg: [\"POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}\"],\n    restorePackageForUser: [\"POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}\"],\n    restorePackageVersionForAuthenticatedUser: [\"POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"],\n    restorePackageVersionForOrg: [\"POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"],\n    restorePackageVersionForUser: [\"POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"]\n  },\n  projects: {\n    addCollaborator: [\"PUT /projects/{project_id}/collaborators/{username}\"],\n    createCard: [\"POST /projects/columns/{column_id}/cards\"],\n    createColumn: [\"POST /projects/{project_id}/columns\"],\n    createForAuthenticatedUser: [\"POST /user/projects\"],\n    createForOrg: [\"POST /orgs/{org}/projects\"],\n    createForRepo: [\"POST /repos/{owner}/{repo}/projects\"],\n    delete: [\"DELETE /projects/{project_id}\"],\n    deleteCard: [\"DELETE /projects/columns/cards/{card_id}\"],\n    deleteColumn: [\"DELETE /projects/columns/{column_id}\"],\n    get: [\"GET /projects/{project_id}\"],\n    getCard: [\"GET /projects/columns/cards/{card_id}\"],\n    getColumn: [\"GET /projects/columns/{column_id}\"],\n    getPermissionForUser: [\"GET /projects/{project_id}/collaborators/{username}/permission\"],\n    listCards: [\"GET /projects/columns/{column_id}/cards\"],\n    listCollaborators: [\"GET /projects/{project_id}/collaborators\"],\n    listColumns: [\"GET /projects/{project_id}/columns\"],\n    listForOrg: [\"GET /orgs/{org}/projects\"],\n    listForRepo: [\"GET /repos/{owner}/{repo}/projects\"],\n    listForUser: [\"GET /users/{username}/projects\"],\n    moveCard: [\"POST /projects/columns/cards/{card_id}/moves\"],\n    moveColumn: [\"POST /projects/columns/{column_id}/moves\"],\n    removeCollaborator: [\"DELETE /projects/{project_id}/collaborators/{username}\"],\n    update: [\"PATCH /projects/{project_id}\"],\n    updateCard: [\"PATCH /projects/columns/cards/{card_id}\"],\n    updateColumn: [\"PATCH /projects/columns/{column_id}\"]\n  },\n  pulls: {\n    checkIfMerged: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/merge\"],\n    create: [\"POST /repos/{owner}/{repo}/pulls\"],\n    createReplyForReviewComment: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\"],\n    createReview: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews\"],\n    createReviewComment: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments\"],\n    deletePendingReview: [\"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"],\n    deleteReviewComment: [\"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}\"],\n    dismissReview: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals\"],\n    get: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}\"],\n    getReview: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"],\n    getReviewComment: [\"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}\"],\n    list: [\"GET /repos/{owner}/{repo}/pulls\"],\n    listCommentsForReview: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\"],\n    listCommits: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\"],\n    listFiles: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\"],\n    listRequestedReviewers: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"],\n    listReviewComments: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\"],\n    listReviewCommentsForRepo: [\"GET /repos/{owner}/{repo}/pulls/comments\"],\n    listReviews: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\"],\n    merge: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge\"],\n    removeRequestedReviewers: [\"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"],\n    requestReviewers: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"],\n    submitReview: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events\"],\n    update: [\"PATCH /repos/{owner}/{repo}/pulls/{pull_number}\"],\n    updateBranch: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch\"],\n    updateReview: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"],\n    updateReviewComment: [\"PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}\"]\n  },\n  rateLimit: {\n    get: [\"GET /rate_limit\"]\n  },\n  reactions: {\n    createForCommitComment: [\"POST /repos/{owner}/{repo}/comments/{comment_id}/reactions\"],\n    createForIssue: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/reactions\"],\n    createForIssueComment: [\"POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\"],\n    createForPullRequestReviewComment: [\"POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\"],\n    createForRelease: [\"POST /repos/{owner}/{repo}/releases/{release_id}/reactions\"],\n    createForTeamDiscussionCommentInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\"],\n    createForTeamDiscussionInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\"],\n    deleteForCommitComment: [\"DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}\"],\n    deleteForIssue: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}\"],\n    deleteForIssueComment: [\"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}\"],\n    deleteForPullRequestComment: [\"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}\"],\n    deleteForRelease: [\"DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}\"],\n    deleteForTeamDiscussion: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}\"],\n    deleteForTeamDiscussionComment: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}\"],\n    listForCommitComment: [\"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\"],\n    listForIssue: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\"],\n    listForIssueComment: [\"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\"],\n    listForPullRequestReviewComment: [\"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\"],\n    listForRelease: [\"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\"],\n    listForTeamDiscussionCommentInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\"],\n    listForTeamDiscussionInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\"]\n  },\n  repos: {\n    acceptInvitation: [\"PATCH /user/repository_invitations/{invitation_id}\", {}, {\n      renamed: [\"repos\", \"acceptInvitationForAuthenticatedUser\"]\n    }],\n    acceptInvitationForAuthenticatedUser: [\"PATCH /user/repository_invitations/{invitation_id}\"],\n    addAppAccessRestrictions: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\", {}, {\n      mapToData: \"apps\"\n    }],\n    addCollaborator: [\"PUT /repos/{owner}/{repo}/collaborators/{username}\"],\n    addStatusCheckContexts: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\", {}, {\n      mapToData: \"contexts\"\n    }],\n    addTeamAccessRestrictions: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\", {}, {\n      mapToData: \"teams\"\n    }],\n    addUserAccessRestrictions: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\", {}, {\n      mapToData: \"users\"\n    }],\n    checkCollaborator: [\"GET /repos/{owner}/{repo}/collaborators/{username}\"],\n    checkVulnerabilityAlerts: [\"GET /repos/{owner}/{repo}/vulnerability-alerts\"],\n    codeownersErrors: [\"GET /repos/{owner}/{repo}/codeowners/errors\"],\n    compareCommits: [\"GET /repos/{owner}/{repo}/compare/{base}...{head}\"],\n    compareCommitsWithBasehead: [\"GET /repos/{owner}/{repo}/compare/{basehead}\"],\n    createAutolink: [\"POST /repos/{owner}/{repo}/autolinks\"],\n    createCommitComment: [\"POST /repos/{owner}/{repo}/commits/{commit_sha}/comments\"],\n    createCommitSignatureProtection: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"],\n    createCommitStatus: [\"POST /repos/{owner}/{repo}/statuses/{sha}\"],\n    createDeployKey: [\"POST /repos/{owner}/{repo}/keys\"],\n    createDeployment: [\"POST /repos/{owner}/{repo}/deployments\"],\n    createDeploymentStatus: [\"POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\"],\n    createDispatchEvent: [\"POST /repos/{owner}/{repo}/dispatches\"],\n    createForAuthenticatedUser: [\"POST /user/repos\"],\n    createFork: [\"POST /repos/{owner}/{repo}/forks\"],\n    createInOrg: [\"POST /orgs/{org}/repos\"],\n    createOrUpdateEnvironment: [\"PUT /repos/{owner}/{repo}/environments/{environment_name}\"],\n    createOrUpdateFileContents: [\"PUT /repos/{owner}/{repo}/contents/{path}\"],\n    createPagesSite: [\"POST /repos/{owner}/{repo}/pages\"],\n    createRelease: [\"POST /repos/{owner}/{repo}/releases\"],\n    createTagProtection: [\"POST /repos/{owner}/{repo}/tags/protection\"],\n    createUsingTemplate: [\"POST /repos/{template_owner}/{template_repo}/generate\"],\n    createWebhook: [\"POST /repos/{owner}/{repo}/hooks\"],\n    declineInvitation: [\"DELETE /user/repository_invitations/{invitation_id}\", {}, {\n      renamed: [\"repos\", \"declineInvitationForAuthenticatedUser\"]\n    }],\n    declineInvitationForAuthenticatedUser: [\"DELETE /user/repository_invitations/{invitation_id}\"],\n    delete: [\"DELETE /repos/{owner}/{repo}\"],\n    deleteAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions\"],\n    deleteAdminBranchProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"],\n    deleteAnEnvironment: [\"DELETE /repos/{owner}/{repo}/environments/{environment_name}\"],\n    deleteAutolink: [\"DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}\"],\n    deleteBranchProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection\"],\n    deleteCommitComment: [\"DELETE /repos/{owner}/{repo}/comments/{comment_id}\"],\n    deleteCommitSignatureProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"],\n    deleteDeployKey: [\"DELETE /repos/{owner}/{repo}/keys/{key_id}\"],\n    deleteDeployment: [\"DELETE /repos/{owner}/{repo}/deployments/{deployment_id}\"],\n    deleteFile: [\"DELETE /repos/{owner}/{repo}/contents/{path}\"],\n    deleteInvitation: [\"DELETE /repos/{owner}/{repo}/invitations/{invitation_id}\"],\n    deletePagesSite: [\"DELETE /repos/{owner}/{repo}/pages\"],\n    deletePullRequestReviewProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"],\n    deleteRelease: [\"DELETE /repos/{owner}/{repo}/releases/{release_id}\"],\n    deleteReleaseAsset: [\"DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    deleteTagProtection: [\"DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}\"],\n    deleteWebhook: [\"DELETE /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    disableAutomatedSecurityFixes: [\"DELETE /repos/{owner}/{repo}/automated-security-fixes\"],\n    disableLfsForRepo: [\"DELETE /repos/{owner}/{repo}/lfs\"],\n    disableVulnerabilityAlerts: [\"DELETE /repos/{owner}/{repo}/vulnerability-alerts\"],\n    downloadArchive: [\"GET /repos/{owner}/{repo}/zipball/{ref}\", {}, {\n      renamed: [\"repos\", \"downloadZipballArchive\"]\n    }],\n    downloadTarballArchive: [\"GET /repos/{owner}/{repo}/tarball/{ref}\"],\n    downloadZipballArchive: [\"GET /repos/{owner}/{repo}/zipball/{ref}\"],\n    enableAutomatedSecurityFixes: [\"PUT /repos/{owner}/{repo}/automated-security-fixes\"],\n    enableLfsForRepo: [\"PUT /repos/{owner}/{repo}/lfs\"],\n    enableVulnerabilityAlerts: [\"PUT /repos/{owner}/{repo}/vulnerability-alerts\"],\n    generateReleaseNotes: [\"POST /repos/{owner}/{repo}/releases/generate-notes\"],\n    get: [\"GET /repos/{owner}/{repo}\"],\n    getAccessRestrictions: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions\"],\n    getAdminBranchProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"],\n    getAllEnvironments: [\"GET /repos/{owner}/{repo}/environments\"],\n    getAllStatusCheckContexts: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\"],\n    getAllTopics: [\"GET /repos/{owner}/{repo}/topics\"],\n    getAppsWithAccessToProtectedBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\"],\n    getAutolink: [\"GET /repos/{owner}/{repo}/autolinks/{autolink_id}\"],\n    getBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}\"],\n    getBranchProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection\"],\n    getClones: [\"GET /repos/{owner}/{repo}/traffic/clones\"],\n    getCodeFrequencyStats: [\"GET /repos/{owner}/{repo}/stats/code_frequency\"],\n    getCollaboratorPermissionLevel: [\"GET /repos/{owner}/{repo}/collaborators/{username}/permission\"],\n    getCombinedStatusForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/status\"],\n    getCommit: [\"GET /repos/{owner}/{repo}/commits/{ref}\"],\n    getCommitActivityStats: [\"GET /repos/{owner}/{repo}/stats/commit_activity\"],\n    getCommitComment: [\"GET /repos/{owner}/{repo}/comments/{comment_id}\"],\n    getCommitSignatureProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"],\n    getCommunityProfileMetrics: [\"GET /repos/{owner}/{repo}/community/profile\"],\n    getContent: [\"GET /repos/{owner}/{repo}/contents/{path}\"],\n    getContributorsStats: [\"GET /repos/{owner}/{repo}/stats/contributors\"],\n    getDeployKey: [\"GET /repos/{owner}/{repo}/keys/{key_id}\"],\n    getDeployment: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}\"],\n    getDeploymentStatus: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}\"],\n    getEnvironment: [\"GET /repos/{owner}/{repo}/environments/{environment_name}\"],\n    getLatestPagesBuild: [\"GET /repos/{owner}/{repo}/pages/builds/latest\"],\n    getLatestRelease: [\"GET /repos/{owner}/{repo}/releases/latest\"],\n    getPages: [\"GET /repos/{owner}/{repo}/pages\"],\n    getPagesBuild: [\"GET /repos/{owner}/{repo}/pages/builds/{build_id}\"],\n    getPagesHealthCheck: [\"GET /repos/{owner}/{repo}/pages/health\"],\n    getParticipationStats: [\"GET /repos/{owner}/{repo}/stats/participation\"],\n    getPullRequestReviewProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"],\n    getPunchCardStats: [\"GET /repos/{owner}/{repo}/stats/punch_card\"],\n    getReadme: [\"GET /repos/{owner}/{repo}/readme\"],\n    getReadmeInDirectory: [\"GET /repos/{owner}/{repo}/readme/{dir}\"],\n    getRelease: [\"GET /repos/{owner}/{repo}/releases/{release_id}\"],\n    getReleaseAsset: [\"GET /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    getReleaseByTag: [\"GET /repos/{owner}/{repo}/releases/tags/{tag}\"],\n    getStatusChecksProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"],\n    getTeamsWithAccessToProtectedBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\"],\n    getTopPaths: [\"GET /repos/{owner}/{repo}/traffic/popular/paths\"],\n    getTopReferrers: [\"GET /repos/{owner}/{repo}/traffic/popular/referrers\"],\n    getUsersWithAccessToProtectedBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\"],\n    getViews: [\"GET /repos/{owner}/{repo}/traffic/views\"],\n    getWebhook: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    getWebhookConfigForRepo: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}/config\"],\n    getWebhookDelivery: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}\"],\n    listAutolinks: [\"GET /repos/{owner}/{repo}/autolinks\"],\n    listBranches: [\"GET /repos/{owner}/{repo}/branches\"],\n    listBranchesForHeadCommit: [\"GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head\"],\n    listCollaborators: [\"GET /repos/{owner}/{repo}/collaborators\"],\n    listCommentsForCommit: [\"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\"],\n    listCommitCommentsForRepo: [\"GET /repos/{owner}/{repo}/comments\"],\n    listCommitStatusesForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/statuses\"],\n    listCommits: [\"GET /repos/{owner}/{repo}/commits\"],\n    listContributors: [\"GET /repos/{owner}/{repo}/contributors\"],\n    listDeployKeys: [\"GET /repos/{owner}/{repo}/keys\"],\n    listDeploymentStatuses: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\"],\n    listDeployments: [\"GET /repos/{owner}/{repo}/deployments\"],\n    listForAuthenticatedUser: [\"GET /user/repos\"],\n    listForOrg: [\"GET /orgs/{org}/repos\"],\n    listForUser: [\"GET /users/{username}/repos\"],\n    listForks: [\"GET /repos/{owner}/{repo}/forks\"],\n    listInvitations: [\"GET /repos/{owner}/{repo}/invitations\"],\n    listInvitationsForAuthenticatedUser: [\"GET /user/repository_invitations\"],\n    listLanguages: [\"GET /repos/{owner}/{repo}/languages\"],\n    listPagesBuilds: [\"GET /repos/{owner}/{repo}/pages/builds\"],\n    listPublic: [\"GET /repositories\"],\n    listPullRequestsAssociatedWithCommit: [\"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\"],\n    listReleaseAssets: [\"GET /repos/{owner}/{repo}/releases/{release_id}/assets\"],\n    listReleases: [\"GET /repos/{owner}/{repo}/releases\"],\n    listTagProtection: [\"GET /repos/{owner}/{repo}/tags/protection\"],\n    listTags: [\"GET /repos/{owner}/{repo}/tags\"],\n    listTeams: [\"GET /repos/{owner}/{repo}/teams\"],\n    listWebhookDeliveries: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\"],\n    listWebhooks: [\"GET /repos/{owner}/{repo}/hooks\"],\n    merge: [\"POST /repos/{owner}/{repo}/merges\"],\n    mergeUpstream: [\"POST /repos/{owner}/{repo}/merge-upstream\"],\n    pingWebhook: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/pings\"],\n    redeliverWebhookDelivery: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts\"],\n    removeAppAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\", {}, {\n      mapToData: \"apps\"\n    }],\n    removeCollaborator: [\"DELETE /repos/{owner}/{repo}/collaborators/{username}\"],\n    removeStatusCheckContexts: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\", {}, {\n      mapToData: \"contexts\"\n    }],\n    removeStatusCheckProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"],\n    removeTeamAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\", {}, {\n      mapToData: \"teams\"\n    }],\n    removeUserAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\", {}, {\n      mapToData: \"users\"\n    }],\n    renameBranch: [\"POST /repos/{owner}/{repo}/branches/{branch}/rename\"],\n    replaceAllTopics: [\"PUT /repos/{owner}/{repo}/topics\"],\n    requestPagesBuild: [\"POST /repos/{owner}/{repo}/pages/builds\"],\n    setAdminBranchProtection: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"],\n    setAppAccessRestrictions: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\", {}, {\n      mapToData: \"apps\"\n    }],\n    setStatusCheckContexts: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\", {}, {\n      mapToData: \"contexts\"\n    }],\n    setTeamAccessRestrictions: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\", {}, {\n      mapToData: \"teams\"\n    }],\n    setUserAccessRestrictions: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\", {}, {\n      mapToData: \"users\"\n    }],\n    testPushWebhook: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/tests\"],\n    transfer: [\"POST /repos/{owner}/{repo}/transfer\"],\n    update: [\"PATCH /repos/{owner}/{repo}\"],\n    updateBranchProtection: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection\"],\n    updateCommitComment: [\"PATCH /repos/{owner}/{repo}/comments/{comment_id}\"],\n    updateInformationAboutPagesSite: [\"PUT /repos/{owner}/{repo}/pages\"],\n    updateInvitation: [\"PATCH /repos/{owner}/{repo}/invitations/{invitation_id}\"],\n    updatePullRequestReviewProtection: [\"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"],\n    updateRelease: [\"PATCH /repos/{owner}/{repo}/releases/{release_id}\"],\n    updateReleaseAsset: [\"PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    updateStatusCheckPotection: [\"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\", {}, {\n      renamed: [\"repos\", \"updateStatusCheckProtection\"]\n    }],\n    updateStatusCheckProtection: [\"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"],\n    updateWebhook: [\"PATCH /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    updateWebhookConfigForRepo: [\"PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config\"],\n    uploadReleaseAsset: [\"POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}\", {\n      baseUrl: \"https://uploads.github.com\"\n    }]\n  },\n  search: {\n    code: [\"GET /search/code\"],\n    commits: [\"GET /search/commits\"],\n    issuesAndPullRequests: [\"GET /search/issues\"],\n    labels: [\"GET /search/labels\"],\n    repos: [\"GET /search/repositories\"],\n    topics: [\"GET /search/topics\"],\n    users: [\"GET /search/users\"]\n  },\n  secretScanning: {\n    getAlert: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}\"],\n    listAlertsForEnterprise: [\"GET /enterprises/{enterprise}/secret-scanning/alerts\"],\n    listAlertsForOrg: [\"GET /orgs/{org}/secret-scanning/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts\"],\n    listLocationsForAlert: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\"],\n    updateAlert: [\"PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}\"]\n  },\n  teams: {\n    addOrUpdateMembershipForUserInOrg: [\"PUT /orgs/{org}/teams/{team_slug}/memberships/{username}\"],\n    addOrUpdateProjectPermissionsInOrg: [\"PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}\"],\n    addOrUpdateRepoPermissionsInOrg: [\"PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"],\n    checkPermissionsForProjectInOrg: [\"GET /orgs/{org}/teams/{team_slug}/projects/{project_id}\"],\n    checkPermissionsForRepoInOrg: [\"GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"],\n    create: [\"POST /orgs/{org}/teams\"],\n    createDiscussionCommentInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\"],\n    createDiscussionInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions\"],\n    deleteDiscussionCommentInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"],\n    deleteDiscussionInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"],\n    deleteInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}\"],\n    getByName: [\"GET /orgs/{org}/teams/{team_slug}\"],\n    getDiscussionCommentInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"],\n    getDiscussionInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"],\n    getMembershipForUserInOrg: [\"GET /orgs/{org}/teams/{team_slug}/memberships/{username}\"],\n    list: [\"GET /orgs/{org}/teams\"],\n    listChildInOrg: [\"GET /orgs/{org}/teams/{team_slug}/teams\"],\n    listDiscussionCommentsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\"],\n    listDiscussionsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions\"],\n    listForAuthenticatedUser: [\"GET /user/teams\"],\n    listMembersInOrg: [\"GET /orgs/{org}/teams/{team_slug}/members\"],\n    listPendingInvitationsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/invitations\"],\n    listProjectsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/projects\"],\n    listReposInOrg: [\"GET /orgs/{org}/teams/{team_slug}/repos\"],\n    removeMembershipForUserInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}\"],\n    removeProjectInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}\"],\n    removeRepoInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"],\n    updateDiscussionCommentInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"],\n    updateDiscussionInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"],\n    updateInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}\"]\n  },\n  users: {\n    addEmailForAuthenticated: [\"POST /user/emails\", {}, {\n      renamed: [\"users\", \"addEmailForAuthenticatedUser\"]\n    }],\n    addEmailForAuthenticatedUser: [\"POST /user/emails\"],\n    block: [\"PUT /user/blocks/{username}\"],\n    checkBlocked: [\"GET /user/blocks/{username}\"],\n    checkFollowingForUser: [\"GET /users/{username}/following/{target_user}\"],\n    checkPersonIsFollowedByAuthenticated: [\"GET /user/following/{username}\"],\n    createGpgKeyForAuthenticated: [\"POST /user/gpg_keys\", {}, {\n      renamed: [\"users\", \"createGpgKeyForAuthenticatedUser\"]\n    }],\n    createGpgKeyForAuthenticatedUser: [\"POST /user/gpg_keys\"],\n    createPublicSshKeyForAuthenticated: [\"POST /user/keys\", {}, {\n      renamed: [\"users\", \"createPublicSshKeyForAuthenticatedUser\"]\n    }],\n    createPublicSshKeyForAuthenticatedUser: [\"POST /user/keys\"],\n    deleteEmailForAuthenticated: [\"DELETE /user/emails\", {}, {\n      renamed: [\"users\", \"deleteEmailForAuthenticatedUser\"]\n    }],\n    deleteEmailForAuthenticatedUser: [\"DELETE /user/emails\"],\n    deleteGpgKeyForAuthenticated: [\"DELETE /user/gpg_keys/{gpg_key_id}\", {}, {\n      renamed: [\"users\", \"deleteGpgKeyForAuthenticatedUser\"]\n    }],\n    deleteGpgKeyForAuthenticatedUser: [\"DELETE /user/gpg_keys/{gpg_key_id}\"],\n    deletePublicSshKeyForAuthenticated: [\"DELETE /user/keys/{key_id}\", {}, {\n      renamed: [\"users\", \"deletePublicSshKeyForAuthenticatedUser\"]\n    }],\n    deletePublicSshKeyForAuthenticatedUser: [\"DELETE /user/keys/{key_id}\"],\n    follow: [\"PUT /user/following/{username}\"],\n    getAuthenticated: [\"GET /user\"],\n    getByUsername: [\"GET /users/{username}\"],\n    getContextForUser: [\"GET /users/{username}/hovercard\"],\n    getGpgKeyForAuthenticated: [\"GET /user/gpg_keys/{gpg_key_id}\", {}, {\n      renamed: [\"users\", \"getGpgKeyForAuthenticatedUser\"]\n    }],\n    getGpgKeyForAuthenticatedUser: [\"GET /user/gpg_keys/{gpg_key_id}\"],\n    getPublicSshKeyForAuthenticated: [\"GET /user/keys/{key_id}\", {}, {\n      renamed: [\"users\", \"getPublicSshKeyForAuthenticatedUser\"]\n    }],\n    getPublicSshKeyForAuthenticatedUser: [\"GET /user/keys/{key_id}\"],\n    list: [\"GET /users\"],\n    listBlockedByAuthenticated: [\"GET /user/blocks\", {}, {\n      renamed: [\"users\", \"listBlockedByAuthenticatedUser\"]\n    }],\n    listBlockedByAuthenticatedUser: [\"GET /user/blocks\"],\n    listEmailsForAuthenticated: [\"GET /user/emails\", {}, {\n      renamed: [\"users\", \"listEmailsForAuthenticatedUser\"]\n    }],\n    listEmailsForAuthenticatedUser: [\"GET /user/emails\"],\n    listFollowedByAuthenticated: [\"GET /user/following\", {}, {\n      renamed: [\"users\", \"listFollowedByAuthenticatedUser\"]\n    }],\n    listFollowedByAuthenticatedUser: [\"GET /user/following\"],\n    listFollowersForAuthenticatedUser: [\"GET /user/followers\"],\n    listFollowersForUser: [\"GET /users/{username}/followers\"],\n    listFollowingForUser: [\"GET /users/{username}/following\"],\n    listGpgKeysForAuthenticated: [\"GET /user/gpg_keys\", {}, {\n      renamed: [\"users\", \"listGpgKeysForAuthenticatedUser\"]\n    }],\n    listGpgKeysForAuthenticatedUser: [\"GET /user/gpg_keys\"],\n    listGpgKeysForUser: [\"GET /users/{username}/gpg_keys\"],\n    listPublicEmailsForAuthenticated: [\"GET /user/public_emails\", {}, {\n      renamed: [\"users\", \"listPublicEmailsForAuthenticatedUser\"]\n    }],\n    listPublicEmailsForAuthenticatedUser: [\"GET /user/public_emails\"],\n    listPublicKeysForUser: [\"GET /users/{username}/keys\"],\n    listPublicSshKeysForAuthenticated: [\"GET /user/keys\", {}, {\n      renamed: [\"users\", \"listPublicSshKeysForAuthenticatedUser\"]\n    }],\n    listPublicSshKeysForAuthenticatedUser: [\"GET /user/keys\"],\n    setPrimaryEmailVisibilityForAuthenticated: [\"PATCH /user/email/visibility\", {}, {\n      renamed: [\"users\", \"setPrimaryEmailVisibilityForAuthenticatedUser\"]\n    }],\n    setPrimaryEmailVisibilityForAuthenticatedUser: [\"PATCH /user/email/visibility\"],\n    unblock: [\"DELETE /user/blocks/{username}\"],\n    unfollow: [\"DELETE /user/following/{username}\"],\n    updateAuthenticated: [\"PATCH /user\"]\n  }\n};\n\nconst VERSION = \"5.16.2\";\n\nfunction endpointsToMethods(octokit, endpointsMap) {\n  const newMethods = {};\n\n  for (const [scope, endpoints] of Object.entries(endpointsMap)) {\n    for (const [methodName, endpoint] of Object.entries(endpoints)) {\n      const [route, defaults, decorations] = endpoint;\n      const [method, url] = route.split(/ /);\n      const endpointDefaults = Object.assign({\n        method,\n        url\n      }, defaults);\n\n      if (!newMethods[scope]) {\n        newMethods[scope] = {};\n      }\n\n      const scopeMethods = newMethods[scope];\n\n      if (decorations) {\n        scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);\n        continue;\n      }\n\n      scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n  }\n\n  return newMethods;\n}\n\nfunction decorate(octokit, scope, methodName, defaults, decorations) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n  /* istanbul ignore next */\n\n  function withDecorations(...args) {\n    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`\n\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: undefined\n      });\n      return requestWithDefaults(options);\n    }\n\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);\n    }\n\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n\n    if (decorations.renamedParameters) {\n      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n      const options = requestWithDefaults.endpoint.merge(...args);\n\n      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {\n        if (name in options) {\n          octokit.log.warn(`\"${name}\" parameter is deprecated for \"octokit.${scope}.${methodName}()\". Use \"${alias}\" instead`);\n\n          if (!(alias in options)) {\n            options[alias] = options[name];\n          }\n\n          delete options[name];\n        }\n      }\n\n      return requestWithDefaults(options);\n    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n\n\n    return requestWithDefaults(...args);\n  }\n\n  return Object.assign(withDecorations, requestWithDefaults);\n}\n\nfunction restEndpointMethods(octokit) {\n  const api = endpointsToMethods(octokit, Endpoints);\n  return {\n    rest: api\n  };\n}\nrestEndpointMethods.VERSION = VERSION;\nfunction legacyRestEndpointMethods(octokit) {\n  const api = endpointsToMethods(octokit, Endpoints);\n  return _objectSpread2(_objectSpread2({}, api), {}, {\n    rest: api\n  });\n}\nlegacyRestEndpointMethods.VERSION = VERSION;\n\nexports.legacyRestEndpointMethods = legacyRestEndpointMethods;\nexports.restEndpointMethods = restEndpointMethods;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar deprecation = require('deprecation');\nvar once = _interopDefault(require('once'));\n\nconst logOnceCode = once(deprecation => console.warn(deprecation));\nconst logOnceHeaders = once(deprecation => console.warn(deprecation));\n/**\n * Error with extra properties to help with debugging\n */\n\nclass RequestError extends Error {\n  constructor(message, statusCode, options) {\n    super(message); // Maintains proper stack trace (only available on V8)\n\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.name = \"HttpError\";\n    this.status = statusCode;\n    let headers;\n\n    if (\"headers\" in options && typeof options.headers !== \"undefined\") {\n      headers = options.headers;\n    }\n\n    if (\"response\" in options) {\n      this.response = options.response;\n      headers = options.response.headers;\n    } // redact request credentials without mutating original request options\n\n\n    const requestCopy = Object.assign({}, options.request);\n\n    if (options.request.headers.authorization) {\n      requestCopy.headers = Object.assign({}, options.request.headers, {\n        authorization: options.request.headers.authorization.replace(/ .*$/, \" [REDACTED]\")\n      });\n    }\n\n    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit\n    // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications\n    .replace(/\\bclient_secret=\\w+/g, \"client_secret=[REDACTED]\") // OAuth tokens can be passed as URL query parameters, although it is not recommended\n    // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header\n    .replace(/\\baccess_token=\\w+/g, \"access_token=[REDACTED]\");\n    this.request = requestCopy; // deprecations\n\n    Object.defineProperty(this, \"code\", {\n      get() {\n        logOnceCode(new deprecation.Deprecation(\"[@octokit/request-error] `error.code` is deprecated, use `error.status`.\"));\n        return statusCode;\n      }\n\n    });\n    Object.defineProperty(this, \"headers\", {\n      get() {\n        logOnceHeaders(new deprecation.Deprecation(\"[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.\"));\n        return headers || {};\n      }\n\n    });\n  }\n\n}\n\nexports.RequestError = RequestError;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar endpoint = require('@octokit/endpoint');\nvar universalUserAgent = require('universal-user-agent');\nvar isPlainObject = require('is-plain-object');\nvar nodeFetch = _interopDefault(require('node-fetch'));\nvar requestError = require('@octokit/request-error');\n\nconst VERSION = \"5.6.3\";\n\nfunction getBufferResponse(response) {\n  return response.arrayBuffer();\n}\n\nfunction fetchWrapper(requestOptions) {\n  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;\n\n  if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {\n    requestOptions.body = JSON.stringify(requestOptions.body);\n  }\n\n  let headers = {};\n  let status;\n  let url;\n  const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;\n  return fetch(requestOptions.url, Object.assign({\n    method: requestOptions.method,\n    body: requestOptions.body,\n    headers: requestOptions.headers,\n    redirect: requestOptions.redirect\n  }, // `requestOptions.request.agent` type is incompatible\n  // see https://github.com/octokit/types.ts/pull/264\n  requestOptions.request)).then(async response => {\n    url = response.url;\n    status = response.status;\n\n    for (const keyAndValue of response.headers) {\n      headers[keyAndValue[0]] = keyAndValue[1];\n    }\n\n    if (\"deprecation\" in headers) {\n      const matches = headers.link && headers.link.match(/<([^>]+)>; rel=\"deprecation\"/);\n      const deprecationLink = matches && matches.pop();\n      log.warn(`[@octokit/request] \"${requestOptions.method} ${requestOptions.url}\" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : \"\"}`);\n    }\n\n    if (status === 204 || status === 205) {\n      return;\n    } // GitHub API returns 200 for HEAD requests\n\n\n    if (requestOptions.method === \"HEAD\") {\n      if (status < 400) {\n        return;\n      }\n\n      throw new requestError.RequestError(response.statusText, status, {\n        response: {\n          url,\n          status,\n          headers,\n          data: undefined\n        },\n        request: requestOptions\n      });\n    }\n\n    if (status === 304) {\n      throw new requestError.RequestError(\"Not modified\", status, {\n        response: {\n          url,\n          status,\n          headers,\n          data: await getResponseData(response)\n        },\n        request: requestOptions\n      });\n    }\n\n    if (status >= 400) {\n      const data = await getResponseData(response);\n      const error = new requestError.RequestError(toErrorMessage(data), status, {\n        response: {\n          url,\n          status,\n          headers,\n          data\n        },\n        request: requestOptions\n      });\n      throw error;\n    }\n\n    return getResponseData(response);\n  }).then(data => {\n    return {\n      status,\n      url,\n      headers,\n      data\n    };\n  }).catch(error => {\n    if (error instanceof requestError.RequestError) throw error;\n    throw new requestError.RequestError(error.message, 500, {\n      request: requestOptions\n    });\n  });\n}\n\nasync function getResponseData(response) {\n  const contentType = response.headers.get(\"content-type\");\n\n  if (/application\\/json/.test(contentType)) {\n    return response.json();\n  }\n\n  if (!contentType || /^text\\/|charset=utf-8$/.test(contentType)) {\n    return response.text();\n  }\n\n  return getBufferResponse(response);\n}\n\nfunction toErrorMessage(data) {\n  if (typeof data === \"string\") return data; // istanbul ignore else - just in case\n\n  if (\"message\" in data) {\n    if (Array.isArray(data.errors)) {\n      return `${data.message}: ${data.errors.map(JSON.stringify).join(\", \")}`;\n    }\n\n    return data.message;\n  } // istanbul ignore next - just in case\n\n\n  return `Unknown error: ${JSON.stringify(data)}`;\n}\n\nfunction withDefaults(oldEndpoint, newDefaults) {\n  const endpoint = oldEndpoint.defaults(newDefaults);\n\n  const newApi = function (route, parameters) {\n    const endpointOptions = endpoint.merge(route, parameters);\n\n    if (!endpointOptions.request || !endpointOptions.request.hook) {\n      return fetchWrapper(endpoint.parse(endpointOptions));\n    }\n\n    const request = (route, parameters) => {\n      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));\n    };\n\n    Object.assign(request, {\n      endpoint,\n      defaults: withDefaults.bind(null, endpoint)\n    });\n    return endpointOptions.request.hook(request, endpointOptions);\n  };\n\n  return Object.assign(newApi, {\n    endpoint,\n    defaults: withDefaults.bind(null, endpoint)\n  });\n}\n\nconst request = withDefaults(endpoint.endpoint, {\n  headers: {\n    \"user-agent\": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`\n  }\n});\n\nexports.request = request;\n//# sourceMappingURL=index.js.map\n","var register = require(\"./lib/register\");\nvar addHook = require(\"./lib/add\");\nvar removeHook = require(\"./lib/remove\");\n\n// bind with array of arguments: https://stackoverflow.com/a/21792913\nvar bind = Function.bind;\nvar bindable = bind.bind(bind);\n\nfunction bindApi(hook, state, name) {\n  var removeHookRef = bindable(removeHook, null).apply(\n    null,\n    name ? [state, name] : [state]\n  );\n  hook.api = { remove: removeHookRef };\n  hook.remove = removeHookRef;\n  [\"before\", \"error\", \"after\", \"wrap\"].forEach(function (kind) {\n    var args = name ? [state, kind, name] : [state, kind];\n    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);\n  });\n}\n\nfunction HookSingular() {\n  var singularHookName = \"h\";\n  var singularHookState = {\n    registry: {},\n  };\n  var singularHook = register.bind(null, singularHookState, singularHookName);\n  bindApi(singularHook, singularHookState, singularHookName);\n  return singularHook;\n}\n\nfunction HookCollection() {\n  var state = {\n    registry: {},\n  };\n\n  var hook = register.bind(null, state);\n  bindApi(hook, state);\n\n  return hook;\n}\n\nvar collectionHookDeprecationMessageDisplayed = false;\nfunction Hook() {\n  if (!collectionHookDeprecationMessageDisplayed) {\n    console.warn(\n      '[before-after-hook]: \"Hook()\" repurposing warning, use \"Hook.Collection()\". Read more: https://git.io/upgrade-before-after-hook-to-1.4'\n    );\n    collectionHookDeprecationMessageDisplayed = true;\n  }\n  return HookCollection();\n}\n\nHook.Singular = HookSingular.bind();\nHook.Collection = HookCollection.bind();\n\nmodule.exports = Hook;\n// expose constructors as a named property for TypeScript\nmodule.exports.Hook = Hook;\nmodule.exports.Singular = Hook.Singular;\nmodule.exports.Collection = Hook.Collection;\n","module.exports = addHook;\n\nfunction addHook(state, kind, name, hook) {\n  var orig = hook;\n  if (!state.registry[name]) {\n    state.registry[name] = [];\n  }\n\n  if (kind === \"before\") {\n    hook = function (method, options) {\n      return Promise.resolve()\n        .then(orig.bind(null, options))\n        .then(method.bind(null, options));\n    };\n  }\n\n  if (kind === \"after\") {\n    hook = function (method, options) {\n      var result;\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .then(function (result_) {\n          result = result_;\n          return orig(result, options);\n        })\n        .then(function () {\n          return result;\n        });\n    };\n  }\n\n  if (kind === \"error\") {\n    hook = function (method, options) {\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .catch(function (error) {\n          return orig(error, options);\n        });\n    };\n  }\n\n  state.registry[name].push({\n    hook: hook,\n    orig: orig,\n  });\n}\n","module.exports = register;\n\nfunction register(state, name, method, options) {\n  if (typeof method !== \"function\") {\n    throw new Error(\"method for before hook must be a function\");\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (Array.isArray(name)) {\n    return name.reverse().reduce(function (callback, name) {\n      return register.bind(null, state, name, callback, options);\n    }, method)();\n  }\n\n  return Promise.resolve().then(function () {\n    if (!state.registry[name]) {\n      return method(options);\n    }\n\n    return state.registry[name].reduce(function (method, registered) {\n      return registered.hook.bind(null, method, options);\n    }, method)();\n  });\n}\n","module.exports = removeHook;\n\nfunction removeHook(state, name, method) {\n  if (!state.registry[name]) {\n    return;\n  }\n\n  var index = state.registry[name]\n    .map(function (registered) {\n      return registered.orig;\n    })\n    .indexOf(method);\n\n  if (index === -1) {\n    return;\n  }\n\n  state.registry[name].splice(index, 1);\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass Deprecation extends Error {\n  constructor(message) {\n    super(message); // Maintains proper stack trace (only available on V8)\n\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.name = 'Deprecation';\n  }\n\n}\n\nexports.Deprecation = Deprecation;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexports.isPlainObject = isPlainObject;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Stream = _interopDefault(require('stream'));\nvar http = _interopDefault(require('http'));\nvar Url = _interopDefault(require('url'));\nvar whatwgUrl = _interopDefault(require('whatwg-url'));\nvar https = _interopDefault(require('https'));\nvar zlib = _interopDefault(require('zlib'));\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nmodule.exports = exports = fetch;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst currentNodeVersion = process.versions.node;\nconst semver = currentNodeVersion.split('.');\nconst [major] = [+semver[0]];\n\nif (major < 14) {\n  // eslint-disable-next-line no-console\n  console.error(\n      'You are running Node.js ' +\n      currentNodeVersion +\n      '.\\n' +\n      'Playwright requires Node.js 14 or higher. \\n' +\n      'Please update your version of Node.js.'\n  );\n  process.exit(1);\n}\n\nmodule.exports = require('./lib/inprocess');\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AndroidServerLauncherImpl = void 0;\nvar _utilsBundle = require(\"./utilsBundle\");\nvar _utils = require(\"./utils\");\nvar _playwright = require(\"./server/playwright\");\nvar _playwrightServer = require(\"./remote/playwrightServer\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass AndroidServerLauncherImpl {\n  async launchServer(options = {}) {\n    const playwright = (0, _playwright.createPlaywright)('javascript');\n    // 1. Pre-connect to the device\n    let devices = await playwright.android.devices({\n      host: options.adbHost,\n      port: options.adbPort,\n      omitDriverInstall: options.omitDriverInstall\n    });\n    if (devices.length === 0) throw new Error('No devices found');\n    if (options.deviceSerialNumber) {\n      devices = devices.filter(d => d.serial === options.deviceSerialNumber);\n      if (devices.length === 0) throw new Error(`No device with serial number '${options.deviceSerialNumber}' not found`);\n    }\n    if (devices.length > 1) throw new Error(`More than one device found. Please specify deviceSerialNumber`);\n    const device = devices[0];\n    const path = options.wsPath ? options.wsPath.startsWith('/') ? options.wsPath : `/${options.wsPath}` : `/${(0, _utils.createGuid)()}`;\n\n    // 2. Start the server\n    const server = new _playwrightServer.PlaywrightServer({\n      path,\n      maxConnections: 1,\n      preLaunchedAndroidDevice: device\n    });\n    const wsEndpoint = await server.listen(options.port);\n\n    // 3. Return the BrowserServer interface\n    const browserServer = new _utilsBundle.ws.EventEmitter();\n    browserServer.wsEndpoint = () => wsEndpoint;\n    browserServer.close = () => device.close();\n    browserServer.kill = () => device.close();\n    device.on('close', () => {\n      server.close();\n      browserServer.emit('close');\n    });\n    return browserServer;\n  }\n}\nexports.AndroidServerLauncherImpl = AndroidServerLauncherImpl;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserServerLauncherImpl = void 0;\nvar _utilsBundle = require(\"./utilsBundle\");\nvar _clientHelper = require(\"./client/clientHelper\");\nvar _utils = require(\"./utils\");\nvar _instrumentation = require(\"./server/instrumentation\");\nvar _playwright = require(\"./server/playwright\");\nvar _playwrightServer = require(\"./remote/playwrightServer\");\nvar _helper = require(\"./server/helper\");\nvar _stackTrace = require(\"./utils/stackTrace\");\nvar _socksProxy = require(\"./common/socksProxy\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserServerLauncherImpl {\n  constructor(browserName) {\n    this._browserName = void 0;\n    this._browserName = browserName;\n  }\n  async launchServer(options = {}) {\n    const playwright = (0, _playwright.createPlaywright)('javascript');\n    // TODO: enable socks proxy once ipv6 is supported.\n    const socksProxy = false ? new _socksProxy.SocksProxy() : undefined;\n    playwright.options.socksProxyPort = await (socksProxy === null || socksProxy === void 0 ? void 0 : socksProxy.listen(0));\n\n    // 1. Pre-launch the browser\n    const metadata = (0, _instrumentation.serverSideCallMetadata)();\n    const browser = await playwright[this._browserName].launch(metadata, {\n      ...options,\n      ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,\n      ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),\n      env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : undefined\n    }, toProtocolLogger(options.logger)).catch(e => {\n      const log = _helper.helper.formatBrowserLogs(metadata.log);\n      (0, _stackTrace.rewriteErrorMessage)(e, `${e.message} Failed to launch browser.${log}`);\n      throw e;\n    });\n    const path = options.wsPath ? options.wsPath.startsWith('/') ? options.wsPath : `/${options.wsPath}` : `/${(0, _utils.createGuid)()}`;\n\n    // 2. Start the server\n    const server = new _playwrightServer.PlaywrightServer({\n      path,\n      maxConnections: Infinity,\n      preLaunchedBrowser: browser,\n      preLaunchedSocksProxy: socksProxy\n    });\n    const wsEndpoint = await server.listen(options.port);\n\n    // 3. Return the BrowserServer interface\n    const browserServer = new _utilsBundle.ws.EventEmitter();\n    browserServer.process = () => browser.options.browserProcess.process;\n    browserServer.wsEndpoint = () => wsEndpoint;\n    browserServer.close = () => browser.options.browserProcess.close();\n    browserServer.kill = () => browser.options.browserProcess.kill();\n    browserServer._disconnectForTest = () => server.close();\n    browserServer._userDataDirForTest = browser._userDataDirForTest;\n    browser.options.browserProcess.onclose = (exitCode, signal) => {\n      socksProxy === null || socksProxy === void 0 ? void 0 : socksProxy.close().catch(() => {});\n      server.close();\n      browserServer.emit('close', exitCode, signal);\n    };\n    return browserServer;\n  }\n}\nexports.BrowserServerLauncherImpl = BrowserServerLauncherImpl;\nfunction toProtocolLogger(logger) {\n  return logger ? (direction, message) => {\n    if (logger.isEnabled('protocol', 'verbose')) logger.log('protocol', 'verbose', (direction === 'send' ? 'SEND ► ' : '◀ RECV ') + JSON.stringify(message), [], {});\n  } : undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Accessibility = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction axNodeFromProtocol(axNode) {\n  const result = {\n    ...axNode,\n    value: axNode.valueNumber !== undefined ? axNode.valueNumber : axNode.valueString,\n    checked: axNode.checked === 'checked' ? true : axNode.checked === 'unchecked' ? false : axNode.checked,\n    pressed: axNode.pressed === 'pressed' ? true : axNode.pressed === 'released' ? false : axNode.pressed,\n    children: axNode.children ? axNode.children.map(axNodeFromProtocol) : undefined\n  };\n  delete result.valueNumber;\n  delete result.valueString;\n  return result;\n}\nclass Accessibility {\n  constructor(channel) {\n    this._channel = void 0;\n    this._channel = channel;\n  }\n  async snapshot(options = {}) {\n    const root = options.root ? options.root._elementChannel : undefined;\n    const result = await this._channel.accessibilitySnapshot({\n      interestingOnly: options.interestingOnly,\n      root\n    });\n    return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;\n  }\n}\nexports.Accessibility = Accessibility;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AndroidWebView = exports.AndroidSocket = exports.AndroidInput = exports.AndroidDevice = exports.Android = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _utils = require(\"../utils\");\nvar _events = require(\"./events\");\nvar _browserContext = require(\"./browserContext\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _waiter = require(\"./waiter\");\nvar _events2 = require(\"events\");\nvar _connection = require(\"./connection\");\nvar _errors = require(\"../common/errors\");\nvar _timeoutRunner = require(\"../utils/timeoutRunner\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Android extends _channelOwner.ChannelOwner {\n  static from(android) {\n    return android._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._timeoutSettings = void 0;\n    this._serverLauncher = void 0;\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n    this._channel.setDefaultTimeoutNoReply({\n      timeout\n    });\n  }\n  async devices(options = {}) {\n    const {\n      devices\n    } = await this._channel.devices(options);\n    return devices.map(d => AndroidDevice.from(d));\n  }\n  async launchServer(options = {}) {\n    if (!this._serverLauncher) throw new Error('Launching server is not supported');\n    return this._serverLauncher.launchServer(options);\n  }\n  async connect(wsEndpoint, options = {}) {\n    return await this._wrapApiCall(async () => {\n      const deadline = options.timeout ? (0, _utils.monotonicTime)() + options.timeout : 0;\n      const headers = {\n        'x-playwright-browser': 'android',\n        ...options.headers\n      };\n      const localUtils = this._connection.localUtils();\n      const connectParams = {\n        wsEndpoint,\n        headers,\n        slowMo: options.slowMo,\n        timeout: options.timeout\n      };\n      const {\n        pipe\n      } = await localUtils._channel.connect(connectParams);\n      const closePipe = () => pipe.close().catch(() => {});\n      const connection = new _connection.Connection(localUtils);\n      connection.markAsRemote();\n      connection.on('close', closePipe);\n      let device;\n      let closeError;\n      const onPipeClosed = () => {\n        var _device;\n        (_device = device) === null || _device === void 0 ? void 0 : _device._didClose();\n        connection.close(closeError || _errors.kBrowserClosedError);\n      };\n      pipe.on('closed', onPipeClosed);\n      connection.onmessage = message => pipe.send({\n        message\n      }).catch(onPipeClosed);\n      pipe.on('message', ({\n        message\n      }) => {\n        try {\n          connection.dispatch(message);\n        } catch (e) {\n          closeError = e.toString();\n          closePipe();\n        }\n      });\n      const result = await (0, _timeoutRunner.raceAgainstTimeout)(async () => {\n        const playwright = await connection.initializePlaywright();\n        if (!playwright._initializer.preConnectedAndroidDevice) {\n          closePipe();\n          throw new Error('Malformed endpoint. Did you use Android.launchServer method?');\n        }\n        device = AndroidDevice.from(playwright._initializer.preConnectedAndroidDevice);\n        device._shouldCloseConnectionOnClose = true;\n        device.on(_events.Events.AndroidDevice.Close, closePipe);\n        return device;\n      }, deadline ? deadline - (0, _utils.monotonicTime)() : 0);\n      if (!result.timedOut) {\n        return result.result;\n      } else {\n        closePipe();\n        throw new Error(`Timeout ${options.timeout}ms exceeded`);\n      }\n    });\n  }\n}\nexports.Android = Android;\nclass AndroidDevice extends _channelOwner.ChannelOwner {\n  static from(androidDevice) {\n    return androidDevice._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._timeoutSettings = void 0;\n    this._webViews = new Map();\n    this._shouldCloseConnectionOnClose = false;\n    this.input = void 0;\n    this.input = new AndroidInput(this);\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(parent._timeoutSettings);\n    this._channel.on('webViewAdded', ({\n      webView\n    }) => this._onWebViewAdded(webView));\n    this._channel.on('webViewRemoved', ({\n      socketName\n    }) => this._onWebViewRemoved(socketName));\n    this._channel.on('close', () => this._didClose());\n  }\n  _onWebViewAdded(webView) {\n    const view = new AndroidWebView(this, webView);\n    this._webViews.set(webView.socketName, view);\n    this.emit(_events.Events.AndroidDevice.WebView, view);\n  }\n  _onWebViewRemoved(socketName) {\n    const view = this._webViews.get(socketName);\n    this._webViews.delete(socketName);\n    if (view) view.emit(_events.Events.AndroidWebView.Close);\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n    this._channel.setDefaultTimeoutNoReply({\n      timeout\n    });\n  }\n  serial() {\n    return this._initializer.serial;\n  }\n  model() {\n    return this._initializer.model;\n  }\n  webViews() {\n    return [...this._webViews.values()];\n  }\n  async webView(selector, options) {\n    const predicate = v => {\n      if (selector.pkg) return v.pkg() === selector.pkg;\n      if (selector.socketName) return v._socketName() === selector.socketName;\n      return false;\n    };\n    const webView = [...this._webViews.values()].find(predicate);\n    if (webView) return webView;\n    return this.waitForEvent('webview', {\n      ...options,\n      predicate\n    });\n  }\n  async wait(selector, options) {\n    await this._channel.wait({\n      selector: toSelectorChannel(selector),\n      ...options\n    });\n  }\n  async fill(selector, text, options) {\n    await this._channel.fill({\n      selector: toSelectorChannel(selector),\n      text,\n      ...options\n    });\n  }\n  async press(selector, key, options) {\n    await this.tap(selector, options);\n    await this.input.press(key);\n  }\n  async tap(selector, options) {\n    await this._channel.tap({\n      selector: toSelectorChannel(selector),\n      ...options\n    });\n  }\n  async drag(selector, dest, options) {\n    await this._channel.drag({\n      selector: toSelectorChannel(selector),\n      dest,\n      ...options\n    });\n  }\n  async fling(selector, direction, options) {\n    await this._channel.fling({\n      selector: toSelectorChannel(selector),\n      direction,\n      ...options\n    });\n  }\n  async longTap(selector, options) {\n    await this._channel.longTap({\n      selector: toSelectorChannel(selector),\n      ...options\n    });\n  }\n  async pinchClose(selector, percent, options) {\n    await this._channel.pinchClose({\n      selector: toSelectorChannel(selector),\n      percent,\n      ...options\n    });\n  }\n  async pinchOpen(selector, percent, options) {\n    await this._channel.pinchOpen({\n      selector: toSelectorChannel(selector),\n      percent,\n      ...options\n    });\n  }\n  async scroll(selector, direction, percent, options) {\n    await this._channel.scroll({\n      selector: toSelectorChannel(selector),\n      direction,\n      percent,\n      ...options\n    });\n  }\n  async swipe(selector, direction, percent, options) {\n    await this._channel.swipe({\n      selector: toSelectorChannel(selector),\n      direction,\n      percent,\n      ...options\n    });\n  }\n  async info(selector) {\n    return (await this._channel.info({\n      selector: toSelectorChannel(selector)\n    })).info;\n  }\n  async screenshot(options = {}) {\n    const {\n      binary\n    } = await this._channel.screenshot();\n    if (options.path) await _fs.default.promises.writeFile(options.path, binary);\n    return binary;\n  }\n  async close() {\n    try {\n      if (this._shouldCloseConnectionOnClose) this._connection.close(_errors.kBrowserClosedError);else await this._channel.close();\n    } catch (e) {\n      if ((0, _errors.isSafeCloseError)(e)) return;\n      throw e;\n    }\n  }\n  _didClose() {\n    this.emit(_events.Events.AndroidDevice.Close, this);\n  }\n  async shell(command) {\n    const {\n      result\n    } = await this._channel.shell({\n      command\n    });\n    return result;\n  }\n  async open(command) {\n    return AndroidSocket.from((await this._channel.open({\n      command\n    })).socket);\n  }\n  async installApk(file, options) {\n    await this._channel.installApk({\n      file: await loadFile(file),\n      args: options && options.args\n    });\n  }\n  async push(file, path, options) {\n    await this._channel.push({\n      file: await loadFile(file),\n      path,\n      mode: options ? options.mode : undefined\n    });\n  }\n  async launchBrowser(options = {}) {\n    const contextOptions = await (0, _browserContext.prepareBrowserContextParams)(options);\n    const {\n      context\n    } = await this._channel.launchBrowser(contextOptions);\n    return _browserContext.BrowserContext.from(context);\n  }\n  async waitForEvent(event, optionsOrPredicate = {}) {\n    return this._wrapApiCall(async () => {\n      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = _waiter.Waiter.createForEvent(this, event);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== _events.Events.AndroidDevice.Close) waiter.rejectOnEvent(this, _events.Events.AndroidDevice.Close, new Error('Device closed'));\n      const result = await waiter.waitForEvent(this, event, predicate);\n      waiter.dispose();\n      return result;\n    });\n  }\n}\nexports.AndroidDevice = AndroidDevice;\nclass AndroidSocket extends _channelOwner.ChannelOwner {\n  static from(androidDevice) {\n    return androidDevice._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._channel.on('data', ({\n      data\n    }) => this.emit(_events.Events.AndroidSocket.Data, data));\n    this._channel.on('close', () => this.emit(_events.Events.AndroidSocket.Close));\n  }\n  async write(data) {\n    await this._channel.write({\n      data\n    });\n  }\n  async close() {\n    await this._channel.close();\n  }\n}\nexports.AndroidSocket = AndroidSocket;\nasync function loadFile(file) {\n  if ((0, _utils.isString)(file)) return _fs.default.promises.readFile(file);\n  return file;\n}\nclass AndroidInput {\n  constructor(device) {\n    this._device = void 0;\n    this._device = device;\n  }\n  async type(text) {\n    await this._device._channel.inputType({\n      text\n    });\n  }\n  async press(key) {\n    await this._device._channel.inputPress({\n      key\n    });\n  }\n  async tap(point) {\n    await this._device._channel.inputTap({\n      point\n    });\n  }\n  async swipe(from, segments, steps) {\n    await this._device._channel.inputSwipe({\n      segments,\n      steps\n    });\n  }\n  async drag(from, to, steps) {\n    await this._device._channel.inputDrag({\n      from,\n      to,\n      steps\n    });\n  }\n}\nexports.AndroidInput = AndroidInput;\nfunction toSelectorChannel(selector) {\n  const {\n    checkable,\n    checked,\n    clazz,\n    clickable,\n    depth,\n    desc,\n    enabled,\n    focusable,\n    focused,\n    hasChild,\n    hasDescendant,\n    longClickable,\n    pkg,\n    res,\n    scrollable,\n    selected,\n    text\n  } = selector;\n  const toRegex = value => {\n    if (value === undefined) return undefined;\n    if ((0, _utils.isRegExp)(value)) return value.source;\n    return '^' + value.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d') + '$';\n  };\n  return {\n    checkable,\n    checked,\n    clazz: toRegex(clazz),\n    pkg: toRegex(pkg),\n    desc: toRegex(desc),\n    res: toRegex(res),\n    text: toRegex(text),\n    clickable,\n    depth,\n    enabled,\n    focusable,\n    focused,\n    hasChild: hasChild ? {\n      selector: toSelectorChannel(hasChild.selector)\n    } : undefined,\n    hasDescendant: hasDescendant ? {\n      selector: toSelectorChannel(hasDescendant.selector),\n      maxDepth: hasDescendant.maxDepth\n    } : undefined,\n    longClickable,\n    scrollable,\n    selected\n  };\n}\nclass AndroidWebView extends _events2.EventEmitter {\n  constructor(device, data) {\n    super();\n    this._device = void 0;\n    this._data = void 0;\n    this._pagePromise = void 0;\n    this._device = device;\n    this._data = data;\n  }\n  pid() {\n    return this._data.pid;\n  }\n  pkg() {\n    return this._data.pkg;\n  }\n  _socketName() {\n    return this._data.socketName;\n  }\n  async page() {\n    if (!this._pagePromise) this._pagePromise = this._fetchPage();\n    return this._pagePromise;\n  }\n  async _fetchPage() {\n    const {\n      context\n    } = await this._device._channel.connectToWebView({\n      socketName: this._data.socketName\n    });\n    return _browserContext.BrowserContext.from(context).pages()[0];\n  }\n}\nexports.AndroidWebView = AndroidWebView;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Artifact = void 0;\nvar fs = _interopRequireWildcard(require(\"fs\"));\nvar _stream = require(\"./stream\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _channelOwner = require(\"./channelOwner\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Artifact extends _channelOwner.ChannelOwner {\n  static from(channel) {\n    return channel._object;\n  }\n  async pathAfterFinished() {\n    if (this._connection.isRemote()) throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);\n    return (await this._channel.pathAfterFinished()).value || null;\n  }\n  async saveAs(path) {\n    if (!this._connection.isRemote()) {\n      await this._channel.saveAs({\n        path\n      });\n      return;\n    }\n    const result = await this._channel.saveAsStream();\n    const stream = _stream.Stream.from(result.stream);\n    await (0, _fileUtils.mkdirIfNeeded)(path);\n    await new Promise((resolve, reject) => {\n      stream.stream().pipe(fs.createWriteStream(path)).on('finish', resolve).on('error', reject);\n    });\n  }\n  async failure() {\n    return (await this._channel.failure()).error || null;\n  }\n  async createReadStream() {\n    const result = await this._channel.stream();\n    if (!result.stream) return null;\n    const stream = _stream.Stream.from(result.stream);\n    return stream.stream();\n  }\n  async cancel() {\n    return this._channel.cancel();\n  }\n  async delete() {\n    return this._channel.delete();\n  }\n}\nexports.Artifact = Artifact;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Browser = void 0;\nvar _browserContext = require(\"./browserContext\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _events = require(\"./events\");\nvar _errors = require(\"../common/errors\");\nvar _cdpSession = require(\"./cdpSession\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Browser extends _channelOwner.ChannelOwner {\n  static from(browser) {\n    return browser._object;\n  }\n  static fromNullable(browser) {\n    return browser ? Browser.from(browser) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._contexts = new Set();\n    this._isConnected = true;\n    this._closedPromise = void 0;\n    this._shouldCloseConnectionOnClose = false;\n    this._browserType = void 0;\n    this._name = void 0;\n    this._name = initializer.name;\n    this._channel.on('close', () => this._didClose());\n    this._closedPromise = new Promise(f => this.once(_events.Events.Browser.Disconnected, f));\n  }\n  _setBrowserType(browserType) {\n    this._browserType = browserType;\n    for (const context of this._contexts) context._setBrowserType(browserType);\n  }\n  browserType() {\n    return this._browserType;\n  }\n  async newContext(options = {}) {\n    return await this._innerNewContext(options, false);\n  }\n  async _newContextForReuse(options = {}) {\n    for (const context of this._contexts) {\n      await this._wrapApiCall(async () => {\n        var _this$_browserType$_o, _this$_browserType;\n        await ((_this$_browserType$_o = (_this$_browserType = this._browserType)._onWillCloseContext) === null || _this$_browserType$_o === void 0 ? void 0 : _this$_browserType$_o.call(_this$_browserType, context));\n      }, true);\n      for (const page of context.pages()) page._onClose();\n      context._onClose();\n    }\n    this._contexts.clear();\n    return await this._innerNewContext(options, true);\n  }\n  async _innerNewContext(options = {}, forReuse) {\n    var _this$_browserType$_o2, _this$_browserType2;\n    options = {\n      ...this._browserType._defaultContextOptions,\n      ...options\n    };\n    const contextOptions = await (0, _browserContext.prepareBrowserContextParams)(options);\n    const response = forReuse ? await this._channel.newContextForReuse(contextOptions) : await this._channel.newContext(contextOptions);\n    const context = _browserContext.BrowserContext.from(response.context);\n    context._options = contextOptions;\n    this._contexts.add(context);\n    context._logger = options.logger || this._logger;\n    context._setBrowserType(this._browserType);\n    await ((_this$_browserType$_o2 = (_this$_browserType2 = this._browserType)._onDidCreateContext) === null || _this$_browserType$_o2 === void 0 ? void 0 : _this$_browserType$_o2.call(_this$_browserType2, context));\n    return context;\n  }\n  contexts() {\n    return [...this._contexts];\n  }\n  version() {\n    return this._initializer.version;\n  }\n  async newPage(options = {}) {\n    const context = await this.newContext(options);\n    const page = await context.newPage();\n    page._ownedContext = context;\n    context._ownerPage = page;\n    return page;\n  }\n  isConnected() {\n    return this._isConnected;\n  }\n  async newBrowserCDPSession() {\n    return _cdpSession.CDPSession.from((await this._channel.newBrowserCDPSession()).session);\n  }\n  async startTracing(page, options = {}) {\n    await this._channel.startTracing({\n      ...options,\n      page: page ? page._channel : undefined\n    });\n  }\n  async stopTracing() {\n    return (await this._channel.stopTracing()).binary;\n  }\n  async close() {\n    try {\n      if (this._shouldCloseConnectionOnClose) this._connection.close(_errors.kBrowserClosedError);else await this._channel.close();\n      await this._closedPromise;\n    } catch (e) {\n      if ((0, _errors.isSafeCloseError)(e)) return;\n      throw e;\n    }\n  }\n  _didClose() {\n    this._isConnected = false;\n    this.emit(_events.Events.Browser.Disconnected, this);\n  }\n}\nexports.Browser = Browser;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserContext = void 0;\nexports.prepareBrowserContextParams = prepareBrowserContextParams;\nvar _page = require(\"./page\");\nvar _frame = require(\"./frame\");\nvar network = _interopRequireWildcard(require(\"./network\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _channelOwner = require(\"./channelOwner\");\nvar _clientHelper = require(\"./clientHelper\");\nvar _browser = require(\"./browser\");\nvar _worker = require(\"./worker\");\nvar _events = require(\"./events\");\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _waiter = require(\"./waiter\");\nvar _utils = require(\"../utils\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _errors = require(\"../common/errors\");\nvar _cdpSession = require(\"./cdpSession\");\nvar _tracing = require(\"./tracing\");\nvar _artifact = require(\"./artifact\");\nvar _fetch = require(\"./fetch\");\nvar _clientInstrumentation = require(\"./clientInstrumentation\");\nvar _stackTrace = require(\"../utils/stackTrace\");\nvar _harRouter = require(\"./harRouter\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserContext extends _channelOwner.ChannelOwner {\n  static from(context) {\n    return context._object;\n  }\n  static fromNullable(context) {\n    return context ? BrowserContext.from(context) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    var _this$_browser;\n    super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());\n    this._pages = new Set();\n    this._routes = [];\n    this._browser = null;\n    this._browserType = void 0;\n    this._bindings = new Map();\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();\n    this._ownerPage = void 0;\n    this._closedPromise = void 0;\n    this._options = {};\n    this.request = void 0;\n    this.tracing = void 0;\n    this._backgroundPages = new Set();\n    this._serviceWorkers = new Set();\n    this._isChromium = void 0;\n    this._harRecorders = new Map();\n    if (parent instanceof _browser.Browser) this._browser = parent;\n    this._isChromium = ((_this$_browser = this._browser) === null || _this$_browser === void 0 ? void 0 : _this$_browser._name) === 'chromium';\n    this.tracing = _tracing.Tracing.from(initializer.tracing);\n    this.request = _fetch.APIRequestContext.from(initializer.requestContext);\n    this._channel.on('bindingCall', ({\n      binding\n    }) => this._onBinding(_page.BindingCall.from(binding)));\n    this._channel.on('close', () => this._onClose());\n    this._channel.on('page', ({\n      page\n    }) => this._onPage(_page.Page.from(page)));\n    this._channel.on('route', ({\n      route\n    }) => this._onRoute(network.Route.from(route)));\n    this._channel.on('backgroundPage', ({\n      page\n    }) => {\n      const backgroundPage = _page.Page.from(page);\n      this._backgroundPages.add(backgroundPage);\n      this.emit(_events.Events.BrowserContext.BackgroundPage, backgroundPage);\n    });\n    this._channel.on('serviceWorker', ({\n      worker\n    }) => {\n      const serviceWorker = _worker.Worker.from(worker);\n      serviceWorker._context = this;\n      this._serviceWorkers.add(serviceWorker);\n      this.emit(_events.Events.BrowserContext.ServiceWorker, serviceWorker);\n    });\n    this._channel.on('request', ({\n      request,\n      page\n    }) => this._onRequest(network.Request.from(request), _page.Page.fromNullable(page)));\n    this._channel.on('requestFailed', ({\n      request,\n      failureText,\n      responseEndTiming,\n      page\n    }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, _page.Page.fromNullable(page)));\n    this._channel.on('requestFinished', params => this._onRequestFinished(params));\n    this._channel.on('response', ({\n      response,\n      page\n    }) => this._onResponse(network.Response.from(response), _page.Page.fromNullable(page)));\n    this._closedPromise = new Promise(f => this.once(_events.Events.BrowserContext.Close, f));\n    this._setEventToSubscriptionMapping(new Map([[_events.Events.BrowserContext.Request, 'request'], [_events.Events.BrowserContext.Response, 'response'], [_events.Events.BrowserContext.RequestFinished, 'requestFinished'], [_events.Events.BrowserContext.RequestFailed, 'requestFailed']]));\n  }\n  _setBrowserType(browserType) {\n    this._browserType = browserType;\n    browserType._contexts.add(this);\n    if (this._options.recordHar) this._harRecorders.set('', {\n      path: this._options.recordHar.path,\n      content: this._options.recordHar.content\n    });\n  }\n  _onPage(page) {\n    this._pages.add(page);\n    this.emit(_events.Events.BrowserContext.Page, page);\n    if (page._opener && !page._opener.isClosed()) page._opener.emit(_events.Events.Page.Popup, page);\n  }\n  _onRequest(request, page) {\n    this.emit(_events.Events.BrowserContext.Request, request);\n    if (page) page.emit(_events.Events.Page.Request, request);\n  }\n  _onResponse(response, page) {\n    this.emit(_events.Events.BrowserContext.Response, response);\n    if (page) page.emit(_events.Events.Page.Response, response);\n  }\n  _onRequestFailed(request, responseEndTiming, failureText, page) {\n    request._failureText = failureText || null;\n    request._setResponseEndTiming(responseEndTiming);\n    this.emit(_events.Events.BrowserContext.RequestFailed, request);\n    if (page) page.emit(_events.Events.Page.RequestFailed, request);\n  }\n  _onRequestFinished(params) {\n    const {\n      responseEndTiming\n    } = params;\n    const request = network.Request.from(params.request);\n    const response = network.Response.fromNullable(params.response);\n    const page = _page.Page.fromNullable(params.page);\n    request._setResponseEndTiming(responseEndTiming);\n    this.emit(_events.Events.BrowserContext.RequestFinished, request);\n    if (page) page.emit(_events.Events.Page.RequestFinished, request);\n    if (response) response._finishedPromise.resolve();\n  }\n  async _onRoute(route) {\n    const routeHandlers = this._routes.slice();\n    for (const routeHandler of routeHandlers) {\n      if (!routeHandler.matches(route.request().url())) continue;\n      if (routeHandler.willExpire()) this._routes.splice(this._routes.indexOf(routeHandler), 1);\n      const handled = await routeHandler.handle(route);\n      if (!this._routes.length) this._wrapApiCall(() => this._updateInterceptionPatterns(), true).catch(() => {});\n      if (handled) return;\n    }\n    await route._innerContinue(true);\n  }\n  async _onBinding(bindingCall) {\n    const func = this._bindings.get(bindingCall._initializer.name);\n    if (!func) return;\n    await bindingCall.call(func);\n  }\n  setDefaultNavigationTimeout(timeout) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n    this._wrapApiCall(async () => {\n      this._channel.setDefaultNavigationTimeoutNoReply({\n        timeout\n      }).catch(() => {});\n    }, true);\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n    this._wrapApiCall(async () => {\n      this._channel.setDefaultTimeoutNoReply({\n        timeout\n      }).catch(() => {});\n    }, true);\n  }\n  browser() {\n    return this._browser;\n  }\n  pages() {\n    return [...this._pages];\n  }\n  async newPage() {\n    if (this._ownerPage) throw new Error('Please use browser.newContext()');\n    return _page.Page.from((await this._channel.newPage()).page);\n  }\n  async cookies(urls) {\n    if (!urls) urls = [];\n    if (urls && typeof urls === 'string') urls = [urls];\n    return (await this._channel.cookies({\n      urls: urls\n    })).cookies;\n  }\n  async addCookies(cookies) {\n    await this._channel.addCookies({\n      cookies\n    });\n  }\n  async clearCookies() {\n    await this._channel.clearCookies();\n  }\n  async grantPermissions(permissions, options) {\n    await this._channel.grantPermissions({\n      permissions,\n      ...options\n    });\n  }\n  async clearPermissions() {\n    await this._channel.clearPermissions();\n  }\n  async setGeolocation(geolocation) {\n    await this._channel.setGeolocation({\n      geolocation: geolocation || undefined\n    });\n  }\n  async setExtraHTTPHeaders(headers) {\n    network.validateHeaders(headers);\n    await this._channel.setExtraHTTPHeaders({\n      headers: (0, _utils.headersObjectToArray)(headers)\n    });\n  }\n  async setOffline(offline) {\n    await this._channel.setOffline({\n      offline\n    });\n  }\n  async setHTTPCredentials(httpCredentials) {\n    await this._channel.setHTTPCredentials({\n      httpCredentials: httpCredentials || undefined\n    });\n  }\n  async addInitScript(script, arg) {\n    const source = await (0, _clientHelper.evaluationScript)(script, arg);\n    await this._channel.addInitScript({\n      source\n    });\n  }\n  async exposeBinding(name, callback, options = {}) {\n    await this._channel.exposeBinding({\n      name,\n      needsHandle: options.handle\n    });\n    this._bindings.set(name, callback);\n  }\n  async exposeFunction(name, callback) {\n    await this._channel.exposeBinding({\n      name\n    });\n    const binding = (source, ...args) => callback(...args);\n    this._bindings.set(name, binding);\n  }\n  async route(url, handler, options = {}) {\n    this._routes.unshift(new network.RouteHandler(this._options.baseURL, url, handler, options.times));\n    await this._updateInterceptionPatterns();\n  }\n  async _recordIntoHAR(har, page, options = {}) {\n    const {\n      harId\n    } = await this._channel.harStart({\n      page: page === null || page === void 0 ? void 0 : page._channel,\n      options: prepareRecordHarOptions({\n        path: har,\n        content: 'attach',\n        mode: 'minimal',\n        urlFilter: options.url\n      })\n    });\n    this._harRecorders.set(harId, {\n      path: har,\n      content: 'attach'\n    });\n  }\n  async routeFromHAR(har, options = {}) {\n    if (options.update) {\n      await this._recordIntoHAR(har, null, options);\n      return;\n    }\n    const harRouter = await _harRouter.HarRouter.create(this._connection.localUtils(), har, options.notFound || 'abort', {\n      urlMatch: options.url\n    });\n    harRouter.addContextRoute(this);\n  }\n  async unroute(url, handler) {\n    this._routes = this._routes.filter(route => route.url !== url || handler && route.handler !== handler);\n    await this._updateInterceptionPatterns();\n  }\n  async _updateInterceptionPatterns() {\n    const patterns = network.RouteHandler.prepareInterceptionPatterns(this._routes);\n    await this._channel.setNetworkInterceptionPatterns({\n      patterns\n    });\n  }\n  async waitForEvent(event, optionsOrPredicate = {}) {\n    return this._wrapApiCall(async () => {\n      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = _waiter.Waiter.createForEvent(this, event);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== _events.Events.BrowserContext.Close) waiter.rejectOnEvent(this, _events.Events.BrowserContext.Close, new Error('Context closed'));\n      const result = await waiter.waitForEvent(this, event, predicate);\n      waiter.dispose();\n      return result;\n    });\n  }\n  async storageState(options = {}) {\n    const state = await this._channel.storageState();\n    if (options.path) {\n      await (0, _fileUtils.mkdirIfNeeded)(options.path);\n      await _fs.default.promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');\n    }\n    return state;\n  }\n  backgroundPages() {\n    return [...this._backgroundPages];\n  }\n  serviceWorkers() {\n    return [...this._serviceWorkers];\n  }\n  async newCDPSession(page) {\n    // channelOwner.ts's validation messages don't handle the pseudo-union type, so we're explicit here\n    if (!(page instanceof _page.Page) && !(page instanceof _frame.Frame)) throw new Error('page: expected Page or Frame');\n    const result = await this._channel.newCDPSession(page instanceof _page.Page ? {\n      page: page._channel\n    } : {\n      frame: page._channel\n    });\n    return _cdpSession.CDPSession.from(result.session);\n  }\n  _onClose() {\n    var _this$_browserType, _this$_browserType$_c;\n    if (this._browser) this._browser._contexts.delete(this);\n    (_this$_browserType = this._browserType) === null || _this$_browserType === void 0 ? void 0 : (_this$_browserType$_c = _this$_browserType._contexts) === null || _this$_browserType$_c === void 0 ? void 0 : _this$_browserType$_c.delete(this);\n    this.emit(_events.Events.BrowserContext.Close, this);\n  }\n  async close() {\n    try {\n      await this._wrapApiCall(async () => {\n        var _this$_browserType2, _this$_browserType2$_;\n        await ((_this$_browserType2 = this._browserType) === null || _this$_browserType2 === void 0 ? void 0 : (_this$_browserType2$_ = _this$_browserType2._onWillCloseContext) === null || _this$_browserType2$_ === void 0 ? void 0 : _this$_browserType2$_.call(_this$_browserType2, this));\n        for (const [harId, harParams] of this._harRecorders) {\n          const har = await this._channel.harExport({\n            harId\n          });\n          const artifact = _artifact.Artifact.from(har.artifact);\n          // Server side will compress artifact if content is attach or if file is .zip.\n          const isCompressed = harParams.content === 'attach' || harParams.path.endsWith('.zip');\n          const needCompressed = harParams.path.endsWith('.zip');\n          if (isCompressed && !needCompressed) {\n            await artifact.saveAs(harParams.path + '.tmp');\n            await this._connection.localUtils()._channel.harUnzip({\n              zipFile: harParams.path + '.tmp',\n              harFile: harParams.path\n            });\n          } else {\n            await artifact.saveAs(harParams.path);\n          }\n          await artifact.delete();\n        }\n      }, true);\n      await this._channel.close();\n      await this._closedPromise;\n    } catch (e) {\n      if ((0, _errors.isSafeCloseError)(e)) return;\n      throw e;\n    }\n  }\n  async _enableRecorder(params) {\n    await this._channel.recorderSupplementEnable(params);\n  }\n}\nexports.BrowserContext = BrowserContext;\nasync function prepareStorageState(options) {\n  if (typeof options.storageState !== 'string') return options.storageState;\n  try {\n    return JSON.parse(await _fs.default.promises.readFile(options.storageState, 'utf8'));\n  } catch (e) {\n    (0, _stackTrace.rewriteErrorMessage)(e, `Error reading storage state from ${options.storageState}:\\n` + e.message);\n    throw e;\n  }\n}\nfunction prepareRecordHarOptions(options) {\n  if (!options) return;\n  return {\n    path: options.path,\n    content: options.content || (options.omitContent ? 'omit' : undefined),\n    urlGlob: (0, _utils.isString)(options.urlFilter) ? options.urlFilter : undefined,\n    urlRegexSource: (0, _utils.isRegExp)(options.urlFilter) ? options.urlFilter.source : undefined,\n    urlRegexFlags: (0, _utils.isRegExp)(options.urlFilter) ? options.urlFilter.flags : undefined,\n    mode: options.mode\n  };\n}\nasync function prepareBrowserContextParams(options) {\n  if (options.videoSize && !options.videosPath) throw new Error(`\"videoSize\" option requires \"videosPath\" to be specified`);\n  if (options.extraHTTPHeaders) network.validateHeaders(options.extraHTTPHeaders);\n  const contextParams = {\n    ...options,\n    viewport: options.viewport === null ? undefined : options.viewport,\n    noDefaultViewport: options.viewport === null,\n    extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : undefined,\n    storageState: await prepareStorageState(options),\n    serviceWorkers: options.serviceWorkers,\n    recordHar: prepareRecordHarOptions(options.recordHar),\n    colorScheme: options.colorScheme === null ? 'no-override' : options.colorScheme,\n    reducedMotion: options.reducedMotion === null ? 'no-override' : options.reducedMotion,\n    forcedColors: options.forcedColors === null ? 'no-override' : options.forcedColors\n  };\n  if (!contextParams.recordVideo && options.videosPath) {\n    contextParams.recordVideo = {\n      dir: options.videosPath,\n      size: options.videoSize\n    };\n  }\n  return contextParams;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserType = void 0;\nvar _browser3 = require(\"./browser\");\nvar _browserContext = require(\"./browserContext\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _connection = require(\"./connection\");\nvar _events = require(\"./events\");\nvar _clientHelper = require(\"./clientHelper\");\nvar _utils = require(\"../utils\");\nvar _errors = require(\"../common/errors\");\nvar _timeoutRunner = require(\"../utils/timeoutRunner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserType extends _channelOwner.ChannelOwner {\n  constructor(...args) {\n    super(...args);\n    this._serverLauncher = void 0;\n    this._contexts = new Set();\n    this._playwright = void 0;\n    this._defaultContextOptions = void 0;\n    this._defaultLaunchOptions = void 0;\n    this._defaultConnectOptions = void 0;\n    this._onDidCreateContext = void 0;\n    this._onWillCloseContext = void 0;\n  }\n  static from(browserType) {\n    return browserType._object;\n  }\n  executablePath() {\n    if (!this._initializer.executablePath) throw new Error('Browser is not supported on current platform');\n    return this._initializer.executablePath;\n  }\n  name() {\n    return this._initializer.name;\n  }\n  async launch(options = {}) {\n    var _this$_defaultLaunchO;\n    (0, _utils.assert)(!options.userDataDir, 'userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead');\n    (0, _utils.assert)(!options.port, 'Cannot specify a port without launching as a server.');\n    if (this._defaultConnectOptions) return await this._connectInsteadOfLaunching(this._defaultConnectOptions, options);\n    const logger = options.logger || ((_this$_defaultLaunchO = this._defaultLaunchOptions) === null || _this$_defaultLaunchO === void 0 ? void 0 : _this$_defaultLaunchO.logger);\n    options = {\n      ...this._defaultLaunchOptions,\n      ...options\n    };\n    const launchOptions = {\n      ...options,\n      ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,\n      ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),\n      env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : undefined\n    };\n    return await this._wrapApiCall(async () => {\n      const browser = _browser3.Browser.from((await this._channel.launch(launchOptions)).browser);\n      browser._logger = logger;\n      browser._setBrowserType(this);\n      return browser;\n    });\n  }\n  async _connectInsteadOfLaunching(connectOptions, launchOptions) {\n    var _connectOptions$timeo;\n    return this._connect({\n      wsEndpoint: connectOptions.wsEndpoint,\n      headers: {\n        'x-playwright-launch-options': JSON.stringify({\n          ...this._defaultLaunchOptions,\n          ...launchOptions\n        }),\n        ...connectOptions.headers\n      },\n      _exposeNetwork: connectOptions._exposeNetwork,\n      slowMo: connectOptions.slowMo,\n      timeout: (_connectOptions$timeo = connectOptions.timeout) !== null && _connectOptions$timeo !== void 0 ? _connectOptions$timeo : 3 * 60 * 1000 // 3 minutes\n    });\n  }\n\n  async launchServer(options = {}) {\n    if (!this._serverLauncher) throw new Error('Launching server is not supported');\n    options = {\n      ...this._defaultLaunchOptions,\n      ...options\n    };\n    return this._serverLauncher.launchServer(options);\n  }\n  async launchPersistentContext(userDataDir, options = {}) {\n    var _this$_defaultLaunchO2;\n    const logger = options.logger || ((_this$_defaultLaunchO2 = this._defaultLaunchOptions) === null || _this$_defaultLaunchO2 === void 0 ? void 0 : _this$_defaultLaunchO2.logger);\n    (0, _utils.assert)(!options.port, 'Cannot specify a port without launching as a server.');\n    options = {\n      ...this._defaultLaunchOptions,\n      ...this._defaultContextOptions,\n      ...options\n    };\n    const contextParams = await (0, _browserContext.prepareBrowserContextParams)(options);\n    const persistentParams = {\n      ...contextParams,\n      ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,\n      ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),\n      env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : undefined,\n      channel: options.channel,\n      userDataDir\n    };\n    return await this._wrapApiCall(async () => {\n      var _this$_onDidCreateCon;\n      const result = await this._channel.launchPersistentContext(persistentParams);\n      const context = _browserContext.BrowserContext.from(result.context);\n      context._options = contextParams;\n      context._logger = logger;\n      context._setBrowserType(this);\n      await ((_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context));\n      return context;\n    });\n  }\n  async connect(optionsOrWsEndpoint, options) {\n    if (typeof optionsOrWsEndpoint === 'string') return this._connect({\n      ...options,\n      wsEndpoint: optionsOrWsEndpoint\n    });\n    (0, _utils.assert)(optionsOrWsEndpoint.wsEndpoint, 'options.wsEndpoint is required');\n    return this._connect(optionsOrWsEndpoint);\n  }\n  async _connect(params) {\n    const logger = params.logger;\n    return await this._wrapApiCall(async () => {\n      const deadline = params.timeout ? (0, _utils.monotonicTime)() + params.timeout : 0;\n      const headers = {\n        'x-playwright-browser': this.name(),\n        ...params.headers\n      };\n      const localUtils = this._connection.localUtils();\n      const connectParams = {\n        wsEndpoint: params.wsEndpoint,\n        headers,\n        exposeNetwork: params._exposeNetwork,\n        slowMo: params.slowMo,\n        timeout: params.timeout\n      };\n      if (params.__testHookRedirectPortForwarding) connectParams.socksProxyRedirectPortForTest = params.__testHookRedirectPortForwarding;\n      const {\n        pipe\n      } = await localUtils._channel.connect(connectParams);\n      const closePipe = () => pipe.close().catch(() => {});\n      const connection = new _connection.Connection(localUtils);\n      connection.markAsRemote();\n      connection.on('close', closePipe);\n      let browser;\n      let closeError;\n      const onPipeClosed = () => {\n        var _browser2;\n        // Emulate all pages, contexts and the browser closing upon disconnect.\n        for (const context of ((_browser = browser) === null || _browser === void 0 ? void 0 : _browser.contexts()) || []) {\n          var _browser;\n          for (const page of context.pages()) page._onClose();\n          context._onClose();\n        }\n        (_browser2 = browser) === null || _browser2 === void 0 ? void 0 : _browser2._didClose();\n        connection.close(closeError || _errors.kBrowserClosedError);\n      };\n      pipe.on('closed', onPipeClosed);\n      connection.onmessage = message => pipe.send({\n        message\n      }).catch(onPipeClosed);\n      pipe.on('message', ({\n        message\n      }) => {\n        try {\n          connection.dispatch(message);\n        } catch (e) {\n          closeError = e.toString();\n          closePipe();\n        }\n      });\n      const result = await (0, _timeoutRunner.raceAgainstTimeout)(async () => {\n        // For tests.\n        if (params.__testHookBeforeCreateBrowser) await params.__testHookBeforeCreateBrowser();\n        const playwright = await connection.initializePlaywright();\n        if (!playwright._initializer.preLaunchedBrowser) {\n          closePipe();\n          throw new Error('Malformed endpoint. Did you use BrowserType.launchServer method?');\n        }\n        playwright._setSelectors(this._playwright.selectors);\n        browser = _browser3.Browser.from(playwright._initializer.preLaunchedBrowser);\n        browser._logger = logger;\n        browser._shouldCloseConnectionOnClose = true;\n        browser._setBrowserType(this);\n        browser.on(_events.Events.Browser.Disconnected, closePipe);\n        return browser;\n      }, deadline ? deadline - (0, _utils.monotonicTime)() : 0);\n      if (!result.timedOut) {\n        return result.result;\n      } else {\n        closePipe();\n        throw new Error(`Timeout ${params.timeout}ms exceeded`);\n      }\n    });\n  }\n  connectOverCDP(endpointURLOrOptions, options) {\n    if (typeof endpointURLOrOptions === 'string') return this._connectOverCDP(endpointURLOrOptions, options);\n    const endpointURL = 'endpointURL' in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;\n    (0, _utils.assert)(endpointURL, 'Cannot connect over CDP without wsEndpoint.');\n    return this.connectOverCDP(endpointURL, endpointURLOrOptions);\n  }\n  async _connectOverCDP(endpointURL, params = {}) {\n    if (this.name() !== 'chromium') throw new Error('Connecting over CDP is only supported in Chromium.');\n    const headers = params.headers ? (0, _utils.headersObjectToArray)(params.headers) : undefined;\n    const result = await this._channel.connectOverCDP({\n      endpointURL,\n      headers,\n      slowMo: params.slowMo,\n      timeout: params.timeout\n    });\n    const browser = _browser3.Browser.from(result.browser);\n    if (result.defaultContext) browser._contexts.add(_browserContext.BrowserContext.from(result.defaultContext));\n    browser._logger = params.logger;\n    browser._setBrowserType(this);\n    return browser;\n  }\n}\nexports.BrowserType = BrowserType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CDPSession = void 0;\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CDPSession extends _channelOwner.ChannelOwner {\n  static from(cdpSession) {\n    return cdpSession._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._channel.on('event', ({\n      method,\n      params\n    }) => {\n      this.emit(method, params);\n    });\n    this.on = super.on;\n    this.addListener = super.addListener;\n    this.off = super.removeListener;\n    this.removeListener = super.removeListener;\n    this.once = super.once;\n  }\n  async send(method, params) {\n    const result = await this._channel.send({\n      method,\n      params\n    });\n    return result.result;\n  }\n  async detach() {\n    return this._channel.detach();\n  }\n}\nexports.CDPSession = CDPSession;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelOwner = void 0;\nvar _events = require(\"events\");\nvar _validator = require(\"../protocol/validator\");\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _stackTrace = require(\"../utils/stackTrace\");\nvar _utils = require(\"../utils\");\nvar _zones = require(\"../utils/zones\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ChannelOwner extends _events.EventEmitter {\n  constructor(parent, type, guid, initializer, instrumentation) {\n    var _this$_parent;\n    super();\n    this._connection = void 0;\n    this._parent = void 0;\n    this._objects = new Map();\n    this._type = void 0;\n    this._guid = void 0;\n    this._channel = void 0;\n    this._initializer = void 0;\n    this._logger = void 0;\n    this._instrumentation = void 0;\n    this._eventToSubscriptionMapping = new Map();\n    this.setMaxListeners(0);\n    this._connection = parent instanceof ChannelOwner ? parent._connection : parent;\n    this._type = type;\n    this._guid = guid;\n    this._parent = parent instanceof ChannelOwner ? parent : undefined;\n    this._instrumentation = instrumentation || ((_this$_parent = this._parent) === null || _this$_parent === void 0 ? void 0 : _this$_parent._instrumentation);\n    this._connection._objects.set(guid, this);\n    if (this._parent) {\n      this._parent._objects.set(guid, this);\n      this._logger = this._parent._logger;\n    }\n    this._channel = this._createChannel(new _events.EventEmitter());\n    this._initializer = initializer;\n  }\n  _setEventToSubscriptionMapping(mapping) {\n    this._eventToSubscriptionMapping = mapping;\n  }\n  _updateSubscription(event, enabled) {\n    const protocolEvent = this._eventToSubscriptionMapping.get(String(event));\n    if (protocolEvent) this._channel.updateSubscription({\n      event: protocolEvent,\n      enabled\n    }).catch(() => {});\n  }\n  on(event, listener) {\n    if (!this.listenerCount(event)) this._updateSubscription(event, true);\n    super.on(event, listener);\n    return this;\n  }\n  addListener(event, listener) {\n    if (!this.listenerCount(event)) this._updateSubscription(event, true);\n    super.addListener(event, listener);\n    return this;\n  }\n  prependListener(event, listener) {\n    if (!this.listenerCount(event)) this._updateSubscription(event, true);\n    super.prependListener(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    super.off(event, listener);\n    if (!this.listenerCount(event)) this._updateSubscription(event, false);\n    return this;\n  }\n  removeListener(event, listener) {\n    super.removeListener(event, listener);\n    if (!this.listenerCount(event)) this._updateSubscription(event, false);\n    return this;\n  }\n  _adopt(child) {\n    child._parent._objects.delete(child._guid);\n    this._objects.set(child._guid, child);\n    child._parent = this;\n  }\n  _dispose() {\n    // Clean up from parent and connection.\n    if (this._parent) this._parent._objects.delete(this._guid);\n    this._connection._objects.delete(this._guid);\n\n    // Dispose all children.\n    for (const object of [...this._objects.values()]) object._dispose();\n    this._objects.clear();\n  }\n  _debugScopeState() {\n    return {\n      _guid: this._guid,\n      objects: Array.from(this._objects.values()).map(o => o._debugScopeState())\n    };\n  }\n  _createChannel(base) {\n    const channel = new Proxy(base, {\n      get: (obj, prop) => {\n        if (typeof prop === 'string') {\n          const validator = (0, _validator.maybeFindValidator)(this._type, prop, 'Params');\n          if (validator) {\n            return params => {\n              return this._wrapApiCall(apiZone => {\n                const {\n                  stackTrace,\n                  csi,\n                  callCookie\n                } = apiZone.reported ? {\n                  csi: undefined,\n                  callCookie: undefined,\n                  stackTrace: null\n                } : apiZone;\n                apiZone.reported = true;\n                if (csi && stackTrace && stackTrace.apiName) csi.onApiCallBegin(renderCallWithParams(stackTrace.apiName, params), stackTrace, callCookie);\n                return this._connection.sendMessageToServer(this, this._type, prop, validator(params, '', {\n                  tChannelImpl: tChannelImplToWire,\n                  binary: this._connection.isRemote() ? 'toBase64' : 'buffer'\n                }), stackTrace);\n              });\n            };\n          }\n        }\n        return obj[prop];\n      }\n    });\n    channel._object = this;\n    return channel;\n  }\n  async _wrapApiCall(func, isInternal = false, customStackTrace) {\n    const logger = this._logger;\n    const stack = (0, _stackTrace.captureRawStack)();\n    const apiZone = _zones.zones.zoneData('apiZone', stack);\n    if (apiZone) return func(apiZone);\n    const stackTrace = customStackTrace || (0, _stackTrace.captureStackTrace)(stack);\n    if (isInternal) delete stackTrace.apiName;\n    const csi = isInternal ? undefined : this._instrumentation;\n    const callCookie = {};\n    const {\n      apiName,\n      frameTexts\n    } = stackTrace;\n    try {\n      logApiCall(logger, `=> ${apiName} started`, isInternal);\n      const apiZone = {\n        stackTrace,\n        isInternal,\n        reported: false,\n        csi,\n        callCookie\n      };\n      const result = await _zones.zones.run('apiZone', apiZone, async () => {\n        return await func(apiZone);\n      });\n      csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie);\n      logApiCall(logger, `<= ${apiName} succeeded`, isInternal);\n      return result;\n    } catch (e) {\n      const innerError = (process.env.PWDEBUGIMPL || (0, _utils.isUnderTest)()) && e.stack ? '\\n<inner error>\\n' + e.stack : '';\n      if (apiName && !apiName.includes('<anonymous>')) e.message = apiName + ': ' + e.message;\n      const stackFrames = '\\n' + frameTexts.join('\\n') + innerError;\n      if (stackFrames.trim()) e.stack = e.message + stackFrames;else e.stack = '';\n      csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie, e);\n      logApiCall(logger, `<= ${apiName} failed`, isInternal);\n      throw e;\n    }\n  }\n  _toImpl() {\n    var _this$_connection$toI, _this$_connection;\n    return (_this$_connection$toI = (_this$_connection = this._connection).toImpl) === null || _this$_connection$toI === void 0 ? void 0 : _this$_connection$toI.call(_this$_connection, this);\n  }\n  toJSON() {\n    // Jest's expect library tries to print objects sometimes.\n    // RPC objects can contain links to lots of other objects,\n    // which can cause jest to crash. Let's help it out\n    // by just returning the important values.\n    return {\n      _type: this._type,\n      _guid: this._guid\n    };\n  }\n}\nexports.ChannelOwner = ChannelOwner;\nfunction logApiCall(logger, message, isNested) {\n  if (isNested) return;\n  if (logger && logger.isEnabled('api', 'info')) logger.log('api', 'info', message, [], {\n    color: 'cyan'\n  });\n  _debugLogger.debugLogger.log('api', message);\n}\nconst paramsToRender = ['url', 'selector', 'text', 'key'];\nfunction renderCallWithParams(apiName, params) {\n  const paramsArray = [];\n  if (params) {\n    for (const name of paramsToRender) {\n      if (params[name]) paramsArray.push(params[name]);\n    }\n  }\n  const paramsText = paramsArray.length ? '(' + paramsArray.join(', ') + ')' : '';\n  return apiName + paramsText;\n}\nfunction tChannelImplToWire(names, arg, path, context) {\n  if (arg._object instanceof ChannelOwner && (names === '*' || names.includes(arg._object._type))) return {\n    guid: arg._object._guid\n  };\n  throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.envObjectToArray = envObjectToArray;\nexports.evaluationScript = evaluationScript;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _utils = require(\"../utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction envObjectToArray(env) {\n  const result = [];\n  for (const name in env) {\n    if (!Object.is(env[name], undefined)) result.push({\n      name,\n      value: String(env[name])\n    });\n  }\n  return result;\n}\nasync function evaluationScript(fun, arg, addSourceUrl = true) {\n  if (typeof fun === 'function') {\n    const source = fun.toString();\n    const argString = Object.is(arg, undefined) ? 'undefined' : JSON.stringify(arg);\n    return `(${source})(${argString})`;\n  }\n  if (arg !== undefined) throw new Error('Cannot evaluate a string with arguments');\n  if ((0, _utils.isString)(fun)) return fun;\n  if (fun.content !== undefined) return fun.content;\n  if (fun.path !== undefined) {\n    let source = await _fs.default.promises.readFile(fun.path, 'utf8');\n    if (addSourceUrl) source += '\\n//# sourceURL=' + fun.path.replace(/\\n/g, '');\n    return source;\n  }\n  throw new Error('Either path or content property must be present');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInstrumentation = createInstrumentation;\n/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction createInstrumentation() {\n  const listeners = [];\n  return new Proxy({}, {\n    get: (obj, prop) => {\n      if (prop === 'addListener') return listener => listeners.push(listener);\n      if (prop === 'removeListener') return listener => listeners.splice(listeners.indexOf(listener), 1);\n      if (prop === 'removeAllListeners') return () => listeners.splice(0, listeners.length);\n      if (!prop.startsWith('on')) return obj[prop];\n      return async (...params) => {\n        for (const listener of listeners) {\n          var _prop, _ref;\n          await ((_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params));\n        }\n      };\n    }\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connection = void 0;\nvar _browser = require(\"./browser\");\nvar _browserContext = require(\"./browserContext\");\nvar _browserType = require(\"./browserType\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _elementHandle = require(\"./elementHandle\");\nvar _frame = require(\"./frame\");\nvar _jsHandle = require(\"./jsHandle\");\nvar _network = require(\"./network\");\nvar _page = require(\"./page\");\nvar _worker = require(\"./worker\");\nvar _consoleMessage = require(\"./consoleMessage\");\nvar _dialog = require(\"./dialog\");\nvar _serializers = require(\"../protocol/serializers\");\nvar _cdpSession = require(\"./cdpSession\");\nvar _playwright = require(\"./playwright\");\nvar _electron = require(\"./electron\");\nvar _stream = require(\"./stream\");\nvar _writableStream = require(\"./writableStream\");\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _selectors = require(\"./selectors\");\nvar _android = require(\"./android\");\nvar _stackTrace = require(\"../utils/stackTrace\");\nvar _artifact = require(\"./artifact\");\nvar _events = require(\"events\");\nvar _jsonPipe = require(\"./jsonPipe\");\nvar _fetch = require(\"./fetch\");\nvar _localUtils = require(\"./localUtils\");\nvar _tracing = require(\"./tracing\");\nvar _validator = require(\"../protocol/validator\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Root extends _channelOwner.ChannelOwner {\n  constructor(connection) {\n    super(connection, 'Root', '', {});\n  }\n  async initialize() {\n    return _playwright.Playwright.from((await this._channel.initialize({\n      sdkLanguage: 'javascript'\n    })).playwright);\n  }\n}\nclass DummyChannelOwner extends _channelOwner.ChannelOwner {}\nclass Connection extends _events.EventEmitter {\n  // Some connections allow resolving in-process dispatchers.\n\n  constructor(localUtils) {\n    super();\n    this._objects = new Map();\n    this.onmessage = message => {};\n    this._lastId = 0;\n    this._callbacks = new Map();\n    this._rootObject = void 0;\n    this._closedErrorMessage = void 0;\n    this._isRemote = false;\n    this._localUtils = void 0;\n    this.toImpl = void 0;\n    this._rootObject = new Root(this);\n    this._localUtils = localUtils;\n  }\n  markAsRemote() {\n    this._isRemote = true;\n  }\n  isRemote() {\n    return this._isRemote;\n  }\n  localUtils() {\n    return this._localUtils;\n  }\n  async initializePlaywright() {\n    return await this._rootObject.initialize();\n  }\n  pendingProtocolCalls() {\n    return Array.from(this._callbacks.values()).map(callback => callback.stackTrace).filter(Boolean);\n  }\n  getObjectWithKnownName(guid) {\n    return this._objects.get(guid);\n  }\n  async sendMessageToServer(object, type, method, params, stackTrace) {\n    if (this._closedErrorMessage) throw new Error(this._closedErrorMessage);\n    const {\n      apiName,\n      frames\n    } = stackTrace || {\n      apiName: '',\n      frames: []\n    };\n    const guid = object._guid;\n    const id = ++this._lastId;\n    const converted = {\n      id,\n      guid,\n      method,\n      params\n    };\n    // Do not include metadata in debug logs to avoid noise.\n    _debugLogger.debugLogger.log('channel:command', converted);\n    const metadata = {\n      stack: frames,\n      apiName,\n      internal: !apiName\n    };\n    this.onmessage({\n      ...converted,\n      metadata\n    });\n    return await new Promise((resolve, reject) => this._callbacks.set(id, {\n      resolve,\n      reject,\n      stackTrace,\n      type,\n      method\n    }));\n  }\n  dispatch(message) {\n    if (this._closedErrorMessage) return;\n    const {\n      id,\n      guid,\n      method,\n      params,\n      result,\n      error\n    } = message;\n    if (id) {\n      _debugLogger.debugLogger.log('channel:response', message);\n      const callback = this._callbacks.get(id);\n      if (!callback) throw new Error(`Cannot find command to respond: ${id}`);\n      this._callbacks.delete(id);\n      if (error && !result) {\n        callback.reject((0, _serializers.parseError)(error));\n      } else {\n        const validator = (0, _validator.findValidator)(callback.type, callback.method, 'Result');\n        callback.resolve(validator(result, '', {\n          tChannelImpl: this._tChannelImplFromWire.bind(this),\n          binary: this.isRemote() ? 'fromBase64' : 'buffer'\n        }));\n      }\n      return;\n    }\n    _debugLogger.debugLogger.log('channel:event', message);\n    if (method === '__create__') {\n      this._createRemoteObject(guid, params.type, params.guid, params.initializer);\n      return;\n    }\n    const object = this._objects.get(guid);\n    if (!object) throw new Error(`Cannot find object to \"${method}\": ${guid}`);\n    if (method === '__adopt__') {\n      const child = this._objects.get(params.guid);\n      if (!child) throw new Error(`Unknown new child: ${params.guid}`);\n      object._adopt(child);\n      return;\n    }\n    if (method === '__dispose__') {\n      object._dispose();\n      return;\n    }\n    const validator = (0, _validator.findValidator)(object._type, method, 'Event');\n    object._channel.emit(method, validator(params, '', {\n      tChannelImpl: this._tChannelImplFromWire.bind(this),\n      binary: this.isRemote() ? 'fromBase64' : 'buffer'\n    }));\n  }\n  close(errorMessage = 'Connection closed') {\n    const stack = (0, _stackTrace.captureStackTrace)().frameTexts.join('\\n');\n    if (stack) errorMessage += '\\n    ==== Closed by ====\\n' + stack + '\\n';\n    this._closedErrorMessage = errorMessage;\n    for (const callback of this._callbacks.values()) callback.reject(new Error(errorMessage));\n    this._callbacks.clear();\n    this.emit('close');\n  }\n  _tChannelImplFromWire(names, arg, path, context) {\n    if (arg && typeof arg === 'object' && typeof arg.guid === 'string') {\n      const object = this._objects.get(arg.guid);\n      if (!object) throw new Error(`Object with guid ${arg.guid} was not bound in the connection`);\n      if (names !== '*' && !names.includes(object._type)) throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);\n      return object._channel;\n    }\n    throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);\n  }\n  _createRemoteObject(parentGuid, type, guid, initializer) {\n    const parent = this._objects.get(parentGuid);\n    if (!parent) throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);\n    let result;\n    const validator = (0, _validator.findValidator)(type, '', 'Initializer');\n    initializer = validator(initializer, '', {\n      tChannelImpl: this._tChannelImplFromWire.bind(this),\n      binary: this.isRemote() ? 'fromBase64' : 'buffer'\n    });\n    switch (type) {\n      case 'Android':\n        result = new _android.Android(parent, type, guid, initializer);\n        break;\n      case 'AndroidSocket':\n        result = new _android.AndroidSocket(parent, type, guid, initializer);\n        break;\n      case 'AndroidDevice':\n        result = new _android.AndroidDevice(parent, type, guid, initializer);\n        break;\n      case 'APIRequestContext':\n        result = new _fetch.APIRequestContext(parent, type, guid, initializer);\n        break;\n      case 'Artifact':\n        result = new _artifact.Artifact(parent, type, guid, initializer);\n        break;\n      case 'BindingCall':\n        result = new _page.BindingCall(parent, type, guid, initializer);\n        break;\n      case 'Browser':\n        result = new _browser.Browser(parent, type, guid, initializer);\n        break;\n      case 'BrowserContext':\n        result = new _browserContext.BrowserContext(parent, type, guid, initializer);\n        break;\n      case 'BrowserType':\n        result = new _browserType.BrowserType(parent, type, guid, initializer);\n        break;\n      case 'CDPSession':\n        result = new _cdpSession.CDPSession(parent, type, guid, initializer);\n        break;\n      case 'ConsoleMessage':\n        result = new _consoleMessage.ConsoleMessage(parent, type, guid, initializer);\n        break;\n      case 'Dialog':\n        result = new _dialog.Dialog(parent, type, guid, initializer);\n        break;\n      case 'Electron':\n        result = new _electron.Electron(parent, type, guid, initializer);\n        break;\n      case 'ElectronApplication':\n        result = new _electron.ElectronApplication(parent, type, guid, initializer);\n        break;\n      case 'ElementHandle':\n        result = new _elementHandle.ElementHandle(parent, type, guid, initializer);\n        break;\n      case 'Frame':\n        result = new _frame.Frame(parent, type, guid, initializer);\n        break;\n      case 'JSHandle':\n        result = new _jsHandle.JSHandle(parent, type, guid, initializer);\n        break;\n      case 'JsonPipe':\n        result = new _jsonPipe.JsonPipe(parent, type, guid, initializer);\n        break;\n      case 'LocalUtils':\n        result = new _localUtils.LocalUtils(parent, type, guid, initializer);\n        if (!this._localUtils) this._localUtils = result;\n        break;\n      case 'Page':\n        result = new _page.Page(parent, type, guid, initializer);\n        break;\n      case 'Playwright':\n        result = new _playwright.Playwright(parent, type, guid, initializer);\n        break;\n      case 'Request':\n        result = new _network.Request(parent, type, guid, initializer);\n        break;\n      case 'Response':\n        result = new _network.Response(parent, type, guid, initializer);\n        break;\n      case 'Route':\n        result = new _network.Route(parent, type, guid, initializer);\n        break;\n      case 'Stream':\n        result = new _stream.Stream(parent, type, guid, initializer);\n        break;\n      case 'Selectors':\n        result = new _selectors.SelectorsOwner(parent, type, guid, initializer);\n        break;\n      case 'SocksSupport':\n        result = new DummyChannelOwner(parent, type, guid, initializer);\n        break;\n      case 'Tracing':\n        result = new _tracing.Tracing(parent, type, guid, initializer);\n        break;\n      case 'WebSocket':\n        result = new _network.WebSocket(parent, type, guid, initializer);\n        break;\n      case 'Worker':\n        result = new _worker.Worker(parent, type, guid, initializer);\n        break;\n      case 'WritableStream':\n        result = new _writableStream.WritableStream(parent, type, guid, initializer);\n        break;\n      default:\n        throw new Error('Missing type ' + type);\n    }\n    return result;\n  }\n}\nexports.Connection = Connection;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConsoleMessage = void 0;\nvar util = _interopRequireWildcard(require(\"util\"));\nvar _jsHandle = require(\"./jsHandle\");\nvar _channelOwner = require(\"./channelOwner\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ConsoleMessage extends _channelOwner.ChannelOwner {\n  static from(message) {\n    return message._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  type() {\n    return this._initializer.type;\n  }\n  text() {\n    return this._initializer.text;\n  }\n  args() {\n    return this._initializer.args.map(_jsHandle.JSHandle.from);\n  }\n  location() {\n    return this._initializer.location;\n  }\n  [util.inspect.custom]() {\n    return this.text();\n  }\n}\nexports.ConsoleMessage = ConsoleMessage;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Coverage = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Coverage {\n  constructor(channel) {\n    this._channel = void 0;\n    this._channel = channel;\n  }\n  async startJSCoverage(options = {}) {\n    await this._channel.startJSCoverage(options);\n  }\n  async stopJSCoverage() {\n    return (await this._channel.stopJSCoverage()).entries;\n  }\n  async startCSSCoverage(options = {}) {\n    await this._channel.startCSSCoverage(options);\n  }\n  async stopCSSCoverage() {\n    return (await this._channel.stopCSSCoverage()).entries;\n  }\n}\nexports.Coverage = Coverage;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dialog = void 0;\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Dialog extends _channelOwner.ChannelOwner {\n  static from(dialog) {\n    return dialog._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  type() {\n    return this._initializer.type;\n  }\n  message() {\n    return this._initializer.message;\n  }\n  defaultValue() {\n    return this._initializer.defaultValue;\n  }\n  async accept(promptText) {\n    await this._channel.accept({\n      promptText\n    });\n  }\n  async dismiss() {\n    await this._channel.dismiss();\n  }\n}\nexports.Dialog = Dialog;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Download = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Download {\n  constructor(page, url, suggestedFilename, artifact) {\n    this._page = void 0;\n    this._url = void 0;\n    this._suggestedFilename = void 0;\n    this._artifact = void 0;\n    this._page = page;\n    this._url = url;\n    this._suggestedFilename = suggestedFilename;\n    this._artifact = artifact;\n  }\n  page() {\n    return this._page;\n  }\n  url() {\n    return this._url;\n  }\n  suggestedFilename() {\n    return this._suggestedFilename;\n  }\n  async path() {\n    return this._artifact.pathAfterFinished();\n  }\n  async saveAs(path) {\n    return this._artifact.saveAs(path);\n  }\n  async failure() {\n    return this._artifact.failure();\n  }\n  async createReadStream() {\n    return this._artifact.createReadStream();\n  }\n  async cancel() {\n    return this._artifact.cancel();\n  }\n  async delete() {\n    return this._artifact.delete();\n  }\n}\nexports.Download = Download;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElectronApplication = exports.Electron = void 0;\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _browserContext = require(\"./browserContext\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _clientHelper = require(\"./clientHelper\");\nvar _events = require(\"./events\");\nvar _jsHandle = require(\"./jsHandle\");\nvar _waiter = require(\"./waiter\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Electron extends _channelOwner.ChannelOwner {\n  static from(electron) {\n    return electron._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  async launch(options = {}) {\n    const params = {\n      ...(await (0, _browserContext.prepareBrowserContextParams)(options)),\n      env: (0, _clientHelper.envObjectToArray)(options.env ? options.env : process.env)\n    };\n    const app = ElectronApplication.from((await this._channel.launch(params)).electronApplication);\n    app._context._options = params;\n    return app;\n  }\n}\nexports.Electron = Electron;\nclass ElectronApplication extends _channelOwner.ChannelOwner {\n  static from(electronApplication) {\n    return electronApplication._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._context = void 0;\n    this._windows = new Set();\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();\n    this._isClosed = false;\n    this._context = _browserContext.BrowserContext.from(initializer.context);\n    for (const page of this._context._pages) this._onPage(page);\n    this._context.on(_events.Events.BrowserContext.Page, page => this._onPage(page));\n    this._channel.on('close', () => {\n      this._isClosed = true;\n      this.emit(_events.Events.ElectronApplication.Close);\n    });\n  }\n  process() {\n    return this._toImpl().process();\n  }\n  _onPage(page) {\n    this._windows.add(page);\n    this.emit(_events.Events.ElectronApplication.Window, page);\n    page.once(_events.Events.Page.Close, () => this._windows.delete(page));\n  }\n  windows() {\n    // TODO: add ElectronPage class inherting from Page.\n    return [...this._windows];\n  }\n  async firstWindow() {\n    if (this._windows.size) return this._windows.values().next().value;\n    return this.waitForEvent('window');\n  }\n  context() {\n    return this._context;\n  }\n  async close() {\n    if (this._isClosed) return;\n    await this._channel.close().catch(() => {});\n  }\n  async waitForEvent(event, optionsOrPredicate = {}) {\n    return this._wrapApiCall(async () => {\n      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = _waiter.Waiter.createForEvent(this, event);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== _events.Events.ElectronApplication.Close) waiter.rejectOnEvent(this, _events.Events.ElectronApplication.Close, new Error('Electron application closed'));\n      const result = await waiter.waitForEvent(this, event, predicate);\n      waiter.dispose();\n      return result;\n    });\n  }\n  async browserWindow(page) {\n    const result = await this._channel.browserWindow({\n      page: page._channel\n    });\n    return _jsHandle.JSHandle.from(result.handle);\n  }\n  async evaluate(pageFunction, arg) {\n    const result = await this._channel.evaluateExpression({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    const result = await this._channel.evaluateExpressionHandle({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return _jsHandle.JSHandle.from(result.handle);\n  }\n}\nexports.ElectronApplication = ElectronApplication;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElementHandle = void 0;\nexports.convertInputFiles = convertInputFiles;\nexports.convertSelectOptionValues = convertSelectOptionValues;\nexports.determineScreenshotType = determineScreenshotType;\nvar _frame = require(\"./frame\");\nvar _jsHandle = require(\"./jsHandle\");\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _utils = require(\"../utils\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _writableStream = require(\"./writableStream\");\nvar _stream = require(\"stream\");\nvar _util = require(\"util\");\nvar _debugLogger = require(\"../common/debugLogger\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst pipelineAsync = (0, _util.promisify)(_stream.pipeline);\nclass ElementHandle extends _jsHandle.JSHandle {\n  static from(handle) {\n    return handle._object;\n  }\n  static fromNullable(handle) {\n    return handle ? ElementHandle.from(handle) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._elementChannel = void 0;\n    this._elementChannel = this._channel;\n  }\n  asElement() {\n    return this;\n  }\n  async ownerFrame() {\n    return _frame.Frame.fromNullable((await this._elementChannel.ownerFrame()).frame);\n  }\n  async contentFrame() {\n    return _frame.Frame.fromNullable((await this._elementChannel.contentFrame()).frame);\n  }\n  async getAttribute(name) {\n    const value = (await this._elementChannel.getAttribute({\n      name\n    })).value;\n    return value === undefined ? null : value;\n  }\n  async inputValue() {\n    return (await this._elementChannel.inputValue()).value;\n  }\n  async textContent() {\n    const value = (await this._elementChannel.textContent()).value;\n    return value === undefined ? null : value;\n  }\n  async innerText() {\n    return (await this._elementChannel.innerText()).value;\n  }\n  async innerHTML() {\n    return (await this._elementChannel.innerHTML()).value;\n  }\n  async isChecked() {\n    return (await this._elementChannel.isChecked()).value;\n  }\n  async isDisabled() {\n    return (await this._elementChannel.isDisabled()).value;\n  }\n  async isEditable() {\n    return (await this._elementChannel.isEditable()).value;\n  }\n  async isEnabled() {\n    return (await this._elementChannel.isEnabled()).value;\n  }\n  async isHidden() {\n    return (await this._elementChannel.isHidden()).value;\n  }\n  async isVisible() {\n    return (await this._elementChannel.isVisible()).value;\n  }\n  async dispatchEvent(type, eventInit = {}) {\n    await this._elementChannel.dispatchEvent({\n      type,\n      eventInit: (0, _jsHandle.serializeArgument)(eventInit)\n    });\n  }\n  async scrollIntoViewIfNeeded(options = {}) {\n    await this._elementChannel.scrollIntoViewIfNeeded(options);\n  }\n  async hover(options = {}) {\n    await this._elementChannel.hover(options);\n  }\n  async click(options = {}) {\n    return await this._elementChannel.click(options);\n  }\n  async dblclick(options = {}) {\n    return await this._elementChannel.dblclick(options);\n  }\n  async tap(options = {}) {\n    return await this._elementChannel.tap(options);\n  }\n  async selectOption(values, options = {}) {\n    const result = await this._elementChannel.selectOption({\n      ...convertSelectOptionValues(values),\n      ...options\n    });\n    return result.values;\n  }\n  async fill(value, options = {}) {\n    return await this._elementChannel.fill({\n      value,\n      ...options\n    });\n  }\n  async selectText(options = {}) {\n    await this._elementChannel.selectText(options);\n  }\n  async setInputFiles(files, options = {}) {\n    const frame = await this.ownerFrame();\n    if (!frame) throw new Error('Cannot set input files to detached element');\n    const converted = await convertInputFiles(files, frame.page().context());\n    if (converted.files) {\n      await this._elementChannel.setInputFiles({\n        files: converted.files,\n        ...options\n      });\n    } else {\n      _debugLogger.debugLogger.log('api', 'switching to large files mode');\n      await this._elementChannel.setInputFilePaths({\n        ...converted,\n        ...options\n      });\n    }\n  }\n  async focus() {\n    await this._elementChannel.focus();\n  }\n  async type(text, options = {}) {\n    await this._elementChannel.type({\n      text,\n      ...options\n    });\n  }\n  async press(key, options = {}) {\n    await this._elementChannel.press({\n      key,\n      ...options\n    });\n  }\n  async check(options = {}) {\n    return await this._elementChannel.check(options);\n  }\n  async uncheck(options = {}) {\n    return await this._elementChannel.uncheck(options);\n  }\n  async setChecked(checked, options) {\n    if (checked) await this.check(options);else await this.uncheck(options);\n  }\n  async boundingBox() {\n    const value = (await this._elementChannel.boundingBox()).value;\n    return value === undefined ? null : value;\n  }\n  async screenshot(options = {}) {\n    const copy = {\n      ...options,\n      mask: undefined\n    };\n    if (!copy.type) copy.type = determineScreenshotType(options);\n    if (options.mask) {\n      copy.mask = options.mask.map(locator => ({\n        frame: locator._frame._channel,\n        selector: locator._selector\n      }));\n    }\n    const result = await this._elementChannel.screenshot(copy);\n    if (options.path) {\n      await (0, _fileUtils.mkdirIfNeeded)(options.path);\n      await _fs.default.promises.writeFile(options.path, result.binary);\n    }\n    return result.binary;\n  }\n  async $(selector) {\n    return ElementHandle.fromNullable((await this._elementChannel.querySelector({\n      selector\n    })).element);\n  }\n  async $$(selector) {\n    const result = await this._elementChannel.querySelectorAll({\n      selector\n    });\n    return result.elements.map(h => ElementHandle.from(h));\n  }\n  async $eval(selector, pageFunction, arg) {\n    const result = await this._elementChannel.evalOnSelector({\n      selector,\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async $$eval(selector, pageFunction, arg) {\n    const result = await this._elementChannel.evalOnSelectorAll({\n      selector,\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async waitForElementState(state, options = {}) {\n    return await this._elementChannel.waitForElementState({\n      state,\n      ...options\n    });\n  }\n  async waitForSelector(selector, options = {}) {\n    const result = await this._elementChannel.waitForSelector({\n      selector,\n      ...options\n    });\n    return ElementHandle.fromNullable(result.element);\n  }\n}\nexports.ElementHandle = ElementHandle;\nfunction convertSelectOptionValues(values) {\n  if (values === null) return {};\n  if (!Array.isArray(values)) values = [values];\n  if (!values.length) return {};\n  for (let i = 0; i < values.length; i++) (0, _utils.assert)(values[i] !== null, `options[${i}]: expected object, got null`);\n  if (values[0] instanceof ElementHandle) return {\n    elements: values.map(v => v._elementChannel)\n  };\n  if ((0, _utils.isString)(values[0])) return {\n    options: values.map(valueOrLabel => ({\n      valueOrLabel\n    }))\n  };\n  return {\n    options: values\n  };\n}\nasync function convertInputFiles(files, context) {\n  const items = Array.isArray(files) ? files.slice() : [files];\n  const sizeLimit = 50 * 1024 * 1024;\n  const hasLargeBuffer = items.find(item => typeof item === 'object' && item.buffer && item.buffer.byteLength > sizeLimit);\n  if (hasLargeBuffer) throw new Error('Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.');\n  const stats = await Promise.all(items.filter(_utils.isString).map(item => _fs.default.promises.stat(item)));\n  const hasLargeFile = !!stats.find(s => s.size > sizeLimit);\n  if (hasLargeFile) {\n    if (context._connection.isRemote()) {\n      const streams = await Promise.all(items.map(async item => {\n        (0, _utils.assert)((0, _utils.isString)(item));\n        const {\n          writableStream: stream\n        } = await context._channel.createTempFile({\n          name: _path.default.basename(item)\n        });\n        const writable = _writableStream.WritableStream.from(stream);\n        await pipelineAsync(_fs.default.createReadStream(item), writable.stream());\n        return stream;\n      }));\n      return {\n        streams\n      };\n    }\n    return {\n      localPaths: items.map(f => _path.default.resolve(f))\n    };\n  }\n  const filePayloads = await Promise.all(items.map(async item => {\n    if (typeof item === 'string') {\n      return {\n        name: _path.default.basename(item),\n        buffer: await _fs.default.promises.readFile(item)\n      };\n    } else {\n      return {\n        name: item.name,\n        mimeType: item.mimeType,\n        buffer: item.buffer\n      };\n    }\n  }));\n  return {\n    files: filePayloads\n  };\n}\nfunction determineScreenshotType(options) {\n  if (options.path) {\n    const mimeType = _utilsBundle.mime.getType(options.path);\n    if (mimeType === 'image/png') return 'png';else if (mimeType === 'image/jpeg') return 'jpeg';\n    throw new Error(`path: unsupported mime type \"${mimeType}\"`);\n  }\n  return options.type;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Events = void 0;\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst Events = {\n  AndroidDevice: {\n    WebView: 'webview',\n    Close: 'close'\n  },\n  AndroidSocket: {\n    Data: 'data',\n    Close: 'close'\n  },\n  AndroidWebView: {\n    Close: 'close'\n  },\n  Browser: {\n    Disconnected: 'disconnected'\n  },\n  BrowserContext: {\n    Close: 'close',\n    Page: 'page',\n    BackgroundPage: 'backgroundpage',\n    ServiceWorker: 'serviceworker',\n    Request: 'request',\n    Response: 'response',\n    RequestFailed: 'requestfailed',\n    RequestFinished: 'requestfinished'\n  },\n  BrowserServer: {\n    Close: 'close'\n  },\n  Page: {\n    Close: 'close',\n    Crash: 'crash',\n    Console: 'console',\n    Dialog: 'dialog',\n    Download: 'download',\n    FileChooser: 'filechooser',\n    DOMContentLoaded: 'domcontentloaded',\n    // Can't use just 'error' due to node.js special treatment of error events.\n    // @see https://nodejs.org/api/events.html#events_error_events\n    PageError: 'pageerror',\n    Request: 'request',\n    Response: 'response',\n    RequestFailed: 'requestfailed',\n    RequestFinished: 'requestfinished',\n    FrameAttached: 'frameattached',\n    FrameDetached: 'framedetached',\n    FrameNavigated: 'framenavigated',\n    Load: 'load',\n    Popup: 'popup',\n    WebSocket: 'websocket',\n    Worker: 'worker'\n  },\n  WebSocket: {\n    Close: 'close',\n    Error: 'socketerror',\n    FrameReceived: 'framereceived',\n    FrameSent: 'framesent'\n  },\n  Worker: {\n    Close: 'close'\n  },\n  ElectronApplication: {\n    Close: 'close',\n    Window: 'window'\n  }\n};\nexports.Events = Events;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.APIResponse = exports.APIRequestContext = exports.APIRequest = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar util = _interopRequireWildcard(require(\"util\"));\nvar _errors = require(\"../common/errors\");\nvar _utils = require(\"../utils\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _network = require(\"./network\");\nvar _clientInstrumentation = require(\"./clientInstrumentation\");\nvar _tracing = require(\"./tracing\");\nlet _util$inspect$custom;\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nclass APIRequest {\n  // Instrumentation.\n\n  constructor(playwright) {\n    this._playwright = void 0;\n    this._contexts = new Set();\n    this._onDidCreateContext = void 0;\n    this._onWillCloseContext = void 0;\n    this._playwright = playwright;\n  }\n  async newContext(options = {}) {\n    var _this$_onDidCreateCon;\n    const storageState = typeof options.storageState === 'string' ? JSON.parse(await _fs.default.promises.readFile(options.storageState, 'utf8')) : options.storageState;\n    const context = APIRequestContext.from((await this._playwright._channel.newRequest({\n      ...options,\n      extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : undefined,\n      storageState\n    })).request);\n    this._contexts.add(context);\n    context._request = this;\n    await ((_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context));\n    return context;\n  }\n}\nexports.APIRequest = APIRequest;\nclass APIRequestContext extends _channelOwner.ChannelOwner {\n  static from(channel) {\n    return channel._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());\n    this._request = void 0;\n    this._tracing = void 0;\n    this._tracing = _tracing.Tracing.from(initializer.tracing);\n  }\n  async dispose() {\n    var _this$_request, _this$_request$_onWil, _this$_request2;\n    await ((_this$_request = this._request) === null || _this$_request === void 0 ? void 0 : (_this$_request$_onWil = _this$_request._onWillCloseContext) === null || _this$_request$_onWil === void 0 ? void 0 : _this$_request$_onWil.call(_this$_request, this));\n    await this._channel.dispose();\n    (_this$_request2 = this._request) === null || _this$_request2 === void 0 ? void 0 : _this$_request2._contexts.delete(this);\n  }\n  async delete(url, options) {\n    return this.fetch(url, {\n      ...options,\n      method: 'DELETE'\n    });\n  }\n  async head(url, options) {\n    return this.fetch(url, {\n      ...options,\n      method: 'HEAD'\n    });\n  }\n  async get(url, options) {\n    return this.fetch(url, {\n      ...options,\n      method: 'GET'\n    });\n  }\n  async patch(url, options) {\n    return this.fetch(url, {\n      ...options,\n      method: 'PATCH'\n    });\n  }\n  async post(url, options) {\n    return this.fetch(url, {\n      ...options,\n      method: 'POST'\n    });\n  }\n  async put(url, options) {\n    return this.fetch(url, {\n      ...options,\n      method: 'PUT'\n    });\n  }\n  async fetch(urlOrRequest, options = {}) {\n    const url = (0, _utils.isString)(urlOrRequest) ? urlOrRequest : undefined;\n    const request = (0, _utils.isString)(urlOrRequest) ? undefined : urlOrRequest;\n    return this._innerFetch({\n      url,\n      request,\n      ...options\n    });\n  }\n  async _innerFetch(options = {}) {\n    return this._wrapApiCall(async () => {\n      var _options$request, _options$request2, _options$request3;\n      (0, _utils.assert)(options.request || typeof options.url === 'string', 'First argument must be either URL string or Request');\n      (0, _utils.assert)((options.data === undefined ? 0 : 1) + (options.form === undefined ? 0 : 1) + (options.multipart === undefined ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);\n      (0, _utils.assert)(options.maxRedirects === undefined || options.maxRedirects >= 0, `'maxRedirects' should be greater than or equal to '0'`);\n      const url = options.url !== undefined ? options.url : options.request.url();\n      const params = objectToArray(options.params);\n      const method = options.method || ((_options$request = options.request) === null || _options$request === void 0 ? void 0 : _options$request.method());\n      const maxRedirects = options.maxRedirects;\n      // Cannot call allHeaders() here as the request may be paused inside route handler.\n      const headersObj = options.headers || ((_options$request2 = options.request) === null || _options$request2 === void 0 ? void 0 : _options$request2.headers());\n      const headers = headersObj ? (0, _utils.headersObjectToArray)(headersObj) : undefined;\n      let jsonData;\n      let formData;\n      let multipartData;\n      let postDataBuffer;\n      if (options.data !== undefined) {\n        if ((0, _utils.isString)(options.data)) {\n          if (isJsonContentType(headers)) jsonData = options.data;else postDataBuffer = Buffer.from(options.data, 'utf8');\n        } else if (Buffer.isBuffer(options.data)) {\n          postDataBuffer = options.data;\n        } else if (typeof options.data === 'object' || typeof options.data === 'number' || typeof options.data === 'boolean') {\n          jsonData = options.data;\n        } else {\n          throw new Error(`Unexpected 'data' type`);\n        }\n      } else if (options.form) {\n        formData = objectToArray(options.form);\n      } else if (options.multipart) {\n        multipartData = [];\n        // Convert file-like values to ServerFilePayload structs.\n        for (const [name, value] of Object.entries(options.multipart)) {\n          if (isFilePayload(value)) {\n            const payload = value;\n            if (!Buffer.isBuffer(payload.buffer)) throw new Error(`Unexpected buffer type of 'data.${name}'`);\n            multipartData.push({\n              name,\n              file: filePayloadToJson(payload)\n            });\n          } else if (value instanceof _fs.default.ReadStream) {\n            multipartData.push({\n              name,\n              file: await readStreamToJson(value)\n            });\n          } else {\n            multipartData.push({\n              name,\n              value: String(value)\n            });\n          }\n        }\n      }\n      if (postDataBuffer === undefined && jsonData === undefined && formData === undefined && multipartData === undefined) postDataBuffer = ((_options$request3 = options.request) === null || _options$request3 === void 0 ? void 0 : _options$request3.postDataBuffer()) || undefined;\n      const fixtures = {\n        __testHookLookup: options.__testHookLookup\n      };\n      const result = await this._channel.fetch({\n        url,\n        params,\n        method,\n        headers,\n        postData: postDataBuffer,\n        jsonData,\n        formData,\n        multipartData,\n        timeout: options.timeout,\n        failOnStatusCode: options.failOnStatusCode,\n        ignoreHTTPSErrors: options.ignoreHTTPSErrors,\n        maxRedirects: maxRedirects,\n        ...fixtures\n      });\n      return new APIResponse(this, result.response);\n    });\n  }\n  async storageState(options = {}) {\n    const state = await this._channel.storageState();\n    if (options.path) {\n      await (0, _fileUtils.mkdirIfNeeded)(options.path);\n      await _fs.default.promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');\n    }\n    return state;\n  }\n}\nexports.APIRequestContext = APIRequestContext;\n_util$inspect$custom = util.inspect.custom;\nclass APIResponse {\n  constructor(context, initializer) {\n    this._initializer = void 0;\n    this._headers = void 0;\n    this._request = void 0;\n    this._request = context;\n    this._initializer = initializer;\n    this._headers = new _network.RawHeaders(this._initializer.headers);\n  }\n  ok() {\n    return this._initializer.status >= 200 && this._initializer.status <= 299;\n  }\n  url() {\n    return this._initializer.url;\n  }\n  status() {\n    return this._initializer.status;\n  }\n  statusText() {\n    return this._initializer.statusText;\n  }\n  headers() {\n    return this._headers.headers();\n  }\n  headersArray() {\n    return this._headers.headersArray();\n  }\n  async body() {\n    try {\n      const result = await this._request._channel.fetchResponseBody({\n        fetchUid: this._fetchUid()\n      });\n      if (result.binary === undefined) throw new Error('Response has been disposed');\n      return result.binary;\n    } catch (e) {\n      if (e.message.includes(_errors.kBrowserOrContextClosedError)) throw new Error('Response has been disposed');\n      throw e;\n    }\n  }\n  async text() {\n    const content = await this.body();\n    return content.toString('utf8');\n  }\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  async dispose() {\n    await this._request._channel.disposeAPIResponse({\n      fetchUid: this._fetchUid()\n    });\n  }\n  [_util$inspect$custom]() {\n    const headers = this.headersArray().map(({\n      name,\n      value\n    }) => `  ${name}: ${value}`);\n    return `APIResponse: ${this.status()} ${this.statusText()}\\n${headers.join('\\n')}`;\n  }\n  _fetchUid() {\n    return this._initializer.fetchUid;\n  }\n  async _fetchLog() {\n    const {\n      log\n    } = await this._request._channel.fetchLog({\n      fetchUid: this._fetchUid()\n    });\n    return log;\n  }\n}\nexports.APIResponse = APIResponse;\nfunction filePayloadToJson(payload) {\n  return {\n    name: payload.name,\n    mimeType: payload.mimeType,\n    buffer: payload.buffer\n  };\n}\nasync function readStreamToJson(stream) {\n  const buffer = await new Promise((resolve, reject) => {\n    const chunks = [];\n    stream.on('data', chunk => chunks.push(chunk));\n    stream.on('end', () => resolve(Buffer.concat(chunks)));\n    stream.on('error', err => reject(err));\n  });\n  const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString('utf8') : stream.path;\n  return {\n    name: _path.default.basename(streamPath),\n    buffer\n  };\n}\nfunction isJsonContentType(headers) {\n  if (!headers) return false;\n  for (const {\n    name,\n    value\n  } of headers) {\n    if (name.toLocaleLowerCase() === 'content-type') return value === 'application/json';\n  }\n  return false;\n}\nfunction objectToArray(map) {\n  if (!map) return undefined;\n  const result = [];\n  for (const [name, value] of Object.entries(map)) result.push({\n    name,\n    value: String(value)\n  });\n  return result;\n}\nfunction isFilePayload(value) {\n  return typeof value === 'object' && value['name'] && value['mimeType'] && value['buffer'];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileChooser = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass FileChooser {\n  constructor(page, elementHandle, isMultiple) {\n    this._page = void 0;\n    this._elementHandle = void 0;\n    this._isMultiple = void 0;\n    this._page = page;\n    this._elementHandle = elementHandle;\n    this._isMultiple = isMultiple;\n  }\n  element() {\n    return this._elementHandle;\n  }\n  isMultiple() {\n    return this._isMultiple;\n  }\n  page() {\n    return this._page;\n  }\n  async setFiles(files, options) {\n    return this._elementHandle.setInputFiles(files, options);\n  }\n}\nexports.FileChooser = FileChooser;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Frame = void 0;\nexports.verifyLoadState = verifyLoadState;\nvar _utils = require(\"../utils\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _locator = require(\"./locator\");\nvar _locatorUtils = require(\"../utils/isomorphic/locatorUtils\");\nvar _elementHandle = require(\"./elementHandle\");\nvar _jsHandle = require(\"./jsHandle\");\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar network = _interopRequireWildcard(require(\"./network\"));\nvar _events = require(\"events\");\nvar _waiter = require(\"./waiter\");\nvar _events2 = require(\"./events\");\nvar _types = require(\"./types\");\nvar _network2 = require(\"../utils/network\");\nvar _debugLogger = require(\"../common/debugLogger\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Frame extends _channelOwner.ChannelOwner {\n  static from(frame) {\n    return frame._object;\n  }\n  static fromNullable(frame) {\n    return frame ? Frame.from(frame) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._eventEmitter = void 0;\n    this._loadStates = void 0;\n    this._parentFrame = null;\n    this._url = '';\n    this._name = '';\n    this._detached = false;\n    this._childFrames = new Set();\n    this._page = void 0;\n    this._eventEmitter = new _events.EventEmitter();\n    this._eventEmitter.setMaxListeners(0);\n    this._parentFrame = Frame.fromNullable(initializer.parentFrame);\n    if (this._parentFrame) this._parentFrame._childFrames.add(this);\n    this._name = initializer.name;\n    this._url = initializer.url;\n    this._loadStates = new Set(initializer.loadStates);\n    this._channel.on('loadstate', event => {\n      if (event.add) {\n        this._loadStates.add(event.add);\n        this._eventEmitter.emit('loadstate', event.add);\n      }\n      if (event.remove) this._loadStates.delete(event.remove);\n      if (!this._parentFrame && event.add === 'load' && this._page) this._page.emit(_events2.Events.Page.Load, this._page);\n      if (!this._parentFrame && event.add === 'domcontentloaded' && this._page) this._page.emit(_events2.Events.Page.DOMContentLoaded, this._page);\n    });\n    this._channel.on('navigated', event => {\n      this._url = event.url;\n      this._name = event.name;\n      this._eventEmitter.emit('navigated', event);\n      if (!event.error && this._page) this._page.emit(_events2.Events.Page.FrameNavigated, this);\n    });\n  }\n  page() {\n    return this._page;\n  }\n  async goto(url, options = {}) {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return network.Response.fromNullable((await this._channel.goto({\n      url,\n      ...options,\n      waitUntil\n    })).response);\n  }\n  _setupNavigationWaiter(options) {\n    const waiter = new _waiter.Waiter(this._page, '');\n    if (this._page.isClosed()) waiter.rejectImmediately(new Error('Navigation failed because page was closed!'));\n    waiter.rejectOnEvent(this._page, _events2.Events.Page.Close, new Error('Navigation failed because page was closed!'));\n    waiter.rejectOnEvent(this._page, _events2.Events.Page.Crash, new Error('Navigation failed because page crashed!'));\n    waiter.rejectOnEvent(this._page, _events2.Events.Page.FrameDetached, new Error('Navigating frame was detached!'), frame => frame === this);\n    const timeout = this._page._timeoutSettings.navigationTimeout(options);\n    waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);\n    return waiter;\n  }\n  async waitForNavigation(options = {}) {\n    return this._page._wrapApiCall(async () => {\n      const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n      const waiter = this._setupNavigationWaiter(options);\n      const toUrl = typeof options.url === 'string' ? ` to \"${options.url}\"` : '';\n      waiter.log(`waiting for navigation${toUrl} until \"${waitUntil}\"`);\n      const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, 'navigated', event => {\n        var _this$_page;\n        // Any failed navigation results in a rejection.\n        if (event.error) return true;\n        waiter.log(`  navigated to \"${event.url}\"`);\n        return (0, _network2.urlMatches)((_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page.context()._options.baseURL, event.url, options.url);\n      });\n      if (navigatedEvent.error) {\n        const e = new Error(navigatedEvent.error);\n        e.stack = '';\n        await waiter.waitForPromise(Promise.reject(e));\n      }\n      if (!this._loadStates.has(waitUntil)) {\n        await waiter.waitForEvent(this._eventEmitter, 'loadstate', s => {\n          waiter.log(`  \"${s}\" event fired`);\n          return s === waitUntil;\n        });\n      }\n      const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;\n      const response = request ? await waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;\n      waiter.dispose();\n      return response;\n    });\n  }\n  async waitForLoadState(state = 'load', options = {}) {\n    state = verifyLoadState('state', state);\n    return this._page._wrapApiCall(async () => {\n      const waiter = this._setupNavigationWaiter(options);\n      if (this._loadStates.has(state)) {\n        waiter.log(`  not waiting, \"${state}\" event already fired`);\n      } else {\n        await waiter.waitForEvent(this._eventEmitter, 'loadstate', s => {\n          waiter.log(`  \"${s}\" event fired`);\n          return s === state;\n        });\n      }\n      waiter.dispose();\n    });\n  }\n  async waitForURL(url, options = {}) {\n    var _this$_page2;\n    if ((0, _network2.urlMatches)((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2.context()._options.baseURL, this.url(), url)) return await this.waitForLoadState(options.waitUntil, options);\n    await this.waitForNavigation({\n      url,\n      ...options\n    });\n  }\n  async frameElement() {\n    return _elementHandle.ElementHandle.from((await this._channel.frameElement()).element);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    const result = await this._channel.evaluateExpressionHandle({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return _jsHandle.JSHandle.from(result.handle);\n  }\n  async evaluate(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    const result = await this._channel.evaluateExpression({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async _evaluateExposeUtilityScript(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    const result = await this._channel.evaluateExpression({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      exposeUtilityScript: true,\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async $(selector, options) {\n    const result = await this._channel.querySelector({\n      selector,\n      ...options\n    });\n    return _elementHandle.ElementHandle.fromNullable(result.element);\n  }\n  async waitForSelector(selector, options = {}) {\n    if (options.visibility) throw new Error('options.visibility is not supported, did you mean options.state?');\n    if (options.waitFor && options.waitFor !== 'visible') throw new Error('options.waitFor is not supported, did you mean options.state?');\n    const result = await this._channel.waitForSelector({\n      selector,\n      ...options\n    });\n    return _elementHandle.ElementHandle.fromNullable(result.element);\n  }\n  async dispatchEvent(selector, type, eventInit, options = {}) {\n    await this._channel.dispatchEvent({\n      selector,\n      type,\n      eventInit: (0, _jsHandle.serializeArgument)(eventInit),\n      ...options\n    });\n  }\n  async $eval(selector, pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);\n    const result = await this._channel.evalOnSelector({\n      selector,\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async $$eval(selector, pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);\n    const result = await this._channel.evalOnSelectorAll({\n      selector,\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async $$(selector) {\n    const result = await this._channel.querySelectorAll({\n      selector\n    });\n    return result.elements.map(e => _elementHandle.ElementHandle.from(e));\n  }\n  async _queryCount(selector) {\n    return (await this._channel.queryCount({\n      selector\n    })).value;\n  }\n  async content() {\n    return (await this._channel.content()).value;\n  }\n  async setContent(html, options = {}) {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    await this._channel.setContent({\n      html,\n      ...options,\n      waitUntil\n    });\n  }\n  name() {\n    return this._name || '';\n  }\n  url() {\n    return this._url;\n  }\n  parentFrame() {\n    return this._parentFrame;\n  }\n  childFrames() {\n    return Array.from(this._childFrames);\n  }\n  isDetached() {\n    return this._detached;\n  }\n  async addScriptTag(options = {}) {\n    const copy = {\n      ...options\n    };\n    if (copy.path) {\n      copy.content = (await _fs.default.promises.readFile(copy.path)).toString();\n      copy.content += '//# sourceURL=' + copy.path.replace(/\\n/g, '');\n    }\n    return _elementHandle.ElementHandle.from((await this._channel.addScriptTag({\n      ...copy\n    })).element);\n  }\n  async addStyleTag(options = {}) {\n    const copy = {\n      ...options\n    };\n    if (copy.path) {\n      copy.content = (await _fs.default.promises.readFile(copy.path)).toString();\n      copy.content += '/*# sourceURL=' + copy.path.replace(/\\n/g, '') + '*/';\n    }\n    return _elementHandle.ElementHandle.from((await this._channel.addStyleTag({\n      ...copy\n    })).element);\n  }\n  async click(selector, options = {}) {\n    return await this._channel.click({\n      selector,\n      ...options\n    });\n  }\n  async dblclick(selector, options = {}) {\n    return await this._channel.dblclick({\n      selector,\n      ...options\n    });\n  }\n  async dragAndDrop(source, target, options = {}) {\n    return await this._channel.dragAndDrop({\n      source,\n      target,\n      ...options\n    });\n  }\n  async tap(selector, options = {}) {\n    return await this._channel.tap({\n      selector,\n      ...options\n    });\n  }\n  async fill(selector, value, options = {}) {\n    return await this._channel.fill({\n      selector,\n      value,\n      ...options\n    });\n  }\n  async _highlight(selector) {\n    return await this._channel.highlight({\n      selector\n    });\n  }\n  locator(selector, options) {\n    return new _locator.Locator(this, selector, options);\n  }\n  getByTestId(testId) {\n    return this.locator((0, _locatorUtils.getByTestIdSelector)((0, _locator.testIdAttributeName)(), testId));\n  }\n  getByAltText(text, options) {\n    return this.locator((0, _locatorUtils.getByAltTextSelector)(text, options));\n  }\n  getByLabel(text, options) {\n    return this.locator((0, _locatorUtils.getByLabelSelector)(text, options));\n  }\n  getByPlaceholder(text, options) {\n    return this.locator((0, _locatorUtils.getByPlaceholderSelector)(text, options));\n  }\n  getByText(text, options) {\n    return this.locator((0, _locatorUtils.getByTextSelector)(text, options));\n  }\n  getByTitle(text, options) {\n    return this.locator((0, _locatorUtils.getByTitleSelector)(text, options));\n  }\n  getByRole(role, options = {}) {\n    return this.locator((0, _locatorUtils.getByRoleSelector)(role, options));\n  }\n  frameLocator(selector) {\n    return new _locator.FrameLocator(this, selector);\n  }\n  async focus(selector, options = {}) {\n    await this._channel.focus({\n      selector,\n      ...options\n    });\n  }\n  async textContent(selector, options = {}) {\n    const value = (await this._channel.textContent({\n      selector,\n      ...options\n    })).value;\n    return value === undefined ? null : value;\n  }\n  async innerText(selector, options = {}) {\n    return (await this._channel.innerText({\n      selector,\n      ...options\n    })).value;\n  }\n  async innerHTML(selector, options = {}) {\n    return (await this._channel.innerHTML({\n      selector,\n      ...options\n    })).value;\n  }\n  async getAttribute(selector, name, options = {}) {\n    const value = (await this._channel.getAttribute({\n      selector,\n      name,\n      ...options\n    })).value;\n    return value === undefined ? null : value;\n  }\n  async inputValue(selector, options = {}) {\n    return (await this._channel.inputValue({\n      selector,\n      ...options\n    })).value;\n  }\n  async isChecked(selector, options = {}) {\n    return (await this._channel.isChecked({\n      selector,\n      ...options\n    })).value;\n  }\n  async isDisabled(selector, options = {}) {\n    return (await this._channel.isDisabled({\n      selector,\n      ...options\n    })).value;\n  }\n  async isEditable(selector, options = {}) {\n    return (await this._channel.isEditable({\n      selector,\n      ...options\n    })).value;\n  }\n  async isEnabled(selector, options = {}) {\n    return (await this._channel.isEnabled({\n      selector,\n      ...options\n    })).value;\n  }\n  async isHidden(selector, options = {}) {\n    return (await this._channel.isHidden({\n      selector,\n      ...options\n    })).value;\n  }\n  async isVisible(selector, options = {}) {\n    return (await this._channel.isVisible({\n      selector,\n      ...options\n    })).value;\n  }\n  async hover(selector, options = {}) {\n    await this._channel.hover({\n      selector,\n      ...options\n    });\n  }\n  async selectOption(selector, values, options = {}) {\n    return (await this._channel.selectOption({\n      selector,\n      ...(0, _elementHandle.convertSelectOptionValues)(values),\n      ...options\n    })).values;\n  }\n  async setInputFiles(selector, files, options = {}) {\n    const converted = await (0, _elementHandle.convertInputFiles)(files, this.page().context());\n    if (converted.files) {\n      await this._channel.setInputFiles({\n        selector,\n        files: converted.files,\n        ...options\n      });\n    } else {\n      _debugLogger.debugLogger.log('api', 'switching to large files mode');\n      await this._channel.setInputFilePaths({\n        selector,\n        ...converted,\n        ...options\n      });\n    }\n  }\n  async type(selector, text, options = {}) {\n    await this._channel.type({\n      selector,\n      text,\n      ...options\n    });\n  }\n  async press(selector, key, options = {}) {\n    await this._channel.press({\n      selector,\n      key,\n      ...options\n    });\n  }\n  async check(selector, options = {}) {\n    await this._channel.check({\n      selector,\n      ...options\n    });\n  }\n  async uncheck(selector, options = {}) {\n    await this._channel.uncheck({\n      selector,\n      ...options\n    });\n  }\n  async setChecked(selector, checked, options) {\n    if (checked) await this.check(selector, options);else await this.uncheck(selector, options);\n  }\n  async waitForTimeout(timeout) {\n    await this._channel.waitForTimeout({\n      timeout\n    });\n  }\n  async waitForFunction(pageFunction, arg, options = {}) {\n    if (typeof options.polling === 'string') (0, _utils.assert)(options.polling === 'raf', 'Unknown polling option: ' + options.polling);\n    const result = await this._channel.waitForFunction({\n      ...options,\n      pollingInterval: options.polling === 'raf' ? undefined : options.polling,\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return _jsHandle.JSHandle.from(result.handle);\n  }\n  async title() {\n    return (await this._channel.title()).value;\n  }\n}\nexports.Frame = Frame;\nfunction verifyLoadState(name, waitUntil) {\n  if (waitUntil === 'networkidle0') waitUntil = 'networkidle';\n  if (!_types.kLifecycleEvents.has(waitUntil)) throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);\n  return waitUntil;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HarRouter = void 0;\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _events = require(\"./events\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass HarRouter {\n  static async create(localUtils, file, notFoundAction, options) {\n    const {\n      harId,\n      error\n    } = await localUtils._channel.harOpen({\n      file\n    });\n    if (error) throw new Error(error);\n    return new HarRouter(localUtils, harId, notFoundAction, options);\n  }\n  constructor(localUtils, harId, notFoundAction, options) {\n    this._localUtils = void 0;\n    this._harId = void 0;\n    this._notFoundAction = void 0;\n    this._options = void 0;\n    this._localUtils = localUtils;\n    this._harId = harId;\n    this._options = options;\n    this._notFoundAction = notFoundAction;\n  }\n  async _handle(route) {\n    const request = route.request();\n    const response = await this._localUtils._channel.harLookup({\n      harId: this._harId,\n      url: request.url(),\n      method: request.method(),\n      headers: await request.headersArray(),\n      postData: request.postDataBuffer() || undefined,\n      isNavigationRequest: request.isNavigationRequest()\n    });\n    if (response.action === 'redirect') {\n      _debugLogger.debugLogger.log('api', `HAR: ${route.request().url()} redirected to ${response.redirectURL}`);\n      await route._redirectNavigationRequest(response.redirectURL);\n      return;\n    }\n    if (response.action === 'fulfill') {\n      await route.fulfill({\n        status: response.status,\n        headers: Object.fromEntries(response.headers.map(h => [h.name, h.value])),\n        body: response.body\n      });\n      return;\n    }\n    if (response.action === 'error') _debugLogger.debugLogger.log('api', 'HAR: ' + response.message);\n    // Report the error, but fall through to the default handler.\n\n    if (this._notFoundAction === 'abort') {\n      await route.abort();\n      return;\n    }\n    await route.fallback();\n  }\n  async addContextRoute(context) {\n    await context.route(this._options.urlMatch || '**/*', route => this._handle(route));\n    context.once(_events.Events.BrowserContext.Close, () => this.dispose());\n  }\n  async addPageRoute(page) {\n    await page.route(this._options.urlMatch || '**/*', route => this._handle(route));\n    page.once(_events.Events.Page.Close, () => this.dispose());\n  }\n  dispose() {\n    this._localUtils._channel.harClose({\n      harId: this._harId\n    }).catch(() => {});\n  }\n}\nexports.HarRouter = HarRouter;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Keyboard {\n  constructor(page) {\n    this._page = void 0;\n    this._page = page;\n  }\n  async down(key) {\n    await this._page._channel.keyboardDown({\n      key\n    });\n  }\n  async up(key) {\n    await this._page._channel.keyboardUp({\n      key\n    });\n  }\n  async insertText(text) {\n    await this._page._channel.keyboardInsertText({\n      text\n    });\n  }\n  async type(text, options = {}) {\n    await this._page._channel.keyboardType({\n      text,\n      ...options\n    });\n  }\n  async press(key, options = {}) {\n    await this._page._channel.keyboardPress({\n      key,\n      ...options\n    });\n  }\n}\nexports.Keyboard = Keyboard;\nclass Mouse {\n  constructor(page) {\n    this._page = void 0;\n    this._page = page;\n  }\n  async move(x, y, options = {}) {\n    await this._page._channel.mouseMove({\n      x,\n      y,\n      ...options\n    });\n  }\n  async down(options = {}) {\n    await this._page._channel.mouseDown({\n      ...options\n    });\n  }\n  async up(options = {}) {\n    await this._page._channel.mouseUp(options);\n  }\n  async click(x, y, options = {}) {\n    await this._page._channel.mouseClick({\n      x,\n      y,\n      ...options\n    });\n  }\n  async dblclick(x, y, options = {}) {\n    await this.click(x, y, {\n      ...options,\n      clickCount: 2\n    });\n  }\n  async wheel(deltaX, deltaY) {\n    await this._page._channel.mouseWheel({\n      deltaX,\n      deltaY\n    });\n  }\n}\nexports.Mouse = Mouse;\nclass Touchscreen {\n  constructor(page) {\n    this._page = void 0;\n    this._page = page;\n  }\n  async tap(x, y) {\n    await this._page._channel.touchscreenTap({\n      x,\n      y\n    });\n  }\n}\nexports.Touchscreen = Touchscreen;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSHandle = void 0;\nexports.assertMaxArguments = assertMaxArguments;\nexports.parseResult = parseResult;\nexports.serializeArgument = serializeArgument;\nvar _channelOwner = require(\"./channelOwner\");\nvar _serializers = require(\"../protocol/serializers\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass JSHandle extends _channelOwner.ChannelOwner {\n  static from(handle) {\n    return handle._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._preview = void 0;\n    this._preview = this._initializer.preview;\n    this._channel.on('previewUpdated', ({\n      preview\n    }) => this._preview = preview);\n  }\n  async evaluate(pageFunction, arg) {\n    const result = await this._channel.evaluateExpression({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: serializeArgument(arg)\n    });\n    return parseResult(result.value);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    const result = await this._channel.evaluateExpressionHandle({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: serializeArgument(arg)\n    });\n    return JSHandle.from(result.handle);\n  }\n  async getProperty(propertyName) {\n    const result = await this._channel.getProperty({\n      name: propertyName\n    });\n    return JSHandle.from(result.handle);\n  }\n  async getProperties() {\n    const map = new Map();\n    for (const {\n      name,\n      value\n    } of (await this._channel.getPropertyList()).properties) map.set(name, JSHandle.from(value));\n    return map;\n  }\n  async jsonValue() {\n    return parseResult((await this._channel.jsonValue()).value);\n  }\n  asElement() {\n    return null;\n  }\n  async dispose() {\n    return await this._channel.dispose();\n  }\n  toString() {\n    return this._preview;\n  }\n}\n\n// This function takes care of converting all JSHandles to their channels,\n// so that generic channel serializer converts them to guids.\nexports.JSHandle = JSHandle;\nfunction serializeArgument(arg) {\n  const handles = [];\n  const pushHandle = channel => {\n    handles.push(channel);\n    return handles.length - 1;\n  };\n  const value = (0, _serializers.serializeValue)(arg, value => {\n    if (value instanceof JSHandle) return {\n      h: pushHandle(value._channel)\n    };\n    return {\n      fallThrough: value\n    };\n  });\n  return {\n    value,\n    handles\n  };\n}\nfunction parseResult(value) {\n  return (0, _serializers.parseSerializedValue)(value, undefined);\n}\nfunction assertMaxArguments(count, max) {\n  if (count > max) throw new Error('Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonPipe = void 0;\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass JsonPipe extends _channelOwner.ChannelOwner {\n  static from(jsonPipe) {\n    return jsonPipe._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  channel() {\n    return this._channel;\n  }\n}\nexports.JsonPipe = JsonPipe;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalUtils = void 0;\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass LocalUtils extends _channelOwner.ChannelOwner {\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n}\nexports.LocalUtils = LocalUtils;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Locator = exports.FrameLocator = void 0;\nexports.setTestIdAttribute = setTestIdAttribute;\nexports.testIdAttributeName = testIdAttributeName;\nvar util = _interopRequireWildcard(require(\"util\"));\nvar _utils = require(\"../utils\");\nvar _elementHandle = require(\"./elementHandle\");\nvar _jsHandle = require(\"./jsHandle\");\nvar _stringUtils = require(\"../utils/isomorphic/stringUtils\");\nvar _locatorUtils = require(\"../utils/isomorphic/locatorUtils\");\nlet _util$inspect$custom;\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n_util$inspect$custom = util.inspect.custom;\nclass Locator {\n  constructor(frame, selector, options) {\n    this._frame = void 0;\n    this._selector = void 0;\n    this._frame = frame;\n    this._selector = selector;\n    if (options !== null && options !== void 0 && options.hasText) this._selector += ` >> internal:has-text=${(0, _stringUtils.escapeForTextSelector)(options.hasText, false)}`;\n    if (options !== null && options !== void 0 && options.has) {\n      const locator = options.has;\n      if (locator._frame !== frame) throw new Error(`Inner \"has\" locator must belong to the same frame.`);\n      this._selector += ` >> internal:has=` + JSON.stringify(locator._selector);\n    }\n  }\n  async _withElement(task, timeout) {\n    timeout = this._frame.page()._timeoutSettings.timeout({\n      timeout\n    });\n    const deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;\n    return this._frame._wrapApiCall(async () => {\n      const result = await this._frame._channel.waitForSelector({\n        selector: this._selector,\n        strict: true,\n        state: 'attached',\n        timeout\n      });\n      const handle = _elementHandle.ElementHandle.fromNullable(result.element);\n      if (!handle) throw new Error(`Could not resolve ${this._selector} to DOM Element`);\n      try {\n        return await task(handle, deadline ? deadline - (0, _utils.monotonicTime)() : 0);\n      } finally {\n        await handle.dispose();\n      }\n    });\n  }\n  page() {\n    return this._frame.page();\n  }\n  async boundingBox(options) {\n    return this._withElement(h => h.boundingBox(), options === null || options === void 0 ? void 0 : options.timeout);\n  }\n  async check(options = {}) {\n    return this._frame.check(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async click(options = {}) {\n    return this._frame.click(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async dblclick(options = {}) {\n    return this._frame.dblclick(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async dispatchEvent(type, eventInit = {}, options) {\n    return this._frame.dispatchEvent(this._selector, type, eventInit, {\n      strict: true,\n      ...options\n    });\n  }\n  async dragTo(target, options = {}) {\n    return this._frame.dragAndDrop(this._selector, target._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async evaluate(pageFunction, arg, options) {\n    return this._withElement(h => h.evaluate(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);\n  }\n  async evaluateAll(pageFunction, arg) {\n    return this._frame.$$eval(this._selector, pageFunction, arg);\n  }\n  async evaluateHandle(pageFunction, arg, options) {\n    return this._withElement(h => h.evaluateHandle(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);\n  }\n  async fill(value, options = {}) {\n    return this._frame.fill(this._selector, value, {\n      strict: true,\n      ...options\n    });\n  }\n  async clear(options = {}) {\n    return this.fill('', options);\n  }\n  async _highlight() {\n    // VS Code extension uses this one, keep it for now.\n    return this._frame._highlight(this._selector);\n  }\n  async highlight() {\n    return this._frame._highlight(this._selector);\n  }\n  locator(selector, options) {\n    return new Locator(this._frame, this._selector + ' >> ' + selector, options);\n  }\n  getByTestId(testId) {\n    return this.locator((0, _locatorUtils.getByTestIdSelector)(testIdAttributeName(), testId));\n  }\n  getByAltText(text, options) {\n    return this.locator((0, _locatorUtils.getByAltTextSelector)(text, options));\n  }\n  getByLabel(text, options) {\n    return this.locator((0, _locatorUtils.getByLabelSelector)(text, options));\n  }\n  getByPlaceholder(text, options) {\n    return this.locator((0, _locatorUtils.getByPlaceholderSelector)(text, options));\n  }\n  getByText(text, options) {\n    return this.locator((0, _locatorUtils.getByTextSelector)(text, options));\n  }\n  getByTitle(text, options) {\n    return this.locator((0, _locatorUtils.getByTitleSelector)(text, options));\n  }\n  getByRole(role, options = {}) {\n    return this.locator((0, _locatorUtils.getByRoleSelector)(role, options));\n  }\n  frameLocator(selector) {\n    return new FrameLocator(this._frame, this._selector + ' >> ' + selector);\n  }\n  filter(options) {\n    return new Locator(this._frame, this._selector, options);\n  }\n  async elementHandle(options) {\n    return await this._frame.waitForSelector(this._selector, {\n      strict: true,\n      state: 'attached',\n      ...options\n    });\n  }\n  async elementHandles() {\n    return this._frame.$$(this._selector);\n  }\n  first() {\n    return new Locator(this._frame, this._selector + ' >> nth=0');\n  }\n  last() {\n    return new Locator(this._frame, this._selector + ` >> nth=-1`);\n  }\n  nth(index) {\n    return new Locator(this._frame, this._selector + ` >> nth=${index}`);\n  }\n  async focus(options) {\n    return this._frame.focus(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async blur(options) {\n    await this._frame._channel.blur({\n      selector: this._selector,\n      strict: true,\n      ...options\n    });\n  }\n  async count() {\n    return this._frame._queryCount(this._selector);\n  }\n  async getAttribute(name, options) {\n    return this._frame.getAttribute(this._selector, name, {\n      strict: true,\n      ...options\n    });\n  }\n  async hover(options = {}) {\n    return this._frame.hover(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async innerHTML(options) {\n    return this._frame.innerHTML(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async innerText(options) {\n    return this._frame.innerText(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async inputValue(options) {\n    return this._frame.inputValue(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async isChecked(options) {\n    return this._frame.isChecked(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async isDisabled(options) {\n    return this._frame.isDisabled(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async isEditable(options) {\n    return this._frame.isEditable(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async isEnabled(options) {\n    return this._frame.isEnabled(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async isHidden(options) {\n    return this._frame.isHidden(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async isVisible(options) {\n    return this._frame.isVisible(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async press(key, options = {}) {\n    return this._frame.press(this._selector, key, {\n      strict: true,\n      ...options\n    });\n  }\n  async screenshot(options = {}) {\n    return this._withElement((h, timeout) => h.screenshot({\n      ...options,\n      timeout\n    }), options.timeout);\n  }\n  async scrollIntoViewIfNeeded(options = {}) {\n    return this._withElement((h, timeout) => h.scrollIntoViewIfNeeded({\n      ...options,\n      timeout\n    }), options.timeout);\n  }\n  async selectOption(values, options = {}) {\n    return this._frame.selectOption(this._selector, values, {\n      strict: true,\n      ...options\n    });\n  }\n  async selectText(options = {}) {\n    return this._withElement((h, timeout) => h.selectText({\n      ...options,\n      timeout\n    }), options.timeout);\n  }\n  async setChecked(checked, options) {\n    if (checked) await this.check(options);else await this.uncheck(options);\n  }\n  async setInputFiles(files, options = {}) {\n    return this._frame.setInputFiles(this._selector, files, {\n      strict: true,\n      ...options\n    });\n  }\n  async tap(options = {}) {\n    return this._frame.tap(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async textContent(options) {\n    return this._frame.textContent(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async type(text, options = {}) {\n    return this._frame.type(this._selector, text, {\n      strict: true,\n      ...options\n    });\n  }\n  async uncheck(options = {}) {\n    return this._frame.uncheck(this._selector, {\n      strict: true,\n      ...options\n    });\n  }\n  async all() {\n    return new Array(await this.count()).fill(0).map((e, i) => this.nth(i));\n  }\n  async allInnerTexts() {\n    return this._frame.$$eval(this._selector, ee => ee.map(e => e.innerText));\n  }\n  async allTextContents() {\n    return this._frame.$$eval(this._selector, ee => ee.map(e => e.textContent || ''));\n  }\n  async waitFor(options) {\n    await this._frame._channel.waitForSelector({\n      selector: this._selector,\n      strict: true,\n      omitReturnValue: true,\n      ...options\n    });\n  }\n  async _expect(customStackTrace, expression, options) {\n    return this._frame._wrapApiCall(async () => {\n      const params = {\n        selector: this._selector,\n        expression,\n        ...options,\n        isNot: !!options.isNot\n      };\n      params.expectedValue = (0, _jsHandle.serializeArgument)(options.expectedValue);\n      const result = await this._frame._channel.expect(params);\n      if (result.received !== undefined) result.received = (0, _jsHandle.parseResult)(result.received);\n      return result;\n    }, false /* isInternal */, customStackTrace);\n  }\n  [_util$inspect$custom]() {\n    return this.toString();\n  }\n  toString() {\n    return `Locator@${this._selector}`;\n  }\n}\nexports.Locator = Locator;\nclass FrameLocator {\n  constructor(frame, selector) {\n    this._frame = void 0;\n    this._frameSelector = void 0;\n    this._frame = frame;\n    this._frameSelector = selector;\n  }\n  locator(selector, options) {\n    return new Locator(this._frame, this._frameSelector + ' >> internal:control=enter-frame >> ' + selector, options);\n  }\n  getByTestId(testId) {\n    return this.locator((0, _locatorUtils.getByTestIdSelector)(testIdAttributeName(), testId));\n  }\n  getByAltText(text, options) {\n    return this.locator((0, _locatorUtils.getByAltTextSelector)(text, options));\n  }\n  getByLabel(text, options) {\n    return this.locator((0, _locatorUtils.getByLabelSelector)(text, options));\n  }\n  getByPlaceholder(text, options) {\n    return this.locator((0, _locatorUtils.getByPlaceholderSelector)(text, options));\n  }\n  getByText(text, options) {\n    return this.locator((0, _locatorUtils.getByTextSelector)(text, options));\n  }\n  getByTitle(text, options) {\n    return this.locator((0, _locatorUtils.getByTitleSelector)(text, options));\n  }\n  getByRole(role, options = {}) {\n    return this.locator((0, _locatorUtils.getByRoleSelector)(role, options));\n  }\n  frameLocator(selector) {\n    return new FrameLocator(this._frame, this._frameSelector + ' >> internal:control=enter-frame >> ' + selector);\n  }\n  first() {\n    return new FrameLocator(this._frame, this._frameSelector + ' >> nth=0');\n  }\n  last() {\n    return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);\n  }\n  nth(index) {\n    return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);\n  }\n}\nexports.FrameLocator = FrameLocator;\nlet _testIdAttributeName = 'data-testid';\nfunction testIdAttributeName() {\n  return _testIdAttributeName;\n}\nfunction setTestIdAttribute(attributeName) {\n  _testIdAttributeName = attributeName;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocket = exports.RouteHandler = exports.Route = exports.Response = exports.Request = exports.RawHeaders = void 0;\nexports.validateHeaders = validateHeaders;\nvar _url = require(\"url\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _frame = require(\"./frame\");\nvar _worker = require(\"./worker\");\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _utils = require(\"../utils\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nvar _events = require(\"./events\");\nvar _waiter = require(\"./waiter\");\nvar _network = require(\"../utils/network\");\nvar _multimap = require(\"../utils/multimap\");\nvar _fetch = require(\"./fetch\");\nvar _errors = require(\"../common/errors\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Request extends _channelOwner.ChannelOwner {\n  static from(request) {\n    return request._object;\n  }\n  static fromNullable(request) {\n    return request ? Request.from(request) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._redirectedFrom = null;\n    this._redirectedTo = null;\n    this._failureText = null;\n    this._provisionalHeaders = void 0;\n    this._actualHeadersPromise = void 0;\n    this._timing = void 0;\n    this._fallbackOverrides = {};\n    this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);\n    if (this._redirectedFrom) this._redirectedFrom._redirectedTo = this;\n    this._provisionalHeaders = new RawHeaders(initializer.headers);\n    this._fallbackOverrides.postDataBuffer = initializer.postData;\n    this._timing = {\n      startTime: 0,\n      domainLookupStart: -1,\n      domainLookupEnd: -1,\n      connectStart: -1,\n      secureConnectionStart: -1,\n      connectEnd: -1,\n      requestStart: -1,\n      responseStart: -1,\n      responseEnd: -1\n    };\n  }\n  url() {\n    return this._fallbackOverrides.url || this._initializer.url;\n  }\n  resourceType() {\n    return this._initializer.resourceType;\n  }\n  method() {\n    return this._fallbackOverrides.method || this._initializer.method;\n  }\n  postData() {\n    var _this$_fallbackOverri;\n    return ((_this$_fallbackOverri = this._fallbackOverrides.postDataBuffer) === null || _this$_fallbackOverri === void 0 ? void 0 : _this$_fallbackOverri.toString('utf-8')) || null;\n  }\n  postDataBuffer() {\n    return this._fallbackOverrides.postDataBuffer || null;\n  }\n  postDataJSON() {\n    const postData = this.postData();\n    if (!postData) return null;\n    const contentType = this.headers()['content-type'];\n    if (contentType === 'application/x-www-form-urlencoded') {\n      const entries = {};\n      const parsed = new _url.URLSearchParams(postData);\n      for (const [k, v] of parsed.entries()) entries[k] = v;\n      return entries;\n    }\n    try {\n      return JSON.parse(postData);\n    } catch (e) {\n      throw new Error('POST data is not a valid JSON object: ' + postData);\n    }\n  }\n\n  /**\n   * @deprecated\n   */\n  headers() {\n    if (this._fallbackOverrides.headers) return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers).headers();\n    return this._provisionalHeaders.headers();\n  }\n  _context() {\n    // TODO: make sure this works for service worker requests.\n    return this.frame().page().context();\n  }\n  _actualHeaders() {\n    if (this._fallbackOverrides.headers) return Promise.resolve(RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers));\n    if (!this._actualHeadersPromise) {\n      this._actualHeadersPromise = this._wrapApiCall(async () => {\n        return new RawHeaders((await this._channel.rawRequestHeaders()).headers);\n      });\n    }\n    return this._actualHeadersPromise;\n  }\n  async allHeaders() {\n    return (await this._actualHeaders()).headers();\n  }\n  async headersArray() {\n    return (await this._actualHeaders()).headersArray();\n  }\n  async headerValue(name) {\n    return (await this._actualHeaders()).get(name);\n  }\n  async response() {\n    return Response.fromNullable((await this._channel.response()).response);\n  }\n  async _internalResponse() {\n    return this._wrapApiCall(async () => {\n      return Response.fromNullable((await this._channel.response()).response);\n    }, true);\n  }\n  frame() {\n    if (!this._initializer.frame) {\n      (0, _utils.assert)(this.serviceWorker());\n      throw new Error('Service Worker requests do not have an associated frame.');\n    }\n    return _frame.Frame.from(this._initializer.frame);\n  }\n  serviceWorker() {\n    return this._initializer.serviceWorker ? _worker.Worker.from(this._initializer.serviceWorker) : null;\n  }\n  isNavigationRequest() {\n    return this._initializer.isNavigationRequest;\n  }\n  redirectedFrom() {\n    return this._redirectedFrom;\n  }\n  redirectedTo() {\n    return this._redirectedTo;\n  }\n  failure() {\n    if (this._failureText === null) return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n  timing() {\n    return this._timing;\n  }\n  async sizes() {\n    const response = await this.response();\n    if (!response) throw new Error('Unable to fetch sizes for failed request');\n    return (await response._channel.sizes()).sizes;\n  }\n  _setResponseEndTiming(responseEndTiming) {\n    this._timing.responseEnd = responseEndTiming;\n    if (this._timing.responseStart === -1) this._timing.responseStart = responseEndTiming;\n  }\n  _finalRequest() {\n    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;\n  }\n  _applyFallbackOverrides(overrides) {\n    if (overrides.url) this._fallbackOverrides.url = overrides.url;\n    if (overrides.method) this._fallbackOverrides.method = overrides.method;\n    if (overrides.headers) this._fallbackOverrides.headers = overrides.headers;\n    if ((0, _utils.isString)(overrides.postData)) this._fallbackOverrides.postDataBuffer = Buffer.from(overrides.postData, 'utf-8');else if (overrides.postData instanceof Buffer) this._fallbackOverrides.postDataBuffer = overrides.postData;else if (overrides.postData) this._fallbackOverrides.postDataBuffer = Buffer.from(JSON.stringify(overrides.postData), 'utf-8');\n  }\n  _fallbackOverridesForContinue() {\n    return this._fallbackOverrides;\n  }\n  _targetClosedPromise() {\n    var _this$serviceWorker, _this$frame$_page;\n    return ((_this$serviceWorker = this.serviceWorker()) === null || _this$serviceWorker === void 0 ? void 0 : _this$serviceWorker._closedPromise) || ((_this$frame$_page = this.frame()._page) === null || _this$frame$_page === void 0 ? void 0 : _this$frame$_page._closedOrCrashedPromise) || new Promise(() => {});\n  }\n}\nexports.Request = Request;\nclass Route extends _channelOwner.ChannelOwner {\n  static from(route) {\n    return route._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._handlingPromise = null;\n  }\n  request() {\n    return Request.from(this._initializer.request);\n  }\n  _raceWithTargetClose(promise) {\n    // When page closes or crashes, we catch any potential rejects from this Route.\n    // Note that page could be missing when routing popup's initial request that\n    // does not have a Page initialized just yet.\n    return Promise.race([promise, this.request()._targetClosedPromise()]);\n  }\n  _startHandling() {\n    this._handlingPromise = new _manualPromise.ManualPromise();\n    return this._handlingPromise;\n  }\n  async fallback(options = {}) {\n    this._checkNotHandled();\n    this.request()._applyFallbackOverrides(options);\n    this._reportHandled(false);\n  }\n  async abort(errorCode) {\n    this._checkNotHandled();\n    await this._raceWithTargetClose(this._channel.abort({\n      errorCode\n    }));\n    this._reportHandled(true);\n  }\n  async _redirectNavigationRequest(url) {\n    this._checkNotHandled();\n    await this._raceWithTargetClose(this._channel.redirectNavigationRequest({\n      url\n    }));\n    this._reportHandled(true);\n  }\n  async fetch(options = {}) {\n    return await this._wrapApiCall(async () => {\n      const context = this.request()._context();\n      return context.request._innerFetch({\n        request: this.request(),\n        data: options.postData,\n        ...options\n      });\n    });\n  }\n  async fulfill(options = {}) {\n    this._checkNotHandled();\n    await this._wrapApiCall(async () => {\n      await this._innerFulfill(options);\n      this._reportHandled(true);\n    });\n  }\n  async _innerFulfill(options = {}) {\n    let fetchResponseUid;\n    let {\n      status: statusOption,\n      headers: headersOption,\n      body\n    } = options;\n    if (options.json !== undefined) {\n      (0, _utils.assert)(options.body === undefined, 'Can specify either body or json parameters');\n      body = JSON.stringify(options.json);\n    }\n    if (options.response instanceof _fetch.APIResponse) {\n      var _statusOption, _headersOption;\n      (_statusOption = statusOption) !== null && _statusOption !== void 0 ? _statusOption : statusOption = options.response.status();\n      (_headersOption = headersOption) !== null && _headersOption !== void 0 ? _headersOption : headersOption = options.response.headers();\n      if (body === undefined && options.path === undefined) {\n        if (options.response._request._connection === this._connection) fetchResponseUid = options.response._fetchUid();else body = await options.response.body();\n      }\n    }\n    let isBase64 = false;\n    let length = 0;\n    if (options.path) {\n      const buffer = await _fs.default.promises.readFile(options.path);\n      body = buffer.toString('base64');\n      isBase64 = true;\n      length = buffer.length;\n    } else if ((0, _utils.isString)(body)) {\n      isBase64 = false;\n      length = Buffer.byteLength(body);\n    } else if (body) {\n      length = body.length;\n      body = body.toString('base64');\n      isBase64 = true;\n    }\n    const headers = {};\n    for (const header of Object.keys(headersOption || {})) headers[header.toLowerCase()] = String(headersOption[header]);\n    if (options.contentType) headers['content-type'] = String(options.contentType);else if (options.json) headers['content-type'] = 'application/json';else if (options.path) headers['content-type'] = _utilsBundle.mime.getType(options.path) || 'application/octet-stream';\n    if (length && !('content-length' in headers)) headers['content-length'] = String(length);\n    await this._raceWithTargetClose(this._channel.fulfill({\n      status: statusOption || 200,\n      headers: (0, _utils.headersObjectToArray)(headers),\n      body,\n      isBase64,\n      fetchResponseUid\n    }));\n  }\n  async continue(options = {}) {\n    this._checkNotHandled();\n    this.request()._applyFallbackOverrides(options);\n    await this._innerContinue();\n    this._reportHandled(true);\n  }\n  _checkNotHandled() {\n    if (!this._handlingPromise) throw new Error('Route is already handled!');\n  }\n  _reportHandled(done) {\n    const chain = this._handlingPromise;\n    this._handlingPromise = null;\n    chain.resolve(done);\n  }\n  async _innerContinue(internal = false) {\n    const options = this.request()._fallbackOverridesForContinue();\n    return await this._wrapApiCall(async () => {\n      await this._raceWithTargetClose(this._channel.continue({\n        url: options.url,\n        method: options.method,\n        headers: options.headers ? (0, _utils.headersObjectToArray)(options.headers) : undefined,\n        postData: options.postDataBuffer\n      }));\n    }, !!internal);\n  }\n}\nexports.Route = Route;\nclass Response extends _channelOwner.ChannelOwner {\n  static from(response) {\n    return response._object;\n  }\n  static fromNullable(response) {\n    return response ? Response.from(response) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._provisionalHeaders = void 0;\n    this._actualHeadersPromise = void 0;\n    this._request = void 0;\n    this._finishedPromise = new _manualPromise.ManualPromise();\n    this._provisionalHeaders = new RawHeaders(initializer.headers);\n    this._request = Request.from(this._initializer.request);\n    Object.assign(this._request._timing, this._initializer.timing);\n  }\n  url() {\n    return this._initializer.url;\n  }\n  ok() {\n    // Status 0 is for file:// URLs\n    return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;\n  }\n  status() {\n    return this._initializer.status;\n  }\n  statusText() {\n    return this._initializer.statusText;\n  }\n  fromServiceWorker() {\n    return this._initializer.fromServiceWorker;\n  }\n\n  /**\n   * @deprecated\n   */\n  headers() {\n    return this._provisionalHeaders.headers();\n  }\n  async _actualHeaders() {\n    if (!this._actualHeadersPromise) {\n      this._actualHeadersPromise = (async () => {\n        return new RawHeaders((await this._channel.rawResponseHeaders()).headers);\n      })();\n    }\n    return this._actualHeadersPromise;\n  }\n  async allHeaders() {\n    return (await this._actualHeaders()).headers();\n  }\n  async headersArray() {\n    return (await this._actualHeaders()).headersArray().slice();\n  }\n  async headerValue(name) {\n    return (await this._actualHeaders()).get(name);\n  }\n  async headerValues(name) {\n    return (await this._actualHeaders()).getAll(name);\n  }\n  async finished() {\n    return Promise.race([this._finishedPromise.then(() => null), this.request()._targetClosedPromise().then(() => {\n      throw new Error(_errors.kBrowserOrContextClosedError);\n    })]);\n  }\n  async body() {\n    return (await this._channel.body()).binary;\n  }\n  async text() {\n    const content = await this.body();\n    return content.toString('utf8');\n  }\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  request() {\n    return this._request;\n  }\n  frame() {\n    return this._request.frame();\n  }\n  async serverAddr() {\n    return (await this._channel.serverAddr()).value || null;\n  }\n  async securityDetails() {\n    return (await this._channel.securityDetails()).value || null;\n  }\n}\nexports.Response = Response;\nclass WebSocket extends _channelOwner.ChannelOwner {\n  static from(webSocket) {\n    return webSocket._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._page = void 0;\n    this._isClosed = void 0;\n    this._isClosed = false;\n    this._page = parent;\n    this._channel.on('frameSent', event => {\n      if (event.opcode === 1) this.emit(_events.Events.WebSocket.FrameSent, {\n        payload: event.data\n      });else if (event.opcode === 2) this.emit(_events.Events.WebSocket.FrameSent, {\n        payload: Buffer.from(event.data, 'base64')\n      });\n    });\n    this._channel.on('frameReceived', event => {\n      if (event.opcode === 1) this.emit(_events.Events.WebSocket.FrameReceived, {\n        payload: event.data\n      });else if (event.opcode === 2) this.emit(_events.Events.WebSocket.FrameReceived, {\n        payload: Buffer.from(event.data, 'base64')\n      });\n    });\n    this._channel.on('socketError', ({\n      error\n    }) => this.emit(_events.Events.WebSocket.Error, error));\n    this._channel.on('close', () => {\n      this._isClosed = true;\n      this.emit(_events.Events.WebSocket.Close, this);\n    });\n  }\n  url() {\n    return this._initializer.url;\n  }\n  isClosed() {\n    return this._isClosed;\n  }\n  async waitForEvent(event, optionsOrPredicate = {}) {\n    return this._wrapApiCall(async () => {\n      const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = _waiter.Waiter.createForEvent(this, event);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== _events.Events.WebSocket.Error) waiter.rejectOnEvent(this, _events.Events.WebSocket.Error, new Error('Socket error'));\n      if (event !== _events.Events.WebSocket.Close) waiter.rejectOnEvent(this, _events.Events.WebSocket.Close, new Error('Socket closed'));\n      waiter.rejectOnEvent(this._page, _events.Events.Page.Close, new Error('Page closed'));\n      const result = await waiter.waitForEvent(this, event, predicate);\n      waiter.dispose();\n      return result;\n    });\n  }\n}\nexports.WebSocket = WebSocket;\nfunction validateHeaders(headers) {\n  for (const key of Object.keys(headers)) {\n    const value = headers[key];\n    if (!Object.is(value, undefined) && !(0, _utils.isString)(value)) throw new Error(`Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n  }\n}\nclass RouteHandler {\n  constructor(baseURL, url, handler, times = Number.MAX_SAFE_INTEGER) {\n    this.handledCount = 0;\n    this._baseURL = void 0;\n    this._times = void 0;\n    this.url = void 0;\n    this.handler = void 0;\n    this._baseURL = baseURL;\n    this._times = times;\n    this.url = url;\n    this.handler = handler;\n  }\n  static prepareInterceptionPatterns(handlers) {\n    const patterns = [];\n    let all = false;\n    for (const handler of handlers) {\n      if ((0, _utils.isString)(handler.url)) patterns.push({\n        glob: handler.url\n      });else if ((0, _utils.isRegExp)(handler.url)) patterns.push({\n        regexSource: handler.url.source,\n        regexFlags: handler.url.flags\n      });else all = true;\n    }\n    if (all) return [{\n      glob: '**/*'\n    }];\n    return patterns;\n  }\n  matches(requestURL) {\n    return (0, _network.urlMatches)(this._baseURL, requestURL, this.url);\n  }\n  async handle(route) {\n    ++this.handledCount;\n    const handledPromise = route._startHandling();\n    // Extract handler into a variable to avoid [RouteHandler.handler] in the stack.\n    const handler = this.handler;\n    const [handled] = await Promise.all([handledPromise, handler(route, route.request())]);\n    return handled;\n  }\n  willExpire() {\n    return this.handledCount + 1 >= this._times;\n  }\n}\nexports.RouteHandler = RouteHandler;\nclass RawHeaders {\n  static _fromHeadersObjectLossy(headers) {\n    const headersArray = Object.entries(headers).map(([name, value]) => ({\n      name,\n      value\n    })).filter(header => header.value !== undefined);\n    return new RawHeaders(headersArray);\n  }\n  constructor(headers) {\n    this._headersArray = void 0;\n    this._headersMap = new _multimap.MultiMap();\n    this._headersArray = headers;\n    for (const header of headers) this._headersMap.set(header.name.toLowerCase(), header.value);\n  }\n  get(name) {\n    const values = this.getAll(name);\n    if (!values || !values.length) return null;\n    return values.join(name.toLowerCase() === 'set-cookie' ? '\\n' : ', ');\n  }\n  getAll(name) {\n    return [...this._headersMap.get(name.toLowerCase())];\n  }\n  headers() {\n    const result = {};\n    for (const name of this._headersMap.keys()) result[name] = this.get(name);\n    return result;\n  }\n  headersArray() {\n    return this._headersArray;\n  }\n}\nexports.RawHeaders = RawHeaders;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Page = exports.BindingCall = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _errors = require(\"../common/errors\");\nvar _network = require(\"../utils/network\");\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _serializers = require(\"../protocol/serializers\");\nvar _utils = require(\"../utils\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _accessibility = require(\"./accessibility\");\nvar _artifact = require(\"./artifact\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _clientHelper = require(\"./clientHelper\");\nvar _consoleMessage = require(\"./consoleMessage\");\nvar _coverage = require(\"./coverage\");\nvar _dialog = require(\"./dialog\");\nvar _download = require(\"./download\");\nvar _elementHandle = require(\"./elementHandle\");\nvar _events = require(\"./events\");\nvar _fileChooser = require(\"./fileChooser\");\nvar _frame = require(\"./frame\");\nvar _input = require(\"./input\");\nvar _jsHandle = require(\"./jsHandle\");\nvar _network2 = require(\"./network\");\nvar _video = require(\"./video\");\nvar _waiter = require(\"./waiter\");\nvar _worker = require(\"./worker\");\nvar _harRouter = require(\"./harRouter\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Page extends _channelOwner.ChannelOwner {\n  static from(page) {\n    return page._object;\n  }\n  static fromNullable(page) {\n    return page ? Page.from(page) : null;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._browserContext = void 0;\n    this._ownedContext = void 0;\n    this._mainFrame = void 0;\n    this._frames = new Set();\n    this._workers = new Set();\n    this._closed = false;\n    this._closedOrCrashedPromise = void 0;\n    this._viewportSize = void 0;\n    this._routes = [];\n    this.accessibility = void 0;\n    this.coverage = void 0;\n    this.keyboard = void 0;\n    this.mouse = void 0;\n    this.request = void 0;\n    this.touchscreen = void 0;\n    this._bindings = new Map();\n    this._timeoutSettings = void 0;\n    this._video = null;\n    this._opener = void 0;\n    this._browserContext = parent;\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(this._browserContext._timeoutSettings);\n    this.accessibility = new _accessibility.Accessibility(this._channel);\n    this.keyboard = new _input.Keyboard(this);\n    this.mouse = new _input.Mouse(this);\n    this.request = this._browserContext.request;\n    this.touchscreen = new _input.Touchscreen(this);\n    this._mainFrame = _frame.Frame.from(initializer.mainFrame);\n    this._mainFrame._page = this;\n    this._frames.add(this._mainFrame);\n    this._viewportSize = initializer.viewportSize || null;\n    this._closed = initializer.isClosed;\n    this._opener = Page.fromNullable(initializer.opener);\n    this._channel.on('bindingCall', ({\n      binding\n    }) => this._onBinding(BindingCall.from(binding)));\n    this._channel.on('close', () => this._onClose());\n    this._channel.on('console', ({\n      message\n    }) => this.emit(_events.Events.Page.Console, _consoleMessage.ConsoleMessage.from(message)));\n    this._channel.on('crash', () => this._onCrash());\n    this._channel.on('dialog', ({\n      dialog\n    }) => {\n      const dialogObj = _dialog.Dialog.from(dialog);\n      if (!this.emit(_events.Events.Page.Dialog, dialogObj)) {\n        if (dialogObj.type() === 'beforeunload') dialog.accept({}).catch(() => {});else dialog.dismiss().catch(() => {});\n      }\n    });\n    this._channel.on('download', ({\n      url,\n      suggestedFilename,\n      artifact\n    }) => {\n      const artifactObject = _artifact.Artifact.from(artifact);\n      this.emit(_events.Events.Page.Download, new _download.Download(this, url, suggestedFilename, artifactObject));\n    });\n    this._channel.on('fileChooser', ({\n      element,\n      isMultiple\n    }) => this.emit(_events.Events.Page.FileChooser, new _fileChooser.FileChooser(this, _elementHandle.ElementHandle.from(element), isMultiple)));\n    this._channel.on('frameAttached', ({\n      frame\n    }) => this._onFrameAttached(_frame.Frame.from(frame)));\n    this._channel.on('frameDetached', ({\n      frame\n    }) => this._onFrameDetached(_frame.Frame.from(frame)));\n    this._channel.on('pageError', ({\n      error\n    }) => this.emit(_events.Events.Page.PageError, (0, _serializers.parseError)(error)));\n    this._channel.on('route', ({\n      route\n    }) => this._onRoute(_network2.Route.from(route)));\n    this._channel.on('video', ({\n      artifact\n    }) => {\n      const artifactObject = _artifact.Artifact.from(artifact);\n      this._forceVideo()._artifactReady(artifactObject);\n    });\n    this._channel.on('webSocket', ({\n      webSocket\n    }) => this.emit(_events.Events.Page.WebSocket, _network2.WebSocket.from(webSocket)));\n    this._channel.on('worker', ({\n      worker\n    }) => this._onWorker(_worker.Worker.from(worker)));\n    this.coverage = new _coverage.Coverage(this._channel);\n    this._closedOrCrashedPromise = Promise.race([new Promise(f => this.once(_events.Events.Page.Close, f)), new Promise(f => this.once(_events.Events.Page.Crash, f))]);\n    this._setEventToSubscriptionMapping(new Map([[_events.Events.Page.Request, 'request'], [_events.Events.Page.Response, 'response'], [_events.Events.Page.RequestFinished, 'requestFinished'], [_events.Events.Page.RequestFailed, 'requestFailed'], [_events.Events.Page.FileChooser, 'fileChooser']]));\n  }\n  _onFrameAttached(frame) {\n    frame._page = this;\n    this._frames.add(frame);\n    if (frame._parentFrame) frame._parentFrame._childFrames.add(frame);\n    this.emit(_events.Events.Page.FrameAttached, frame);\n  }\n  _onFrameDetached(frame) {\n    this._frames.delete(frame);\n    frame._detached = true;\n    if (frame._parentFrame) frame._parentFrame._childFrames.delete(frame);\n    this.emit(_events.Events.Page.FrameDetached, frame);\n  }\n  async _onRoute(route) {\n    const routeHandlers = this._routes.slice();\n    for (const routeHandler of routeHandlers) {\n      if (!routeHandler.matches(route.request().url())) continue;\n      if (routeHandler.willExpire()) this._routes.splice(this._routes.indexOf(routeHandler), 1);\n      const handled = await routeHandler.handle(route);\n      if (!this._routes.length) this._wrapApiCall(() => this._updateInterceptionPatterns(), true).catch(() => {});\n      if (handled) return;\n    }\n    await this._browserContext._onRoute(route);\n  }\n  async _onBinding(bindingCall) {\n    const func = this._bindings.get(bindingCall._initializer.name);\n    if (func) {\n      await bindingCall.call(func);\n      return;\n    }\n    await this._browserContext._onBinding(bindingCall);\n  }\n  _onWorker(worker) {\n    this._workers.add(worker);\n    worker._page = this;\n    this.emit(_events.Events.Page.Worker, worker);\n  }\n  _onClose() {\n    this._closed = true;\n    this._browserContext._pages.delete(this);\n    this._browserContext._backgroundPages.delete(this);\n    this.emit(_events.Events.Page.Close, this);\n  }\n  _onCrash() {\n    this.emit(_events.Events.Page.Crash, this);\n  }\n  context() {\n    return this._browserContext;\n  }\n  async opener() {\n    if (!this._opener || this._opener.isClosed()) return null;\n    return this._opener;\n  }\n  mainFrame() {\n    return this._mainFrame;\n  }\n  frame(frameSelector) {\n    const name = (0, _utils.isString)(frameSelector) ? frameSelector : frameSelector.name;\n    const url = (0, _utils.isObject)(frameSelector) ? frameSelector.url : undefined;\n    (0, _utils.assert)(name || url, 'Either name or url matcher should be specified');\n    return this.frames().find(f => {\n      if (name) return f.name() === name;\n      return (0, _network.urlMatches)(this._browserContext._options.baseURL, f.url(), url);\n    }) || null;\n  }\n  frames() {\n    return [...this._frames];\n  }\n  setDefaultNavigationTimeout(timeout) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n    this._wrapApiCall(async () => {\n      this._channel.setDefaultNavigationTimeoutNoReply({\n        timeout\n      }).catch(() => {});\n    }, true);\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n    this._wrapApiCall(async () => {\n      this._channel.setDefaultTimeoutNoReply({\n        timeout\n      }).catch(() => {});\n    }, true);\n  }\n  _forceVideo() {\n    if (!this._video) this._video = new _video.Video(this, this._connection);\n    return this._video;\n  }\n  video() {\n    // Note: we are creating Video object lazily, because we do not know\n    // BrowserContextOptions when constructing the page - it is assigned\n    // too late during launchPersistentContext.\n    if (!this._browserContext._options.recordVideo) return null;\n    return this._forceVideo();\n  }\n  async $(selector, options) {\n    return this._mainFrame.$(selector, options);\n  }\n  async waitForSelector(selector, options) {\n    return this._mainFrame.waitForSelector(selector, options);\n  }\n  async dispatchEvent(selector, type, eventInit, options) {\n    return this._mainFrame.dispatchEvent(selector, type, eventInit, options);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    return this._mainFrame.evaluateHandle(pageFunction, arg);\n  }\n  async $eval(selector, pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);\n    return this._mainFrame.$eval(selector, pageFunction, arg);\n  }\n  async $$eval(selector, pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);\n    return this._mainFrame.$$eval(selector, pageFunction, arg);\n  }\n  async $$(selector) {\n    return this._mainFrame.$$(selector);\n  }\n  async addScriptTag(options = {}) {\n    return this._mainFrame.addScriptTag(options);\n  }\n  async addStyleTag(options = {}) {\n    return this._mainFrame.addStyleTag(options);\n  }\n  async exposeFunction(name, callback) {\n    await this._channel.exposeBinding({\n      name\n    });\n    const binding = (source, ...args) => callback(...args);\n    this._bindings.set(name, binding);\n  }\n  async exposeBinding(name, callback, options = {}) {\n    await this._channel.exposeBinding({\n      name,\n      needsHandle: options.handle\n    });\n    this._bindings.set(name, callback);\n  }\n  async setExtraHTTPHeaders(headers) {\n    (0, _network2.validateHeaders)(headers);\n    await this._channel.setExtraHTTPHeaders({\n      headers: (0, _utils.headersObjectToArray)(headers)\n    });\n  }\n  url() {\n    return this._mainFrame.url();\n  }\n  async content() {\n    return this._mainFrame.content();\n  }\n  async setContent(html, options) {\n    return this._mainFrame.setContent(html, options);\n  }\n  async goto(url, options) {\n    return this._mainFrame.goto(url, options);\n  }\n  async reload(options = {}) {\n    const waitUntil = (0, _frame.verifyLoadState)('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return _network2.Response.fromNullable((await this._channel.reload({\n      ...options,\n      waitUntil\n    })).response);\n  }\n  async waitForLoadState(state, options) {\n    return this._mainFrame.waitForLoadState(state, options);\n  }\n  async waitForNavigation(options) {\n    return this._mainFrame.waitForNavigation(options);\n  }\n  async waitForURL(url, options) {\n    return this._mainFrame.waitForURL(url, options);\n  }\n  async waitForRequest(urlOrPredicate, options = {}) {\n    const predicate = request => {\n      if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate)) return (0, _network.urlMatches)(this._browserContext._options.baseURL, request.url(), urlOrPredicate);\n      return urlOrPredicate(request);\n    };\n    const trimmedUrl = trimUrl(urlOrPredicate);\n    const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : undefined;\n    return this._waitForEvent(_events.Events.Page.Request, {\n      predicate,\n      timeout: options.timeout\n    }, logLine);\n  }\n  async waitForResponse(urlOrPredicate, options = {}) {\n    const predicate = response => {\n      if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate)) return (0, _network.urlMatches)(this._browserContext._options.baseURL, response.url(), urlOrPredicate);\n      return urlOrPredicate(response);\n    };\n    const trimmedUrl = trimUrl(urlOrPredicate);\n    const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : undefined;\n    return this._waitForEvent(_events.Events.Page.Response, {\n      predicate,\n      timeout: options.timeout\n    }, logLine);\n  }\n  async waitForEvent(event, optionsOrPredicate = {}) {\n    return this._waitForEvent(event, optionsOrPredicate, `waiting for event \"${event}\"`);\n  }\n  async _waitForEvent(event, optionsOrPredicate, logLine) {\n    return this._wrapApiCall(async () => {\n      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = _waiter.Waiter.createForEvent(this, event);\n      if (logLine) waiter.log(logLine);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== _events.Events.Page.Crash) waiter.rejectOnEvent(this, _events.Events.Page.Crash, new Error('Page crashed'));\n      if (event !== _events.Events.Page.Close) waiter.rejectOnEvent(this, _events.Events.Page.Close, new Error('Page closed'));\n      const result = await waiter.waitForEvent(this, event, predicate);\n      waiter.dispose();\n      return result;\n    });\n  }\n  async goBack(options = {}) {\n    const waitUntil = (0, _frame.verifyLoadState)('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return _network2.Response.fromNullable((await this._channel.goBack({\n      ...options,\n      waitUntil\n    })).response);\n  }\n  async goForward(options = {}) {\n    const waitUntil = (0, _frame.verifyLoadState)('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return _network2.Response.fromNullable((await this._channel.goForward({\n      ...options,\n      waitUntil\n    })).response);\n  }\n  async emulateMedia(options = {}) {\n    await this._channel.emulateMedia({\n      media: options.media === null ? 'no-override' : options.media,\n      colorScheme: options.colorScheme === null ? 'no-override' : options.colorScheme,\n      reducedMotion: options.reducedMotion === null ? 'no-override' : options.reducedMotion,\n      forcedColors: options.forcedColors === null ? 'no-override' : options.forcedColors\n    });\n  }\n  async setViewportSize(viewportSize) {\n    this._viewportSize = viewportSize;\n    await this._channel.setViewportSize({\n      viewportSize\n    });\n  }\n  viewportSize() {\n    return this._viewportSize;\n  }\n  async evaluate(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    return this._mainFrame.evaluate(pageFunction, arg);\n  }\n  async addInitScript(script, arg) {\n    const source = await (0, _clientHelper.evaluationScript)(script, arg);\n    await this._channel.addInitScript({\n      source\n    });\n  }\n  async route(url, handler, options = {}) {\n    this._routes.unshift(new _network2.RouteHandler(this._browserContext._options.baseURL, url, handler, options.times));\n    await this._updateInterceptionPatterns();\n  }\n  async routeFromHAR(har, options = {}) {\n    if (options.update) {\n      await this._browserContext._recordIntoHAR(har, this, options);\n      return;\n    }\n    const harRouter = await _harRouter.HarRouter.create(this._connection.localUtils(), har, options.notFound || 'abort', {\n      urlMatch: options.url\n    });\n    harRouter.addPageRoute(this);\n  }\n  async unroute(url, handler) {\n    this._routes = this._routes.filter(route => route.url !== url || handler && route.handler !== handler);\n    await this._updateInterceptionPatterns();\n  }\n  async _updateInterceptionPatterns() {\n    const patterns = _network2.RouteHandler.prepareInterceptionPatterns(this._routes);\n    await this._channel.setNetworkInterceptionPatterns({\n      patterns\n    });\n  }\n  async screenshot(options = {}) {\n    const copy = {\n      ...options,\n      mask: undefined\n    };\n    if (!copy.type) copy.type = (0, _elementHandle.determineScreenshotType)(options);\n    if (options.mask) {\n      copy.mask = options.mask.map(locator => ({\n        frame: locator._frame._channel,\n        selector: locator._selector\n      }));\n    }\n    const result = await this._channel.screenshot(copy);\n    if (options.path) {\n      await (0, _fileUtils.mkdirIfNeeded)(options.path);\n      await _fs.default.promises.writeFile(options.path, result.binary);\n    }\n    return result.binary;\n  }\n  async _expectScreenshot(customStackTrace, options) {\n    return this._wrapApiCall(async () => {\n      var _options$screenshotOp, _options$screenshotOp2;\n      const mask = (_options$screenshotOp = options.screenshotOptions) !== null && _options$screenshotOp !== void 0 && _options$screenshotOp.mask ? (_options$screenshotOp2 = options.screenshotOptions) === null || _options$screenshotOp2 === void 0 ? void 0 : _options$screenshotOp2.mask.map(locator => ({\n        frame: locator._frame._channel,\n        selector: locator._selector\n      })) : undefined;\n      const locator = options.locator ? {\n        frame: options.locator._frame._channel,\n        selector: options.locator._selector\n      } : undefined;\n      return await this._channel.expectScreenshot({\n        ...options,\n        isNot: !!options.isNot,\n        locator,\n        screenshotOptions: {\n          ...options.screenshotOptions,\n          mask\n        }\n      });\n    }, false /* isInternal */, customStackTrace);\n  }\n  async title() {\n    return this._mainFrame.title();\n  }\n  async bringToFront() {\n    await this._channel.bringToFront();\n  }\n  async close(options = {\n    runBeforeUnload: undefined\n  }) {\n    try {\n      if (this._ownedContext) await this._ownedContext.close();else await this._channel.close(options);\n    } catch (e) {\n      if ((0, _errors.isSafeCloseError)(e)) return;\n      throw e;\n    }\n  }\n  isClosed() {\n    return this._closed;\n  }\n  async click(selector, options) {\n    return this._mainFrame.click(selector, options);\n  }\n  async dragAndDrop(source, target, options) {\n    return this._mainFrame.dragAndDrop(source, target, options);\n  }\n  async dblclick(selector, options) {\n    return this._mainFrame.dblclick(selector, options);\n  }\n  async tap(selector, options) {\n    return this._mainFrame.tap(selector, options);\n  }\n  async fill(selector, value, options) {\n    return this._mainFrame.fill(selector, value, options);\n  }\n  locator(selector, options) {\n    return this.mainFrame().locator(selector, options);\n  }\n  getByTestId(testId) {\n    return this.mainFrame().getByTestId(testId);\n  }\n  getByAltText(text, options) {\n    return this.mainFrame().getByAltText(text, options);\n  }\n  getByLabel(text, options) {\n    return this.mainFrame().getByLabel(text, options);\n  }\n  getByPlaceholder(text, options) {\n    return this.mainFrame().getByPlaceholder(text, options);\n  }\n  getByText(text, options) {\n    return this.mainFrame().getByText(text, options);\n  }\n  getByTitle(text, options) {\n    return this.mainFrame().getByTitle(text, options);\n  }\n  getByRole(role, options = {}) {\n    return this.mainFrame().getByRole(role, options);\n  }\n  frameLocator(selector) {\n    return this.mainFrame().frameLocator(selector);\n  }\n  async focus(selector, options) {\n    return this._mainFrame.focus(selector, options);\n  }\n  async textContent(selector, options) {\n    return this._mainFrame.textContent(selector, options);\n  }\n  async innerText(selector, options) {\n    return this._mainFrame.innerText(selector, options);\n  }\n  async innerHTML(selector, options) {\n    return this._mainFrame.innerHTML(selector, options);\n  }\n  async getAttribute(selector, name, options) {\n    return this._mainFrame.getAttribute(selector, name, options);\n  }\n  async inputValue(selector, options) {\n    return this._mainFrame.inputValue(selector, options);\n  }\n  async isChecked(selector, options) {\n    return this._mainFrame.isChecked(selector, options);\n  }\n  async isDisabled(selector, options) {\n    return this._mainFrame.isDisabled(selector, options);\n  }\n  async isEditable(selector, options) {\n    return this._mainFrame.isEditable(selector, options);\n  }\n  async isEnabled(selector, options) {\n    return this._mainFrame.isEnabled(selector, options);\n  }\n  async isHidden(selector, options) {\n    return this._mainFrame.isHidden(selector, options);\n  }\n  async isVisible(selector, options) {\n    return this._mainFrame.isVisible(selector, options);\n  }\n  async hover(selector, options) {\n    return this._mainFrame.hover(selector, options);\n  }\n  async selectOption(selector, values, options) {\n    return this._mainFrame.selectOption(selector, values, options);\n  }\n  async setInputFiles(selector, files, options) {\n    return this._mainFrame.setInputFiles(selector, files, options);\n  }\n  async type(selector, text, options) {\n    return this._mainFrame.type(selector, text, options);\n  }\n  async press(selector, key, options) {\n    return this._mainFrame.press(selector, key, options);\n  }\n  async check(selector, options) {\n    return this._mainFrame.check(selector, options);\n  }\n  async uncheck(selector, options) {\n    return this._mainFrame.uncheck(selector, options);\n  }\n  async setChecked(selector, checked, options) {\n    return this._mainFrame.setChecked(selector, checked, options);\n  }\n  async waitForTimeout(timeout) {\n    return this._mainFrame.waitForTimeout(timeout);\n  }\n  async waitForFunction(pageFunction, arg, options) {\n    return this._mainFrame.waitForFunction(pageFunction, arg, options);\n  }\n  workers() {\n    return [...this._workers];\n  }\n  async pause() {\n    if (require('inspector').url()) return;\n    await Promise.race([this.context()._channel.pause(), this._closedOrCrashedPromise]);\n  }\n  async pdf(options = {}) {\n    const transportOptions = {\n      ...options\n    };\n    if (transportOptions.margin) transportOptions.margin = {\n      ...transportOptions.margin\n    };\n    if (typeof options.width === 'number') transportOptions.width = options.width + 'px';\n    if (typeof options.height === 'number') transportOptions.height = options.height + 'px';\n    for (const margin of ['top', 'right', 'bottom', 'left']) {\n      const index = margin;\n      if (options.margin && typeof options.margin[index] === 'number') transportOptions.margin[index] = transportOptions.margin[index] + 'px';\n    }\n    const result = await this._channel.pdf(transportOptions);\n    if (options.path) {\n      await _fs.default.promises.mkdir(_path.default.dirname(options.path), {\n        recursive: true\n      });\n      await _fs.default.promises.writeFile(options.path, result.pdf);\n    }\n    return result.pdf;\n  }\n}\nexports.Page = Page;\nclass BindingCall extends _channelOwner.ChannelOwner {\n  static from(channel) {\n    return channel._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  async call(func) {\n    try {\n      const frame = _frame.Frame.from(this._initializer.frame);\n      const source = {\n        context: frame._page.context(),\n        page: frame._page,\n        frame\n      };\n      let result;\n      if (this._initializer.handle) result = await func(source, _jsHandle.JSHandle.from(this._initializer.handle));else result = await func(source, ...this._initializer.args.map(_jsHandle.parseResult));\n      this._channel.resolve({\n        result: (0, _jsHandle.serializeArgument)(result)\n      }).catch(() => {});\n    } catch (e) {\n      this._channel.reject({\n        error: (0, _serializers.serializeError)(e)\n      }).catch(() => {});\n    }\n  }\n}\nexports.BindingCall = BindingCall;\nfunction trimEnd(s) {\n  if (s.length > 50) s = s.substring(0, 50) + '\\u2026';\n  return s;\n}\nfunction trimUrl(param) {\n  if ((0, _utils.isRegExp)(param)) return `/${trimEnd(param.source)}/${param.flags}`;\n  if ((0, _utils.isString)(param)) return `\"${trimEnd(param)}\"`;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Playwright = void 0;\nvar _errors = require(\"../common/errors\");\nvar _android = require(\"./android\");\nvar _browserType = require(\"./browserType\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _electron = require(\"./electron\");\nvar _fetch = require(\"./fetch\");\nvar _selectors = require(\"./selectors\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Playwright extends _channelOwner.ChannelOwner {\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._android = void 0;\n    this._electron = void 0;\n    this.chromium = void 0;\n    this.firefox = void 0;\n    this.webkit = void 0;\n    this.devices = void 0;\n    this.selectors = void 0;\n    this.request = void 0;\n    this.errors = void 0;\n    this.request = new _fetch.APIRequest(this);\n    this.chromium = _browserType.BrowserType.from(initializer.chromium);\n    this.chromium._playwright = this;\n    this.firefox = _browserType.BrowserType.from(initializer.firefox);\n    this.firefox._playwright = this;\n    this.webkit = _browserType.BrowserType.from(initializer.webkit);\n    this.webkit._playwright = this;\n    this._android = _android.Android.from(initializer.android);\n    this._electron = _electron.Electron.from(initializer.electron);\n    this.devices = {};\n    for (const {\n      name,\n      descriptor\n    } of initializer.deviceDescriptors) this.devices[name] = descriptor;\n    this.selectors = new _selectors.Selectors();\n    this.errors = {\n      TimeoutError: _errors.TimeoutError\n    };\n    const selectorsOwner = _selectors.SelectorsOwner.from(initializer.selectors);\n    this.selectors._addChannel(selectorsOwner);\n    this._connection.on('close', () => {\n      this.selectors._removeChannel(selectorsOwner);\n    });\n    global._playwrightInstance = this;\n  }\n  _setSelectors(selectors) {\n    const selectorsOwner = _selectors.SelectorsOwner.from(this._initializer.selectors);\n    this.selectors._removeChannel(selectorsOwner);\n    this.selectors = selectors;\n    this.selectors._addChannel(selectorsOwner);\n  }\n  static from(channel) {\n    return channel._object;\n  }\n}\nexports.Playwright = Playwright;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SelectorsOwner = exports.Selectors = void 0;\nvar _clientHelper = require(\"./clientHelper\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _locator = require(\"./locator\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Selectors {\n  constructor() {\n    this._channels = new Set();\n    this._registrations = [];\n  }\n  async register(name, script, options = {}) {\n    const source = await (0, _clientHelper.evaluationScript)(script, undefined, false);\n    const params = {\n      ...options,\n      name,\n      source\n    };\n    for (const channel of this._channels) await channel._channel.register(params);\n    this._registrations.push(params);\n  }\n  setTestIdAttribute(attributeName) {\n    (0, _locator.setTestIdAttribute)(attributeName);\n    for (const channel of this._channels) channel._channel.setTestIdAttributeName({\n      testIdAttributeName: attributeName\n    }).catch(() => {});\n  }\n  _addChannel(channel) {\n    this._channels.add(channel);\n    for (const params of this._registrations) {\n      // This should not fail except for connection closure, but just in case we catch.\n      channel._channel.register(params).catch(() => {});\n      channel._channel.setTestIdAttributeName({\n        testIdAttributeName: (0, _locator.testIdAttributeName)()\n      }).catch(() => {});\n    }\n  }\n  _removeChannel(channel) {\n    this._channels.delete(channel);\n  }\n}\nexports.Selectors = Selectors;\nclass SelectorsOwner extends _channelOwner.ChannelOwner {\n  static from(browser) {\n    return browser._object;\n  }\n}\nexports.SelectorsOwner = SelectorsOwner;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = void 0;\nvar _stream = require(\"stream\");\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Stream extends _channelOwner.ChannelOwner {\n  static from(Stream) {\n    return Stream._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  stream() {\n    return new StreamImpl(this._channel);\n  }\n}\nexports.Stream = Stream;\nclass StreamImpl extends _stream.Readable {\n  constructor(channel) {\n    super();\n    this._channel = void 0;\n    this._channel = channel;\n  }\n  async _read(size) {\n    const result = await this._channel.read({\n      size\n    });\n    if (result.binary.byteLength) this.push(result.binary);else this.push(null);\n  }\n  _destroy(error, callback) {\n    // Stream might be destroyed after the connection was closed.\n    this._channel.close().catch(e => null);\n    super._destroy(error, callback);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tracing = void 0;\nvar _artifact = require(\"./artifact\");\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Tracing extends _channelOwner.ChannelOwner {\n  static from(channel) {\n    return channel._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  async start(options = {}) {\n    await this._wrapApiCall(async () => {\n      await this._channel.tracingStart(options);\n      await this._channel.tracingStartChunk({\n        title: options.title\n      });\n    });\n  }\n  async startChunk(options = {}) {\n    await this._channel.tracingStartChunk(options);\n  }\n  async stopChunk(options = {}) {\n    await this._doStopChunk(options.path);\n  }\n  async stop(options = {}) {\n    await this._wrapApiCall(async () => {\n      await this._doStopChunk(options.path);\n      await this._channel.tracingStop();\n    });\n  }\n  async _doStopChunk(filePath) {\n    var _result$sourceEntries;\n    const isLocal = !this._connection.isRemote();\n    let mode = 'doNotSave';\n    if (filePath) {\n      if (isLocal) mode = 'compressTraceAndSources';else mode = 'compressTrace';\n    }\n    const result = await this._channel.tracingStopChunk({\n      mode\n    });\n    if (!filePath) {\n      // Not interested in artifacts.\n      return;\n    }\n\n    // The artifact may be missing if the browser closed while stopping tracing.\n    if (!result.artifact) return;\n\n    // Save trace to the final local file.\n    const artifact = _artifact.Artifact.from(result.artifact);\n    await artifact.saveAs(filePath);\n    await artifact.delete();\n\n    // Add local sources to the remote trace if necessary.\n    if ((_result$sourceEntries = result.sourceEntries) !== null && _result$sourceEntries !== void 0 && _result$sourceEntries.length) await this._connection.localUtils()._channel.zip({\n      zipFile: filePath,\n      entries: result.sourceEntries\n    });\n  }\n}\nexports.Tracing = Tracing;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.kLifecycleEvents = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle', 'commit']);\nexports.kLifecycleEvents = kLifecycleEvents;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Video = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Video {\n  constructor(page, connection) {\n    this._artifact = null;\n    this._artifactCallback = artifact => {};\n    this._isRemote = false;\n    this._isRemote = connection.isRemote();\n    this._artifact = Promise.race([new Promise(f => this._artifactCallback = f), page._closedOrCrashedPromise.then(() => null)]);\n  }\n  _artifactReady(artifact) {\n    this._artifactCallback(artifact);\n  }\n  async path() {\n    if (this._isRemote) throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);\n    const artifact = await this._artifact;\n    if (!artifact) throw new Error('Page did not produce any video frames');\n    return artifact._initializer.absolutePath;\n  }\n  async saveAs(path) {\n    const artifact = await this._artifact;\n    if (!artifact) throw new Error('Page did not produce any video frames');\n    return artifact.saveAs(path);\n  }\n  async delete() {\n    const artifact = await this._artifact;\n    if (artifact) await artifact.delete();\n  }\n}\nexports.Video = Video;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Waiter = void 0;\nvar _stackTrace = require(\"../utils/stackTrace\");\nvar _errors = require(\"../common/errors\");\nvar _utils = require(\"../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Waiter {\n  constructor(channelOwner, event) {\n    this._dispose = void 0;\n    this._failures = [];\n    this._immediateError = void 0;\n    this._logs = [];\n    this._channelOwner = void 0;\n    this._waitId = void 0;\n    this._error = void 0;\n    this._waitId = (0, _utils.createGuid)();\n    this._channelOwner = channelOwner;\n    this._channelOwner._channel.waitForEventInfo({\n      info: {\n        waitId: this._waitId,\n        phase: 'before',\n        event\n      }\n    }).catch(() => {});\n    this._dispose = [() => this._channelOwner._wrapApiCall(async () => {\n      await this._channelOwner._channel.waitForEventInfo({\n        info: {\n          waitId: this._waitId,\n          phase: 'after',\n          error: this._error\n        }\n      });\n    }, true).catch(() => {})];\n  }\n  static createForEvent(channelOwner, event) {\n    return new Waiter(channelOwner, event);\n  }\n  async waitForEvent(emitter, event, predicate) {\n    const {\n      promise,\n      dispose\n    } = waitForEvent(emitter, event, predicate);\n    return this.waitForPromise(promise, dispose);\n  }\n  rejectOnEvent(emitter, event, error, predicate) {\n    const {\n      promise,\n      dispose\n    } = waitForEvent(emitter, event, predicate);\n    this._rejectOn(promise.then(() => {\n      throw error;\n    }), dispose);\n  }\n  rejectOnTimeout(timeout, message) {\n    if (!timeout) return;\n    const {\n      promise,\n      dispose\n    } = waitForTimeout(timeout);\n    this._rejectOn(promise.then(() => {\n      throw new _errors.TimeoutError(message);\n    }), dispose);\n  }\n  rejectImmediately(error) {\n    this._immediateError = error;\n  }\n  dispose() {\n    for (const dispose of this._dispose) dispose();\n  }\n  async waitForPromise(promise, dispose) {\n    try {\n      if (this._immediateError) throw this._immediateError;\n      const result = await Promise.race([promise, ...this._failures]);\n      if (dispose) dispose();\n      return result;\n    } catch (e) {\n      if (dispose) dispose();\n      this._error = e.message;\n      this.dispose();\n      (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(this._logs));\n      throw e;\n    }\n  }\n  log(s) {\n    this._logs.push(s);\n    this._channelOwner._wrapApiCall(async () => {\n      await this._channelOwner._channel.waitForEventInfo({\n        info: {\n          waitId: this._waitId,\n          phase: 'log',\n          message: s\n        }\n      }).catch(() => {});\n    }, true);\n  }\n  _rejectOn(promise, dispose) {\n    this._failures.push(promise);\n    if (dispose) this._dispose.push(dispose);\n  }\n}\nexports.Waiter = Waiter;\nfunction waitForEvent(emitter, event, predicate) {\n  let listener;\n  const promise = new Promise((resolve, reject) => {\n    listener = async eventArg => {\n      try {\n        if (predicate && !(await predicate(eventArg))) return;\n        emitter.removeListener(event, listener);\n        resolve(eventArg);\n      } catch (e) {\n        emitter.removeListener(event, listener);\n        reject(e);\n      }\n    };\n    emitter.addListener(event, listener);\n  });\n  const dispose = () => emitter.removeListener(event, listener);\n  return {\n    promise,\n    dispose\n  };\n}\nfunction waitForTimeout(timeout) {\n  let timeoutId;\n  const promise = new Promise(resolve => timeoutId = setTimeout(resolve, timeout));\n  const dispose = () => clearTimeout(timeoutId);\n  return {\n    promise,\n    dispose\n  };\n}\nfunction formatLogRecording(log) {\n  if (!log.length) return '';\n  const header = ` logs `;\n  const headerLength = 60;\n  const leftLength = (headerLength - header.length) / 2;\n  const rightLength = headerLength - header.length - leftLength;\n  return `\\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\\n${log.join('\\n')}\\n${'='.repeat(headerLength)}`;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Worker = void 0;\nvar _events = require(\"./events\");\nvar _channelOwner = require(\"./channelOwner\");\nvar _jsHandle = require(\"./jsHandle\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Worker extends _channelOwner.ChannelOwner {\n  // Set for web workers.\n  // Set for service workers.\n\n  static from(worker) {\n    return worker._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n    this._page = void 0;\n    this._context = void 0;\n    this._closedPromise = void 0;\n    this._channel.on('close', () => {\n      if (this._page) this._page._workers.delete(this);\n      if (this._context) this._context._serviceWorkers.delete(this);\n      this.emit(_events.Events.Worker.Close, this);\n    });\n    this._closedPromise = new Promise(f => this.once(_events.Events.Worker.Close, f));\n  }\n  url() {\n    return this._initializer.url;\n  }\n  async evaluate(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    const result = await this._channel.evaluateExpression({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return (0, _jsHandle.parseResult)(result.value);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);\n    const result = await this._channel.evaluateExpressionHandle({\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: (0, _jsHandle.serializeArgument)(arg)\n    });\n    return _jsHandle.JSHandle.from(result.handle);\n  }\n}\nexports.Worker = Worker;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WritableStream = void 0;\nvar _stream = require(\"stream\");\nvar _channelOwner = require(\"./channelOwner\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WritableStream extends _channelOwner.ChannelOwner {\n  static from(Stream) {\n    return Stream._object;\n  }\n  constructor(parent, type, guid, initializer) {\n    super(parent, type, guid, initializer);\n  }\n  stream() {\n    return new WritableStreamImpl(this._channel);\n  }\n}\nexports.WritableStream = WritableStream;\nclass WritableStreamImpl extends _stream.Writable {\n  constructor(channel) {\n    super();\n    this._channel = void 0;\n    this._channel = channel;\n  }\n  async _write(chunk, encoding, callback) {\n    const error = await this._channel.write({\n      binary: typeof chunk === 'string' ? Buffer.from(chunk) : chunk\n    }).catch(e => e);\n    callback(error || null);\n  }\n  async _final(callback) {\n    // Stream might be destroyed after the connection was closed.\n    const error = await this._channel.close().catch(e => e);\n    callback(error || null);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.debugLogger = exports.RecentLogsCollector = void 0;\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _fs = _interopRequireDefault(require(\"fs\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst debugLoggerColorMap = {\n  'api': 45,\n  // cyan\n  'protocol': 34,\n  // green\n  'install': 34,\n  // green\n  'download': 34,\n  // green\n  'browser': 0,\n  // reset\n  'proxy': 92,\n  // purple\n  'error': 160,\n  // red,\n  'channel:command': 33,\n  // blue\n  'channel:response': 202,\n  // orange\n  'channel:event': 207 // magenta\n};\n\nclass DebugLogger {\n  constructor() {\n    this._debuggers = new Map();\n    if (process.env.DEBUG_FILE) {\n      const ansiRegex = new RegExp(['[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)', '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'].join('|'), 'g');\n      const stream = _fs.default.createWriteStream(process.env.DEBUG_FILE);\n      _utilsBundle.debug.log = data => {\n        stream.write(data.replace(ansiRegex, ''));\n        stream.write('\\n');\n      };\n    }\n  }\n  log(name, message) {\n    let cachedDebugger = this._debuggers.get(name);\n    if (!cachedDebugger) {\n      cachedDebugger = (0, _utilsBundle.debug)(`pw:${name}`);\n      this._debuggers.set(name, cachedDebugger);\n      cachedDebugger.color = debugLoggerColorMap[name];\n    }\n    cachedDebugger(message);\n  }\n  isEnabled(name) {\n    return _utilsBundle.debug.enabled(`pw:${name}`);\n  }\n}\nconst debugLogger = new DebugLogger();\nexports.debugLogger = debugLogger;\nconst kLogCount = 150;\nclass RecentLogsCollector {\n  constructor() {\n    this._logs = [];\n  }\n  log(message) {\n    this._logs.push(message);\n    if (this._logs.length === kLogCount * 2) this._logs.splice(0, kLogCount);\n  }\n  recentLogs() {\n    if (this._logs.length > kLogCount) return this._logs.slice(-kLogCount);\n    return this._logs;\n  }\n}\nexports.RecentLogsCollector = RecentLogsCollector;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeoutError = void 0;\nexports.isSafeCloseError = isSafeCloseError;\nexports.kBrowserOrContextClosedError = exports.kBrowserClosedError = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\nclass TimeoutError extends CustomError {}\nexports.TimeoutError = TimeoutError;\nconst kBrowserClosedError = 'Browser has been closed';\nexports.kBrowserClosedError = kBrowserClosedError;\nconst kBrowserOrContextClosedError = 'Target page, context or browser has been closed';\nexports.kBrowserOrContextClosedError = kBrowserOrContextClosedError;\nfunction isSafeCloseError(error) {\n  return error.message.endsWith(kBrowserClosedError) || error.message.endsWith(kBrowserOrContextClosedError);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocksProxyHandler = exports.SocksProxy = void 0;\nexports.parsePattern = parsePattern;\nvar _dns = _interopRequireDefault(require(\"dns\"));\nvar _events = _interopRequireDefault(require(\"events\"));\nvar _net = _interopRequireDefault(require(\"net\"));\nvar _util = _interopRequireDefault(require(\"util\"));\nvar _debugLogger = require(\"./debugLogger\");\nvar _network = require(\"../utils/network\");\nvar _utils = require(\"../utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst dnsLookupAsync = _util.default.promisify(_dns.default.lookup);\n\n// https://tools.ietf.org/html/rfc1928\nvar SocksAuth;\n(function (SocksAuth) {\n  SocksAuth[SocksAuth[\"NO_AUTHENTICATION_REQUIRED\"] = 0] = \"NO_AUTHENTICATION_REQUIRED\";\n  SocksAuth[SocksAuth[\"GSSAPI\"] = 1] = \"GSSAPI\";\n  SocksAuth[SocksAuth[\"USERNAME_PASSWORD\"] = 2] = \"USERNAME_PASSWORD\";\n  SocksAuth[SocksAuth[\"NO_ACCEPTABLE_METHODS\"] = 255] = \"NO_ACCEPTABLE_METHODS\";\n})(SocksAuth || (SocksAuth = {}));\nvar SocksAddressType;\n(function (SocksAddressType) {\n  SocksAddressType[SocksAddressType[\"IPv4\"] = 1] = \"IPv4\";\n  SocksAddressType[SocksAddressType[\"FqName\"] = 3] = \"FqName\";\n  SocksAddressType[SocksAddressType[\"IPv6\"] = 4] = \"IPv6\";\n})(SocksAddressType || (SocksAddressType = {}));\nvar SocksCommand;\n(function (SocksCommand) {\n  SocksCommand[SocksCommand[\"CONNECT\"] = 1] = \"CONNECT\";\n  SocksCommand[SocksCommand[\"BIND\"] = 2] = \"BIND\";\n  SocksCommand[SocksCommand[\"UDP_ASSOCIATE\"] = 3] = \"UDP_ASSOCIATE\";\n})(SocksCommand || (SocksCommand = {}));\nvar SocksReply;\n(function (SocksReply) {\n  SocksReply[SocksReply[\"Succeeded\"] = 0] = \"Succeeded\";\n  SocksReply[SocksReply[\"GeneralServerFailure\"] = 1] = \"GeneralServerFailure\";\n  SocksReply[SocksReply[\"NotAllowedByRuleSet\"] = 2] = \"NotAllowedByRuleSet\";\n  SocksReply[SocksReply[\"NetworkUnreachable\"] = 3] = \"NetworkUnreachable\";\n  SocksReply[SocksReply[\"HostUnreachable\"] = 4] = \"HostUnreachable\";\n  SocksReply[SocksReply[\"ConnectionRefused\"] = 5] = \"ConnectionRefused\";\n  SocksReply[SocksReply[\"TtlExpired\"] = 6] = \"TtlExpired\";\n  SocksReply[SocksReply[\"CommandNotSupported\"] = 7] = \"CommandNotSupported\";\n  SocksReply[SocksReply[\"AddressTypeNotSupported\"] = 8] = \"AddressTypeNotSupported\";\n})(SocksReply || (SocksReply = {}));\nclass SocksConnection {\n  constructor(uid, socket, client) {\n    this._buffer = Buffer.from([]);\n    this._offset = 0;\n    this._fence = 0;\n    this._fenceCallback = void 0;\n    this._socket = void 0;\n    this._boundOnData = void 0;\n    this._uid = void 0;\n    this._client = void 0;\n    this._uid = uid;\n    this._socket = socket;\n    this._client = client;\n    this._boundOnData = this._onData.bind(this);\n    socket.on('data', this._boundOnData);\n    socket.on('close', () => this._onClose());\n    socket.on('end', () => this._onClose());\n    socket.on('error', () => this._onClose());\n    this._run().catch(() => this._socket.end());\n  }\n  async _run() {\n    (0, _utils.assert)(await this._authenticate());\n    const {\n      command,\n      host,\n      port\n    } = await this._parseRequest();\n    if (command !== SocksCommand.CONNECT) {\n      this._writeBytes(Buffer.from([0x05, SocksReply.CommandNotSupported, 0x00,\n      // RSV\n      0x01,\n      // IPv4\n      0x00, 0x00, 0x00, 0x00,\n      // Address\n      0x00, 0x00 // Port\n      ]));\n\n      return;\n    }\n    this._socket.off('data', this._boundOnData);\n    this._client.onSocketRequested({\n      uid: this._uid,\n      host,\n      port\n    });\n  }\n  async _authenticate() {\n    // Request:\n    // +----+----------+----------+\n    // |VER | NMETHODS | METHODS  |\n    // +----+----------+----------+\n    // | 1  |    1     | 1 to 255 |\n    // +----+----------+----------+\n\n    // Response:\n    // +----+--------+\n    // |VER | METHOD |\n    // +----+--------+\n    // | 1  |   1    |\n    // +----+--------+\n\n    const version = await this._readByte();\n    (0, _utils.assert)(version === 0x05, 'The VER field must be set to x05 for this version of the protocol, was ' + version);\n    const nMethods = await this._readByte();\n    (0, _utils.assert)(nMethods, 'No authentication methods specified');\n    const methods = await this._readBytes(nMethods);\n    for (const method of methods) {\n      if (method === 0) {\n        this._writeBytes(Buffer.from([version, method]));\n        return true;\n      }\n    }\n    this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));\n    return false;\n  }\n  async _parseRequest() {\n    // Request.\n    // +----+-----+-------+------+----------+----------+\n    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n    // +----+-----+-------+------+----------+----------+\n    // | 1  |  1  | X'00' |  1   | Variable |    2     |\n    // +----+-----+-------+------+----------+----------+\n\n    // Response.\n    // +----+-----+-------+------+----------+----------+\n    // |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |\n    // +----+-----+-------+------+----------+----------+\n    // | 1  |  1  | X'00' |  1   | Variable |    2     |\n    // +----+-----+-------+------+----------+----------+\n\n    const version = await this._readByte();\n    (0, _utils.assert)(version === 0x05, 'The VER field must be set to x05 for this version of the protocol, was ' + version);\n    const command = await this._readByte();\n    await this._readByte(); // skip reserved.\n    const addressType = await this._readByte();\n    let host = '';\n    switch (addressType) {\n      case SocksAddressType.IPv4:\n        host = (await this._readBytes(4)).join('.');\n        break;\n      case SocksAddressType.FqName:\n        const length = await this._readByte();\n        host = (await this._readBytes(length)).toString();\n        break;\n      case SocksAddressType.IPv6:\n        const bytes = await this._readBytes(16);\n        const tokens = [];\n        for (let i = 0; i < 8; ++i) tokens.push(bytes.readUInt16BE(i * 2).toString(16));\n        host = tokens.join(':');\n        break;\n    }\n    const port = (await this._readBytes(2)).readUInt16BE(0);\n    this._buffer = Buffer.from([]);\n    this._offset = 0;\n    this._fence = 0;\n    return {\n      command,\n      host,\n      port\n    };\n  }\n  async _readByte() {\n    const buffer = await this._readBytes(1);\n    return buffer[0];\n  }\n  async _readBytes(length) {\n    this._fence = this._offset + length;\n    if (!this._buffer || this._buffer.length < this._fence) await new Promise(f => this._fenceCallback = f);\n    this._offset += length;\n    return this._buffer.slice(this._offset - length, this._offset);\n  }\n  _writeBytes(buffer) {\n    if (this._socket.writable) this._socket.write(buffer);\n  }\n  _onClose() {\n    this._client.onSocketClosed({\n      uid: this._uid\n    });\n  }\n  _onData(buffer) {\n    this._buffer = Buffer.concat([this._buffer, buffer]);\n    if (this._fenceCallback && this._buffer.length >= this._fence) {\n      const callback = this._fenceCallback;\n      this._fenceCallback = undefined;\n      callback();\n    }\n  }\n  socketConnected(host, port) {\n    this._writeBytes(Buffer.from([0x05, SocksReply.Succeeded, 0x00,\n    // RSV\n    ...ipToSocksAddress(host),\n    // ATYP, Address\n    port >> 8, port & 0xFF // Port\n    ]));\n\n    this._socket.on('data', data => this._client.onSocketData({\n      uid: this._uid,\n      data\n    }));\n  }\n  socketFailed(errorCode) {\n    const buffer = Buffer.from([0x05, 0, 0x00,\n    // RSV\n    ...ipToSocksAddress('0.0.0.0'),\n    // ATYP, Address\n    0, 0 // Port\n    ]);\n\n    switch (errorCode) {\n      case 'ENOENT':\n      case 'ENOTFOUND':\n      case 'ETIMEDOUT':\n      case 'EHOSTUNREACH':\n        buffer[1] = SocksReply.HostUnreachable;\n        break;\n      case 'ENETUNREACH':\n        buffer[1] = SocksReply.NetworkUnreachable;\n        break;\n      case 'ECONNREFUSED':\n        buffer[1] = SocksReply.ConnectionRefused;\n        break;\n      case 'ERULESET':\n        buffer[1] = SocksReply.NotAllowedByRuleSet;\n        break;\n    }\n    this._writeBytes(buffer);\n    this._socket.end();\n  }\n  sendData(data) {\n    this._socket.write(data);\n  }\n  end() {\n    this._socket.end();\n  }\n  error(error) {\n    this._socket.destroy(new Error(error));\n  }\n}\nfunction hexToNumber(hex) {\n  // Note: parseInt has a few issues including ignoring trailing characters and allowing leading 0x.\n  return [...hex].reduce((value, digit) => {\n    const code = digit.charCodeAt(0);\n    if (code >= 48 && code <= 57)\n      // 0..9\n      return value + code;\n    if (code >= 97 && code <= 102)\n      // a..f\n      return value + (code - 97) + 10;\n    if (code >= 65 && code <= 70)\n      // A..F\n      return value + (code - 65) + 10;\n    throw new Error('Invalid IPv6 token ' + hex);\n  }, 0);\n}\nfunction ipToSocksAddress(address) {\n  if (_net.default.isIPv4(address)) {\n    return [0x01,\n    // IPv4\n    ...address.split('.', 4).map(t => +t & 0xFF) // Address\n    ];\n  }\n\n  if (_net.default.isIPv6(address)) {\n    const result = [0x04]; // IPv6\n    const tokens = address.split(':', 8);\n    while (tokens.length < 8) tokens.unshift('');\n    for (const token of tokens) {\n      const value = hexToNumber(token);\n      result.push(value >> 8 & 0xFF, value & 0xFF); // Big-endian\n    }\n\n    return result;\n  }\n  throw new Error('Only IPv4 and IPv6 addresses are supported');\n}\nfunction starMatchToRegex(pattern) {\n  const source = pattern.split('*').map(s => {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }).join('.*');\n  return new RegExp('^' + source + '$');\n}\n\n// This follows \"Proxy bypass rules\" syntax without implicit and negative rules.\n// https://source.chromium.org/chromium/chromium/src/+/main:net/docs/proxy.md;l=331\nfunction parsePattern(pattern) {\n  if (!pattern) return () => false;\n  const matchers = pattern.split(',').map(token => {\n    const match = token.match(/^(.*?)(?::(\\d+))?$/);\n    if (!match) throw new Error(`Unsupported token \"${token}\" in pattern \"${pattern}\"`);\n    const tokenPort = match[2] ? +match[2] : undefined;\n    const portMatches = port => tokenPort === undefined || tokenPort === port;\n    let tokenHost = match[1];\n    if (tokenHost === '<loopback>') {\n      return (host, port) => {\n        if (!portMatches(port)) return false;\n        return host === 'localhost' || host.endsWith('.localhost') || host === '127.0.0.1' || host === '[::1]';\n      };\n    }\n    if (tokenHost === '*') return (host, port) => portMatches(port);\n    if (_net.default.isIPv4(tokenHost) || _net.default.isIPv6(tokenHost)) return (host, port) => host === tokenHost && portMatches(port);\n    if (tokenHost[0] === '.') tokenHost = '*' + tokenHost;\n    const tokenRegex = starMatchToRegex(tokenHost);\n    return (host, port) => {\n      if (!portMatches(port)) return false;\n      if (_net.default.isIPv4(host) || _net.default.isIPv6(host)) return false;\n      return !!host.match(tokenRegex);\n    };\n  });\n  return (host, port) => matchers.some(matcher => matcher(host, port));\n}\nclass SocksProxy extends _events.default {\n  constructor() {\n    super();\n    this._server = void 0;\n    this._connections = new Map();\n    this._sockets = new Set();\n    this._closed = false;\n    this._port = void 0;\n    this._patternMatcher = () => false;\n    this._directSockets = new Map();\n    this._server = new _net.default.Server(socket => {\n      const uid = (0, _utils.createGuid)();\n      const connection = new SocksConnection(uid, socket, this);\n      this._connections.set(uid, connection);\n    });\n    this._server.on('connection', socket => {\n      if (this._closed) {\n        socket.destroy();\n        return;\n      }\n      this._sockets.add(socket);\n      socket.once('close', () => this._sockets.delete(socket));\n    });\n  }\n  setPattern(pattern) {\n    try {\n      this._patternMatcher = parsePattern(pattern);\n    } catch (e) {\n      this._patternMatcher = () => false;\n    }\n  }\n  async _handleDirect(request) {\n    try {\n      var _this$_connections$ge4;\n      // TODO: Node.js 17 does resolve localhost to ipv6\n      const {\n        address\n      } = await dnsLookupAsync(request.host === 'localhost' ? '127.0.0.1' : request.host);\n      const socket = await (0, _network.createSocket)(address, request.port);\n      socket.on('data', data => {\n        var _this$_connections$ge;\n        return (_this$_connections$ge = this._connections.get(request.uid)) === null || _this$_connections$ge === void 0 ? void 0 : _this$_connections$ge.sendData(data);\n      });\n      socket.on('error', error => {\n        var _this$_connections$ge2;\n        (_this$_connections$ge2 = this._connections.get(request.uid)) === null || _this$_connections$ge2 === void 0 ? void 0 : _this$_connections$ge2.error(error.message);\n        this._directSockets.delete(request.uid);\n      });\n      socket.on('end', () => {\n        var _this$_connections$ge3;\n        (_this$_connections$ge3 = this._connections.get(request.uid)) === null || _this$_connections$ge3 === void 0 ? void 0 : _this$_connections$ge3.end();\n        this._directSockets.delete(request.uid);\n      });\n      const localAddress = socket.localAddress;\n      const localPort = socket.localPort;\n      this._directSockets.set(request.uid, socket);\n      (_this$_connections$ge4 = this._connections.get(request.uid)) === null || _this$_connections$ge4 === void 0 ? void 0 : _this$_connections$ge4.socketConnected(localAddress, localPort);\n    } catch (error) {\n      var _this$_connections$ge5;\n      (_this$_connections$ge5 = this._connections.get(request.uid)) === null || _this$_connections$ge5 === void 0 ? void 0 : _this$_connections$ge5.socketFailed(error.code);\n    }\n  }\n  port() {\n    return this._port;\n  }\n  async listen(port) {\n    return new Promise(f => {\n      this._server.listen(port, () => {\n        const port = this._server.address().port;\n        this._port = port;\n        _debugLogger.debugLogger.log('proxy', `Starting socks proxy server on port ${port}`);\n        f(port);\n      });\n    });\n  }\n  async close() {\n    if (this._closed) return;\n    this._closed = true;\n    for (const socket of this._sockets) socket.destroy();\n    this._sockets.clear();\n    await new Promise(f => this._server.close(f));\n  }\n  onSocketRequested(payload) {\n    if (!this._patternMatcher(payload.host, payload.port)) {\n      this._handleDirect(payload);\n      return;\n    }\n    this.emit(SocksProxy.Events.SocksRequested, payload);\n  }\n  onSocketData(payload) {\n    const direct = this._directSockets.get(payload.uid);\n    if (direct) {\n      direct.write(payload.data);\n      return;\n    }\n    this.emit(SocksProxy.Events.SocksData, payload);\n  }\n  onSocketClosed(payload) {\n    const direct = this._directSockets.get(payload.uid);\n    if (direct) {\n      direct.destroy();\n      this._directSockets.delete(payload.uid);\n      return;\n    }\n    this.emit(SocksProxy.Events.SocksClosed, payload);\n  }\n  socketConnected({\n    uid,\n    host,\n    port\n  }) {\n    var _this$_connections$ge6;\n    (_this$_connections$ge6 = this._connections.get(uid)) === null || _this$_connections$ge6 === void 0 ? void 0 : _this$_connections$ge6.socketConnected(host, port);\n  }\n  socketFailed({\n    uid,\n    errorCode\n  }) {\n    var _this$_connections$ge7;\n    (_this$_connections$ge7 = this._connections.get(uid)) === null || _this$_connections$ge7 === void 0 ? void 0 : _this$_connections$ge7.socketFailed(errorCode);\n  }\n  sendSocketData({\n    uid,\n    data\n  }) {\n    var _this$_connections$ge8;\n    (_this$_connections$ge8 = this._connections.get(uid)) === null || _this$_connections$ge8 === void 0 ? void 0 : _this$_connections$ge8.sendData(data);\n  }\n  sendSocketEnd({\n    uid\n  }) {\n    var _this$_connections$ge9;\n    (_this$_connections$ge9 = this._connections.get(uid)) === null || _this$_connections$ge9 === void 0 ? void 0 : _this$_connections$ge9.end();\n  }\n  sendSocketError({\n    uid,\n    error\n  }) {\n    var _this$_connections$ge10;\n    (_this$_connections$ge10 = this._connections.get(uid)) === null || _this$_connections$ge10 === void 0 ? void 0 : _this$_connections$ge10.error(error);\n  }\n}\nexports.SocksProxy = SocksProxy;\nSocksProxy.Events = {\n  SocksRequested: 'socksRequested',\n  SocksData: 'socksData',\n  SocksClosed: 'socksClosed'\n};\nclass SocksProxyHandler extends _events.default {\n  constructor(pattern, redirectPortForTest) {\n    super();\n    this._sockets = new Map();\n    this._patternMatcher = () => false;\n    this._redirectPortForTest = void 0;\n    this._patternMatcher = parsePattern(pattern);\n    this._redirectPortForTest = redirectPortForTest;\n  }\n  cleanup() {\n    for (const uid of this._sockets.keys()) this.socketClosed({\n      uid\n    });\n  }\n  async socketRequested({\n    uid,\n    host,\n    port\n  }) {\n    if (!this._patternMatcher(host, port)) {\n      const payload = {\n        uid,\n        errorCode: 'ERULESET'\n      };\n      this.emit(SocksProxyHandler.Events.SocksFailed, payload);\n      return;\n    }\n    if (host === 'local.playwright') host = '127.0.0.1';\n    // Node.js 17 does resolve localhost to ipv6\n    if (host === 'localhost') host = '127.0.0.1';\n    try {\n      if (this._redirectPortForTest) port = this._redirectPortForTest;\n      const {\n        address\n      } = await dnsLookupAsync(host);\n      const socket = await (0, _network.createSocket)(address, port);\n      socket.on('data', data => {\n        const payload = {\n          uid,\n          data\n        };\n        this.emit(SocksProxyHandler.Events.SocksData, payload);\n      });\n      socket.on('error', error => {\n        const payload = {\n          uid,\n          error: error.message\n        };\n        this.emit(SocksProxyHandler.Events.SocksError, payload);\n        this._sockets.delete(uid);\n      });\n      socket.on('end', () => {\n        const payload = {\n          uid\n        };\n        this.emit(SocksProxyHandler.Events.SocksEnd, payload);\n        this._sockets.delete(uid);\n      });\n      const localAddress = socket.localAddress;\n      const localPort = socket.localPort;\n      this._sockets.set(uid, socket);\n      const payload = {\n        uid,\n        host: localAddress,\n        port: localPort\n      };\n      this.emit(SocksProxyHandler.Events.SocksConnected, payload);\n    } catch (error) {\n      const payload = {\n        uid,\n        errorCode: error.code\n      };\n      this.emit(SocksProxyHandler.Events.SocksFailed, payload);\n    }\n  }\n  sendSocketData({\n    uid,\n    data\n  }) {\n    var _this$_sockets$get;\n    (_this$_sockets$get = this._sockets.get(uid)) === null || _this$_sockets$get === void 0 ? void 0 : _this$_sockets$get.write(data);\n  }\n  socketClosed({\n    uid\n  }) {\n    var _this$_sockets$get2;\n    (_this$_sockets$get2 = this._sockets.get(uid)) === null || _this$_sockets$get2 === void 0 ? void 0 : _this$_sockets$get2.destroy();\n    this._sockets.delete(uid);\n  }\n}\nexports.SocksProxyHandler = SocksProxyHandler;\nSocksProxyHandler.Events = {\n  SocksConnected: 'socksConnected',\n  SocksData: 'socksData',\n  SocksError: 'socksError',\n  SocksFailed: 'socksFailed',\n  SocksEnd: 'socksEnd'\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeoutSettings = exports.DEFAULT_TIMEOUT = exports.DEFAULT_LAUNCH_TIMEOUT = void 0;\nvar _utils = require(\"../utils\");\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst DEFAULT_TIMEOUT = 30000;\nexports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\nconst DEFAULT_LAUNCH_TIMEOUT = 3 * 60 * 1000; // 3 minutes\nexports.DEFAULT_LAUNCH_TIMEOUT = DEFAULT_LAUNCH_TIMEOUT;\nclass TimeoutSettings {\n  constructor(parent) {\n    this._parent = void 0;\n    this._defaultTimeout = void 0;\n    this._defaultNavigationTimeout = void 0;\n    this._parent = parent;\n  }\n  setDefaultTimeout(timeout) {\n    this._defaultTimeout = timeout;\n  }\n  setDefaultNavigationTimeout(timeout) {\n    this._defaultNavigationTimeout = timeout;\n  }\n  navigationTimeout(options) {\n    if (typeof options.timeout === 'number') return options.timeout;\n    if (this._defaultNavigationTimeout !== undefined) return this._defaultNavigationTimeout;\n    if ((0, _utils.debugMode)()) return 0;\n    if (this._defaultTimeout !== undefined) return this._defaultTimeout;\n    if (this._parent) return this._parent.navigationTimeout(options);\n    return DEFAULT_TIMEOUT;\n  }\n  timeout(options) {\n    if (typeof options.timeout === 'number') return options.timeout;\n    if ((0, _utils.debugMode)()) return 0;\n    if (this._defaultTimeout !== undefined) return this._defaultTimeout;\n    if (this._parent) return this._parent.timeout(options);\n    return DEFAULT_TIMEOUT;\n  }\n  static timeout(options) {\n    if (typeof options.timeout === 'number') return options.timeout;\n    if ((0, _utils.debugMode)()) return 0;\n    return DEFAULT_TIMEOUT;\n  }\n  static launchTimeout(options) {\n    if (typeof options.timeout === 'number') return options.timeout;\n    if ((0, _utils.debugMode)()) return 0;\n    return DEFAULT_LAUNCH_TIMEOUT;\n  }\n}\nexports.TimeoutSettings = TimeoutSettings;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.source = void 0;\nconst source = \"\\\"use strict\\\";\\n\\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\\nfunction escapeWithQuotes(text, char = \\\"'\\\") {\\n  const stringified = JSON.stringify(text);\\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\\\\\\\"/g, '\\\"');\\n  if (char === \\\"'\\\")\\n    return char + escapedText.replace(/[']/g, \\\"\\\\\\\\'\\\") + char;\\n  if (char === '\\\"')\\n    return char + escapedText.replace(/[\\\"]/g, '\\\\\\\\\\\"') + char;\\n  if (char === \\\"`\\\")\\n    return char + escapedText.replace(/[`]/g, \\\"`\\\") + char;\\n  throw new Error(\\\"Invalid escape char\\\");\\n}\\nfunction isString(obj) {\\n  return typeof obj === \\\"string\\\" || obj instanceof String;\\n}\\nfunction toTitleCase(name) {\\n  return name.charAt(0).toUpperCase() + name.substring(1);\\n}\\nfunction toSnakeCase(name) {\\n  return name.replace(/([a-z0-9])([A-Z])/g, \\\"$1_$2\\\").replace(/([A-Z])([A-Z][a-z])/g, \\\"$1_$2\\\").toLowerCase();\\n}\\nfunction cssEscape(s) {\\n  let result = \\\"\\\";\\n  for (let i = 0; i < s.length; i++)\\n    result += cssEscapeOne(s, i);\\n  return result;\\n}\\nfunction cssEscapeOne(s, i) {\\n  const c = s.charCodeAt(i);\\n  if (c === 0)\\n    return \\\"\\\\uFFFD\\\";\\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\\n    return \\\"\\\\\\\\\\\" + c.toString(16) + \\\" \\\";\\n  if (i === 0 && c === 45 && s.length === 1)\\n    return \\\"\\\\\\\\\\\" + s.charAt(i);\\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\\n    return s.charAt(i);\\n  return \\\"\\\\\\\\\\\" + s.charAt(i);\\n}\\nfunction normalizeWhiteSpace(text) {\\n  return text.replace(/\\\\u200b/g, \\\"\\\").trim().replace(/\\\\s+/g, \\\" \\\");\\n}\\nfunction escapeForTextSelector(text, exact) {\\n  if (typeof text !== \\\"string\\\")\\n    return String(text);\\n  return `${JSON.stringify(text)}${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\nfunction escapeForAttributeSelector(value, exact) {\\n  return `\\\"${value.replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\").replace(/[\\\"]/g, '\\\\\\\\\\\"')}\\\"${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\n\\n// packages/playwright-core/src/utils/isomorphic/locatorUtils.ts\\nfunction getByAttributeTextSelector(attrName, text, options) {\\n  if (!isString(text))\\n    return `internal:attr=[${attrName}=${text}]`;\\n  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, (options == null ? void 0 : options.exact) || false)}]`;\\n}\\nfunction getByTestIdSelector(testIdAttributeName, testId) {\\n  if (!isString(testId))\\n    return `internal:testid=[${testIdAttributeName}=${testId}]`;\\n  return `internal:testid=[${testIdAttributeName}=${escapeForAttributeSelector(testId, true)}]`;\\n}\\nfunction getByLabelSelector(text, options) {\\n  return \\\"internal:label=\\\" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\\n}\\nfunction getByAltTextSelector(text, options) {\\n  return getByAttributeTextSelector(\\\"alt\\\", text, options);\\n}\\nfunction getByTitleSelector(text, options) {\\n  return getByAttributeTextSelector(\\\"title\\\", text, options);\\n}\\nfunction getByPlaceholderSelector(text, options) {\\n  return getByAttributeTextSelector(\\\"placeholder\\\", text, options);\\n}\\nfunction getByTextSelector(text, options) {\\n  return \\\"internal:text=\\\" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\\n}\\nfunction getByRoleSelector(role, options = {}) {\\n  const props = [];\\n  if (options.checked !== void 0)\\n    props.push([\\\"checked\\\", String(options.checked)]);\\n  if (options.disabled !== void 0)\\n    props.push([\\\"disabled\\\", String(options.disabled)]);\\n  if (options.selected !== void 0)\\n    props.push([\\\"selected\\\", String(options.selected)]);\\n  if (options.expanded !== void 0)\\n    props.push([\\\"expanded\\\", String(options.expanded)]);\\n  if (options.includeHidden !== void 0)\\n    props.push([\\\"include-hidden\\\", String(options.includeHidden)]);\\n  if (options.level !== void 0)\\n    props.push([\\\"level\\\", String(options.level)]);\\n  if (options.name !== void 0)\\n    props.push([\\\"name\\\", isString(options.name) ? escapeForAttributeSelector(options.name, !!options.exact) : String(options.name)]);\\n  if (options.pressed !== void 0)\\n    props.push([\\\"pressed\\\", String(options.pressed)]);\\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join(\\\"\\\")}`;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.ts\\nvar between = function(num, first, last) {\\n  return num >= first && num <= last;\\n};\\nfunction digit(code) {\\n  return between(code, 48, 57);\\n}\\nfunction hexdigit(code) {\\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\\n}\\nfunction uppercaseletter(code) {\\n  return between(code, 65, 90);\\n}\\nfunction lowercaseletter(code) {\\n  return between(code, 97, 122);\\n}\\nfunction letter(code) {\\n  return uppercaseletter(code) || lowercaseletter(code);\\n}\\nfunction nonascii(code) {\\n  return code >= 128;\\n}\\nfunction namestartchar(code) {\\n  return letter(code) || nonascii(code) || code === 95;\\n}\\nfunction namechar(code) {\\n  return namestartchar(code) || digit(code) || code === 45;\\n}\\nfunction nonprintable(code) {\\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\\n}\\nfunction newline(code) {\\n  return code === 10;\\n}\\nfunction whitespace(code) {\\n  return newline(code) || code === 9 || code === 32;\\n}\\nvar maximumallowedcodepoint = 1114111;\\nvar InvalidCharacterError = class extends Error {\\n  constructor(message) {\\n    super(message);\\n    this.name = \\\"InvalidCharacterError\\\";\\n  }\\n};\\nfunction preprocess(str) {\\n  const codepoints = [];\\n  for (let i = 0; i < str.length; i++) {\\n    let code = str.charCodeAt(i);\\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\\n      code = 10;\\n      i++;\\n    }\\n    if (code === 13 || code === 12)\\n      code = 10;\\n    if (code === 0)\\n      code = 65533;\\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\\n      const lead = code - 55296;\\n      const trail = str.charCodeAt(i + 1) - 56320;\\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\\n      i++;\\n    }\\n    codepoints.push(code);\\n  }\\n  return codepoints;\\n}\\nfunction stringFromCode(code) {\\n  if (code <= 65535)\\n    return String.fromCharCode(code);\\n  code -= Math.pow(2, 16);\\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\\n  const trail = code % Math.pow(2, 10) + 56320;\\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\\n}\\nfunction tokenize(str1) {\\n  const str = preprocess(str1);\\n  let i = -1;\\n  const tokens = [];\\n  let code;\\n  let line = 0;\\n  let column = 0;\\n  let lastLineLength = 0;\\n  const incrLineno = function() {\\n    line += 1;\\n    lastLineLength = column;\\n    column = 0;\\n  };\\n  const locStart = { line, column };\\n  const codepoint = function(i2) {\\n    if (i2 >= str.length)\\n      return -1;\\n    return str[i2];\\n  };\\n  const next = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    if (num > 3)\\n      throw \\\"Spec Error: no more than three codepoints of lookahead.\\\";\\n    return codepoint(i + num);\\n  };\\n  const consume = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    i += num;\\n    code = codepoint(i);\\n    if (newline(code))\\n      incrLineno();\\n    else\\n      column += num;\\n    return true;\\n  };\\n  const reconsume = function() {\\n    i -= 1;\\n    if (newline(code)) {\\n      line -= 1;\\n      column = lastLineLength;\\n    } else {\\n      column -= 1;\\n    }\\n    locStart.line = line;\\n    locStart.column = column;\\n    return true;\\n  };\\n  const eof = function(codepoint2) {\\n    if (codepoint2 === void 0)\\n      codepoint2 = code;\\n    return codepoint2 === -1;\\n  };\\n  const donothing = function() {\\n  };\\n  const parseerror = function() {\\n  };\\n  const consumeAToken = function() {\\n    consumeComments();\\n    consume();\\n    if (whitespace(code)) {\\n      while (whitespace(next()))\\n        consume();\\n      return new WhitespaceToken();\\n    } else if (code === 34) {\\n      return consumeAStringToken();\\n    } else if (code === 35) {\\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\\n        const token = new HashToken(\\\"\\\");\\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n          token.type = \\\"id\\\";\\n        token.value = consumeAName();\\n        return token;\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 36) {\\n      if (next() === 61) {\\n        consume();\\n        return new SuffixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 39) {\\n      return consumeAStringToken();\\n    } else if (code === 40) {\\n      return new OpenParenToken();\\n    } else if (code === 41) {\\n      return new CloseParenToken();\\n    } else if (code === 42) {\\n      if (next() === 61) {\\n        consume();\\n        return new SubstringMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 43) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 44) {\\n      return new CommaToken();\\n    } else if (code === 45) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else if (next(1) === 45 && next(2) === 62) {\\n        consume(2);\\n        return new CDCToken();\\n      } else if (startsWithAnIdentifier()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 46) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 58) {\\n      return new ColonToken();\\n    } else if (code === 59) {\\n      return new SemicolonToken();\\n    } else if (code === 60) {\\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\\n        consume(3);\\n        return new CDOToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 64) {\\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n        return new AtKeywordToken(consumeAName());\\n      else\\n        return new DelimToken(code);\\n    } else if (code === 91) {\\n      return new OpenSquareToken();\\n    } else if (code === 92) {\\n      if (startsWithAValidEscape()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        parseerror();\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 93) {\\n      return new CloseSquareToken();\\n    } else if (code === 94) {\\n      if (next() === 61) {\\n        consume();\\n        return new PrefixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 123) {\\n      return new OpenCurlyToken();\\n    } else if (code === 124) {\\n      if (next() === 61) {\\n        consume();\\n        return new DashMatchToken();\\n      } else if (next() === 124) {\\n        consume();\\n        return new ColumnToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 125) {\\n      return new CloseCurlyToken();\\n    } else if (code === 126) {\\n      if (next() === 61) {\\n        consume();\\n        return new IncludeMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (digit(code)) {\\n      reconsume();\\n      return consumeANumericToken();\\n    } else if (namestartchar(code)) {\\n      reconsume();\\n      return consumeAnIdentlikeToken();\\n    } else if (eof()) {\\n      return new EOFToken();\\n    } else {\\n      return new DelimToken(code);\\n    }\\n  };\\n  const consumeComments = function() {\\n    while (next(1) === 47 && next(2) === 42) {\\n      consume(2);\\n      while (true) {\\n        consume();\\n        if (code === 42 && next() === 47) {\\n          consume();\\n          break;\\n        } else if (eof()) {\\n          parseerror();\\n          return;\\n        }\\n      }\\n    }\\n  };\\n  const consumeANumericToken = function() {\\n    const num = consumeANumber();\\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\\n      const token = new DimensionToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      token.unit = consumeAName();\\n      return token;\\n    } else if (next() === 37) {\\n      consume();\\n      const token = new PercentageToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      return token;\\n    } else {\\n      const token = new NumberToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      return token;\\n    }\\n  };\\n  const consumeAnIdentlikeToken = function() {\\n    const str2 = consumeAName();\\n    if (str2.toLowerCase() === \\\"url\\\" && next() === 40) {\\n      consume();\\n      while (whitespace(next(1)) && whitespace(next(2)))\\n        consume();\\n      if (next() === 34 || next() === 39)\\n        return new FunctionToken(str2);\\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\\n        return new FunctionToken(str2);\\n      else\\n        return consumeAURLToken();\\n    } else if (next() === 40) {\\n      consume();\\n      return new FunctionToken(str2);\\n    } else {\\n      return new IdentToken(str2);\\n    }\\n  };\\n  const consumeAStringToken = function(endingCodePoint) {\\n    if (endingCodePoint === void 0)\\n      endingCodePoint = code;\\n    let string = \\\"\\\";\\n    while (consume()) {\\n      if (code === endingCodePoint || eof()) {\\n        return new StringToken(string);\\n      } else if (newline(code)) {\\n        parseerror();\\n        reconsume();\\n        return new BadStringToken();\\n      } else if (code === 92) {\\n        if (eof(next()))\\n          donothing();\\n        else if (newline(next()))\\n          consume();\\n        else\\n          string += stringFromCode(consumeEscape());\\n      } else {\\n        string += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeAURLToken = function() {\\n    const token = new URLToken(\\\"\\\");\\n    while (whitespace(next()))\\n      consume();\\n    if (eof(next()))\\n      return token;\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return token;\\n      } else if (whitespace(code)) {\\n        while (whitespace(next()))\\n          consume();\\n        if (next() === 41 || eof(next())) {\\n          consume();\\n          return token;\\n        } else {\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\\n        parseerror();\\n        consumeTheRemnantsOfABadURL();\\n        return new BadURLToken();\\n      } else if (code === 92) {\\n        if (startsWithAValidEscape()) {\\n          token.value += stringFromCode(consumeEscape());\\n        } else {\\n          parseerror();\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else {\\n        token.value += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeEscape = function() {\\n    consume();\\n    if (hexdigit(code)) {\\n      const digits = [code];\\n      for (let total = 0; total < 5; total++) {\\n        if (hexdigit(next())) {\\n          consume();\\n          digits.push(code);\\n        } else {\\n          break;\\n        }\\n      }\\n      if (whitespace(next()))\\n        consume();\\n      let value = parseInt(digits.map(function(x) {\\n        return String.fromCharCode(x);\\n      }).join(\\\"\\\"), 16);\\n      if (value > maximumallowedcodepoint)\\n        value = 65533;\\n      return value;\\n    } else if (eof()) {\\n      return 65533;\\n    } else {\\n      return code;\\n    }\\n  };\\n  const areAValidEscape = function(c1, c2) {\\n    if (c1 !== 92)\\n      return false;\\n    if (newline(c2))\\n      return false;\\n    return true;\\n  };\\n  const startsWithAValidEscape = function() {\\n    return areAValidEscape(code, next());\\n  };\\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\\n    if (c1 === 45)\\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\\n    else if (namestartchar(c1))\\n      return true;\\n    else if (c1 === 92)\\n      return areAValidEscape(c1, c2);\\n    else\\n      return false;\\n  };\\n  const startsWithAnIdentifier = function() {\\n    return wouldStartAnIdentifier(code, next(1), next(2));\\n  };\\n  const wouldStartANumber = function(c1, c2, c3) {\\n    if (c1 === 43 || c1 === 45) {\\n      if (digit(c2))\\n        return true;\\n      if (c2 === 46 && digit(c3))\\n        return true;\\n      return false;\\n    } else if (c1 === 46) {\\n      if (digit(c2))\\n        return true;\\n      return false;\\n    } else if (digit(c1)) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  };\\n  const startsWithANumber = function() {\\n    return wouldStartANumber(code, next(1), next(2));\\n  };\\n  const consumeAName = function() {\\n    let result = \\\"\\\";\\n    while (consume()) {\\n      if (namechar(code)) {\\n        result += stringFromCode(code);\\n      } else if (startsWithAValidEscape()) {\\n        result += stringFromCode(consumeEscape());\\n      } else {\\n        reconsume();\\n        return result;\\n      }\\n    }\\n    throw new Error(\\\"Internal parse error\\\");\\n  };\\n  const consumeANumber = function() {\\n    let repr = \\\"\\\";\\n    let type = \\\"integer\\\";\\n    if (next() === 43 || next() === 45) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    while (digit(next())) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    if (next(1) === 46 && digit(next(2))) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const c1 = next(1), c2 = next(2), c3 = next(3);\\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const value = convertAStringToANumber(repr);\\n    return { type, value, repr };\\n  };\\n  const convertAStringToANumber = function(string) {\\n    return +string;\\n  };\\n  const consumeTheRemnantsOfABadURL = function() {\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return;\\n      } else if (startsWithAValidEscape()) {\\n        consumeEscape();\\n        donothing();\\n      } else {\\n        donothing();\\n      }\\n    }\\n  };\\n  let iterationCount = 0;\\n  while (!eof(next())) {\\n    tokens.push(consumeAToken());\\n    iterationCount++;\\n    if (iterationCount > str.length * 2)\\n      throw new Error(\\\"I'm infinite-looping!\\\");\\n  }\\n  return tokens;\\n}\\nvar CSSParserToken = class {\\n  constructor() {\\n    this.tokenType = \\\"\\\";\\n  }\\n  toJSON() {\\n    return { token: this.tokenType };\\n  }\\n  toString() {\\n    return this.tokenType;\\n  }\\n  toSource() {\\n    return \\\"\\\" + this;\\n  }\\n};\\nvar BadStringToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADSTRING\\\";\\n  }\\n};\\nvar BadURLToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADURL\\\";\\n  }\\n};\\nvar WhitespaceToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"WHITESPACE\\\";\\n  }\\n  toString() {\\n    return \\\"WS\\\";\\n  }\\n  toSource() {\\n    return \\\" \\\";\\n  }\\n};\\nvar CDOToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDO\\\";\\n  }\\n  toSource() {\\n    return \\\"<!--\\\";\\n  }\\n};\\nvar CDCToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDC\\\";\\n  }\\n  toSource() {\\n    return \\\"-->\\\";\\n  }\\n};\\nvar ColonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\":\\\";\\n  }\\n};\\nvar SemicolonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\";\\\";\\n  }\\n};\\nvar CommaToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\",\\\";\\n  }\\n};\\nvar GroupingToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n    this.mirror = \\\"\\\";\\n  }\\n};\\nvar OpenCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"{\\\";\\n    this.value = \\\"{\\\";\\n    this.mirror = \\\"}\\\";\\n  }\\n};\\nvar CloseCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"}\\\";\\n    this.value = \\\"}\\\";\\n    this.mirror = \\\"{\\\";\\n  }\\n};\\nvar OpenSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"[\\\";\\n    this.value = \\\"[\\\";\\n    this.mirror = \\\"]\\\";\\n  }\\n};\\nvar CloseSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"]\\\";\\n    this.value = \\\"]\\\";\\n    this.mirror = \\\"[\\\";\\n  }\\n};\\nvar OpenParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"(\\\";\\n    this.value = \\\"(\\\";\\n    this.mirror = \\\")\\\";\\n  }\\n};\\nvar CloseParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\")\\\";\\n    this.value = \\\")\\\";\\n    this.mirror = \\\"(\\\";\\n  }\\n};\\nvar IncludeMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"~=\\\";\\n  }\\n};\\nvar DashMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"|=\\\";\\n  }\\n};\\nvar PrefixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"^=\\\";\\n  }\\n};\\nvar SuffixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"$=\\\";\\n  }\\n};\\nvar SubstringMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"*=\\\";\\n  }\\n};\\nvar ColumnToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"||\\\";\\n  }\\n};\\nvar EOFToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"EOF\\\";\\n  }\\n  toSource() {\\n    return \\\"\\\";\\n  }\\n};\\nvar DelimToken = class extends CSSParserToken {\\n  constructor(code) {\\n    super();\\n    this.tokenType = \\\"DELIM\\\";\\n    this.value = \\\"\\\";\\n    this.value = stringFromCode(code);\\n  }\\n  toString() {\\n    return \\\"DELIM(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.value === \\\"\\\\\\\\\\\")\\n      return \\\"\\\\\\\\\\\\n\\\";\\n    else\\n      return this.value;\\n  }\\n};\\nvar StringValuedToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n  }\\n  ASCIIMatch(str) {\\n    return this.value.toLowerCase() === str.toLowerCase();\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n};\\nvar IdentToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"IDENT\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"IDENT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value);\\n  }\\n};\\nvar FunctionToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"FUNCTION\\\";\\n    this.value = val;\\n    this.mirror = \\\")\\\";\\n  }\\n  toString() {\\n    return \\\"FUNCTION(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value) + \\\"(\\\";\\n  }\\n};\\nvar AtKeywordToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"AT-KEYWORD\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"AT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return \\\"@\\\" + escapeIdent(this.value);\\n  }\\n};\\nvar HashToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"HASH\\\";\\n    this.value = val;\\n    this.type = \\\"unrestricted\\\";\\n  }\\n  toString() {\\n    return \\\"HASH(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.type === \\\"id\\\")\\n      return \\\"#\\\" + escapeIdent(this.value);\\n    else\\n      return \\\"#\\\" + escapeHash(this.value);\\n  }\\n};\\nvar StringToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"STRING\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return '\\\"' + escapeString(this.value) + '\\\"';\\n  }\\n};\\nvar URLToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"URL\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"URL(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return 'url(\\\"' + escapeString(this.value) + '\\\")';\\n  }\\n};\\nvar NumberToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"NUMBER\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    if (this.type === \\\"integer\\\")\\n      return \\\"INT(\\\" + this.value + \\\")\\\";\\n    return \\\"NUMBER(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = super.toJSON();\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr;\\n  }\\n};\\nvar PercentageToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"PERCENTAGE\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"PERCENTAGE(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr + \\\"%\\\";\\n  }\\n};\\nvar DimensionToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"DIMENSION\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n    this.unit = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"DIM(\\\" + this.value + \\\",\\\" + this.unit + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    json.unit = this.unit;\\n    return json;\\n  }\\n  toSource() {\\n    const source = this.repr;\\n    let unit = escapeIdent(this.unit);\\n    if (unit[0].toLowerCase() === \\\"e\\\" && (unit[1] === \\\"-\\\" || between(unit.charCodeAt(1), 48, 57))) {\\n      unit = \\\"\\\\\\\\65 \\\" + unit.slice(1, unit.length);\\n    }\\n    return source + unit;\\n  }\\n};\\nfunction escapeIdent(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  const firstcode = string.charCodeAt(0);\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n  }\\n  return result;\\n}\\nfunction escapeHash(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n  }\\n  return result;\\n}\\nfunction escapeString(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code === 34 || code === 92)\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n    else\\n      result += string[i];\\n  }\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\\nvar InvalidSelectorError = class extends Error {\\n};\\nfunction parseCSS(selector, customNames) {\\n  let tokens;\\n  try {\\n    tokens = tokenize(selector);\\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\\n      tokens.push(new EOFToken());\\n  } catch (e) {\\n    const newMessage = e.message + ` while parsing selector \\\"${selector}\\\"`;\\n    const index = (e.stack || \\\"\\\").indexOf(e.message);\\n    if (index !== -1)\\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\\n    e.message = newMessage;\\n    throw e;\\n  }\\n  const unsupportedToken = tokens.find((token) => {\\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || token instanceof URLToken || token instanceof PercentageToken;\\n  });\\n  if (unsupportedToken)\\n    throw new InvalidSelectorError(`Unsupported token \\\"${unsupportedToken.toSource()}\\\" while parsing selector \\\"${selector}\\\"`);\\n  let pos = 0;\\n  const names = /* @__PURE__ */ new Set();\\n  function unexpected() {\\n    return new InvalidSelectorError(`Unexpected token \\\"${tokens[pos].toSource()}\\\" while parsing selector \\\"${selector}\\\"`);\\n  }\\n  function skipWhitespace() {\\n    while (tokens[pos] instanceof WhitespaceToken)\\n      pos++;\\n  }\\n  function isIdent(p = pos) {\\n    return tokens[p] instanceof IdentToken;\\n  }\\n  function isString2(p = pos) {\\n    return tokens[p] instanceof StringToken;\\n  }\\n  function isNumber(p = pos) {\\n    return tokens[p] instanceof NumberToken;\\n  }\\n  function isComma(p = pos) {\\n    return tokens[p] instanceof CommaToken;\\n  }\\n  function isCloseParen(p = pos) {\\n    return tokens[p] instanceof CloseParenToken;\\n  }\\n  function isStar(p = pos) {\\n    return tokens[p] instanceof DelimToken && tokens[p].value === \\\"*\\\";\\n  }\\n  function isEOF(p = pos) {\\n    return tokens[p] instanceof EOFToken;\\n  }\\n  function isClauseCombinator(p = pos) {\\n    return tokens[p] instanceof DelimToken && [\\\">\\\", \\\"+\\\", \\\"~\\\"].includes(tokens[p].value);\\n  }\\n  function isSelectorClauseEnd(p = pos) {\\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\\n  }\\n  function consumeFunctionArguments() {\\n    const result2 = [consumeArgument()];\\n    while (true) {\\n      skipWhitespace();\\n      if (!isComma())\\n        break;\\n      pos++;\\n      result2.push(consumeArgument());\\n    }\\n    return result2;\\n  }\\n  function consumeArgument() {\\n    skipWhitespace();\\n    if (isNumber())\\n      return tokens[pos++].value;\\n    if (isString2())\\n      return tokens[pos++].value;\\n    return consumeComplexSelector();\\n  }\\n  function consumeComplexSelector() {\\n    const result2 = { simples: [] };\\n    skipWhitespace();\\n    if (isClauseCombinator()) {\\n      result2.simples.push({ selector: { functions: [{ name: \\\"scope\\\", args: [] }] }, combinator: \\\"\\\" });\\n    } else {\\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: \\\"\\\" });\\n    }\\n    while (true) {\\n      skipWhitespace();\\n      if (isClauseCombinator()) {\\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\\n        skipWhitespace();\\n      } else if (isSelectorClauseEnd()) {\\n        break;\\n      }\\n      result2.simples.push({ combinator: \\\"\\\", selector: consumeSimpleSelector() });\\n    }\\n    return result2;\\n  }\\n  function consumeSimpleSelector() {\\n    let rawCSSString = \\\"\\\";\\n    const functions = [];\\n    while (!isSelectorClauseEnd()) {\\n      if (isIdent() || isStar()) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof HashToken) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === \\\".\\\") {\\n        pos++;\\n        if (isIdent())\\n          rawCSSString += \\\".\\\" + tokens[pos++].toSource();\\n        else\\n          throw unexpected();\\n      } else if (tokens[pos] instanceof ColonToken) {\\n        pos++;\\n        if (isIdent()) {\\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\\n            rawCSSString += \\\":\\\" + tokens[pos++].toSource();\\n          } else {\\n            const name = tokens[pos++].value.toLowerCase();\\n            functions.push({ name, args: [] });\\n            names.add(name);\\n          }\\n        } else if (tokens[pos] instanceof FunctionToken) {\\n          const name = tokens[pos++].value.toLowerCase();\\n          if (!customNames.has(name)) {\\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\\n          } else {\\n            functions.push({ name, args: consumeFunctionArguments() });\\n            names.add(name);\\n          }\\n          skipWhitespace();\\n          if (!isCloseParen())\\n            throw unexpected();\\n          pos++;\\n        } else {\\n          throw unexpected();\\n        }\\n      } else if (tokens[pos] instanceof OpenSquareToken) {\\n        rawCSSString += \\\"[\\\";\\n        pos++;\\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\\n          rawCSSString += tokens[pos++].toSource();\\n        if (!(tokens[pos] instanceof CloseSquareToken))\\n          throw unexpected();\\n        rawCSSString += \\\"]\\\";\\n        pos++;\\n      } else {\\n        throw unexpected();\\n      }\\n    }\\n    if (!rawCSSString && !functions.length)\\n      throw unexpected();\\n    return { css: rawCSSString || void 0, functions };\\n  }\\n  function consumeBuiltinFunctionArguments() {\\n    let s = \\\"\\\";\\n    while (!isCloseParen() && !isEOF())\\n      s += tokens[pos++].toSource();\\n    return s;\\n  }\\n  const result = consumeFunctionArguments();\\n  if (!isEOF())\\n    throw new InvalidSelectorError(`Error while parsing selector \\\"${selector}\\\"`);\\n  if (result.some((arg) => typeof arg !== \\\"object\\\" || !(\\\"simples\\\" in arg)))\\n    throw new InvalidSelectorError(`Error while parsing selector \\\"${selector}\\\"`);\\n  return { selector: result, names: Array.from(names) };\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/selectorParser.ts\\nvar kNestedSelectorNames = /* @__PURE__ */ new Set([\\\"internal:has\\\", \\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set([\\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar customCSSNames = /* @__PURE__ */ new Set([\\\"not\\\", \\\"is\\\", \\\"where\\\", \\\"has\\\", \\\"scope\\\", \\\"light\\\", \\\"visible\\\", \\\"text\\\", \\\"text-matches\\\", \\\"text-is\\\", \\\"has-text\\\", \\\"above\\\", \\\"below\\\", \\\"right-of\\\", \\\"left-of\\\", \\\"near\\\", \\\"nth-match\\\"]);\\nfunction parseSelector(selector) {\\n  const result = parseSelectorString(selector);\\n  const parts = result.parts.map((part) => {\\n    if (part.name === \\\"css\\\" || part.name === \\\"css:light\\\") {\\n      if (part.name === \\\"css:light\\\")\\n        part.body = \\\":light(\\\" + part.body + \\\")\\\";\\n      const parsedCSS = parseCSS(part.body, customCSSNames);\\n      return {\\n        name: \\\"css\\\",\\n        body: parsedCSS.selector,\\n        source: part.body\\n      };\\n    }\\n    if (kNestedSelectorNames.has(part.name)) {\\n      let innerSelector;\\n      let distance;\\n      try {\\n        const unescaped = JSON.parse(\\\"[\\\" + part.body + \\\"]\\\");\\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== \\\"string\\\")\\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n        innerSelector = unescaped[0];\\n        if (unescaped.length === 2) {\\n          if (typeof unescaped[1] !== \\\"number\\\" || !kNestedSelectorNamesWithDistance.has(part.name))\\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n          distance = unescaped[1];\\n        }\\n      } catch (e) {\\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n      }\\n      const result2 = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\\n      if (result2.body.parsed.parts.some((part2) => part2.name === \\\"internal:control\\\" && part2.body === \\\"enter-frame\\\"))\\n        throw new InvalidSelectorError(`Frames are not allowed inside \\\"${part.name}\\\" selectors`);\\n      return result2;\\n    }\\n    return { ...part, source: part.body };\\n  });\\n  if (kNestedSelectorNames.has(parts[0].name))\\n    throw new InvalidSelectorError(`\\\"${parts[0].name}\\\" selector cannot be first`);\\n  return {\\n    capture: result.capture,\\n    parts\\n  };\\n}\\nfunction stringifySelector(selector) {\\n  if (typeof selector === \\\"string\\\")\\n    return selector;\\n  return selector.parts.map((p, i) => {\\n    const prefix = p.name === \\\"css\\\" ? \\\"\\\" : p.name + \\\"=\\\";\\n    return `${i === selector.capture ? \\\"*\\\" : \\\"\\\"}${prefix}${p.source}`;\\n  }).join(\\\" >> \\\");\\n}\\nfunction parseSelectorString(selector) {\\n  let index = 0;\\n  let quote;\\n  let start = 0;\\n  const result = { parts: [] };\\n  const append = () => {\\n    const part = selector.substring(start, index).trim();\\n    const eqIndex = part.indexOf(\\\"=\\\");\\n    let name;\\n    let body;\\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\\n      name = part.substring(0, eqIndex).trim();\\n      body = part.substring(eqIndex + 1);\\n    } else if (part.length > 1 && part[0] === '\\\"' && part[part.length - 1] === '\\\"') {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (part.length > 1 && part[0] === \\\"'\\\" && part[part.length - 1] === \\\"'\\\") {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (/^\\\\(*\\\\/\\\\//.test(part) || part.startsWith(\\\"..\\\")) {\\n      name = \\\"xpath\\\";\\n      body = part;\\n    } else {\\n      name = \\\"css\\\";\\n      body = part;\\n    }\\n    let capture = false;\\n    if (name[0] === \\\"*\\\") {\\n      capture = true;\\n      name = name.substring(1);\\n    }\\n    result.parts.push({ name, body });\\n    if (capture) {\\n      if (result.capture !== void 0)\\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\\n      result.capture = result.parts.length - 1;\\n    }\\n  };\\n  if (!selector.includes(\\\">>\\\")) {\\n    index = selector.length;\\n    append();\\n    return result;\\n  }\\n  const shouldIgnoreTextSelectorQuote = () => {\\n    const prefix = selector.substring(start, index);\\n    const match = prefix.match(/^\\\\s*text\\\\s*=(.*)$/);\\n    return !!match && !!match[1];\\n  };\\n  while (index < selector.length) {\\n    const c = selector[index];\\n    if (c === \\\"\\\\\\\\\\\" && index + 1 < selector.length) {\\n      index += 2;\\n    } else if (c === quote) {\\n      quote = void 0;\\n      index++;\\n    } else if (!quote && (c === '\\\"' || c === \\\"'\\\" || c === \\\"`\\\") && !shouldIgnoreTextSelectorQuote()) {\\n      quote = c;\\n      index++;\\n    } else if (!quote && c === \\\">\\\" && selector[index + 1] === \\\">\\\") {\\n      append();\\n      index += 2;\\n      start = index;\\n    } else {\\n      index++;\\n    }\\n  }\\n  append();\\n  return result;\\n}\\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\\n  let wp = 0;\\n  let EOL = selector.length === 0;\\n  const next = () => selector[wp] || \\\"\\\";\\n  const eat1 = () => {\\n    const result2 = next();\\n    ++wp;\\n    EOL = wp >= selector.length;\\n    return result2;\\n  };\\n  const syntaxError = (stage) => {\\n    if (EOL)\\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\\\`${selector}\\\\``);\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - unexpected symbol \\\"${next()}\\\" at position ${wp}` + (stage ? \\\" during \\\" + stage : \\\"\\\"));\\n  };\\n  function skipSpaces() {\\n    while (!EOL && /\\\\s/.test(next()))\\n      eat1();\\n  }\\n  function isCSSNameChar(char) {\\n    return char >= \\\"\\\\x80\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char >= \\\"A\\\" && char <= \\\"Z\\\" || char >= \\\"a\\\" && char <= \\\"z\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char === \\\"_\\\" || char === \\\"-\\\";\\n  }\\n  function readIdentifier() {\\n    let result2 = \\\"\\\";\\n    skipSpaces();\\n    while (!EOL && isCSSNameChar(next()))\\n      result2 += eat1();\\n    return result2;\\n  }\\n  function readQuotedString(quote) {\\n    let result2 = eat1();\\n    if (result2 !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    while (!EOL && next() !== quote) {\\n      if (next() === \\\"\\\\\\\\\\\")\\n        eat1();\\n      result2 += eat1();\\n    }\\n    if (next() !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    result2 += eat1();\\n    return result2;\\n  }\\n  function readRegularExpression() {\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let source = \\\"\\\";\\n    let inClass = false;\\n    while (!EOL) {\\n      if (next() === \\\"\\\\\\\\\\\") {\\n        source += eat1();\\n        if (EOL)\\n          syntaxError(\\\"parsing regular expressiion\\\");\\n      } else if (inClass && next() === \\\"]\\\") {\\n        inClass = false;\\n      } else if (!inClass && next() === \\\"[\\\") {\\n        inClass = true;\\n      } else if (!inClass && next() === \\\"/\\\") {\\n        break;\\n      }\\n      source += eat1();\\n    }\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let flags = \\\"\\\";\\n    while (!EOL && next().match(/[dgimsuy]/))\\n      flags += eat1();\\n    try {\\n      return new RegExp(source, flags);\\n    } catch (e) {\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\`: ${e.message}`);\\n    }\\n  }\\n  function readAttributeToken() {\\n    let token = \\\"\\\";\\n    skipSpaces();\\n    if (next() === `'` || next() === `\\\"`)\\n      token = readQuotedString(next()).slice(1, -1);\\n    else\\n      token = readIdentifier();\\n    if (!token)\\n      syntaxError(\\\"parsing property path\\\");\\n    return token;\\n  }\\n  function readOperator() {\\n    skipSpaces();\\n    let op = \\\"\\\";\\n    if (!EOL)\\n      op += eat1();\\n    if (!EOL && op !== \\\"=\\\")\\n      op += eat1();\\n    if (![\\\"=\\\", \\\"*=\\\", \\\"^=\\\", \\\"$=\\\", \\\"|=\\\", \\\"~=\\\"].includes(op))\\n      syntaxError(\\\"parsing operator\\\");\\n    return op;\\n  }\\n  function readAttribute() {\\n    eat1();\\n    const jsonPath = [];\\n    jsonPath.push(readAttributeToken());\\n    skipSpaces();\\n    while (next() === \\\".\\\") {\\n      eat1();\\n      jsonPath.push(readAttributeToken());\\n      skipSpaces();\\n    }\\n    if (next() === \\\"]\\\") {\\n      eat1();\\n      return { name: jsonPath.join(\\\".\\\"), jsonPath, op: \\\"<truthy>\\\", value: null, caseSensitive: false };\\n    }\\n    const operator = readOperator();\\n    let value = void 0;\\n    let caseSensitive = true;\\n    skipSpaces();\\n    if (next() === \\\"/\\\") {\\n      if (operator !== \\\"=\\\")\\n        throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with regular expression`);\\n      value = readRegularExpression();\\n    } else if (next() === `'` || next() === `\\\"`) {\\n      value = readQuotedString(next()).slice(1, -1);\\n      skipSpaces();\\n      if (next() === \\\"i\\\" || next() === \\\"I\\\") {\\n        caseSensitive = false;\\n        eat1();\\n      } else if (next() === \\\"s\\\" || next() === \\\"S\\\") {\\n        caseSensitive = true;\\n        eat1();\\n      }\\n    } else {\\n      value = \\\"\\\";\\n      while (!EOL && (isCSSNameChar(next()) || next() === \\\"+\\\" || next() === \\\".\\\"))\\n        value += eat1();\\n      if (value === \\\"true\\\") {\\n        value = true;\\n      } else if (value === \\\"false\\\") {\\n        value = false;\\n      } else {\\n        if (!allowUnquotedStrings) {\\n          value = +value;\\n          if (Number.isNaN(value))\\n            syntaxError(\\\"parsing attribute value\\\");\\n        }\\n      }\\n    }\\n    skipSpaces();\\n    if (next() !== \\\"]\\\")\\n      syntaxError(\\\"parsing attribute value\\\");\\n    eat1();\\n    if (operator !== \\\"=\\\" && typeof value !== \\\"string\\\")\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\\n    return { name: jsonPath.join(\\\".\\\"), jsonPath, op: operator, value, caseSensitive };\\n  }\\n  const result = {\\n    name: \\\"\\\",\\n    attributes: []\\n  };\\n  result.name = readIdentifier();\\n  skipSpaces();\\n  while (next() === \\\"[\\\") {\\n    result.attributes.push(readAttribute());\\n    skipSpaces();\\n  }\\n  if (!EOL)\\n    syntaxError(void 0);\\n  if (!result.name && !result.attributes.length)\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - selector cannot be empty`);\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/locatorGenerators.ts\\nfunction asLocator(lang, selector, isFrameLocator = false) {\\n  return innerAsLocator(generators[lang], parseSelector(selector), isFrameLocator);\\n}\\nfunction innerAsLocator(factory, parsed, isFrameLocator = false) {\\n  const parts = [...parsed.parts];\\n  for (let index = 0; index < parts.length - 1; index++) {\\n    if (parts[index].name === \\\"nth\\\" && parts[index + 1].name === \\\"internal:control\\\" && parts[index + 1].body === \\\"enter-frame\\\") {\\n      const [nth] = parts.splice(index, 1);\\n      parts.splice(index + 1, 0, nth);\\n    }\\n  }\\n  const tokens = [];\\n  let nextBase = isFrameLocator ? \\\"frame-locator\\\" : \\\"page\\\";\\n  for (let index = 0; index < parts.length; index++) {\\n    const part = parts[index];\\n    const base = nextBase;\\n    nextBase = \\\"locator\\\";\\n    if (part.name === \\\"nth\\\") {\\n      if (part.body === \\\"0\\\")\\n        tokens.push(factory.generateLocator(base, \\\"first\\\", \\\"\\\"));\\n      else if (part.body === \\\"-1\\\")\\n        tokens.push(factory.generateLocator(base, \\\"last\\\", \\\"\\\"));\\n      else\\n        tokens.push(factory.generateLocator(base, \\\"nth\\\", part.body));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"text\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has-text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"has-text\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has\\\") {\\n      const inner = innerAsLocator(factory, part.body.parsed);\\n      tokens.push(factory.generateLocator(base, \\\"has\\\", inner));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:label\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"label\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:role\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const options = { attrs: [] };\\n      for (const attr of attrSelector.attributes) {\\n        if (attr.name === \\\"name\\\") {\\n          options.exact = attr.caseSensitive;\\n          options.name = attr.value;\\n        } else {\\n          if (attr.name === \\\"level\\\" && typeof attr.value === \\\"string\\\")\\n            attr.value = +attr.value;\\n          options.attrs.push({ name: attr.name === \\\"include-hidden\\\" ? \\\"includeHidden\\\" : attr.name, value: attr.value });\\n        }\\n      }\\n      tokens.push(factory.generateLocator(base, \\\"role\\\", attrSelector.name, options));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:testid\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { value } = attrSelector.attributes[0];\\n      tokens.push(factory.generateLocator(base, \\\"test-id\\\", value));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:attr\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\\n      const text = value;\\n      const exact = !!caseSensitive;\\n      if (name === \\\"placeholder\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"placeholder\\\", text, { exact }));\\n        continue;\\n      }\\n      if (name === \\\"alt\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"alt\\\", text, { exact }));\\n        continue;\\n      }\\n      if (name === \\\"title\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"title\\\", text, { exact }));\\n        continue;\\n      }\\n    }\\n    let locatorType = \\\"default\\\";\\n    const nextPart = parts[index + 1];\\n    if (nextPart && nextPart.name === \\\"internal:control\\\" && nextPart.body === \\\"enter-frame\\\") {\\n      locatorType = \\\"frame\\\";\\n      nextBase = \\\"frame-locator\\\";\\n      index++;\\n    }\\n    const p = { parts: [part] };\\n    tokens.push(factory.generateLocator(base, locatorType, stringifySelector(p)));\\n  }\\n  return tokens.join(\\\".\\\");\\n}\\nfunction detectExact(text) {\\n  let exact = false;\\n  const match = text.match(/^\\\\/(.*)\\\\/([igm]*)$/);\\n  if (match)\\n    return { text: new RegExp(match[1], match[2]) };\\n  if (text.endsWith('\\\"')) {\\n    text = JSON.parse(text);\\n    exact = true;\\n  } else if (text.endsWith('\\\"s')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = true;\\n  } else if (text.endsWith('\\\"i')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = false;\\n  }\\n  return { exact, text };\\n}\\nvar JavaScriptLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name: ${options.name}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name: ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact: true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${name}: ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `getByRole(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter({ hasText: ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `filter({ has: ${body} })`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${body})`;\\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return String(body);\\n    return this.quote(body);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, \\\"'\\\");\\n  }\\n};\\nvar PythonLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frame_locator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first`;\\n      case \\\"last\\\":\\n        return `last`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name=${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name=${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact=True`);\\n        }\\n        for (const { name, value } of options.attrs) {\\n          let valueString = typeof value === \\\"string\\\" ? this.quote(value) : value;\\n          if (typeof value === \\\"boolean\\\")\\n            valueString = value ? \\\"True\\\" : \\\"False\\\";\\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\\n        }\\n        const attrString = attrs.length ? `, ${attrs.join(\\\", \\\")}` : \\\"\\\";\\n        return `get_by_role(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(has_text=${this.toHasText(body)})`;\\n      case \\\"has\\\":\\n        return `filter(has=${body})`;\\n      case \\\"test-id\\\":\\n        return `get_by_test_id(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"get_by_text\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"get_by_alt_text\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"get_by_placeholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"get_by_label\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"get_by_title\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", re.IGNORECASE\\\" : \\\"\\\";\\n    return `re.compile(r\\\"${body.source.replace(/\\\\\\\\\\\\//, \\\"/\\\").replace(/\\\"/g, '\\\\\\\\\\\"')}\\\"${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, exact=True)`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return `${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar JavaLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    let clazz;\\n    switch (base) {\\n      case \\\"page\\\":\\n        clazz = \\\"Page\\\";\\n        break;\\n      case \\\"frame-locator\\\":\\n        clazz = \\\"FrameLocator\\\";\\n        break;\\n      case \\\"locator\\\":\\n        clazz = \\\"Locator\\\";\\n        break;\\n    }\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`.setName(${this.quote(options.name)})`);\\n          if (options.exact)\\n            attrs.push(`.setExact(true)`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === \\\"string\\\" ? this.quote(value) : value})`);\\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join(\\\"\\\")}` : \\\"\\\";\\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\\n      case \\\"has\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(clazz, \\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(clazz, \\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(clazz, \\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(clazz, \\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(clazz, \\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", Pattern.CASE_INSENSITIVE\\\" : \\\"\\\";\\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\\n  }\\n  toCallWithExact(clazz, method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return this.quote(body);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar CSharpLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `Locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `FrameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `Nth(${body})`;\\n      case \\\"first\\\":\\n        return `First`;\\n      case \\\"last\\\":\\n        return `Last`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`Name = ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`Exact = true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${toTitleCase(name)} = ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, new() { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `Filter(new() { ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `Filter(new() { Has = ${body} })`;\\n      case \\\"test-id\\\":\\n        return `GetByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"GetByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"GetByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"GetByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"GetByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"GetByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", RegexOptions.IgnoreCase\\\" : \\\"\\\";\\n    return `new Regex(${this.quote(body.source)}${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return `HasTextRegex = ${this.regexToString(body)}`;\\n    return `HasText = ${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar generators = {\\n  javascript: new JavaScriptLocatorFactory(),\\n  python: new PythonLocatorFactory(),\\n  java: new JavaLocatorFactory(),\\n  csharp: new CSharpLocatorFactory()\\n};\\nfunction isRegExp(obj) {\\n  return obj instanceof RegExp;\\n}\\n\\n// packages/playwright-core/src/server/injected/domUtils.ts\\nfunction parentElementOrShadowHost(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return;\\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\\n    return element.parentNode.host;\\n}\\nfunction enclosingShadowRootOrDocument(element) {\\n  let node = element;\\n  while (node.parentNode)\\n    node = node.parentNode;\\n  if (node.nodeType === 11 || node.nodeType === 9)\\n    return node;\\n}\\nfunction enclosingShadowHost(element) {\\n  while (element.parentElement)\\n    element = element.parentElement;\\n  return parentElementOrShadowHost(element);\\n}\\nfunction closestCrossShadow(element, css) {\\n  while (element) {\\n    const closest = element.closest(css);\\n    if (closest)\\n      return closest;\\n    element = enclosingShadowHost(element);\\n  }\\n}\\nfunction getElementComputedStyle(element, pseudo) {\\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\\n}\\nfunction isElementStyleVisibilityVisible(element, style) {\\n  style = style != null ? style : getElementComputedStyle(element);\\n  if (!style)\\n    return true;\\n  if (Element.prototype.checkVisibility) {\\n    if (!element.checkVisibility({ checkOpacity: false, checkVisibilityCSS: false }))\\n      return false;\\n  } else {\\n    const detailsOrSummary = element.closest(\\\"details,summary\\\");\\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === \\\"DETAILS\\\" && !detailsOrSummary.open)\\n      return false;\\n  }\\n  if (style.visibility !== \\\"visible\\\")\\n    return false;\\n  return true;\\n}\\n\\n// packages/playwright-core/src/server/injected/roleUtils.ts\\nfunction hasExplicitAccessibleName(e) {\\n  return e.hasAttribute(\\\"aria-label\\\") || e.hasAttribute(\\\"aria-labelledby\\\");\\n}\\nvar kAncestorPreventingLandmark = \\\"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\\\";\\nvar kGlobalAriaAttributes = [\\n  \\\"aria-atomic\\\",\\n  \\\"aria-busy\\\",\\n  \\\"aria-controls\\\",\\n  \\\"aria-current\\\",\\n  \\\"aria-describedby\\\",\\n  \\\"aria-details\\\",\\n  \\\"aria-disabled\\\",\\n  \\\"aria-dropeffect\\\",\\n  \\\"aria-errormessage\\\",\\n  \\\"aria-flowto\\\",\\n  \\\"aria-grabbed\\\",\\n  \\\"aria-haspopup\\\",\\n  \\\"aria-hidden\\\",\\n  \\\"aria-invalid\\\",\\n  \\\"aria-keyshortcuts\\\",\\n  \\\"aria-label\\\",\\n  \\\"aria-labelledby\\\",\\n  \\\"aria-live\\\",\\n  \\\"aria-owns\\\",\\n  \\\"aria-relevant\\\",\\n  \\\"aria-roledescription\\\"\\n];\\nfunction hasGlobalAriaAttribute(e) {\\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\\n}\\nvar kImplicitRoleByTagName = {\\n  \\\"A\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"AREA\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"ARTICLE\\\": () => \\\"article\\\",\\n  \\\"ASIDE\\\": () => \\\"complementary\\\",\\n  \\\"BLOCKQUOTE\\\": () => \\\"blockquote\\\",\\n  \\\"BUTTON\\\": () => \\\"button\\\",\\n  \\\"CAPTION\\\": () => \\\"caption\\\",\\n  \\\"CODE\\\": () => \\\"code\\\",\\n  \\\"DATALIST\\\": () => \\\"listbox\\\",\\n  \\\"DD\\\": () => \\\"definition\\\",\\n  \\\"DEL\\\": () => \\\"deletion\\\",\\n  \\\"DETAILS\\\": () => \\\"group\\\",\\n  \\\"DFN\\\": () => \\\"term\\\",\\n  \\\"DIALOG\\\": () => \\\"dialog\\\",\\n  \\\"DT\\\": () => \\\"term\\\",\\n  \\\"EM\\\": () => \\\"emphasis\\\",\\n  \\\"FIELDSET\\\": () => \\\"group\\\",\\n  \\\"FIGURE\\\": () => \\\"figure\\\",\\n  \\\"FOOTER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"contentinfo\\\",\\n  \\\"FORM\\\": (e) => hasExplicitAccessibleName(e) ? \\\"form\\\" : null,\\n  \\\"H1\\\": () => \\\"heading\\\",\\n  \\\"H2\\\": () => \\\"heading\\\",\\n  \\\"H3\\\": () => \\\"heading\\\",\\n  \\\"H4\\\": () => \\\"heading\\\",\\n  \\\"H5\\\": () => \\\"heading\\\",\\n  \\\"H6\\\": () => \\\"heading\\\",\\n  \\\"HEADER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"banner\\\",\\n  \\\"HR\\\": () => \\\"separator\\\",\\n  \\\"HTML\\\": () => \\\"document\\\",\\n  \\\"IMG\\\": (e) => e.getAttribute(\\\"alt\\\") === \\\"\\\" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute(\\\"tabindex\\\")))) ? \\\"presentation\\\" : \\\"img\\\",\\n  \\\"INPUT\\\": (e) => {\\n    const type = e.type.toLowerCase();\\n    if (type === \\\"search\\\")\\n      return e.hasAttribute(\\\"list\\\") ? \\\"combobox\\\" : \\\"searchbox\\\";\\n    if ([\\\"email\\\", \\\"tel\\\", \\\"text\\\", \\\"url\\\", \\\"\\\"].includes(type)) {\\n      const list = getIdRefs(e, e.getAttribute(\\\"list\\\"))[0];\\n      return list && list.tagName === \\\"DATALIST\\\" ? \\\"combobox\\\" : \\\"textbox\\\";\\n    }\\n    if (type === \\\"hidden\\\")\\n      return \\\"\\\";\\n    return {\\n      \\\"button\\\": \\\"button\\\",\\n      \\\"checkbox\\\": \\\"checkbox\\\",\\n      \\\"image\\\": \\\"button\\\",\\n      \\\"number\\\": \\\"spinbutton\\\",\\n      \\\"radio\\\": \\\"radio\\\",\\n      \\\"range\\\": \\\"slider\\\",\\n      \\\"reset\\\": \\\"button\\\",\\n      \\\"submit\\\": \\\"button\\\"\\n    }[type] || \\\"textbox\\\";\\n  },\\n  \\\"INS\\\": () => \\\"insertion\\\",\\n  \\\"LI\\\": () => \\\"listitem\\\",\\n  \\\"MAIN\\\": () => \\\"main\\\",\\n  \\\"MARK\\\": () => \\\"mark\\\",\\n  \\\"MATH\\\": () => \\\"math\\\",\\n  \\\"MENU\\\": () => \\\"list\\\",\\n  \\\"METER\\\": () => \\\"meter\\\",\\n  \\\"NAV\\\": () => \\\"navigation\\\",\\n  \\\"OL\\\": () => \\\"list\\\",\\n  \\\"OPTGROUP\\\": () => \\\"group\\\",\\n  \\\"OPTION\\\": () => \\\"option\\\",\\n  \\\"OUTPUT\\\": () => \\\"status\\\",\\n  \\\"P\\\": () => \\\"paragraph\\\",\\n  \\\"PROGRESS\\\": () => \\\"progressbar\\\",\\n  \\\"SECTION\\\": (e) => hasExplicitAccessibleName(e) ? \\\"region\\\" : null,\\n  \\\"SELECT\\\": (e) => e.hasAttribute(\\\"multiple\\\") || e.size > 1 ? \\\"listbox\\\" : \\\"combobox\\\",\\n  \\\"STRONG\\\": () => \\\"strong\\\",\\n  \\\"SUB\\\": () => \\\"subscript\\\",\\n  \\\"SUP\\\": () => \\\"superscript\\\",\\n  \\\"TABLE\\\": () => \\\"table\\\",\\n  \\\"TBODY\\\": () => \\\"rowgroup\\\",\\n  \\\"TD\\\": (e) => {\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"TEXTAREA\\\": () => \\\"textbox\\\",\\n  \\\"TFOOT\\\": () => \\\"rowgroup\\\",\\n  \\\"TH\\\": (e) => {\\n    if (e.getAttribute(\\\"scope\\\") === \\\"col\\\")\\n      return \\\"columnheader\\\";\\n    if (e.getAttribute(\\\"scope\\\") === \\\"row\\\")\\n      return \\\"rowheader\\\";\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"THEAD\\\": () => \\\"rowgroup\\\",\\n  \\\"TIME\\\": () => \\\"time\\\",\\n  \\\"TR\\\": () => \\\"row\\\",\\n  \\\"UL\\\": () => \\\"list\\\"\\n};\\nvar kPresentationInheritanceParents = {\\n  \\\"DD\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"DIV\\\": [\\\"DL\\\"],\\n  \\\"DT\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"LI\\\": [\\\"OL\\\", \\\"UL\\\"],\\n  \\\"TBODY\\\": [\\\"TABLE\\\"],\\n  \\\"TD\\\": [\\\"TR\\\"],\\n  \\\"TFOOT\\\": [\\\"TABLE\\\"],\\n  \\\"TH\\\": [\\\"TR\\\"],\\n  \\\"THEAD\\\": [\\\"TABLE\\\"],\\n  \\\"TR\\\": [\\\"THEAD\\\", \\\"TBODY\\\", \\\"TFOOT\\\", \\\"TABLE\\\"]\\n};\\nfunction getImplicitAriaRole(element) {\\n  var _a;\\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \\\"\\\";\\n  if (!implicitRole)\\n    return null;\\n  let ancestor = element;\\n  while (ancestor) {\\n    const parent = parentElementOrShadowHost(ancestor);\\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\\n    if (!parents || !parent || !parents.includes(parent.tagName))\\n      break;\\n    const parentExplicitRole = getExplicitAriaRole(parent);\\n    if ((parentExplicitRole === \\\"none\\\" || parentExplicitRole === \\\"presentation\\\") && !hasPresentationConflictResolution(parent))\\n      return parentExplicitRole;\\n    ancestor = parent;\\n  }\\n  return implicitRole;\\n}\\nvar allRoles = [\\n  \\\"alert\\\",\\n  \\\"alertdialog\\\",\\n  \\\"application\\\",\\n  \\\"article\\\",\\n  \\\"banner\\\",\\n  \\\"blockquote\\\",\\n  \\\"button\\\",\\n  \\\"caption\\\",\\n  \\\"cell\\\",\\n  \\\"checkbox\\\",\\n  \\\"code\\\",\\n  \\\"columnheader\\\",\\n  \\\"combobox\\\",\\n  \\\"command\\\",\\n  \\\"complementary\\\",\\n  \\\"composite\\\",\\n  \\\"contentinfo\\\",\\n  \\\"definition\\\",\\n  \\\"deletion\\\",\\n  \\\"dialog\\\",\\n  \\\"directory\\\",\\n  \\\"document\\\",\\n  \\\"emphasis\\\",\\n  \\\"feed\\\",\\n  \\\"figure\\\",\\n  \\\"form\\\",\\n  \\\"generic\\\",\\n  \\\"grid\\\",\\n  \\\"gridcell\\\",\\n  \\\"group\\\",\\n  \\\"heading\\\",\\n  \\\"img\\\",\\n  \\\"input\\\",\\n  \\\"insertion\\\",\\n  \\\"landmark\\\",\\n  \\\"link\\\",\\n  \\\"list\\\",\\n  \\\"listbox\\\",\\n  \\\"listitem\\\",\\n  \\\"log\\\",\\n  \\\"main\\\",\\n  \\\"marquee\\\",\\n  \\\"math\\\",\\n  \\\"meter\\\",\\n  \\\"menu\\\",\\n  \\\"menubar\\\",\\n  \\\"menuitem\\\",\\n  \\\"menuitemcheckbox\\\",\\n  \\\"menuitemradio\\\",\\n  \\\"navigation\\\",\\n  \\\"none\\\",\\n  \\\"note\\\",\\n  \\\"option\\\",\\n  \\\"paragraph\\\",\\n  \\\"presentation\\\",\\n  \\\"progressbar\\\",\\n  \\\"radio\\\",\\n  \\\"radiogroup\\\",\\n  \\\"range\\\",\\n  \\\"region\\\",\\n  \\\"roletype\\\",\\n  \\\"row\\\",\\n  \\\"rowgroup\\\",\\n  \\\"rowheader\\\",\\n  \\\"scrollbar\\\",\\n  \\\"search\\\",\\n  \\\"searchbox\\\",\\n  \\\"section\\\",\\n  \\\"sectionhead\\\",\\n  \\\"select\\\",\\n  \\\"separator\\\",\\n  \\\"slider\\\",\\n  \\\"spinbutton\\\",\\n  \\\"status\\\",\\n  \\\"strong\\\",\\n  \\\"structure\\\",\\n  \\\"subscript\\\",\\n  \\\"superscript\\\",\\n  \\\"switch\\\",\\n  \\\"tab\\\",\\n  \\\"table\\\",\\n  \\\"tablist\\\",\\n  \\\"tabpanel\\\",\\n  \\\"term\\\",\\n  \\\"textbox\\\",\\n  \\\"time\\\",\\n  \\\"timer\\\",\\n  \\\"toolbar\\\",\\n  \\\"tooltip\\\",\\n  \\\"tree\\\",\\n  \\\"treegrid\\\",\\n  \\\"treeitem\\\",\\n  \\\"widget\\\",\\n  \\\"window\\\"\\n];\\nvar abstractRoles = [\\\"command\\\", \\\"composite\\\", \\\"input\\\", \\\"landmark\\\", \\\"range\\\", \\\"roletype\\\", \\\"section\\\", \\\"sectionhead\\\", \\\"select\\\", \\\"structure\\\", \\\"widget\\\", \\\"window\\\"];\\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\\nfunction getExplicitAriaRole(element) {\\n  const roles = (element.getAttribute(\\\"role\\\") || \\\"\\\").split(\\\" \\\").map((role) => role.trim());\\n  return roles.find((role) => validRoles.includes(role)) || null;\\n}\\nfunction hasPresentationConflictResolution(element) {\\n  return !hasGlobalAriaAttribute(element);\\n}\\nfunction getAriaRole(element) {\\n  const explicitRole = getExplicitAriaRole(element);\\n  if (!explicitRole)\\n    return getImplicitAriaRole(element);\\n  if ((explicitRole === \\\"none\\\" || explicitRole === \\\"presentation\\\") && hasPresentationConflictResolution(element))\\n    return getImplicitAriaRole(element);\\n  return explicitRole;\\n}\\nfunction getAriaBoolean(attr) {\\n  return attr === null ? void 0 : attr.toLowerCase() === \\\"true\\\";\\n}\\nfunction isElementHiddenForAria(element, cache) {\\n  if ([\\\"STYLE\\\", \\\"SCRIPT\\\", \\\"NOSCRIPT\\\", \\\"TEMPLATE\\\"].includes(element.tagName))\\n    return true;\\n  const isOptionInsideSelect = element.nodeName === \\\"OPTION\\\" && !!element.closest(\\\"select\\\");\\n  const isSlot = element.nodeName === \\\"SLOT\\\";\\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element))\\n    return true;\\n  return belongsToDisplayNoneOrAriaHidden(element, cache);\\n}\\nfunction belongsToDisplayNoneOrAriaHidden(element, cache) {\\n  if (!cache.has(element)) {\\n    const style = getElementComputedStyle(element);\\n    let hidden = !style || style.display === \\\"none\\\" || getAriaBoolean(element.getAttribute(\\\"aria-hidden\\\")) === true;\\n    if (!hidden) {\\n      const parent = parentElementOrShadowHost(element);\\n      if (parent)\\n        hidden = hidden || belongsToDisplayNoneOrAriaHidden(parent, cache);\\n    }\\n    cache.set(element, hidden);\\n  }\\n  return cache.get(element);\\n}\\nfunction getIdRefs(element, ref) {\\n  if (!ref)\\n    return [];\\n  const root = enclosingShadowRootOrDocument(element);\\n  if (!root)\\n    return [];\\n  try {\\n    const ids = ref.split(\\\" \\\").filter((id) => !!id);\\n    const set = /* @__PURE__ */ new Set();\\n    for (const id of ids) {\\n      const firstElement = root.querySelector(\\\"#\\\" + CSS.escape(id));\\n      if (firstElement)\\n        set.add(firstElement);\\n    }\\n    return [...set];\\n  } catch (e) {\\n    return [];\\n  }\\n}\\nfunction normalizeAccessbileName(s) {\\n  return s.replace(/\\\\r\\\\n/g, \\\"\\\\n\\\").replace(/\\\\u00A0/g, \\\" \\\").replace(/\\\\s\\\\s+/g, \\\" \\\").trim();\\n}\\nfunction queryInAriaOwned(element, selector) {\\n  const result = [...element.querySelectorAll(selector)];\\n  for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\"))) {\\n    if (owned.matches(selector))\\n      result.push(owned);\\n    result.push(...owned.querySelectorAll(selector));\\n  }\\n  return result;\\n}\\nfunction getPseudoContent(pseudoStyle) {\\n  if (!pseudoStyle)\\n    return \\\"\\\";\\n  const content = pseudoStyle.getPropertyValue(\\\"content\\\");\\n  if (content[0] === \\\"'\\\" && content[content.length - 1] === \\\"'\\\" || content[0] === '\\\"' && content[content.length - 1] === '\\\"') {\\n    const unquoted = content.substring(1, content.length - 1);\\n    const display = pseudoStyle.getPropertyValue(\\\"display\\\") || \\\"inline\\\";\\n    if (display !== \\\"inline\\\")\\n      return \\\" \\\" + unquoted + \\\" \\\";\\n    return unquoted;\\n  }\\n  return \\\"\\\";\\n}\\nfunction getAriaLabelledByElements(element) {\\n  const ref = element.getAttribute(\\\"aria-labelledby\\\");\\n  if (ref === null)\\n    return null;\\n  return getIdRefs(element, ref);\\n}\\nfunction allowsNameFromContent(role, targetDescendant) {\\n  const alwaysAllowsNameFromContent = [\\\"button\\\", \\\"cell\\\", \\\"checkbox\\\", \\\"columnheader\\\", \\\"gridcell\\\", \\\"heading\\\", \\\"link\\\", \\\"menuitem\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"option\\\", \\\"radio\\\", \\\"row\\\", \\\"rowheader\\\", \\\"switch\\\", \\\"tab\\\", \\\"tooltip\\\", \\\"treeitem\\\"].includes(role);\\n  const descendantAllowsNameFromContent = targetDescendant && [\\\"\\\", \\\"caption\\\", \\\"code\\\", \\\"contentinfo\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"insertion\\\", \\\"list\\\", \\\"listitem\\\", \\\"mark\\\", \\\"none\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"region\\\", \\\"row\\\", \\\"rowgroup\\\", \\\"section\\\", \\\"strong\\\", \\\"subscript\\\", \\\"superscript\\\", \\\"table\\\", \\\"term\\\", \\\"time\\\"].includes(role);\\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\\n}\\nfunction getElementAccessibleName(element, includeHidden, hiddenCache) {\\n  const elementProhibitsNaming = [\\\"caption\\\", \\\"code\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"generic\\\", \\\"insertion\\\", \\\"mark\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"strong\\\", \\\"subscript\\\", \\\"suggestion\\\", \\\"superscript\\\", \\\"term\\\", \\\"time\\\"].includes(getAriaRole(element) || \\\"\\\");\\n  if (elementProhibitsNaming)\\n    return \\\"\\\";\\n  const accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\\n    includeHidden,\\n    hiddenCache,\\n    visitedElements: /* @__PURE__ */ new Set(),\\n    embeddedInLabelledBy: \\\"none\\\",\\n    embeddedInLabel: \\\"none\\\",\\n    embeddedInTextAlternativeElement: false,\\n    embeddedInTargetElement: \\\"self\\\"\\n  }));\\n  return accessibleName;\\n}\\nfunction getElementAccessibleNameInternal(element, options) {\\n  if (options.visitedElements.has(element))\\n    return \\\"\\\";\\n  const childOptions = {\\n    ...options,\\n    embeddedInLabel: options.embeddedInLabel === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInLabel,\\n    embeddedInLabelledBy: options.embeddedInLabelledBy === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInLabelledBy,\\n    embeddedInTargetElement: options.embeddedInTargetElement === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInTargetElement\\n  };\\n  if (!options.includeHidden && options.embeddedInLabelledBy !== \\\"self\\\" && isElementHiddenForAria(element, options.hiddenCache)) {\\n    options.visitedElements.add(element);\\n    return \\\"\\\";\\n  }\\n  if (options.embeddedInLabelledBy === \\\"none\\\") {\\n    const refs = getAriaLabelledByElements(element) || [];\\n    const accessibleName = refs.map((ref) => getElementAccessibleNameInternal(ref, {\\n      ...options,\\n      embeddedInLabelledBy: \\\"self\\\",\\n      embeddedInTargetElement: \\\"none\\\",\\n      embeddedInLabel: \\\"none\\\",\\n      embeddedInTextAlternativeElement: false\\n    })).join(\\\" \\\");\\n    if (accessibleName)\\n      return accessibleName;\\n  }\\n  const role = getAriaRole(element) || \\\"\\\";\\n  if (options.embeddedInLabel !== \\\"none\\\" || options.embeddedInLabelledBy !== \\\"none\\\") {\\n    const isOwnLabel = [...element.labels || []].includes(element);\\n    const isOwnLabelledBy = getIdRefs(element, element.getAttribute(\\\"aria-labelledby\\\")).includes(element);\\n    if (!isOwnLabel && !isOwnLabelledBy) {\\n      if (role === \\\"textbox\\\") {\\n        options.visitedElements.add(element);\\n        if (element.tagName === \\\"INPUT\\\" || element.tagName === \\\"TEXTAREA\\\")\\n          return element.value;\\n        return element.textContent || \\\"\\\";\\n      }\\n      if ([\\\"combobox\\\", \\\"listbox\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        let selectedOptions;\\n        if (element.tagName === \\\"SELECT\\\") {\\n          selectedOptions = [...element.selectedOptions];\\n          if (!selectedOptions.length && element.options.length)\\n            selectedOptions.push(element.options[0]);\\n        } else {\\n          const listbox = role === \\\"combobox\\\" ? queryInAriaOwned(element, \\\"*\\\").find((e) => getAriaRole(e) === \\\"listbox\\\") : element;\\n          selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\\\"true\\\"]').filter((e) => getAriaRole(e) === \\\"option\\\") : [];\\n        }\\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(\\\" \\\");\\n      }\\n      if ([\\\"progressbar\\\", \\\"scrollbar\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"meter\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        if (element.hasAttribute(\\\"aria-valuetext\\\"))\\n          return element.getAttribute(\\\"aria-valuetext\\\") || \\\"\\\";\\n        if (element.hasAttribute(\\\"aria-valuenow\\\"))\\n          return element.getAttribute(\\\"aria-valuenow\\\") || \\\"\\\";\\n        return element.getAttribute(\\\"value\\\") || \\\"\\\";\\n      }\\n      if ([\\\"menu\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        return \\\"\\\";\\n      }\\n    }\\n  }\\n  const ariaLabel = element.getAttribute(\\\"aria-label\\\") || \\\"\\\";\\n  if (ariaLabel.trim()) {\\n    options.visitedElements.add(element);\\n    return ariaLabel;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role)) {\\n    if (element.tagName === \\\"INPUT\\\" && [\\\"button\\\", \\\"submit\\\", \\\"reset\\\"].includes(element.type)) {\\n      options.visitedElements.add(element);\\n      const value = element.value || \\\"\\\";\\n      if (value.trim())\\n        return value;\\n      if (element.type === \\\"submit\\\")\\n        return \\\"Submit\\\";\\n      if (element.type === \\\"reset\\\")\\n        return \\\"Reset\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"INPUT\\\" && element.type === \\\"image\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const labels = element.labels || [];\\n      if (labels.length) {\\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\\n          ...options,\\n          embeddedInLabel: \\\"self\\\",\\n          embeddedInTextAlternativeElement: false,\\n          embeddedInLabelledBy: \\\"none\\\",\\n          embeddedInTargetElement: \\\"none\\\"\\n        })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (title.trim())\\n        return title;\\n      return \\\"Submit\\\";\\n    }\\n    if (element.tagName === \\\"TEXTAREA\\\" || element.tagName === \\\"SELECT\\\" || element.tagName === \\\"INPUT\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length) {\\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\\n          ...options,\\n          embeddedInLabel: \\\"self\\\",\\n          embeddedInTextAlternativeElement: false,\\n          embeddedInLabelledBy: \\\"none\\\",\\n          embeddedInTargetElement: \\\"none\\\"\\n        })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n      }\\n      const usePlaceholder = element.tagName === \\\"INPUT\\\" && [\\\"text\\\", \\\"password\\\", \\\"search\\\", \\\"tel\\\", \\\"email\\\", \\\"url\\\"].includes(element.type) || element.tagName === \\\"TEXTAREA\\\";\\n      const placeholder = element.getAttribute(\\\"placeholder\\\") || \\\"\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (!usePlaceholder || title)\\n        return title;\\n      return placeholder;\\n    }\\n    if (element.tagName === \\\"FIELDSET\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"LEGEND\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"FIGURE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"FIGCAPTION\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"IMG\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"TABLE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"CAPTION\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const summary = element.getAttribute(\\\"summary\\\") || \\\"\\\";\\n      if (summary)\\n        return summary;\\n    }\\n    if (element.tagName === \\\"AREA\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"SVG\\\" && element.ownerSVGElement) {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"TITLE\\\" && element.ownerSVGElement) {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n    }\\n  }\\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === \\\"descendant\\\") || options.embeddedInLabelledBy !== \\\"none\\\" || options.embeddedInLabel !== \\\"none\\\" || options.embeddedInTextAlternativeElement) {\\n    options.visitedElements.add(element);\\n    const tokens = [];\\n    const visit = (node, skipSlotted) => {\\n      var _a;\\n      if (skipSlotted && node.assignedSlot)\\n        return;\\n      if (node.nodeType === 1) {\\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.getPropertyValue(\\\"display\\\")) || \\\"inline\\\";\\n        let token = getElementAccessibleNameInternal(node, childOptions);\\n        if (display !== \\\"inline\\\" || node.nodeName === \\\"BR\\\")\\n          token = \\\" \\\" + token + \\\" \\\";\\n        tokens.push(token);\\n      } else if (node.nodeType === 3) {\\n        tokens.push(node.textContent || \\\"\\\");\\n      }\\n    };\\n    tokens.push(getPseudoContent(getElementComputedStyle(element, \\\"::before\\\")));\\n    const assignedNodes = element.nodeName === \\\"SLOT\\\" ? element.assignedNodes() : [];\\n    if (assignedNodes.length) {\\n      for (const child of assignedNodes)\\n        visit(child, false);\\n    } else {\\n      for (let child = element.firstChild; child; child = child.nextSibling)\\n        visit(child, true);\\n      if (element.shadowRoot) {\\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\\n          visit(child, true);\\n      }\\n      for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\")))\\n        visit(owned, true);\\n    }\\n    tokens.push(getPseudoContent(getElementComputedStyle(element, \\\"::after\\\")));\\n    const accessibleName = tokens.join(\\\"\\\");\\n    if (accessibleName.trim())\\n      return accessibleName;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role) || element.tagName === \\\"IFRAME\\\") {\\n    options.visitedElements.add(element);\\n    const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n    if (title.trim())\\n      return title;\\n  }\\n  options.visitedElements.add(element);\\n  return \\\"\\\";\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorUtils.ts\\nfunction shouldSkipForTextMatching(element) {\\n  return element.nodeName === \\\"SCRIPT\\\" || element.nodeName === \\\"NOSCRIPT\\\" || element.nodeName === \\\"STYLE\\\" || document.head && document.head.contains(element);\\n}\\nfunction elementText(cache, root) {\\n  let value = cache.get(root);\\n  if (value === void 0) {\\n    value = { full: \\\"\\\", immediate: [] };\\n    if (!shouldSkipForTextMatching(root)) {\\n      let currentImmediate = \\\"\\\";\\n      if (root instanceof HTMLInputElement && (root.type === \\\"submit\\\" || root.type === \\\"button\\\")) {\\n        value = { full: root.value, immediate: [root.value] };\\n      } else {\\n        for (let child = root.firstChild; child; child = child.nextSibling) {\\n          if (child.nodeType === Node.TEXT_NODE) {\\n            value.full += child.nodeValue || \\\"\\\";\\n            currentImmediate += child.nodeValue || \\\"\\\";\\n          } else {\\n            if (currentImmediate)\\n              value.immediate.push(currentImmediate);\\n            currentImmediate = \\\"\\\";\\n            if (child.nodeType === Node.ELEMENT_NODE)\\n              value.full += elementText(cache, child).full;\\n          }\\n        }\\n        if (currentImmediate)\\n          value.immediate.push(currentImmediate);\\n        if (root.shadowRoot)\\n          value.full += elementText(cache, root.shadowRoot).full;\\n      }\\n    }\\n    cache.set(root, value);\\n  }\\n  return value;\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\\nvar cacheAllowText = /* @__PURE__ */ new Map();\\nvar cacheDisallowText = /* @__PURE__ */ new Map();\\nvar kTextScoreRange = 10;\\nvar kExactPenalty = kTextScoreRange / 2;\\nvar kTestIdScore = 1;\\nvar kOtherTestIdScore = 2;\\nvar kIframeByAttributeScore = 10;\\nvar kBeginPenalizedScore = 50;\\nvar kPlaceholderScore = 100;\\nvar kLabelScore = 120;\\nvar kRoleWithNameScore = 140;\\nvar kAltTextScore = 160;\\nvar kTextScore = 180;\\nvar kTitleScore = 200;\\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\\nvar kTextScoreExact = kTextScore + kExactPenalty;\\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\\nvar kEndPenalizedScore = 300;\\nvar kCSSIdScore = 500;\\nvar kRoleWithoutNameScore = 510;\\nvar kCSSInputTypeNameScore = 520;\\nvar kCSSTagNameScore = 530;\\nvar kNthScore = 1e4;\\nvar kCSSFallbackScore = 1e7;\\nfunction generateSelector(injectedScript, targetElement, testIdAttributeName) {\\n  injectedScript._evaluator.begin();\\n  try {\\n    targetElement = targetElement.closest(\\\"button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]\\\") || targetElement;\\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, testIdAttributeName);\\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement);\\n    const selector = joinTokens(bestTokens);\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    return {\\n      selector,\\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\\n    };\\n  } finally {\\n    cacheAllowText.clear();\\n    cacheDisallowText.clear();\\n    injectedScript._evaluator.end();\\n  }\\n}\\nfunction filterRegexTokens(textCandidates) {\\n  return textCandidates.filter((c) => c[0].selector[0] !== \\\"/\\\");\\n}\\nfunction generateSelectorFor(injectedScript, targetElement, testIdAttributeName) {\\n  if (targetElement.ownerDocument.documentElement === targetElement)\\n    return [{ engine: \\\"css\\\", selector: \\\"html\\\", score: 1 }];\\n  const accessibleNameCache = /* @__PURE__ */ new Map();\\n  const calculate = (element, allowText) => {\\n    const allowNthMatch = element === targetElement;\\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement, accessibleNameCache) : [];\\n    if (element !== targetElement) {\\n      textCandidates = filterRegexTokens(textCandidates);\\n    }\\n    const noTextCandidates = buildCandidates(injectedScript, element, testIdAttributeName, accessibleNameCache).map((token) => [token]);\\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\\n    textCandidates = filterRegexTokens(textCandidates);\\n    const checkWithText = (textCandidatesToUse) => {\\n      const allowParentText = allowText && !textCandidatesToUse.length;\\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\\n        if (!result)\\n          return true;\\n        return combineScores(c) < combineScores(result);\\n      });\\n      let bestPossibleInParent = candidates[0];\\n      if (!bestPossibleInParent)\\n        return;\\n      for (let parent = parentElementOrShadowHost2(element); parent; parent = parentElementOrShadowHost2(parent)) {\\n        const parentTokens = calculateCached(parent, allowParentText);\\n        if (!parentTokens)\\n          continue;\\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\\n          continue;\\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\\n        if (!bestPossibleInParent)\\n          return;\\n        const combined = [...parentTokens, ...bestPossibleInParent];\\n        if (!result || combineScores(combined) < combineScores(result))\\n          result = combined;\\n      }\\n    };\\n    checkWithText(textCandidates);\\n    if (element === targetElement && textCandidates.length)\\n      checkWithText([]);\\n    return result;\\n  };\\n  const calculateCached = (element, allowText) => {\\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\\n    let value = cache.get(element);\\n    if (value === void 0) {\\n      value = calculate(element, allowText);\\n      cache.set(element, value);\\n    }\\n    return value;\\n  };\\n  return calculateCached(targetElement, true);\\n}\\nfunction buildCandidates(injectedScript, element, testIdAttributeName, accessibleNameCache) {\\n  var _a;\\n  const candidates = [];\\n  for (const attr of [\\\"data-testid\\\", \\\"data-test-id\\\", \\\"data-test\\\"]) {\\n    if (attr !== testIdAttributeName && element.getAttribute(attr))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${attr}=${quoteAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\\n  }\\n  const idAttr = element.getAttribute(\\\"id\\\");\\n  if (idAttr && !isGuidLike(idAttr))\\n    candidates.push({ engine: \\\"css\\\", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\\n  candidates.push({ engine: \\\"css\\\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\\n  if (element.nodeName === \\\"IFRAME\\\") {\\n    for (const attribute of [\\\"name\\\", \\\"title\\\"]) {\\n      if (element.getAttribute(attribute))\\n        candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\\n    }\\n    if (element.getAttribute(testIdAttributeName))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(testIdAttributeName), true)}]`, score: kTestIdScore });\\n    penalizeScoreForLength([candidates]);\\n    return candidates;\\n  }\\n  if (element.getAttribute(testIdAttributeName))\\n    candidates.push({ engine: \\\"internal:testid\\\", selector: `[${testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(testIdAttributeName), true)}]`, score: kTestIdScore });\\n  if (element.nodeName === \\\"INPUT\\\" || element.nodeName === \\\"TEXTAREA\\\") {\\n    const input = element;\\n    if (input.placeholder) {\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, false)}]`, score: kPlaceholderScore });\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\\n    }\\n    const label = (_a = input.labels) == null ? void 0 : _a[0];\\n    if (label) {\\n      const labelText = elementText(injectedScript._evaluator._cacheText, label).full.trim();\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, false), score: kLabelScore });\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\\n    }\\n  }\\n  const ariaRole = getAriaRole(element);\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false, accessibleNameCache);\\n    if (ariaName) {\\n      candidates.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore });\\n      candidates.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact });\\n    } else {\\n      candidates.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n    }\\n  }\\n  if (element.getAttribute(\\\"alt\\\") && [\\\"APPLET\\\", \\\"AREA\\\", \\\"IMG\\\", \\\"INPUT\\\"].includes(element.nodeName)) {\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(element.getAttribute(\\\"alt\\\"), false)}]`, score: kAltTextScore });\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(element.getAttribute(\\\"alt\\\"), true)}]`, score: kAltTextScoreExact });\\n  }\\n  if (element.getAttribute(\\\"name\\\") && [\\\"BUTTON\\\", \\\"FORM\\\", \\\"FIELDSET\\\", \\\"FRAME\\\", \\\"IFRAME\\\", \\\"INPUT\\\", \\\"KEYGEN\\\", \\\"OBJECT\\\", \\\"OUTPUT\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\", \\\"MAP\\\", \\\"META\\\", \\\"PARAM\\\"].includes(element.nodeName))\\n    candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute(\\\"name\\\"))}]`, score: kCSSInputTypeNameScore });\\n  if (element.getAttribute(\\\"title\\\")) {\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(element.getAttribute(\\\"title\\\"), false)}]`, score: kTitleScore });\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(element.getAttribute(\\\"title\\\"), true)}]`, score: kTitleScoreExact });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\") {\\n    if (element.getAttribute(\\\"type\\\"))\\n      candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute(\\\"type\\\"))}]`, score: kCSSInputTypeNameScore });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\", \\\"SELECT\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\")\\n    candidates.push({ engine: \\\"css\\\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\\n  penalizeScoreForLength([candidates]);\\n  return candidates;\\n}\\nfunction buildTextCandidates(injectedScript, element, isTargetNode, accessibleNameCache) {\\n  if (element.nodeName === \\\"SELECT\\\")\\n    return [];\\n  const text = normalizeWhiteSpace(elementText(injectedScript._evaluator._cacheText, element).full).substring(0, 80);\\n  if (!text)\\n    return [];\\n  const candidates = [];\\n  const escaped = escapeForTextSelector(text, false);\\n  const exactEscaped = escapeForTextSelector(text, true);\\n  if (isTargetNode) {\\n    candidates.push([{ engine: \\\"internal:text\\\", selector: escaped, score: kTextScore }]);\\n    candidates.push([{ engine: \\\"internal:text\\\", selector: exactEscaped, score: kTextScoreExact }]);\\n  }\\n  const ariaRole = getAriaRole(element);\\n  const candidate = [];\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false, accessibleNameCache);\\n    if (ariaName) {\\n      candidate.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore });\\n      candidate.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact });\\n    } else {\\n      candidate.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n    }\\n  } else {\\n    candidate.push({ engine: \\\"css\\\", selector: element.nodeName.toLowerCase(), score: kCSSTagNameScore });\\n  }\\n  candidates.push([...candidate, { engine: \\\"internal:has-text\\\", selector: escaped, score: kTextScore }]);\\n  candidates.push([...candidate, { engine: \\\"internal:has-text\\\", selector: exactEscaped, score: kTextScoreExact }]);\\n  penalizeScoreForLength(candidates);\\n  return candidates;\\n}\\nfunction parentElementOrShadowHost2(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return null;\\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\\n    return element.parentNode.host;\\n  return null;\\n}\\nfunction makeSelectorForId(id) {\\n  return /^[a-zA-Z][a-zA-Z0-9\\\\-\\\\_]+$/.test(id) ? \\\"#\\\" + id : `[id=\\\"${cssEscape(id)}\\\"]`;\\n}\\nfunction cssFallback(injectedScript, targetElement) {\\n  const root = targetElement.ownerDocument;\\n  const tokens = [];\\n  function uniqueCSSSelector(prefix) {\\n    const path = tokens.slice();\\n    if (prefix)\\n      path.unshift(prefix);\\n    const selector = path.join(\\\" > \\\");\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\\n    return node === targetElement ? selector : void 0;\\n  }\\n  function makeStrict(selector) {\\n    const token = { engine: \\\"css\\\", selector, score: kCSSFallbackScore };\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\\n    if (elements.length === 1)\\n      return [token];\\n    const nth = { engine: \\\"nth\\\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\\n    return [token, nth];\\n  }\\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost2(element)) {\\n    const nodeName = element.nodeName.toLowerCase();\\n    let bestTokenForLevel = \\\"\\\";\\n    if (element.id) {\\n      const token = makeSelectorForId(element.id);\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      bestTokenForLevel = token;\\n    }\\n    const parent = element.parentNode;\\n    const classes = [...element.classList];\\n    for (let i = 0; i < classes.length; ++i) {\\n      const token = \\\".\\\" + cssEscape(classes.slice(0, i + 1).join(\\\".\\\"));\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel && parent) {\\n        const sameClassSiblings = parent.querySelectorAll(token);\\n        if (sameClassSiblings.length === 1)\\n          bestTokenForLevel = token;\\n      }\\n    }\\n    if (parent) {\\n      const siblings = [...parent.children];\\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel)\\n        bestTokenForLevel = token;\\n    } else if (!bestTokenForLevel) {\\n      bestTokenForLevel = nodeName;\\n    }\\n    tokens.unshift(bestTokenForLevel);\\n  }\\n  return makeStrict(uniqueCSSSelector());\\n}\\nfunction quoteAttributeValue(text) {\\n  return `\\\"${cssEscape(text).replace(/\\\\\\\\ /g, \\\" \\\")}\\\"`;\\n}\\nfunction penalizeScoreForLength(groups) {\\n  for (const group of groups) {\\n    for (const token of group) {\\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\\n    }\\n  }\\n}\\nfunction joinTokens(tokens) {\\n  const parts = [];\\n  let lastEngine = \\\"\\\";\\n  for (const { engine, selector } of tokens) {\\n    if (parts.length && (lastEngine !== \\\"css\\\" || engine !== \\\"css\\\" || selector.startsWith(\\\":nth-match(\\\")))\\n      parts.push(\\\">>\\\");\\n    lastEngine = engine;\\n    if (engine === \\\"css\\\")\\n      parts.push(selector);\\n    else\\n      parts.push(`${engine}=${selector}`);\\n  }\\n  return parts.join(\\\" \\\");\\n}\\nfunction combineScores(tokens) {\\n  let score = 0;\\n  for (let i = 0; i < tokens.length; i++)\\n    score += tokens[i].score * (tokens.length - i);\\n  return score;\\n}\\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\\n  joined.sort((a, b) => a.score - b.score);\\n  let bestWithIndex = null;\\n  for (const { tokens } of joined) {\\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\\n    if (result[0] === targetElement && result.length === 1) {\\n      return tokens;\\n    }\\n    const index = result.indexOf(targetElement);\\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\\n      continue;\\n    const nth = { engine: \\\"nth\\\", selector: String(index), score: kNthScore };\\n    bestWithIndex = [...tokens, nth];\\n  }\\n  return bestWithIndex;\\n}\\nfunction isGuidLike(id) {\\n  let lastCharacterType;\\n  let transitionCount = 0;\\n  for (let i = 0; i < id.length; ++i) {\\n    const c = id[i];\\n    let characterType;\\n    if (c === \\\"-\\\" || c === \\\"_\\\")\\n      continue;\\n    if (c >= \\\"a\\\" && c <= \\\"z\\\")\\n      characterType = \\\"lower\\\";\\n    else if (c >= \\\"A\\\" && c <= \\\"Z\\\")\\n      characterType = \\\"upper\\\";\\n    else if (c >= \\\"0\\\" && c <= \\\"9\\\")\\n      characterType = \\\"digit\\\";\\n    else\\n      characterType = \\\"other\\\";\\n    if (characterType === \\\"lower\\\" && lastCharacterType === \\\"upper\\\") {\\n      lastCharacterType = characterType;\\n      continue;\\n    }\\n    if (lastCharacterType && lastCharacterType !== characterType)\\n      ++transitionCount;\\n    lastCharacterType = characterType;\\n  }\\n  return transitionCount >= id.length / 4;\\n}\\n\\n// packages/playwright-core/src/server/injected/consoleApi.ts\\nvar selectorSymbol = Symbol(\\\"selector\\\");\\nvar injectedScriptSymbol = Symbol(\\\"injectedScript\\\");\\nvar Locator = class {\\n  constructor(injectedScript, selector, options) {\\n    this[selectorSymbol] = selector;\\n    this[injectedScriptSymbol] = injectedScript;\\n    if (options == null ? void 0 : options.hasText)\\n      selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\\n    if (options == null ? void 0 : options.has)\\n      selector += ` >> internal:has=` + JSON.stringify(options.has[selectorSymbol]);\\n    if (selector) {\\n      const parsed = injectedScript.parseSelector(selector);\\n      this.element = injectedScript.querySelector(parsed, document, false);\\n      this.elements = injectedScript.querySelectorAll(parsed, document);\\n    }\\n    const selectorBase = selector;\\n    const self = this;\\n    self.locator = (selector2, options2) => {\\n      return new Locator(injectedScript, selectorBase ? selectorBase + \\\" >> \\\" + selector2 : selector2, options2);\\n    };\\n    self.getByTestId = (testId) => self.locator(getByTestIdSelector(injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen(), testId));\\n    self.getByAltText = (text, options2) => self.locator(getByAltTextSelector(text, options2));\\n    self.getByLabel = (text, options2) => self.locator(getByLabelSelector(text, options2));\\n    self.getByPlaceholder = (text, options2) => self.locator(getByPlaceholderSelector(text, options2));\\n    self.getByText = (text, options2) => self.locator(getByTextSelector(text, options2));\\n    self.getByTitle = (text, options2) => self.locator(getByTitleSelector(text, options2));\\n    self.getByRole = (role, options2 = {}) => self.locator(getByRoleSelector(role, options2));\\n    self.filter = (options2) => new Locator(injectedScript, selector, options2);\\n    self.first = () => self.locator(\\\"nth=0\\\");\\n    self.last = () => self.locator(\\\"nth=-1\\\");\\n    self.nth = (index) => self.locator(`nth=${index}`);\\n  }\\n};\\nvar ConsoleAPI = class {\\n  constructor(injectedScript) {\\n    this._injectedScript = injectedScript;\\n    if (window.playwright)\\n      return;\\n    window.playwright = {\\n      $: (selector, strict) => this._querySelector(selector, !!strict),\\n      $$: (selector) => this._querySelectorAll(selector),\\n      inspect: (selector) => this._inspect(selector),\\n      selector: (element) => this._selector(element),\\n      generateLocator: (element, language) => this._generateLocator(element, language),\\n      resume: () => this._resume(),\\n      ...new Locator(injectedScript, \\\"\\\")\\n    };\\n    delete window.playwright.filter;\\n    delete window.playwright.first;\\n    delete window.playwright.last;\\n    delete window.playwright.nth;\\n  }\\n  _querySelector(selector, strict) {\\n    if (typeof selector !== \\\"string\\\")\\n      throw new Error(`Usage: playwright.query('Playwright >> selector').`);\\n    const parsed = this._injectedScript.parseSelector(selector);\\n    return this._injectedScript.querySelector(parsed, document, strict);\\n  }\\n  _querySelectorAll(selector) {\\n    if (typeof selector !== \\\"string\\\")\\n      throw new Error(`Usage: playwright.$$('Playwright >> selector').`);\\n    const parsed = this._injectedScript.parseSelector(selector);\\n    return this._injectedScript.querySelectorAll(parsed, document);\\n  }\\n  _inspect(selector) {\\n    if (typeof selector !== \\\"string\\\")\\n      throw new Error(`Usage: playwright.inspect('Playwright >> selector').`);\\n    window.inspect(this._querySelector(selector, false));\\n  }\\n  _selector(element) {\\n    if (!(element instanceof Element))\\n      throw new Error(`Usage: playwright.selector(element).`);\\n    return generateSelector(this._injectedScript, element, this._injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen()).selector;\\n  }\\n  _generateLocator(element, language) {\\n    if (!(element instanceof Element))\\n      throw new Error(`Usage: playwright.locator(element).`);\\n    const selector = generateSelector(this._injectedScript, element, this._injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen()).selector;\\n    return asLocator(language || \\\"javascript\\\", selector);\\n  }\\n  _resume() {\\n    window.__pw_resume().catch(() => {\\n    });\\n  }\\n};\\nmodule.exports = ConsoleAPI;\\n\";\nexports.source = source;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.source = void 0;\nconst source = \"\\\"use strict\\\";\\nlet __export = (target, all) => {\\n  for (var name in all)\\n    target[name] = all[name];\\n};\\nlet __commonJS = cb => function __require() {\\n  let fn;\\n  for (const name in cb) {\\n    fn = cb[name];\\n    break;\\n  }\\n  const exports = {};\\n  fn(exports);\\n  return exports;\\n};\\nlet __toESM = mod => ({ ...mod, 'default': mod });\\nlet __toCommonJS = mod =>  ({ ...mod, __esModule: true });\\n// packages/playwright-core/src/server/injected/injectedScript.ts\\nvar injectedScript_exports = {};\\n__export(injectedScript_exports, {\\n  InjectedScript: () => InjectedScript\\n});\\nmodule.exports = __toCommonJS(injectedScript_exports);\\n\\n// packages/playwright-core/src/server/injected/xpathSelectorEngine.ts\\nvar XPathEngine = {\\n  queryAll(root, selector) {\\n    if (selector.startsWith(\\\"/\\\"))\\n      selector = \\\".\\\" + selector;\\n    const result = [];\\n    const document2 = root instanceof Document ? root : root.ownerDocument;\\n    if (!document2)\\n      return result;\\n    const it = document2.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\\n      if (node.nodeType === Node.ELEMENT_NODE)\\n        result.push(node);\\n    }\\n    return result;\\n  }\\n};\\n\\n// packages/playwright-core/src/server/injected/domUtils.ts\\nfunction isInsideScope(scope, element) {\\n  while (element) {\\n    if (scope.contains(element))\\n      return true;\\n    element = enclosingShadowHost(element);\\n  }\\n  return false;\\n}\\nfunction parentElementOrShadowHost(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return;\\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\\n    return element.parentNode.host;\\n}\\nfunction enclosingShadowRootOrDocument(element) {\\n  let node = element;\\n  while (node.parentNode)\\n    node = node.parentNode;\\n  if (node.nodeType === 11 || node.nodeType === 9)\\n    return node;\\n}\\nfunction enclosingShadowHost(element) {\\n  while (element.parentElement)\\n    element = element.parentElement;\\n  return parentElementOrShadowHost(element);\\n}\\nfunction closestCrossShadow(element, css) {\\n  while (element) {\\n    const closest = element.closest(css);\\n    if (closest)\\n      return closest;\\n    element = enclosingShadowHost(element);\\n  }\\n}\\nfunction getElementComputedStyle(element, pseudo) {\\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\\n}\\nfunction isElementStyleVisibilityVisible(element, style) {\\n  style = style != null ? style : getElementComputedStyle(element);\\n  if (!style)\\n    return true;\\n  if (Element.prototype.checkVisibility) {\\n    if (!element.checkVisibility({ checkOpacity: false, checkVisibilityCSS: false }))\\n      return false;\\n  } else {\\n    const detailsOrSummary = element.closest(\\\"details,summary\\\");\\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === \\\"DETAILS\\\" && !detailsOrSummary.open)\\n      return false;\\n  }\\n  if (style.visibility !== \\\"visible\\\")\\n    return false;\\n  return true;\\n}\\nfunction isElementVisible(element) {\\n  const style = getElementComputedStyle(element);\\n  if (!style)\\n    return true;\\n  if (style.display === \\\"contents\\\") {\\n    for (let child = element.firstChild; child; child = child.nextSibling) {\\n      if (child.nodeType === 1 && isElementVisible(child))\\n        return true;\\n      if (child.nodeType === 3 && isVisibleTextNode(child))\\n        return true;\\n    }\\n    return false;\\n  }\\n  if (!isElementStyleVisibilityVisible(element, style))\\n    return false;\\n  const rect = element.getBoundingClientRect();\\n  return rect.width > 0 && rect.height > 0;\\n}\\nfunction isVisibleTextNode(node) {\\n  const range = document.createRange();\\n  range.selectNode(node);\\n  const rect = range.getBoundingClientRect();\\n  return rect.width > 0 && rect.height > 0;\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorUtils.ts\\nfunction matchesComponentAttribute(obj, attr) {\\n  for (const token of attr.jsonPath) {\\n    if (obj !== void 0 && obj !== null)\\n      obj = obj[token];\\n  }\\n  return matchesAttributePart(obj, attr);\\n}\\nfunction matchesAttributePart(value, attr) {\\n  const objValue = typeof value === \\\"string\\\" && !attr.caseSensitive ? value.toUpperCase() : value;\\n  const attrValue = typeof attr.value === \\\"string\\\" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\\n  if (attr.op === \\\"<truthy>\\\")\\n    return !!objValue;\\n  if (attr.op === \\\"=\\\") {\\n    if (attrValue instanceof RegExp)\\n      return typeof objValue === \\\"string\\\" && !!objValue.match(attrValue);\\n    return objValue === attrValue;\\n  }\\n  if (typeof objValue !== \\\"string\\\" || typeof attrValue !== \\\"string\\\")\\n    return false;\\n  if (attr.op === \\\"*=\\\")\\n    return objValue.includes(attrValue);\\n  if (attr.op === \\\"^=\\\")\\n    return objValue.startsWith(attrValue);\\n  if (attr.op === \\\"$=\\\")\\n    return objValue.endsWith(attrValue);\\n  if (attr.op === \\\"|=\\\")\\n    return objValue === attrValue || objValue.startsWith(attrValue + \\\"-\\\");\\n  if (attr.op === \\\"~=\\\")\\n    return objValue.split(\\\" \\\").includes(attrValue);\\n  return false;\\n}\\nfunction shouldSkipForTextMatching(element) {\\n  return element.nodeName === \\\"SCRIPT\\\" || element.nodeName === \\\"NOSCRIPT\\\" || element.nodeName === \\\"STYLE\\\" || document.head && document.head.contains(element);\\n}\\nfunction elementText(cache, root) {\\n  let value = cache.get(root);\\n  if (value === void 0) {\\n    value = { full: \\\"\\\", immediate: [] };\\n    if (!shouldSkipForTextMatching(root)) {\\n      let currentImmediate = \\\"\\\";\\n      if (root instanceof HTMLInputElement && (root.type === \\\"submit\\\" || root.type === \\\"button\\\")) {\\n        value = { full: root.value, immediate: [root.value] };\\n      } else {\\n        for (let child = root.firstChild; child; child = child.nextSibling) {\\n          if (child.nodeType === Node.TEXT_NODE) {\\n            value.full += child.nodeValue || \\\"\\\";\\n            currentImmediate += child.nodeValue || \\\"\\\";\\n          } else {\\n            if (currentImmediate)\\n              value.immediate.push(currentImmediate);\\n            currentImmediate = \\\"\\\";\\n            if (child.nodeType === Node.ELEMENT_NODE)\\n              value.full += elementText(cache, child).full;\\n          }\\n        }\\n        if (currentImmediate)\\n          value.immediate.push(currentImmediate);\\n        if (root.shadowRoot)\\n          value.full += elementText(cache, root.shadowRoot).full;\\n      }\\n    }\\n    cache.set(root, value);\\n  }\\n  return value;\\n}\\nfunction elementMatchesText(cache, element, matcher) {\\n  if (shouldSkipForTextMatching(element))\\n    return \\\"none\\\";\\n  if (!matcher(elementText(cache, element)))\\n    return \\\"none\\\";\\n  for (let child = element.firstChild; child; child = child.nextSibling) {\\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\\n      return \\\"selfAndChildren\\\";\\n  }\\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\\n    return \\\"selfAndChildren\\\";\\n  return \\\"self\\\";\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.ts\\nvar between = function(num, first, last) {\\n  return num >= first && num <= last;\\n};\\nfunction digit(code) {\\n  return between(code, 48, 57);\\n}\\nfunction hexdigit(code) {\\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\\n}\\nfunction uppercaseletter(code) {\\n  return between(code, 65, 90);\\n}\\nfunction lowercaseletter(code) {\\n  return between(code, 97, 122);\\n}\\nfunction letter(code) {\\n  return uppercaseletter(code) || lowercaseletter(code);\\n}\\nfunction nonascii(code) {\\n  return code >= 128;\\n}\\nfunction namestartchar(code) {\\n  return letter(code) || nonascii(code) || code === 95;\\n}\\nfunction namechar(code) {\\n  return namestartchar(code) || digit(code) || code === 45;\\n}\\nfunction nonprintable(code) {\\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\\n}\\nfunction newline(code) {\\n  return code === 10;\\n}\\nfunction whitespace(code) {\\n  return newline(code) || code === 9 || code === 32;\\n}\\nvar maximumallowedcodepoint = 1114111;\\nvar InvalidCharacterError = class extends Error {\\n  constructor(message) {\\n    super(message);\\n    this.name = \\\"InvalidCharacterError\\\";\\n  }\\n};\\nfunction preprocess(str) {\\n  const codepoints = [];\\n  for (let i = 0; i < str.length; i++) {\\n    let code = str.charCodeAt(i);\\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\\n      code = 10;\\n      i++;\\n    }\\n    if (code === 13 || code === 12)\\n      code = 10;\\n    if (code === 0)\\n      code = 65533;\\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\\n      const lead = code - 55296;\\n      const trail = str.charCodeAt(i + 1) - 56320;\\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\\n      i++;\\n    }\\n    codepoints.push(code);\\n  }\\n  return codepoints;\\n}\\nfunction stringFromCode(code) {\\n  if (code <= 65535)\\n    return String.fromCharCode(code);\\n  code -= Math.pow(2, 16);\\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\\n  const trail = code % Math.pow(2, 10) + 56320;\\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\\n}\\nfunction tokenize(str1) {\\n  const str = preprocess(str1);\\n  let i = -1;\\n  const tokens = [];\\n  let code;\\n  let line = 0;\\n  let column = 0;\\n  let lastLineLength = 0;\\n  const incrLineno = function() {\\n    line += 1;\\n    lastLineLength = column;\\n    column = 0;\\n  };\\n  const locStart = { line, column };\\n  const codepoint = function(i2) {\\n    if (i2 >= str.length)\\n      return -1;\\n    return str[i2];\\n  };\\n  const next = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    if (num > 3)\\n      throw \\\"Spec Error: no more than three codepoints of lookahead.\\\";\\n    return codepoint(i + num);\\n  };\\n  const consume = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    i += num;\\n    code = codepoint(i);\\n    if (newline(code))\\n      incrLineno();\\n    else\\n      column += num;\\n    return true;\\n  };\\n  const reconsume = function() {\\n    i -= 1;\\n    if (newline(code)) {\\n      line -= 1;\\n      column = lastLineLength;\\n    } else {\\n      column -= 1;\\n    }\\n    locStart.line = line;\\n    locStart.column = column;\\n    return true;\\n  };\\n  const eof = function(codepoint2) {\\n    if (codepoint2 === void 0)\\n      codepoint2 = code;\\n    return codepoint2 === -1;\\n  };\\n  const donothing = function() {\\n  };\\n  const parseerror = function() {\\n  };\\n  const consumeAToken = function() {\\n    consumeComments();\\n    consume();\\n    if (whitespace(code)) {\\n      while (whitespace(next()))\\n        consume();\\n      return new WhitespaceToken();\\n    } else if (code === 34) {\\n      return consumeAStringToken();\\n    } else if (code === 35) {\\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\\n        const token = new HashToken(\\\"\\\");\\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n          token.type = \\\"id\\\";\\n        token.value = consumeAName();\\n        return token;\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 36) {\\n      if (next() === 61) {\\n        consume();\\n        return new SuffixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 39) {\\n      return consumeAStringToken();\\n    } else if (code === 40) {\\n      return new OpenParenToken();\\n    } else if (code === 41) {\\n      return new CloseParenToken();\\n    } else if (code === 42) {\\n      if (next() === 61) {\\n        consume();\\n        return new SubstringMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 43) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 44) {\\n      return new CommaToken();\\n    } else if (code === 45) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else if (next(1) === 45 && next(2) === 62) {\\n        consume(2);\\n        return new CDCToken();\\n      } else if (startsWithAnIdentifier()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 46) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 58) {\\n      return new ColonToken();\\n    } else if (code === 59) {\\n      return new SemicolonToken();\\n    } else if (code === 60) {\\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\\n        consume(3);\\n        return new CDOToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 64) {\\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n        return new AtKeywordToken(consumeAName());\\n      else\\n        return new DelimToken(code);\\n    } else if (code === 91) {\\n      return new OpenSquareToken();\\n    } else if (code === 92) {\\n      if (startsWithAValidEscape()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        parseerror();\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 93) {\\n      return new CloseSquareToken();\\n    } else if (code === 94) {\\n      if (next() === 61) {\\n        consume();\\n        return new PrefixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 123) {\\n      return new OpenCurlyToken();\\n    } else if (code === 124) {\\n      if (next() === 61) {\\n        consume();\\n        return new DashMatchToken();\\n      } else if (next() === 124) {\\n        consume();\\n        return new ColumnToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 125) {\\n      return new CloseCurlyToken();\\n    } else if (code === 126) {\\n      if (next() === 61) {\\n        consume();\\n        return new IncludeMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (digit(code)) {\\n      reconsume();\\n      return consumeANumericToken();\\n    } else if (namestartchar(code)) {\\n      reconsume();\\n      return consumeAnIdentlikeToken();\\n    } else if (eof()) {\\n      return new EOFToken();\\n    } else {\\n      return new DelimToken(code);\\n    }\\n  };\\n  const consumeComments = function() {\\n    while (next(1) === 47 && next(2) === 42) {\\n      consume(2);\\n      while (true) {\\n        consume();\\n        if (code === 42 && next() === 47) {\\n          consume();\\n          break;\\n        } else if (eof()) {\\n          parseerror();\\n          return;\\n        }\\n      }\\n    }\\n  };\\n  const consumeANumericToken = function() {\\n    const num = consumeANumber();\\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\\n      const token = new DimensionToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      token.unit = consumeAName();\\n      return token;\\n    } else if (next() === 37) {\\n      consume();\\n      const token = new PercentageToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      return token;\\n    } else {\\n      const token = new NumberToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      return token;\\n    }\\n  };\\n  const consumeAnIdentlikeToken = function() {\\n    const str2 = consumeAName();\\n    if (str2.toLowerCase() === \\\"url\\\" && next() === 40) {\\n      consume();\\n      while (whitespace(next(1)) && whitespace(next(2)))\\n        consume();\\n      if (next() === 34 || next() === 39)\\n        return new FunctionToken(str2);\\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\\n        return new FunctionToken(str2);\\n      else\\n        return consumeAURLToken();\\n    } else if (next() === 40) {\\n      consume();\\n      return new FunctionToken(str2);\\n    } else {\\n      return new IdentToken(str2);\\n    }\\n  };\\n  const consumeAStringToken = function(endingCodePoint) {\\n    if (endingCodePoint === void 0)\\n      endingCodePoint = code;\\n    let string = \\\"\\\";\\n    while (consume()) {\\n      if (code === endingCodePoint || eof()) {\\n        return new StringToken(string);\\n      } else if (newline(code)) {\\n        parseerror();\\n        reconsume();\\n        return new BadStringToken();\\n      } else if (code === 92) {\\n        if (eof(next()))\\n          donothing();\\n        else if (newline(next()))\\n          consume();\\n        else\\n          string += stringFromCode(consumeEscape());\\n      } else {\\n        string += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeAURLToken = function() {\\n    const token = new URLToken(\\\"\\\");\\n    while (whitespace(next()))\\n      consume();\\n    if (eof(next()))\\n      return token;\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return token;\\n      } else if (whitespace(code)) {\\n        while (whitespace(next()))\\n          consume();\\n        if (next() === 41 || eof(next())) {\\n          consume();\\n          return token;\\n        } else {\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\\n        parseerror();\\n        consumeTheRemnantsOfABadURL();\\n        return new BadURLToken();\\n      } else if (code === 92) {\\n        if (startsWithAValidEscape()) {\\n          token.value += stringFromCode(consumeEscape());\\n        } else {\\n          parseerror();\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else {\\n        token.value += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeEscape = function() {\\n    consume();\\n    if (hexdigit(code)) {\\n      const digits = [code];\\n      for (let total = 0; total < 5; total++) {\\n        if (hexdigit(next())) {\\n          consume();\\n          digits.push(code);\\n        } else {\\n          break;\\n        }\\n      }\\n      if (whitespace(next()))\\n        consume();\\n      let value = parseInt(digits.map(function(x) {\\n        return String.fromCharCode(x);\\n      }).join(\\\"\\\"), 16);\\n      if (value > maximumallowedcodepoint)\\n        value = 65533;\\n      return value;\\n    } else if (eof()) {\\n      return 65533;\\n    } else {\\n      return code;\\n    }\\n  };\\n  const areAValidEscape = function(c1, c2) {\\n    if (c1 !== 92)\\n      return false;\\n    if (newline(c2))\\n      return false;\\n    return true;\\n  };\\n  const startsWithAValidEscape = function() {\\n    return areAValidEscape(code, next());\\n  };\\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\\n    if (c1 === 45)\\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\\n    else if (namestartchar(c1))\\n      return true;\\n    else if (c1 === 92)\\n      return areAValidEscape(c1, c2);\\n    else\\n      return false;\\n  };\\n  const startsWithAnIdentifier = function() {\\n    return wouldStartAnIdentifier(code, next(1), next(2));\\n  };\\n  const wouldStartANumber = function(c1, c2, c3) {\\n    if (c1 === 43 || c1 === 45) {\\n      if (digit(c2))\\n        return true;\\n      if (c2 === 46 && digit(c3))\\n        return true;\\n      return false;\\n    } else if (c1 === 46) {\\n      if (digit(c2))\\n        return true;\\n      return false;\\n    } else if (digit(c1)) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  };\\n  const startsWithANumber = function() {\\n    return wouldStartANumber(code, next(1), next(2));\\n  };\\n  const consumeAName = function() {\\n    let result = \\\"\\\";\\n    while (consume()) {\\n      if (namechar(code)) {\\n        result += stringFromCode(code);\\n      } else if (startsWithAValidEscape()) {\\n        result += stringFromCode(consumeEscape());\\n      } else {\\n        reconsume();\\n        return result;\\n      }\\n    }\\n    throw new Error(\\\"Internal parse error\\\");\\n  };\\n  const consumeANumber = function() {\\n    let repr = \\\"\\\";\\n    let type = \\\"integer\\\";\\n    if (next() === 43 || next() === 45) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    while (digit(next())) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    if (next(1) === 46 && digit(next(2))) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const c1 = next(1), c2 = next(2), c3 = next(3);\\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const value = convertAStringToANumber(repr);\\n    return { type, value, repr };\\n  };\\n  const convertAStringToANumber = function(string) {\\n    return +string;\\n  };\\n  const consumeTheRemnantsOfABadURL = function() {\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return;\\n      } else if (startsWithAValidEscape()) {\\n        consumeEscape();\\n        donothing();\\n      } else {\\n        donothing();\\n      }\\n    }\\n  };\\n  let iterationCount = 0;\\n  while (!eof(next())) {\\n    tokens.push(consumeAToken());\\n    iterationCount++;\\n    if (iterationCount > str.length * 2)\\n      throw new Error(\\\"I'm infinite-looping!\\\");\\n  }\\n  return tokens;\\n}\\nvar CSSParserToken = class {\\n  constructor() {\\n    this.tokenType = \\\"\\\";\\n  }\\n  toJSON() {\\n    return { token: this.tokenType };\\n  }\\n  toString() {\\n    return this.tokenType;\\n  }\\n  toSource() {\\n    return \\\"\\\" + this;\\n  }\\n};\\nvar BadStringToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADSTRING\\\";\\n  }\\n};\\nvar BadURLToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADURL\\\";\\n  }\\n};\\nvar WhitespaceToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"WHITESPACE\\\";\\n  }\\n  toString() {\\n    return \\\"WS\\\";\\n  }\\n  toSource() {\\n    return \\\" \\\";\\n  }\\n};\\nvar CDOToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDO\\\";\\n  }\\n  toSource() {\\n    return \\\"<!--\\\";\\n  }\\n};\\nvar CDCToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDC\\\";\\n  }\\n  toSource() {\\n    return \\\"-->\\\";\\n  }\\n};\\nvar ColonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\":\\\";\\n  }\\n};\\nvar SemicolonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\";\\\";\\n  }\\n};\\nvar CommaToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\",\\\";\\n  }\\n};\\nvar GroupingToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n    this.mirror = \\\"\\\";\\n  }\\n};\\nvar OpenCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"{\\\";\\n    this.value = \\\"{\\\";\\n    this.mirror = \\\"}\\\";\\n  }\\n};\\nvar CloseCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"}\\\";\\n    this.value = \\\"}\\\";\\n    this.mirror = \\\"{\\\";\\n  }\\n};\\nvar OpenSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"[\\\";\\n    this.value = \\\"[\\\";\\n    this.mirror = \\\"]\\\";\\n  }\\n};\\nvar CloseSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"]\\\";\\n    this.value = \\\"]\\\";\\n    this.mirror = \\\"[\\\";\\n  }\\n};\\nvar OpenParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"(\\\";\\n    this.value = \\\"(\\\";\\n    this.mirror = \\\")\\\";\\n  }\\n};\\nvar CloseParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\")\\\";\\n    this.value = \\\")\\\";\\n    this.mirror = \\\"(\\\";\\n  }\\n};\\nvar IncludeMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"~=\\\";\\n  }\\n};\\nvar DashMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"|=\\\";\\n  }\\n};\\nvar PrefixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"^=\\\";\\n  }\\n};\\nvar SuffixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"$=\\\";\\n  }\\n};\\nvar SubstringMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"*=\\\";\\n  }\\n};\\nvar ColumnToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"||\\\";\\n  }\\n};\\nvar EOFToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"EOF\\\";\\n  }\\n  toSource() {\\n    return \\\"\\\";\\n  }\\n};\\nvar DelimToken = class extends CSSParserToken {\\n  constructor(code) {\\n    super();\\n    this.tokenType = \\\"DELIM\\\";\\n    this.value = \\\"\\\";\\n    this.value = stringFromCode(code);\\n  }\\n  toString() {\\n    return \\\"DELIM(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.value === \\\"\\\\\\\\\\\")\\n      return \\\"\\\\\\\\\\\\n\\\";\\n    else\\n      return this.value;\\n  }\\n};\\nvar StringValuedToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n  }\\n  ASCIIMatch(str) {\\n    return this.value.toLowerCase() === str.toLowerCase();\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n};\\nvar IdentToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"IDENT\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"IDENT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value);\\n  }\\n};\\nvar FunctionToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"FUNCTION\\\";\\n    this.value = val;\\n    this.mirror = \\\")\\\";\\n  }\\n  toString() {\\n    return \\\"FUNCTION(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value) + \\\"(\\\";\\n  }\\n};\\nvar AtKeywordToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"AT-KEYWORD\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"AT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return \\\"@\\\" + escapeIdent(this.value);\\n  }\\n};\\nvar HashToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"HASH\\\";\\n    this.value = val;\\n    this.type = \\\"unrestricted\\\";\\n  }\\n  toString() {\\n    return \\\"HASH(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.type === \\\"id\\\")\\n      return \\\"#\\\" + escapeIdent(this.value);\\n    else\\n      return \\\"#\\\" + escapeHash(this.value);\\n  }\\n};\\nvar StringToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"STRING\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return '\\\"' + escapeString(this.value) + '\\\"';\\n  }\\n};\\nvar URLToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"URL\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"URL(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return 'url(\\\"' + escapeString(this.value) + '\\\")';\\n  }\\n};\\nvar NumberToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"NUMBER\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    if (this.type === \\\"integer\\\")\\n      return \\\"INT(\\\" + this.value + \\\")\\\";\\n    return \\\"NUMBER(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = super.toJSON();\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr;\\n  }\\n};\\nvar PercentageToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"PERCENTAGE\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"PERCENTAGE(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr + \\\"%\\\";\\n  }\\n};\\nvar DimensionToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"DIMENSION\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n    this.unit = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"DIM(\\\" + this.value + \\\",\\\" + this.unit + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    json.unit = this.unit;\\n    return json;\\n  }\\n  toSource() {\\n    const source = this.repr;\\n    let unit = escapeIdent(this.unit);\\n    if (unit[0].toLowerCase() === \\\"e\\\" && (unit[1] === \\\"-\\\" || between(unit.charCodeAt(1), 48, 57))) {\\n      unit = \\\"\\\\\\\\65 \\\" + unit.slice(1, unit.length);\\n    }\\n    return source + unit;\\n  }\\n};\\nfunction escapeIdent(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  const firstcode = string.charCodeAt(0);\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n  }\\n  return result;\\n}\\nfunction escapeHash(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n  }\\n  return result;\\n}\\nfunction escapeString(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code === 34 || code === 92)\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n    else\\n      result += string[i];\\n  }\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\\nvar InvalidSelectorError = class extends Error {\\n};\\nfunction parseCSS(selector, customNames) {\\n  let tokens;\\n  try {\\n    tokens = tokenize(selector);\\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\\n      tokens.push(new EOFToken());\\n  } catch (e) {\\n    const newMessage = e.message + ` while parsing selector \\\"${selector}\\\"`;\\n    const index = (e.stack || \\\"\\\").indexOf(e.message);\\n    if (index !== -1)\\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\\n    e.message = newMessage;\\n    throw e;\\n  }\\n  const unsupportedToken = tokens.find((token) => {\\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || token instanceof URLToken || token instanceof PercentageToken;\\n  });\\n  if (unsupportedToken)\\n    throw new InvalidSelectorError(`Unsupported token \\\"${unsupportedToken.toSource()}\\\" while parsing selector \\\"${selector}\\\"`);\\n  let pos = 0;\\n  const names = /* @__PURE__ */ new Set();\\n  function unexpected() {\\n    return new InvalidSelectorError(`Unexpected token \\\"${tokens[pos].toSource()}\\\" while parsing selector \\\"${selector}\\\"`);\\n  }\\n  function skipWhitespace() {\\n    while (tokens[pos] instanceof WhitespaceToken)\\n      pos++;\\n  }\\n  function isIdent(p = pos) {\\n    return tokens[p] instanceof IdentToken;\\n  }\\n  function isString(p = pos) {\\n    return tokens[p] instanceof StringToken;\\n  }\\n  function isNumber(p = pos) {\\n    return tokens[p] instanceof NumberToken;\\n  }\\n  function isComma(p = pos) {\\n    return tokens[p] instanceof CommaToken;\\n  }\\n  function isCloseParen(p = pos) {\\n    return tokens[p] instanceof CloseParenToken;\\n  }\\n  function isStar(p = pos) {\\n    return tokens[p] instanceof DelimToken && tokens[p].value === \\\"*\\\";\\n  }\\n  function isEOF(p = pos) {\\n    return tokens[p] instanceof EOFToken;\\n  }\\n  function isClauseCombinator(p = pos) {\\n    return tokens[p] instanceof DelimToken && [\\\">\\\", \\\"+\\\", \\\"~\\\"].includes(tokens[p].value);\\n  }\\n  function isSelectorClauseEnd(p = pos) {\\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\\n  }\\n  function consumeFunctionArguments() {\\n    const result2 = [consumeArgument()];\\n    while (true) {\\n      skipWhitespace();\\n      if (!isComma())\\n        break;\\n      pos++;\\n      result2.push(consumeArgument());\\n    }\\n    return result2;\\n  }\\n  function consumeArgument() {\\n    skipWhitespace();\\n    if (isNumber())\\n      return tokens[pos++].value;\\n    if (isString())\\n      return tokens[pos++].value;\\n    return consumeComplexSelector();\\n  }\\n  function consumeComplexSelector() {\\n    const result2 = { simples: [] };\\n    skipWhitespace();\\n    if (isClauseCombinator()) {\\n      result2.simples.push({ selector: { functions: [{ name: \\\"scope\\\", args: [] }] }, combinator: \\\"\\\" });\\n    } else {\\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: \\\"\\\" });\\n    }\\n    while (true) {\\n      skipWhitespace();\\n      if (isClauseCombinator()) {\\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\\n        skipWhitespace();\\n      } else if (isSelectorClauseEnd()) {\\n        break;\\n      }\\n      result2.simples.push({ combinator: \\\"\\\", selector: consumeSimpleSelector() });\\n    }\\n    return result2;\\n  }\\n  function consumeSimpleSelector() {\\n    let rawCSSString = \\\"\\\";\\n    const functions = [];\\n    while (!isSelectorClauseEnd()) {\\n      if (isIdent() || isStar()) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof HashToken) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === \\\".\\\") {\\n        pos++;\\n        if (isIdent())\\n          rawCSSString += \\\".\\\" + tokens[pos++].toSource();\\n        else\\n          throw unexpected();\\n      } else if (tokens[pos] instanceof ColonToken) {\\n        pos++;\\n        if (isIdent()) {\\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\\n            rawCSSString += \\\":\\\" + tokens[pos++].toSource();\\n          } else {\\n            const name = tokens[pos++].value.toLowerCase();\\n            functions.push({ name, args: [] });\\n            names.add(name);\\n          }\\n        } else if (tokens[pos] instanceof FunctionToken) {\\n          const name = tokens[pos++].value.toLowerCase();\\n          if (!customNames.has(name)) {\\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\\n          } else {\\n            functions.push({ name, args: consumeFunctionArguments() });\\n            names.add(name);\\n          }\\n          skipWhitespace();\\n          if (!isCloseParen())\\n            throw unexpected();\\n          pos++;\\n        } else {\\n          throw unexpected();\\n        }\\n      } else if (tokens[pos] instanceof OpenSquareToken) {\\n        rawCSSString += \\\"[\\\";\\n        pos++;\\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\\n          rawCSSString += tokens[pos++].toSource();\\n        if (!(tokens[pos] instanceof CloseSquareToken))\\n          throw unexpected();\\n        rawCSSString += \\\"]\\\";\\n        pos++;\\n      } else {\\n        throw unexpected();\\n      }\\n    }\\n    if (!rawCSSString && !functions.length)\\n      throw unexpected();\\n    return { css: rawCSSString || void 0, functions };\\n  }\\n  function consumeBuiltinFunctionArguments() {\\n    let s = \\\"\\\";\\n    while (!isCloseParen() && !isEOF())\\n      s += tokens[pos++].toSource();\\n    return s;\\n  }\\n  const result = consumeFunctionArguments();\\n  if (!isEOF())\\n    throw new InvalidSelectorError(`Error while parsing selector \\\"${selector}\\\"`);\\n  if (result.some((arg) => typeof arg !== \\\"object\\\" || !(\\\"simples\\\" in arg)))\\n    throw new InvalidSelectorError(`Error while parsing selector \\\"${selector}\\\"`);\\n  return { selector: result, names: Array.from(names) };\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/selectorParser.ts\\nvar kNestedSelectorNames = /* @__PURE__ */ new Set([\\\"internal:has\\\", \\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set([\\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar customCSSNames = /* @__PURE__ */ new Set([\\\"not\\\", \\\"is\\\", \\\"where\\\", \\\"has\\\", \\\"scope\\\", \\\"light\\\", \\\"visible\\\", \\\"text\\\", \\\"text-matches\\\", \\\"text-is\\\", \\\"has-text\\\", \\\"above\\\", \\\"below\\\", \\\"right-of\\\", \\\"left-of\\\", \\\"near\\\", \\\"nth-match\\\"]);\\nfunction parseSelector(selector) {\\n  const result = parseSelectorString(selector);\\n  const parts = result.parts.map((part) => {\\n    if (part.name === \\\"css\\\" || part.name === \\\"css:light\\\") {\\n      if (part.name === \\\"css:light\\\")\\n        part.body = \\\":light(\\\" + part.body + \\\")\\\";\\n      const parsedCSS = parseCSS(part.body, customCSSNames);\\n      return {\\n        name: \\\"css\\\",\\n        body: parsedCSS.selector,\\n        source: part.body\\n      };\\n    }\\n    if (kNestedSelectorNames.has(part.name)) {\\n      let innerSelector;\\n      let distance;\\n      try {\\n        const unescaped = JSON.parse(\\\"[\\\" + part.body + \\\"]\\\");\\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== \\\"string\\\")\\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n        innerSelector = unescaped[0];\\n        if (unescaped.length === 2) {\\n          if (typeof unescaped[1] !== \\\"number\\\" || !kNestedSelectorNamesWithDistance.has(part.name))\\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n          distance = unescaped[1];\\n        }\\n      } catch (e) {\\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n      }\\n      const result2 = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\\n      if (result2.body.parsed.parts.some((part2) => part2.name === \\\"internal:control\\\" && part2.body === \\\"enter-frame\\\"))\\n        throw new InvalidSelectorError(`Frames are not allowed inside \\\"${part.name}\\\" selectors`);\\n      return result2;\\n    }\\n    return { ...part, source: part.body };\\n  });\\n  if (kNestedSelectorNames.has(parts[0].name))\\n    throw new InvalidSelectorError(`\\\"${parts[0].name}\\\" selector cannot be first`);\\n  return {\\n    capture: result.capture,\\n    parts\\n  };\\n}\\nfunction stringifySelector(selector) {\\n  if (typeof selector === \\\"string\\\")\\n    return selector;\\n  return selector.parts.map((p, i) => {\\n    const prefix = p.name === \\\"css\\\" ? \\\"\\\" : p.name + \\\"=\\\";\\n    return `${i === selector.capture ? \\\"*\\\" : \\\"\\\"}${prefix}${p.source}`;\\n  }).join(\\\" >> \\\");\\n}\\nfunction allEngineNames(selector) {\\n  const result = /* @__PURE__ */ new Set();\\n  const visit = (selector2) => {\\n    for (const part of selector2.parts) {\\n      result.add(part.name);\\n      if (kNestedSelectorNames.has(part.name))\\n        visit(part.body.parsed);\\n    }\\n  };\\n  visit(selector);\\n  return result;\\n}\\nfunction parseSelectorString(selector) {\\n  let index = 0;\\n  let quote;\\n  let start = 0;\\n  const result = { parts: [] };\\n  const append = () => {\\n    const part = selector.substring(start, index).trim();\\n    const eqIndex = part.indexOf(\\\"=\\\");\\n    let name;\\n    let body;\\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\\n      name = part.substring(0, eqIndex).trim();\\n      body = part.substring(eqIndex + 1);\\n    } else if (part.length > 1 && part[0] === '\\\"' && part[part.length - 1] === '\\\"') {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (part.length > 1 && part[0] === \\\"'\\\" && part[part.length - 1] === \\\"'\\\") {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (/^\\\\(*\\\\/\\\\//.test(part) || part.startsWith(\\\"..\\\")) {\\n      name = \\\"xpath\\\";\\n      body = part;\\n    } else {\\n      name = \\\"css\\\";\\n      body = part;\\n    }\\n    let capture = false;\\n    if (name[0] === \\\"*\\\") {\\n      capture = true;\\n      name = name.substring(1);\\n    }\\n    result.parts.push({ name, body });\\n    if (capture) {\\n      if (result.capture !== void 0)\\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\\n      result.capture = result.parts.length - 1;\\n    }\\n  };\\n  if (!selector.includes(\\\">>\\\")) {\\n    index = selector.length;\\n    append();\\n    return result;\\n  }\\n  const shouldIgnoreTextSelectorQuote = () => {\\n    const prefix = selector.substring(start, index);\\n    const match = prefix.match(/^\\\\s*text\\\\s*=(.*)$/);\\n    return !!match && !!match[1];\\n  };\\n  while (index < selector.length) {\\n    const c = selector[index];\\n    if (c === \\\"\\\\\\\\\\\" && index + 1 < selector.length) {\\n      index += 2;\\n    } else if (c === quote) {\\n      quote = void 0;\\n      index++;\\n    } else if (!quote && (c === '\\\"' || c === \\\"'\\\" || c === \\\"`\\\") && !shouldIgnoreTextSelectorQuote()) {\\n      quote = c;\\n      index++;\\n    } else if (!quote && c === \\\">\\\" && selector[index + 1] === \\\">\\\") {\\n      append();\\n      index += 2;\\n      start = index;\\n    } else {\\n      index++;\\n    }\\n  }\\n  append();\\n  return result;\\n}\\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\\n  let wp = 0;\\n  let EOL = selector.length === 0;\\n  const next = () => selector[wp] || \\\"\\\";\\n  const eat1 = () => {\\n    const result2 = next();\\n    ++wp;\\n    EOL = wp >= selector.length;\\n    return result2;\\n  };\\n  const syntaxError = (stage) => {\\n    if (EOL)\\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\\\`${selector}\\\\``);\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - unexpected symbol \\\"${next()}\\\" at position ${wp}` + (stage ? \\\" during \\\" + stage : \\\"\\\"));\\n  };\\n  function skipSpaces() {\\n    while (!EOL && /\\\\s/.test(next()))\\n      eat1();\\n  }\\n  function isCSSNameChar(char) {\\n    return char >= \\\"\\\\x80\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char >= \\\"A\\\" && char <= \\\"Z\\\" || char >= \\\"a\\\" && char <= \\\"z\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char === \\\"_\\\" || char === \\\"-\\\";\\n  }\\n  function readIdentifier() {\\n    let result2 = \\\"\\\";\\n    skipSpaces();\\n    while (!EOL && isCSSNameChar(next()))\\n      result2 += eat1();\\n    return result2;\\n  }\\n  function readQuotedString(quote) {\\n    let result2 = eat1();\\n    if (result2 !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    while (!EOL && next() !== quote) {\\n      if (next() === \\\"\\\\\\\\\\\")\\n        eat1();\\n      result2 += eat1();\\n    }\\n    if (next() !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    result2 += eat1();\\n    return result2;\\n  }\\n  function readRegularExpression() {\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let source = \\\"\\\";\\n    let inClass = false;\\n    while (!EOL) {\\n      if (next() === \\\"\\\\\\\\\\\") {\\n        source += eat1();\\n        if (EOL)\\n          syntaxError(\\\"parsing regular expressiion\\\");\\n      } else if (inClass && next() === \\\"]\\\") {\\n        inClass = false;\\n      } else if (!inClass && next() === \\\"[\\\") {\\n        inClass = true;\\n      } else if (!inClass && next() === \\\"/\\\") {\\n        break;\\n      }\\n      source += eat1();\\n    }\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let flags = \\\"\\\";\\n    while (!EOL && next().match(/[dgimsuy]/))\\n      flags += eat1();\\n    try {\\n      return new RegExp(source, flags);\\n    } catch (e) {\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\`: ${e.message}`);\\n    }\\n  }\\n  function readAttributeToken() {\\n    let token = \\\"\\\";\\n    skipSpaces();\\n    if (next() === `'` || next() === `\\\"`)\\n      token = readQuotedString(next()).slice(1, -1);\\n    else\\n      token = readIdentifier();\\n    if (!token)\\n      syntaxError(\\\"parsing property path\\\");\\n    return token;\\n  }\\n  function readOperator() {\\n    skipSpaces();\\n    let op = \\\"\\\";\\n    if (!EOL)\\n      op += eat1();\\n    if (!EOL && op !== \\\"=\\\")\\n      op += eat1();\\n    if (![\\\"=\\\", \\\"*=\\\", \\\"^=\\\", \\\"$=\\\", \\\"|=\\\", \\\"~=\\\"].includes(op))\\n      syntaxError(\\\"parsing operator\\\");\\n    return op;\\n  }\\n  function readAttribute() {\\n    eat1();\\n    const jsonPath = [];\\n    jsonPath.push(readAttributeToken());\\n    skipSpaces();\\n    while (next() === \\\".\\\") {\\n      eat1();\\n      jsonPath.push(readAttributeToken());\\n      skipSpaces();\\n    }\\n    if (next() === \\\"]\\\") {\\n      eat1();\\n      return { name: jsonPath.join(\\\".\\\"), jsonPath, op: \\\"<truthy>\\\", value: null, caseSensitive: false };\\n    }\\n    const operator = readOperator();\\n    let value = void 0;\\n    let caseSensitive = true;\\n    skipSpaces();\\n    if (next() === \\\"/\\\") {\\n      if (operator !== \\\"=\\\")\\n        throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with regular expression`);\\n      value = readRegularExpression();\\n    } else if (next() === `'` || next() === `\\\"`) {\\n      value = readQuotedString(next()).slice(1, -1);\\n      skipSpaces();\\n      if (next() === \\\"i\\\" || next() === \\\"I\\\") {\\n        caseSensitive = false;\\n        eat1();\\n      } else if (next() === \\\"s\\\" || next() === \\\"S\\\") {\\n        caseSensitive = true;\\n        eat1();\\n      }\\n    } else {\\n      value = \\\"\\\";\\n      while (!EOL && (isCSSNameChar(next()) || next() === \\\"+\\\" || next() === \\\".\\\"))\\n        value += eat1();\\n      if (value === \\\"true\\\") {\\n        value = true;\\n      } else if (value === \\\"false\\\") {\\n        value = false;\\n      } else {\\n        if (!allowUnquotedStrings) {\\n          value = +value;\\n          if (Number.isNaN(value))\\n            syntaxError(\\\"parsing attribute value\\\");\\n        }\\n      }\\n    }\\n    skipSpaces();\\n    if (next() !== \\\"]\\\")\\n      syntaxError(\\\"parsing attribute value\\\");\\n    eat1();\\n    if (operator !== \\\"=\\\" && typeof value !== \\\"string\\\")\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\\n    return { name: jsonPath.join(\\\".\\\"), jsonPath, op: operator, value, caseSensitive };\\n  }\\n  const result = {\\n    name: \\\"\\\",\\n    attributes: []\\n  };\\n  result.name = readIdentifier();\\n  skipSpaces();\\n  while (next() === \\\"[\\\") {\\n    result.attributes.push(readAttribute());\\n    skipSpaces();\\n  }\\n  if (!EOL)\\n    syntaxError(void 0);\\n  if (!result.name && !result.attributes.length)\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - selector cannot be empty`);\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/injected/reactSelectorEngine.ts\\nfunction getComponentName(reactElement) {\\n  if (typeof reactElement.type === \\\"function\\\")\\n    return reactElement.type.displayName || reactElement.type.name || \\\"Anonymous\\\";\\n  if (typeof reactElement.type === \\\"string\\\")\\n    return reactElement.type;\\n  if (reactElement._currentElement) {\\n    const elementType = reactElement._currentElement.type;\\n    if (typeof elementType === \\\"string\\\")\\n      return elementType;\\n    if (typeof elementType === \\\"function\\\")\\n      return elementType.displayName || elementType.name || \\\"Anonymous\\\";\\n  }\\n  return \\\"\\\";\\n}\\nfunction getComponentKey(reactElement) {\\n  var _a, _b;\\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\\n}\\nfunction getChildren(reactElement) {\\n  if (reactElement.child) {\\n    const children = [];\\n    for (let child = reactElement.child; child; child = child.sibling)\\n      children.push(child);\\n    return children;\\n  }\\n  if (!reactElement._currentElement)\\n    return [];\\n  const isKnownElement = (reactElement2) => {\\n    var _a;\\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\\n    return typeof elementType === \\\"function\\\" || typeof elementType === \\\"string\\\";\\n  };\\n  if (reactElement._renderedComponent) {\\n    const child = reactElement._renderedComponent;\\n    return isKnownElement(child) ? [child] : [];\\n  }\\n  if (reactElement._renderedChildren)\\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\\n  return [];\\n}\\nfunction getProps(reactElement) {\\n  var _a;\\n  const props = reactElement.memoizedProps || ((_a = reactElement._currentElement) == null ? void 0 : _a.props);\\n  if (!props || typeof props === \\\"string\\\")\\n    return props;\\n  const result = { ...props };\\n  delete result.children;\\n  return result;\\n}\\nfunction buildComponentsTree(reactElement) {\\n  var _a;\\n  const treeNode = {\\n    key: getComponentKey(reactElement),\\n    name: getComponentName(reactElement),\\n    children: getChildren(reactElement).map(buildComponentsTree),\\n    rootElements: [],\\n    props: getProps(reactElement)\\n  };\\n  const rootElement = reactElement.stateNode || reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode);\\n  if (rootElement instanceof Element) {\\n    treeNode.rootElements.push(rootElement);\\n  } else {\\n    for (const child of treeNode.children)\\n      treeNode.rootElements.push(...child.rootElements);\\n  }\\n  return treeNode;\\n}\\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\\n  if (searchFn(treeNode))\\n    result.push(treeNode);\\n  for (const child of treeNode.children)\\n    filterComponentsTree(child, searchFn, result);\\n  return result;\\n}\\nfunction findReactRoots(root, roots = []) {\\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\\n  do {\\n    const node = walker.currentNode;\\n    const rootKey = Object.keys(node).find((key) => key.startsWith(\\\"__reactContainer\\\"));\\n    if (rootKey) {\\n      roots.push(node[rootKey].stateNode.current);\\n    } else if (node.hasOwnProperty(\\\"_reactRootContainer\\\")) {\\n      roots.push(node._reactRootContainer._internalRoot.current);\\n    }\\n    if (node instanceof Element && node.hasAttribute(\\\"data-reactroot\\\")) {\\n      for (const key of Object.keys(node)) {\\n        if (key.startsWith(\\\"__reactInternalInstance\\\") || key.startsWith(\\\"__reactFiber\\\"))\\n          roots.push(node[key]);\\n      }\\n    }\\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\\n    if (shadowRoot)\\n      findReactRoots(shadowRoot, roots);\\n  } while (walker.nextNode());\\n  return roots;\\n}\\nvar ReactEngine = {\\n  queryAll(scope, selector) {\\n    const { name, attributes } = parseAttributeSelector(selector, false);\\n    const reactRoots = findReactRoots(document);\\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\\n      var _a;\\n      const props = (_a = treeNode.props) != null ? _a : {};\\n      if (treeNode.key !== void 0)\\n        props.key = treeNode.key;\\n      if (name && treeNode.name !== name)\\n        return false;\\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\\n        return false;\\n      for (const attr of attributes) {\\n        if (!matchesComponentAttribute(props, attr))\\n          return false;\\n      }\\n      return true;\\n    })).flat();\\n    const allRootElements = /* @__PURE__ */ new Set();\\n    for (const treeNode of treeNodes) {\\n      for (const domNode of treeNode.rootElements)\\n        allRootElements.add(domNode);\\n    }\\n    return [...allRootElements];\\n  }\\n};\\n\\n// packages/playwright-core/src/server/injected/vueSelectorEngine.ts\\nfunction basename(filename, ext) {\\n  const normalized = filename.replace(/^[a-zA-Z]:/, \\\"\\\").replace(/\\\\\\\\/g, \\\"/\\\");\\n  let result = normalized.substring(normalized.lastIndexOf(\\\"/\\\") + 1);\\n  if (ext && result.endsWith(ext))\\n    result = result.substring(0, result.length - ext.length);\\n  return result;\\n}\\nfunction toUpper(_, c) {\\n  return c ? c.toUpperCase() : \\\"\\\";\\n}\\nvar classifyRE = /(?:^|[-_/])(\\\\w)/g;\\nvar classify = (str) => {\\n  return str && str.replace(classifyRE, toUpper);\\n};\\nfunction buildComponentsTreeVue3(instance) {\\n  function getComponentTypeName(options) {\\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\\n    if (name)\\n      return name;\\n    const file = options.__file;\\n    if (file)\\n      return classify(basename(file, \\\".vue\\\"));\\n  }\\n  function saveComponentName(instance2, key) {\\n    instance2.type.__playwright_guessedName = key;\\n    return key;\\n  }\\n  function getInstanceName(instance2) {\\n    var _a, _b, _c, _d;\\n    const name = getComponentTypeName(instance2.type || {});\\n    if (name)\\n      return name;\\n    if (instance2.root === instance2)\\n      return \\\"Root\\\";\\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components)\\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\\n        return saveComponentName(instance2, key);\\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components)\\n      if (instance2.appContext.components[key] === instance2.type)\\n        return saveComponentName(instance2, key);\\n    return \\\"Anonymous Component\\\";\\n  }\\n  function isBeingDestroyed(instance2) {\\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\\n  }\\n  function isFragment(instance2) {\\n    return instance2.subTree.type.toString() === \\\"Symbol(Fragment)\\\";\\n  }\\n  function getInternalInstanceChildren(subTree) {\\n    const list = [];\\n    if (subTree.component)\\n      list.push(subTree.component);\\n    if (subTree.suspense)\\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\\n    if (Array.isArray(subTree.children)) {\\n      subTree.children.forEach((childSubTree) => {\\n        if (childSubTree.component)\\n          list.push(childSubTree.component);\\n        else\\n          list.push(...getInternalInstanceChildren(childSubTree));\\n      });\\n    }\\n    return list.filter((child) => {\\n      var _a;\\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\\n    });\\n  }\\n  function getRootElementsFromComponentInstance(instance2) {\\n    if (isFragment(instance2))\\n      return getFragmentRootElements(instance2.subTree);\\n    return [instance2.subTree.el];\\n  }\\n  function getFragmentRootElements(vnode) {\\n    if (!vnode.children)\\n      return [];\\n    const list = [];\\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\\n      const childVnode = vnode.children[i];\\n      if (childVnode.component)\\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\\n      else if (childVnode.el)\\n        list.push(childVnode.el);\\n    }\\n    return list;\\n  }\\n  function buildComponentsTree2(instance2) {\\n    return {\\n      name: getInstanceName(instance2),\\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\\n      rootElements: getRootElementsFromComponentInstance(instance2),\\n      props: instance2.props\\n    };\\n  }\\n  return buildComponentsTree2(instance);\\n}\\nfunction buildComponentsTreeVue2(instance) {\\n  function getComponentName2(options) {\\n    const name = options.displayName || options.name || options._componentTag;\\n    if (name)\\n      return name;\\n    const file = options.__file;\\n    if (file)\\n      return classify(basename(file, \\\".vue\\\"));\\n  }\\n  function getInstanceName(instance2) {\\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\\n    if (name)\\n      return name;\\n    return instance2.$root === instance2 ? \\\"Root\\\" : \\\"Anonymous Component\\\";\\n  }\\n  function getInternalInstanceChildren(instance2) {\\n    if (instance2.$children)\\n      return instance2.$children;\\n    if (Array.isArray(instance2.subTree.children))\\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\\n    return [];\\n  }\\n  function buildComponentsTree2(instance2) {\\n    return {\\n      name: getInstanceName(instance2),\\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\\n      rootElements: [instance2.$el],\\n      props: instance2._props\\n    };\\n  }\\n  return buildComponentsTree2(instance);\\n}\\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\\n  if (searchFn(treeNode))\\n    result.push(treeNode);\\n  for (const child of treeNode.children)\\n    filterComponentsTree2(child, searchFn, result);\\n  return result;\\n}\\nfunction findVueRoots(root, roots = []) {\\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\\n  const vue2Roots = /* @__PURE__ */ new Set();\\n  do {\\n    const node = walker.currentNode;\\n    if (node.__vue__)\\n      vue2Roots.add(node.__vue__.$root);\\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\\n      roots.push({ root: node._vnode.component, version: 3 });\\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\\n    if (shadowRoot)\\n      findVueRoots(shadowRoot, roots);\\n  } while (walker.nextNode());\\n  for (const vue2root of vue2Roots) {\\n    roots.push({\\n      version: 2,\\n      root: vue2root\\n    });\\n  }\\n  return roots;\\n}\\nvar VueEngine = {\\n  queryAll(scope, selector) {\\n    const { name, attributes } = parseAttributeSelector(selector, false);\\n    const vueRoots = findVueRoots(document);\\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\\n      if (name && treeNode.name !== name)\\n        return false;\\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\\n        return false;\\n      for (const attr of attributes) {\\n        if (!matchesComponentAttribute(treeNode.props, attr))\\n          return false;\\n      }\\n      return true;\\n    })).flat();\\n    const allRootElements = /* @__PURE__ */ new Set();\\n    for (const treeNode of treeNodes) {\\n      for (const rootElement of treeNode.rootElements)\\n        allRootElements.add(rootElement);\\n    }\\n    return [...allRootElements];\\n  }\\n};\\n\\n// packages/playwright-core/src/server/injected/roleUtils.ts\\nfunction hasExplicitAccessibleName(e) {\\n  return e.hasAttribute(\\\"aria-label\\\") || e.hasAttribute(\\\"aria-labelledby\\\");\\n}\\nvar kAncestorPreventingLandmark = \\\"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\\\";\\nvar kGlobalAriaAttributes = [\\n  \\\"aria-atomic\\\",\\n  \\\"aria-busy\\\",\\n  \\\"aria-controls\\\",\\n  \\\"aria-current\\\",\\n  \\\"aria-describedby\\\",\\n  \\\"aria-details\\\",\\n  \\\"aria-disabled\\\",\\n  \\\"aria-dropeffect\\\",\\n  \\\"aria-errormessage\\\",\\n  \\\"aria-flowto\\\",\\n  \\\"aria-grabbed\\\",\\n  \\\"aria-haspopup\\\",\\n  \\\"aria-hidden\\\",\\n  \\\"aria-invalid\\\",\\n  \\\"aria-keyshortcuts\\\",\\n  \\\"aria-label\\\",\\n  \\\"aria-labelledby\\\",\\n  \\\"aria-live\\\",\\n  \\\"aria-owns\\\",\\n  \\\"aria-relevant\\\",\\n  \\\"aria-roledescription\\\"\\n];\\nfunction hasGlobalAriaAttribute(e) {\\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\\n}\\nvar kImplicitRoleByTagName = {\\n  \\\"A\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"AREA\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"ARTICLE\\\": () => \\\"article\\\",\\n  \\\"ASIDE\\\": () => \\\"complementary\\\",\\n  \\\"BLOCKQUOTE\\\": () => \\\"blockquote\\\",\\n  \\\"BUTTON\\\": () => \\\"button\\\",\\n  \\\"CAPTION\\\": () => \\\"caption\\\",\\n  \\\"CODE\\\": () => \\\"code\\\",\\n  \\\"DATALIST\\\": () => \\\"listbox\\\",\\n  \\\"DD\\\": () => \\\"definition\\\",\\n  \\\"DEL\\\": () => \\\"deletion\\\",\\n  \\\"DETAILS\\\": () => \\\"group\\\",\\n  \\\"DFN\\\": () => \\\"term\\\",\\n  \\\"DIALOG\\\": () => \\\"dialog\\\",\\n  \\\"DT\\\": () => \\\"term\\\",\\n  \\\"EM\\\": () => \\\"emphasis\\\",\\n  \\\"FIELDSET\\\": () => \\\"group\\\",\\n  \\\"FIGURE\\\": () => \\\"figure\\\",\\n  \\\"FOOTER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"contentinfo\\\",\\n  \\\"FORM\\\": (e) => hasExplicitAccessibleName(e) ? \\\"form\\\" : null,\\n  \\\"H1\\\": () => \\\"heading\\\",\\n  \\\"H2\\\": () => \\\"heading\\\",\\n  \\\"H3\\\": () => \\\"heading\\\",\\n  \\\"H4\\\": () => \\\"heading\\\",\\n  \\\"H5\\\": () => \\\"heading\\\",\\n  \\\"H6\\\": () => \\\"heading\\\",\\n  \\\"HEADER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"banner\\\",\\n  \\\"HR\\\": () => \\\"separator\\\",\\n  \\\"HTML\\\": () => \\\"document\\\",\\n  \\\"IMG\\\": (e) => e.getAttribute(\\\"alt\\\") === \\\"\\\" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute(\\\"tabindex\\\")))) ? \\\"presentation\\\" : \\\"img\\\",\\n  \\\"INPUT\\\": (e) => {\\n    const type = e.type.toLowerCase();\\n    if (type === \\\"search\\\")\\n      return e.hasAttribute(\\\"list\\\") ? \\\"combobox\\\" : \\\"searchbox\\\";\\n    if ([\\\"email\\\", \\\"tel\\\", \\\"text\\\", \\\"url\\\", \\\"\\\"].includes(type)) {\\n      const list = getIdRefs(e, e.getAttribute(\\\"list\\\"))[0];\\n      return list && list.tagName === \\\"DATALIST\\\" ? \\\"combobox\\\" : \\\"textbox\\\";\\n    }\\n    if (type === \\\"hidden\\\")\\n      return \\\"\\\";\\n    return {\\n      \\\"button\\\": \\\"button\\\",\\n      \\\"checkbox\\\": \\\"checkbox\\\",\\n      \\\"image\\\": \\\"button\\\",\\n      \\\"number\\\": \\\"spinbutton\\\",\\n      \\\"radio\\\": \\\"radio\\\",\\n      \\\"range\\\": \\\"slider\\\",\\n      \\\"reset\\\": \\\"button\\\",\\n      \\\"submit\\\": \\\"button\\\"\\n    }[type] || \\\"textbox\\\";\\n  },\\n  \\\"INS\\\": () => \\\"insertion\\\",\\n  \\\"LI\\\": () => \\\"listitem\\\",\\n  \\\"MAIN\\\": () => \\\"main\\\",\\n  \\\"MARK\\\": () => \\\"mark\\\",\\n  \\\"MATH\\\": () => \\\"math\\\",\\n  \\\"MENU\\\": () => \\\"list\\\",\\n  \\\"METER\\\": () => \\\"meter\\\",\\n  \\\"NAV\\\": () => \\\"navigation\\\",\\n  \\\"OL\\\": () => \\\"list\\\",\\n  \\\"OPTGROUP\\\": () => \\\"group\\\",\\n  \\\"OPTION\\\": () => \\\"option\\\",\\n  \\\"OUTPUT\\\": () => \\\"status\\\",\\n  \\\"P\\\": () => \\\"paragraph\\\",\\n  \\\"PROGRESS\\\": () => \\\"progressbar\\\",\\n  \\\"SECTION\\\": (e) => hasExplicitAccessibleName(e) ? \\\"region\\\" : null,\\n  \\\"SELECT\\\": (e) => e.hasAttribute(\\\"multiple\\\") || e.size > 1 ? \\\"listbox\\\" : \\\"combobox\\\",\\n  \\\"STRONG\\\": () => \\\"strong\\\",\\n  \\\"SUB\\\": () => \\\"subscript\\\",\\n  \\\"SUP\\\": () => \\\"superscript\\\",\\n  \\\"TABLE\\\": () => \\\"table\\\",\\n  \\\"TBODY\\\": () => \\\"rowgroup\\\",\\n  \\\"TD\\\": (e) => {\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"TEXTAREA\\\": () => \\\"textbox\\\",\\n  \\\"TFOOT\\\": () => \\\"rowgroup\\\",\\n  \\\"TH\\\": (e) => {\\n    if (e.getAttribute(\\\"scope\\\") === \\\"col\\\")\\n      return \\\"columnheader\\\";\\n    if (e.getAttribute(\\\"scope\\\") === \\\"row\\\")\\n      return \\\"rowheader\\\";\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"THEAD\\\": () => \\\"rowgroup\\\",\\n  \\\"TIME\\\": () => \\\"time\\\",\\n  \\\"TR\\\": () => \\\"row\\\",\\n  \\\"UL\\\": () => \\\"list\\\"\\n};\\nvar kPresentationInheritanceParents = {\\n  \\\"DD\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"DIV\\\": [\\\"DL\\\"],\\n  \\\"DT\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"LI\\\": [\\\"OL\\\", \\\"UL\\\"],\\n  \\\"TBODY\\\": [\\\"TABLE\\\"],\\n  \\\"TD\\\": [\\\"TR\\\"],\\n  \\\"TFOOT\\\": [\\\"TABLE\\\"],\\n  \\\"TH\\\": [\\\"TR\\\"],\\n  \\\"THEAD\\\": [\\\"TABLE\\\"],\\n  \\\"TR\\\": [\\\"THEAD\\\", \\\"TBODY\\\", \\\"TFOOT\\\", \\\"TABLE\\\"]\\n};\\nfunction getImplicitAriaRole(element) {\\n  var _a;\\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \\\"\\\";\\n  if (!implicitRole)\\n    return null;\\n  let ancestor = element;\\n  while (ancestor) {\\n    const parent = parentElementOrShadowHost(ancestor);\\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\\n    if (!parents || !parent || !parents.includes(parent.tagName))\\n      break;\\n    const parentExplicitRole = getExplicitAriaRole(parent);\\n    if ((parentExplicitRole === \\\"none\\\" || parentExplicitRole === \\\"presentation\\\") && !hasPresentationConflictResolution(parent))\\n      return parentExplicitRole;\\n    ancestor = parent;\\n  }\\n  return implicitRole;\\n}\\nvar allRoles = [\\n  \\\"alert\\\",\\n  \\\"alertdialog\\\",\\n  \\\"application\\\",\\n  \\\"article\\\",\\n  \\\"banner\\\",\\n  \\\"blockquote\\\",\\n  \\\"button\\\",\\n  \\\"caption\\\",\\n  \\\"cell\\\",\\n  \\\"checkbox\\\",\\n  \\\"code\\\",\\n  \\\"columnheader\\\",\\n  \\\"combobox\\\",\\n  \\\"command\\\",\\n  \\\"complementary\\\",\\n  \\\"composite\\\",\\n  \\\"contentinfo\\\",\\n  \\\"definition\\\",\\n  \\\"deletion\\\",\\n  \\\"dialog\\\",\\n  \\\"directory\\\",\\n  \\\"document\\\",\\n  \\\"emphasis\\\",\\n  \\\"feed\\\",\\n  \\\"figure\\\",\\n  \\\"form\\\",\\n  \\\"generic\\\",\\n  \\\"grid\\\",\\n  \\\"gridcell\\\",\\n  \\\"group\\\",\\n  \\\"heading\\\",\\n  \\\"img\\\",\\n  \\\"input\\\",\\n  \\\"insertion\\\",\\n  \\\"landmark\\\",\\n  \\\"link\\\",\\n  \\\"list\\\",\\n  \\\"listbox\\\",\\n  \\\"listitem\\\",\\n  \\\"log\\\",\\n  \\\"main\\\",\\n  \\\"marquee\\\",\\n  \\\"math\\\",\\n  \\\"meter\\\",\\n  \\\"menu\\\",\\n  \\\"menubar\\\",\\n  \\\"menuitem\\\",\\n  \\\"menuitemcheckbox\\\",\\n  \\\"menuitemradio\\\",\\n  \\\"navigation\\\",\\n  \\\"none\\\",\\n  \\\"note\\\",\\n  \\\"option\\\",\\n  \\\"paragraph\\\",\\n  \\\"presentation\\\",\\n  \\\"progressbar\\\",\\n  \\\"radio\\\",\\n  \\\"radiogroup\\\",\\n  \\\"range\\\",\\n  \\\"region\\\",\\n  \\\"roletype\\\",\\n  \\\"row\\\",\\n  \\\"rowgroup\\\",\\n  \\\"rowheader\\\",\\n  \\\"scrollbar\\\",\\n  \\\"search\\\",\\n  \\\"searchbox\\\",\\n  \\\"section\\\",\\n  \\\"sectionhead\\\",\\n  \\\"select\\\",\\n  \\\"separator\\\",\\n  \\\"slider\\\",\\n  \\\"spinbutton\\\",\\n  \\\"status\\\",\\n  \\\"strong\\\",\\n  \\\"structure\\\",\\n  \\\"subscript\\\",\\n  \\\"superscript\\\",\\n  \\\"switch\\\",\\n  \\\"tab\\\",\\n  \\\"table\\\",\\n  \\\"tablist\\\",\\n  \\\"tabpanel\\\",\\n  \\\"term\\\",\\n  \\\"textbox\\\",\\n  \\\"time\\\",\\n  \\\"timer\\\",\\n  \\\"toolbar\\\",\\n  \\\"tooltip\\\",\\n  \\\"tree\\\",\\n  \\\"treegrid\\\",\\n  \\\"treeitem\\\",\\n  \\\"widget\\\",\\n  \\\"window\\\"\\n];\\nvar abstractRoles = [\\\"command\\\", \\\"composite\\\", \\\"input\\\", \\\"landmark\\\", \\\"range\\\", \\\"roletype\\\", \\\"section\\\", \\\"sectionhead\\\", \\\"select\\\", \\\"structure\\\", \\\"widget\\\", \\\"window\\\"];\\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\\nfunction getExplicitAriaRole(element) {\\n  const roles = (element.getAttribute(\\\"role\\\") || \\\"\\\").split(\\\" \\\").map((role) => role.trim());\\n  return roles.find((role) => validRoles.includes(role)) || null;\\n}\\nfunction hasPresentationConflictResolution(element) {\\n  return !hasGlobalAriaAttribute(element);\\n}\\nfunction getAriaRole(element) {\\n  const explicitRole = getExplicitAriaRole(element);\\n  if (!explicitRole)\\n    return getImplicitAriaRole(element);\\n  if ((explicitRole === \\\"none\\\" || explicitRole === \\\"presentation\\\") && hasPresentationConflictResolution(element))\\n    return getImplicitAriaRole(element);\\n  return explicitRole;\\n}\\nfunction getAriaBoolean(attr) {\\n  return attr === null ? void 0 : attr.toLowerCase() === \\\"true\\\";\\n}\\nfunction isElementHiddenForAria(element, cache) {\\n  if ([\\\"STYLE\\\", \\\"SCRIPT\\\", \\\"NOSCRIPT\\\", \\\"TEMPLATE\\\"].includes(element.tagName))\\n    return true;\\n  const isOptionInsideSelect = element.nodeName === \\\"OPTION\\\" && !!element.closest(\\\"select\\\");\\n  const isSlot = element.nodeName === \\\"SLOT\\\";\\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element))\\n    return true;\\n  return belongsToDisplayNoneOrAriaHidden(element, cache);\\n}\\nfunction belongsToDisplayNoneOrAriaHidden(element, cache) {\\n  if (!cache.has(element)) {\\n    const style = getElementComputedStyle(element);\\n    let hidden = !style || style.display === \\\"none\\\" || getAriaBoolean(element.getAttribute(\\\"aria-hidden\\\")) === true;\\n    if (!hidden) {\\n      const parent = parentElementOrShadowHost(element);\\n      if (parent)\\n        hidden = hidden || belongsToDisplayNoneOrAriaHidden(parent, cache);\\n    }\\n    cache.set(element, hidden);\\n  }\\n  return cache.get(element);\\n}\\nfunction getIdRefs(element, ref) {\\n  if (!ref)\\n    return [];\\n  const root = enclosingShadowRootOrDocument(element);\\n  if (!root)\\n    return [];\\n  try {\\n    const ids = ref.split(\\\" \\\").filter((id) => !!id);\\n    const set = /* @__PURE__ */ new Set();\\n    for (const id of ids) {\\n      const firstElement = root.querySelector(\\\"#\\\" + CSS.escape(id));\\n      if (firstElement)\\n        set.add(firstElement);\\n    }\\n    return [...set];\\n  } catch (e) {\\n    return [];\\n  }\\n}\\nfunction normalizeAccessbileName(s) {\\n  return s.replace(/\\\\r\\\\n/g, \\\"\\\\n\\\").replace(/\\\\u00A0/g, \\\" \\\").replace(/\\\\s\\\\s+/g, \\\" \\\").trim();\\n}\\nfunction queryInAriaOwned(element, selector) {\\n  const result = [...element.querySelectorAll(selector)];\\n  for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\"))) {\\n    if (owned.matches(selector))\\n      result.push(owned);\\n    result.push(...owned.querySelectorAll(selector));\\n  }\\n  return result;\\n}\\nfunction getPseudoContent(pseudoStyle) {\\n  if (!pseudoStyle)\\n    return \\\"\\\";\\n  const content = pseudoStyle.getPropertyValue(\\\"content\\\");\\n  if (content[0] === \\\"'\\\" && content[content.length - 1] === \\\"'\\\" || content[0] === '\\\"' && content[content.length - 1] === '\\\"') {\\n    const unquoted = content.substring(1, content.length - 1);\\n    const display = pseudoStyle.getPropertyValue(\\\"display\\\") || \\\"inline\\\";\\n    if (display !== \\\"inline\\\")\\n      return \\\" \\\" + unquoted + \\\" \\\";\\n    return unquoted;\\n  }\\n  return \\\"\\\";\\n}\\nfunction getAriaLabelledByElements(element) {\\n  const ref = element.getAttribute(\\\"aria-labelledby\\\");\\n  if (ref === null)\\n    return null;\\n  return getIdRefs(element, ref);\\n}\\nfunction allowsNameFromContent(role, targetDescendant) {\\n  const alwaysAllowsNameFromContent = [\\\"button\\\", \\\"cell\\\", \\\"checkbox\\\", \\\"columnheader\\\", \\\"gridcell\\\", \\\"heading\\\", \\\"link\\\", \\\"menuitem\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"option\\\", \\\"radio\\\", \\\"row\\\", \\\"rowheader\\\", \\\"switch\\\", \\\"tab\\\", \\\"tooltip\\\", \\\"treeitem\\\"].includes(role);\\n  const descendantAllowsNameFromContent = targetDescendant && [\\\"\\\", \\\"caption\\\", \\\"code\\\", \\\"contentinfo\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"insertion\\\", \\\"list\\\", \\\"listitem\\\", \\\"mark\\\", \\\"none\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"region\\\", \\\"row\\\", \\\"rowgroup\\\", \\\"section\\\", \\\"strong\\\", \\\"subscript\\\", \\\"superscript\\\", \\\"table\\\", \\\"term\\\", \\\"time\\\"].includes(role);\\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\\n}\\nfunction getElementAccessibleName(element, includeHidden, hiddenCache) {\\n  const elementProhibitsNaming = [\\\"caption\\\", \\\"code\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"generic\\\", \\\"insertion\\\", \\\"mark\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"strong\\\", \\\"subscript\\\", \\\"suggestion\\\", \\\"superscript\\\", \\\"term\\\", \\\"time\\\"].includes(getAriaRole(element) || \\\"\\\");\\n  if (elementProhibitsNaming)\\n    return \\\"\\\";\\n  const accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\\n    includeHidden,\\n    hiddenCache,\\n    visitedElements: /* @__PURE__ */ new Set(),\\n    embeddedInLabelledBy: \\\"none\\\",\\n    embeddedInLabel: \\\"none\\\",\\n    embeddedInTextAlternativeElement: false,\\n    embeddedInTargetElement: \\\"self\\\"\\n  }));\\n  return accessibleName;\\n}\\nfunction getElementAccessibleNameInternal(element, options) {\\n  if (options.visitedElements.has(element))\\n    return \\\"\\\";\\n  const childOptions = {\\n    ...options,\\n    embeddedInLabel: options.embeddedInLabel === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInLabel,\\n    embeddedInLabelledBy: options.embeddedInLabelledBy === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInLabelledBy,\\n    embeddedInTargetElement: options.embeddedInTargetElement === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInTargetElement\\n  };\\n  if (!options.includeHidden && options.embeddedInLabelledBy !== \\\"self\\\" && isElementHiddenForAria(element, options.hiddenCache)) {\\n    options.visitedElements.add(element);\\n    return \\\"\\\";\\n  }\\n  if (options.embeddedInLabelledBy === \\\"none\\\") {\\n    const refs = getAriaLabelledByElements(element) || [];\\n    const accessibleName = refs.map((ref) => getElementAccessibleNameInternal(ref, {\\n      ...options,\\n      embeddedInLabelledBy: \\\"self\\\",\\n      embeddedInTargetElement: \\\"none\\\",\\n      embeddedInLabel: \\\"none\\\",\\n      embeddedInTextAlternativeElement: false\\n    })).join(\\\" \\\");\\n    if (accessibleName)\\n      return accessibleName;\\n  }\\n  const role = getAriaRole(element) || \\\"\\\";\\n  if (options.embeddedInLabel !== \\\"none\\\" || options.embeddedInLabelledBy !== \\\"none\\\") {\\n    const isOwnLabel = [...element.labels || []].includes(element);\\n    const isOwnLabelledBy = getIdRefs(element, element.getAttribute(\\\"aria-labelledby\\\")).includes(element);\\n    if (!isOwnLabel && !isOwnLabelledBy) {\\n      if (role === \\\"textbox\\\") {\\n        options.visitedElements.add(element);\\n        if (element.tagName === \\\"INPUT\\\" || element.tagName === \\\"TEXTAREA\\\")\\n          return element.value;\\n        return element.textContent || \\\"\\\";\\n      }\\n      if ([\\\"combobox\\\", \\\"listbox\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        let selectedOptions;\\n        if (element.tagName === \\\"SELECT\\\") {\\n          selectedOptions = [...element.selectedOptions];\\n          if (!selectedOptions.length && element.options.length)\\n            selectedOptions.push(element.options[0]);\\n        } else {\\n          const listbox = role === \\\"combobox\\\" ? queryInAriaOwned(element, \\\"*\\\").find((e) => getAriaRole(e) === \\\"listbox\\\") : element;\\n          selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\\\"true\\\"]').filter((e) => getAriaRole(e) === \\\"option\\\") : [];\\n        }\\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(\\\" \\\");\\n      }\\n      if ([\\\"progressbar\\\", \\\"scrollbar\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"meter\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        if (element.hasAttribute(\\\"aria-valuetext\\\"))\\n          return element.getAttribute(\\\"aria-valuetext\\\") || \\\"\\\";\\n        if (element.hasAttribute(\\\"aria-valuenow\\\"))\\n          return element.getAttribute(\\\"aria-valuenow\\\") || \\\"\\\";\\n        return element.getAttribute(\\\"value\\\") || \\\"\\\";\\n      }\\n      if ([\\\"menu\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        return \\\"\\\";\\n      }\\n    }\\n  }\\n  const ariaLabel = element.getAttribute(\\\"aria-label\\\") || \\\"\\\";\\n  if (ariaLabel.trim()) {\\n    options.visitedElements.add(element);\\n    return ariaLabel;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role)) {\\n    if (element.tagName === \\\"INPUT\\\" && [\\\"button\\\", \\\"submit\\\", \\\"reset\\\"].includes(element.type)) {\\n      options.visitedElements.add(element);\\n      const value = element.value || \\\"\\\";\\n      if (value.trim())\\n        return value;\\n      if (element.type === \\\"submit\\\")\\n        return \\\"Submit\\\";\\n      if (element.type === \\\"reset\\\")\\n        return \\\"Reset\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"INPUT\\\" && element.type === \\\"image\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const labels = element.labels || [];\\n      if (labels.length) {\\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\\n          ...options,\\n          embeddedInLabel: \\\"self\\\",\\n          embeddedInTextAlternativeElement: false,\\n          embeddedInLabelledBy: \\\"none\\\",\\n          embeddedInTargetElement: \\\"none\\\"\\n        })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (title.trim())\\n        return title;\\n      return \\\"Submit\\\";\\n    }\\n    if (element.tagName === \\\"TEXTAREA\\\" || element.tagName === \\\"SELECT\\\" || element.tagName === \\\"INPUT\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length) {\\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\\n          ...options,\\n          embeddedInLabel: \\\"self\\\",\\n          embeddedInTextAlternativeElement: false,\\n          embeddedInLabelledBy: \\\"none\\\",\\n          embeddedInTargetElement: \\\"none\\\"\\n        })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n      }\\n      const usePlaceholder = element.tagName === \\\"INPUT\\\" && [\\\"text\\\", \\\"password\\\", \\\"search\\\", \\\"tel\\\", \\\"email\\\", \\\"url\\\"].includes(element.type) || element.tagName === \\\"TEXTAREA\\\";\\n      const placeholder = element.getAttribute(\\\"placeholder\\\") || \\\"\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (!usePlaceholder || title)\\n        return title;\\n      return placeholder;\\n    }\\n    if (element.tagName === \\\"FIELDSET\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"LEGEND\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"FIGURE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"FIGCAPTION\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"IMG\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"TABLE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"CAPTION\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const summary = element.getAttribute(\\\"summary\\\") || \\\"\\\";\\n      if (summary)\\n        return summary;\\n    }\\n    if (element.tagName === \\\"AREA\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"SVG\\\" && element.ownerSVGElement) {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"TITLE\\\" && element.ownerSVGElement) {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n    }\\n  }\\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === \\\"descendant\\\") || options.embeddedInLabelledBy !== \\\"none\\\" || options.embeddedInLabel !== \\\"none\\\" || options.embeddedInTextAlternativeElement) {\\n    options.visitedElements.add(element);\\n    const tokens = [];\\n    const visit = (node, skipSlotted) => {\\n      var _a;\\n      if (skipSlotted && node.assignedSlot)\\n        return;\\n      if (node.nodeType === 1) {\\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.getPropertyValue(\\\"display\\\")) || \\\"inline\\\";\\n        let token = getElementAccessibleNameInternal(node, childOptions);\\n        if (display !== \\\"inline\\\" || node.nodeName === \\\"BR\\\")\\n          token = \\\" \\\" + token + \\\" \\\";\\n        tokens.push(token);\\n      } else if (node.nodeType === 3) {\\n        tokens.push(node.textContent || \\\"\\\");\\n      }\\n    };\\n    tokens.push(getPseudoContent(getElementComputedStyle(element, \\\"::before\\\")));\\n    const assignedNodes = element.nodeName === \\\"SLOT\\\" ? element.assignedNodes() : [];\\n    if (assignedNodes.length) {\\n      for (const child of assignedNodes)\\n        visit(child, false);\\n    } else {\\n      for (let child = element.firstChild; child; child = child.nextSibling)\\n        visit(child, true);\\n      if (element.shadowRoot) {\\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\\n          visit(child, true);\\n      }\\n      for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\")))\\n        visit(owned, true);\\n    }\\n    tokens.push(getPseudoContent(getElementComputedStyle(element, \\\"::after\\\")));\\n    const accessibleName = tokens.join(\\\"\\\");\\n    if (accessibleName.trim())\\n      return accessibleName;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role) || element.tagName === \\\"IFRAME\\\") {\\n    options.visitedElements.add(element);\\n    const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n    if (title.trim())\\n      return title;\\n  }\\n  options.visitedElements.add(element);\\n  return \\\"\\\";\\n}\\nvar kAriaSelectedRoles = [\\\"gridcell\\\", \\\"option\\\", \\\"row\\\", \\\"tab\\\", \\\"rowheader\\\", \\\"columnheader\\\", \\\"treeitem\\\"];\\nfunction getAriaSelected(element) {\\n  if (element.tagName === \\\"OPTION\\\")\\n    return element.selected;\\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || \\\"\\\"))\\n    return getAriaBoolean(element.getAttribute(\\\"aria-selected\\\")) === true;\\n  return false;\\n}\\nvar kAriaCheckedRoles = [\\\"checkbox\\\", \\\"menuitemcheckbox\\\", \\\"option\\\", \\\"radio\\\", \\\"switch\\\", \\\"menuitemradio\\\", \\\"treeitem\\\"];\\nfunction getAriaChecked(element) {\\n  const result = getChecked(element, true);\\n  return result === \\\"error\\\" ? false : result;\\n}\\nfunction getChecked(element, allowMixed) {\\n  if (allowMixed && element.tagName === \\\"INPUT\\\" && element.indeterminate)\\n    return \\\"mixed\\\";\\n  if (element.tagName === \\\"INPUT\\\" && [\\\"checkbox\\\", \\\"radio\\\"].includes(element.type))\\n    return element.checked;\\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const checked = element.getAttribute(\\\"aria-checked\\\");\\n    if (checked === \\\"true\\\")\\n      return true;\\n    if (allowMixed && checked === \\\"mixed\\\")\\n      return \\\"mixed\\\";\\n    return false;\\n  }\\n  return \\\"error\\\";\\n}\\nvar kAriaPressedRoles = [\\\"button\\\"];\\nfunction getAriaPressed(element) {\\n  if (kAriaPressedRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const pressed = element.getAttribute(\\\"aria-pressed\\\");\\n    if (pressed === \\\"true\\\")\\n      return true;\\n    if (pressed === \\\"mixed\\\")\\n      return \\\"mixed\\\";\\n  }\\n  return false;\\n}\\nvar kAriaExpandedRoles = [\\\"application\\\", \\\"button\\\", \\\"checkbox\\\", \\\"combobox\\\", \\\"gridcell\\\", \\\"link\\\", \\\"listbox\\\", \\\"menuitem\\\", \\\"row\\\", \\\"rowheader\\\", \\\"tab\\\", \\\"treeitem\\\", \\\"columnheader\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"rowheader\\\", \\\"switch\\\"];\\nfunction getAriaExpanded(element) {\\n  if (element.tagName === \\\"DETAILS\\\")\\n    return element.open;\\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const expanded = element.getAttribute(\\\"aria-expanded\\\");\\n    if (expanded === null)\\n      return \\\"none\\\";\\n    if (expanded === \\\"true\\\")\\n      return true;\\n    return false;\\n  }\\n  return \\\"none\\\";\\n}\\nvar kAriaLevelRoles = [\\\"heading\\\", \\\"listitem\\\", \\\"row\\\", \\\"treeitem\\\"];\\nfunction getAriaLevel(element) {\\n  const native = { \\\"H1\\\": 1, \\\"H2\\\": 2, \\\"H3\\\": 3, \\\"H4\\\": 4, \\\"H5\\\": 5, \\\"H6\\\": 6 }[element.tagName];\\n  if (native)\\n    return native;\\n  if (kAriaLevelRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const attr = element.getAttribute(\\\"aria-level\\\");\\n    const value = attr === null ? Number.NaN : Number(attr);\\n    if (Number.isInteger(value) && value >= 1)\\n      return value;\\n  }\\n  return 0;\\n}\\nvar kAriaDisabledRoles = [\\\"application\\\", \\\"button\\\", \\\"composite\\\", \\\"gridcell\\\", \\\"group\\\", \\\"input\\\", \\\"link\\\", \\\"menuitem\\\", \\\"scrollbar\\\", \\\"separator\\\", \\\"tab\\\", \\\"checkbox\\\", \\\"columnheader\\\", \\\"combobox\\\", \\\"grid\\\", \\\"listbox\\\", \\\"menu\\\", \\\"menubar\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"option\\\", \\\"radio\\\", \\\"radiogroup\\\", \\\"row\\\", \\\"rowheader\\\", \\\"searchbox\\\", \\\"select\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"switch\\\", \\\"tablist\\\", \\\"textbox\\\", \\\"toolbar\\\", \\\"tree\\\", \\\"treegrid\\\", \\\"treeitem\\\"];\\nfunction getAriaDisabled(element) {\\n  const isNativeFormControl = [\\\"BUTTON\\\", \\\"INPUT\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\", \\\"OPTION\\\", \\\"OPTGROUP\\\"].includes(element.tagName);\\n  if (isNativeFormControl && (element.hasAttribute(\\\"disabled\\\") || belongsToDisabledFieldSet(element)))\\n    return true;\\n  return hasExplicitAriaDisabled(element);\\n}\\nfunction belongsToDisabledFieldSet(element) {\\n  if (!element)\\n    return false;\\n  if (element.tagName === \\\"FIELDSET\\\" && element.hasAttribute(\\\"disabled\\\"))\\n    return true;\\n  return belongsToDisabledFieldSet(element.parentElement);\\n}\\nfunction hasExplicitAriaDisabled(element) {\\n  if (!element)\\n    return false;\\n  if (kAriaDisabledRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const attribute = (element.getAttribute(\\\"aria-disabled\\\") || \\\"\\\").toLowerCase();\\n    if (attribute === \\\"true\\\")\\n      return true;\\n    if (attribute === \\\"false\\\")\\n      return false;\\n  }\\n  return hasExplicitAriaDisabled(parentElementOrShadowHost(element));\\n}\\n\\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\\nfunction escapeWithQuotes(text, char = \\\"'\\\") {\\n  const stringified = JSON.stringify(text);\\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\\\\\\\"/g, '\\\"');\\n  if (char === \\\"'\\\")\\n    return char + escapedText.replace(/[']/g, \\\"\\\\\\\\'\\\") + char;\\n  if (char === '\\\"')\\n    return char + escapedText.replace(/[\\\"]/g, '\\\\\\\\\\\"') + char;\\n  if (char === \\\"`\\\")\\n    return char + escapedText.replace(/[`]/g, \\\"`\\\") + char;\\n  throw new Error(\\\"Invalid escape char\\\");\\n}\\nfunction toTitleCase(name) {\\n  return name.charAt(0).toUpperCase() + name.substring(1);\\n}\\nfunction toSnakeCase(name) {\\n  return name.replace(/([a-z0-9])([A-Z])/g, \\\"$1_$2\\\").replace(/([A-Z])([A-Z][a-z])/g, \\\"$1_$2\\\").toLowerCase();\\n}\\nfunction cssEscape(s) {\\n  let result = \\\"\\\";\\n  for (let i = 0; i < s.length; i++)\\n    result += cssEscapeOne(s, i);\\n  return result;\\n}\\nfunction cssEscapeOne(s, i) {\\n  const c = s.charCodeAt(i);\\n  if (c === 0)\\n    return \\\"\\\\uFFFD\\\";\\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\\n    return \\\"\\\\\\\\\\\" + c.toString(16) + \\\" \\\";\\n  if (i === 0 && c === 45 && s.length === 1)\\n    return \\\"\\\\\\\\\\\" + s.charAt(i);\\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\\n    return s.charAt(i);\\n  return \\\"\\\\\\\\\\\" + s.charAt(i);\\n}\\nfunction normalizeWhiteSpace(text) {\\n  return text.replace(/\\\\u200b/g, \\\"\\\").trim().replace(/\\\\s+/g, \\\" \\\");\\n}\\nfunction escapeForTextSelector(text, exact) {\\n  if (typeof text !== \\\"string\\\")\\n    return String(text);\\n  return `${JSON.stringify(text)}${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\nfunction escapeForAttributeSelector(value, exact) {\\n  return `\\\"${value.replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\").replace(/[\\\"]/g, '\\\\\\\\\\\"')}\\\"${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\n\\n// packages/playwright-core/src/server/injected/roleSelectorEngine.ts\\nvar kSupportedAttributes = [\\\"selected\\\", \\\"checked\\\", \\\"pressed\\\", \\\"expanded\\\", \\\"level\\\", \\\"disabled\\\", \\\"name\\\", \\\"include-hidden\\\"];\\nkSupportedAttributes.sort();\\nfunction validateSupportedRole(attr, roles, role) {\\n  if (!roles.includes(role))\\n    throw new Error(`\\\"${attr}\\\" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `\\\"${role2}\\\"`).join(\\\", \\\")}`);\\n}\\nfunction validateSupportedValues(attr, values) {\\n  if (attr.op !== \\\"<truthy>\\\" && !values.includes(attr.value))\\n    throw new Error(`\\\"${attr.name}\\\" must be one of ${values.map((v) => JSON.stringify(v)).join(\\\", \\\")}`);\\n}\\nfunction validateSupportedOp(attr, ops) {\\n  if (!ops.includes(attr.op))\\n    throw new Error(`\\\"${attr.name}\\\" does not support \\\"${attr.op}\\\" matcher`);\\n}\\nfunction validateAttributes(attrs, role) {\\n  const options = { role };\\n  for (const attr of attrs) {\\n    switch (attr.name) {\\n      case \\\"checked\\\": {\\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\\n        validateSupportedValues(attr, [true, false, \\\"mixed\\\"]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.checked = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"pressed\\\": {\\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\\n        validateSupportedValues(attr, [true, false, \\\"mixed\\\"]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.pressed = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"selected\\\": {\\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.selected = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"expanded\\\": {\\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.expanded = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"level\\\": {\\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\\n        if (typeof attr.value === \\\"string\\\")\\n          attr.value = +attr.value;\\n        if (attr.op !== \\\"=\\\" || typeof attr.value !== \\\"number\\\" || Number.isNaN(attr.value))\\n          throw new Error(`\\\"level\\\" attribute must be compared to a number`);\\n        options.level = attr.value;\\n        break;\\n      }\\n      case \\\"disabled\\\": {\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.disabled = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"name\\\": {\\n        if (attr.op === \\\"<truthy>\\\")\\n          throw new Error(`\\\"name\\\" attribute must have a value`);\\n        if (typeof attr.value !== \\\"string\\\" && !(attr.value instanceof RegExp))\\n          throw new Error(`\\\"name\\\" attribute must be a string or a regular expression`);\\n        options.name = attr.value;\\n        options.nameOp = attr.op;\\n        options.exact = attr.caseSensitive;\\n        break;\\n      }\\n      case \\\"include-hidden\\\": {\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.includeHidden = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      default: {\\n        throw new Error(`Unknown attribute \\\"${attr.name}\\\", must be one of ${kSupportedAttributes.map((a) => `\\\"${a}\\\"`).join(\\\", \\\")}.`);\\n      }\\n    }\\n  }\\n  return options;\\n}\\nfunction queryRole(scope, options, internal) {\\n  const hiddenCache = /* @__PURE__ */ new Map();\\n  const result = [];\\n  const match = (element) => {\\n    if (getAriaRole(element) !== options.role)\\n      return;\\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\\n      return;\\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\\n      return;\\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\\n      return;\\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\\n      return;\\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\\n      return;\\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\\n      return;\\n    if (!options.includeHidden) {\\n      const isHidden = isElementHiddenForAria(element, hiddenCache);\\n      if (isHidden)\\n        return;\\n    }\\n    if (options.name !== void 0) {\\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden, hiddenCache));\\n      if (typeof options.name === \\\"string\\\")\\n        options.name = normalizeWhiteSpace(options.name);\\n      if (internal && !options.exact && options.nameOp === \\\"=\\\")\\n        options.nameOp = \\\"*=\\\";\\n      if (!matchesAttributePart(accessibleName, { name: \\\"\\\", jsonPath: [], op: options.nameOp || \\\"=\\\", value: options.name, caseSensitive: !!options.exact }))\\n        return;\\n    }\\n    result.push(element);\\n  };\\n  const query = (root) => {\\n    const shadows = [];\\n    if (root.shadowRoot)\\n      shadows.push(root.shadowRoot);\\n    for (const element of root.querySelectorAll(\\\"*\\\")) {\\n      match(element);\\n      if (element.shadowRoot)\\n        shadows.push(element.shadowRoot);\\n    }\\n    shadows.forEach(query);\\n  };\\n  query(scope);\\n  return result;\\n}\\nfunction createRoleEngine(internal) {\\n  return {\\n    queryAll: (scope, selector) => {\\n      const parsed = parseAttributeSelector(selector, true);\\n      const role = parsed.name.toLowerCase();\\n      if (!role)\\n        throw new Error(`Role must not be empty`);\\n      const options = validateAttributes(parsed.attributes, role);\\n      return queryRole(scope, options, internal);\\n    }\\n  };\\n}\\n\\n// packages/playwright-core/src/server/injected/layoutSelectorUtils.ts\\nfunction boxRightOf(box1, box2, maxDistance) {\\n  const distance = box1.left - box2.right;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\\n}\\nfunction boxLeftOf(box1, box2, maxDistance) {\\n  const distance = box2.left - box1.right;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\\n}\\nfunction boxAbove(box1, box2, maxDistance) {\\n  const distance = box2.top - box1.bottom;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\\n}\\nfunction boxBelow(box1, box2, maxDistance) {\\n  const distance = box1.top - box2.bottom;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\\n}\\nfunction boxNear(box1, box2, maxDistance) {\\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\\n  let score = 0;\\n  if (box1.left - box2.right >= 0)\\n    score += box1.left - box2.right;\\n  if (box2.left - box1.right >= 0)\\n    score += box2.left - box1.right;\\n  if (box2.top - box1.bottom >= 0)\\n    score += box2.top - box1.bottom;\\n  if (box1.top - box2.bottom >= 0)\\n    score += box1.top - box2.bottom;\\n  return score > kThreshold ? void 0 : score;\\n}\\nvar kLayoutSelectorNames = [\\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"];\\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\\n  const box = element.getBoundingClientRect();\\n  const scorer = { \\\"left-of\\\": boxLeftOf, \\\"right-of\\\": boxRightOf, \\\"above\\\": boxAbove, \\\"below\\\": boxBelow, \\\"near\\\": boxNear }[name];\\n  let bestScore;\\n  for (const e of inner) {\\n    if (e === element)\\n      continue;\\n    const score = scorer(box, e.getBoundingClientRect(), maxDistance);\\n    if (score === void 0)\\n      continue;\\n    if (bestScore === void 0 || score < bestScore)\\n      bestScore = score;\\n  }\\n  return bestScore;\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorEvaluator.ts\\nvar SelectorEvaluatorImpl = class {\\n  constructor(extraEngines) {\\n    this._engines = /* @__PURE__ */ new Map();\\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\\n    this._cacheMatches = /* @__PURE__ */ new Map();\\n    this._cacheQuery = /* @__PURE__ */ new Map();\\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\\n    this._cacheText = /* @__PURE__ */ new Map();\\n    this._retainCacheCounter = 0;\\n    for (const [name, engine] of extraEngines)\\n      this._engines.set(name, engine);\\n    this._engines.set(\\\"not\\\", notEngine);\\n    this._engines.set(\\\"is\\\", isEngine);\\n    this._engines.set(\\\"where\\\", isEngine);\\n    this._engines.set(\\\"has\\\", hasEngine);\\n    this._engines.set(\\\"scope\\\", scopeEngine);\\n    this._engines.set(\\\"light\\\", lightEngine);\\n    this._engines.set(\\\"visible\\\", visibleEngine);\\n    this._engines.set(\\\"text\\\", textEngine);\\n    this._engines.set(\\\"text-is\\\", textIsEngine);\\n    this._engines.set(\\\"text-matches\\\", textMatchesEngine);\\n    this._engines.set(\\\"has-text\\\", hasTextEngine);\\n    this._engines.set(\\\"right-of\\\", createLayoutEngine(\\\"right-of\\\"));\\n    this._engines.set(\\\"left-of\\\", createLayoutEngine(\\\"left-of\\\"));\\n    this._engines.set(\\\"above\\\", createLayoutEngine(\\\"above\\\"));\\n    this._engines.set(\\\"below\\\", createLayoutEngine(\\\"below\\\"));\\n    this._engines.set(\\\"near\\\", createLayoutEngine(\\\"near\\\"));\\n    this._engines.set(\\\"nth-match\\\", nthMatchEngine);\\n    const allNames = [...this._engines.keys()];\\n    allNames.sort();\\n    const parserNames = [...customCSSNames];\\n    parserNames.sort();\\n    if (allNames.join(\\\"|\\\") !== parserNames.join(\\\"|\\\"))\\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join(\\\"|\\\")} vs ${parserNames.join(\\\"|\\\")}`);\\n  }\\n  begin() {\\n    ++this._retainCacheCounter;\\n  }\\n  end() {\\n    --this._retainCacheCounter;\\n    if (!this._retainCacheCounter) {\\n      this._cacheQueryCSS.clear();\\n      this._cacheMatches.clear();\\n      this._cacheQuery.clear();\\n      this._cacheMatchesSimple.clear();\\n      this._cacheMatchesParents.clear();\\n      this._cacheCallMatches.clear();\\n      this._cacheCallQuery.clear();\\n      this._cacheQuerySimple.clear();\\n      this._cacheText.clear();\\n    }\\n  }\\n  _cached(cache, main, rest, cb) {\\n    if (!cache.has(main))\\n      cache.set(main, []);\\n    const entries = cache.get(main);\\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\\n    if (entry)\\n      return entry.result;\\n    const result = cb();\\n    entries.push({ rest, result });\\n    return result;\\n  }\\n  _checkSelector(s) {\\n    const wellFormed = typeof s === \\\"object\\\" && s && (Array.isArray(s) || \\\"simples\\\" in s && s.simples.length);\\n    if (!wellFormed)\\n      throw new Error(`Malformed selector \\\"${s}\\\"`);\\n    return s;\\n  }\\n  matches(element, s, context) {\\n    const selector = this._checkSelector(s);\\n    this.begin();\\n    try {\\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\\n        if (Array.isArray(selector))\\n          return this._matchesEngine(isEngine, element, selector, context);\\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\\n          return false;\\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\\n      });\\n    } finally {\\n      this.end();\\n    }\\n  }\\n  query(context, s) {\\n    const selector = this._checkSelector(s);\\n    this.begin();\\n    try {\\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\\n        if (Array.isArray(selector))\\n          return this._queryEngine(isEngine, context, selector);\\n        const previousScoreMap = this._scoreMap;\\n        this._scoreMap = /* @__PURE__ */ new Map();\\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\\n        if (this._scoreMap.size) {\\n          elements.sort((a, b) => {\\n            const aScore = this._scoreMap.get(a);\\n            const bScore = this._scoreMap.get(b);\\n            if (aScore === bScore)\\n              return 0;\\n            if (aScore === void 0)\\n              return 1;\\n            if (bScore === void 0)\\n              return -1;\\n            return aScore - bScore;\\n          });\\n        }\\n        this._scoreMap = previousScoreMap;\\n        return elements;\\n      });\\n    } finally {\\n      this.end();\\n    }\\n  }\\n  _markScore(element, score) {\\n    if (this._scoreMap)\\n      this._scoreMap.set(element, score);\\n  }\\n  _matchesSimple(element, simple, context) {\\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\\n      const isPossiblyScopeClause = simple.functions.some((f) => f.name === \\\"scope\\\" || f.name === \\\"is\\\");\\n      if (!isPossiblyScopeClause && element === context.scope)\\n        return false;\\n      if (simple.css && !this._matchesCSS(element, simple.css))\\n        return false;\\n      for (const func of simple.functions) {\\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\\n          return false;\\n      }\\n      return true;\\n    });\\n  }\\n  _querySimple(context, simple) {\\n    if (!simple.functions.length)\\n      return this._queryCSS(context, simple.css || \\\"*\\\");\\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\\n      let css = simple.css;\\n      const funcs = simple.functions;\\n      if (css === \\\"*\\\" && funcs.length)\\n        css = void 0;\\n      let elements;\\n      let firstIndex = -1;\\n      if (css !== void 0) {\\n        elements = this._queryCSS(context, css);\\n        const hasScopeClause = funcs.some((f) => f.name === \\\"scope\\\");\\n        if (hasScopeClause && context.scope.nodeType === 1 && this._matchesCSS(context.scope, css))\\n          elements.unshift(context.scope);\\n      } else {\\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\\n        if (firstIndex === -1)\\n          firstIndex = 0;\\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\\n      }\\n      for (let i = 0; i < funcs.length; i++) {\\n        if (i === firstIndex)\\n          continue;\\n        const engine = this._getEngine(funcs[i].name);\\n        if (engine.matches !== void 0)\\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\\n      }\\n      for (let i = 0; i < funcs.length; i++) {\\n        if (i === firstIndex)\\n          continue;\\n        const engine = this._getEngine(funcs[i].name);\\n        if (engine.matches === void 0)\\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\\n      }\\n      return elements;\\n    });\\n  }\\n  _matchesParents(element, complex, index, context) {\\n    if (index < 0)\\n      return true;\\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\\n      const { selector: simple, combinator } = complex.simples[index];\\n      if (combinator === \\\">\\\") {\\n        const parent = parentElementOrShadowHostInContext(element, context);\\n        if (!parent || !this._matchesSimple(parent, simple, context))\\n          return false;\\n        return this._matchesParents(parent, complex, index - 1, context);\\n      }\\n      if (combinator === \\\"+\\\") {\\n        const previousSibling = previousSiblingInContext(element, context);\\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\\n          return false;\\n        return this._matchesParents(previousSibling, complex, index - 1, context);\\n      }\\n      if (combinator === \\\"\\\") {\\n        let parent = parentElementOrShadowHostInContext(element, context);\\n        while (parent) {\\n          if (this._matchesSimple(parent, simple, context)) {\\n            if (this._matchesParents(parent, complex, index - 1, context))\\n              return true;\\n            if (complex.simples[index - 1].combinator === \\\"\\\")\\n              break;\\n          }\\n          parent = parentElementOrShadowHostInContext(parent, context);\\n        }\\n        return false;\\n      }\\n      if (combinator === \\\"~\\\") {\\n        let previousSibling = previousSiblingInContext(element, context);\\n        while (previousSibling) {\\n          if (this._matchesSimple(previousSibling, simple, context)) {\\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\\n              return true;\\n            if (complex.simples[index - 1].combinator === \\\"~\\\")\\n              break;\\n          }\\n          previousSibling = previousSiblingInContext(previousSibling, context);\\n        }\\n        return false;\\n      }\\n      if (combinator === \\\">=\\\") {\\n        let parent = element;\\n        while (parent) {\\n          if (this._matchesSimple(parent, simple, context)) {\\n            if (this._matchesParents(parent, complex, index - 1, context))\\n              return true;\\n            if (complex.simples[index - 1].combinator === \\\"\\\")\\n              break;\\n          }\\n          parent = parentElementOrShadowHostInContext(parent, context);\\n        }\\n        return false;\\n      }\\n      throw new Error(`Unsupported combinator \\\"${combinator}\\\"`);\\n    });\\n  }\\n  _matchesEngine(engine, element, args, context) {\\n    if (engine.matches)\\n      return this._callMatches(engine, element, args, context);\\n    if (engine.query)\\n      return this._callQuery(engine, args, context).includes(element);\\n    throw new Error(`Selector engine should implement \\\"matches\\\" or \\\"query\\\"`);\\n  }\\n  _queryEngine(engine, context, args) {\\n    if (engine.query)\\n      return this._callQuery(engine, args, context);\\n    if (engine.matches)\\n      return this._queryCSS(context, \\\"*\\\").filter((element) => this._callMatches(engine, element, args, context));\\n    throw new Error(`Selector engine should implement \\\"matches\\\" or \\\"query\\\"`);\\n  }\\n  _callMatches(engine, element, args, context) {\\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\\n      return engine.matches(element, args, context, this);\\n    });\\n  }\\n  _callQuery(engine, args, context) {\\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\\n      return engine.query(context, args, this);\\n    });\\n  }\\n  _matchesCSS(element, css) {\\n    return element.matches(css);\\n  }\\n  _queryCSS(context, css) {\\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\\n      let result = [];\\n      function query(root) {\\n        result = result.concat([...root.querySelectorAll(css)]);\\n        if (!context.pierceShadow)\\n          return;\\n        if (root.shadowRoot)\\n          query(root.shadowRoot);\\n        for (const element of root.querySelectorAll(\\\"*\\\")) {\\n          if (element.shadowRoot)\\n            query(element.shadowRoot);\\n        }\\n      }\\n      query(context.scope);\\n      return result;\\n    });\\n  }\\n  _getEngine(name) {\\n    const engine = this._engines.get(name);\\n    if (!engine)\\n      throw new Error(`Unknown selector engine \\\"${name}\\\"`);\\n    return engine;\\n  }\\n};\\nvar isEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"is\\\" engine expects non-empty selector list`);\\n    return args.some((selector) => evaluator.matches(element, selector, context));\\n  },\\n  query(context, args, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"is\\\" engine expects non-empty selector list`);\\n    let elements = [];\\n    for (const arg of args)\\n      elements = elements.concat(evaluator.query(context, arg));\\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\\n  }\\n};\\nvar hasEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"has\\\" engine expects non-empty selector list`);\\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\\n  }\\n};\\nvar scopeEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 0)\\n      throw new Error(`\\\"scope\\\" engine expects no arguments`);\\n    if (context.scope.nodeType === 9)\\n      return element === context.scope.documentElement;\\n    return element === context.scope;\\n  },\\n  query(context, args, evaluator) {\\n    if (args.length !== 0)\\n      throw new Error(`\\\"scope\\\" engine expects no arguments`);\\n    if (context.scope.nodeType === 9) {\\n      const root = context.scope.documentElement;\\n      return root ? [root] : [];\\n    }\\n    if (context.scope.nodeType === 1)\\n      return [context.scope];\\n    return [];\\n  }\\n};\\nvar notEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"not\\\" engine expects non-empty selector list`);\\n    return !evaluator.matches(element, args, context);\\n  }\\n};\\nvar lightEngine = {\\n  query(context, args, evaluator) {\\n    return evaluator.query({ ...context, pierceShadow: false }, args);\\n  },\\n  matches(element, args, context, evaluator) {\\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\\n  }\\n};\\nvar visibleEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length)\\n      throw new Error(`\\\"visible\\\" engine expects no arguments`);\\n    return isElementVisible(element);\\n  }\\n};\\nvar textEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 1 || typeof args[0] !== \\\"string\\\")\\n      throw new Error(`\\\"text\\\" engine expects a single string`);\\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\\n    const matcher = (elementText2) => normalizeWhiteSpace(elementText2.full).toLowerCase().includes(text);\\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \\\"self\\\";\\n  }\\n};\\nvar textIsEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 1 || typeof args[0] !== \\\"string\\\")\\n      throw new Error(`\\\"text-is\\\" engine expects a single string`);\\n    const text = normalizeWhiteSpace(args[0]);\\n    const matcher = (elementText2) => {\\n      if (!text && !elementText2.immediate.length)\\n        return true;\\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\\n    };\\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== \\\"none\\\";\\n  }\\n};\\nvar textMatchesEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0 || typeof args[0] !== \\\"string\\\" || args.length > 2 || args.length === 2 && typeof args[1] !== \\\"string\\\")\\n      throw new Error(`\\\"text-matches\\\" engine expects a regexp body and optional regexp flags`);\\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\\n    const matcher = (elementText2) => re.test(elementText2.full);\\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \\\"self\\\";\\n  }\\n};\\nvar hasTextEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 1 || typeof args[0] !== \\\"string\\\")\\n      throw new Error(`\\\"has-text\\\" engine expects a single string`);\\n    if (shouldSkipForTextMatching(element))\\n      return false;\\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\\n    const matcher = (elementText2) => normalizeWhiteSpace(elementText2.full).toLowerCase().includes(text);\\n    return matcher(elementText(evaluator._cacheText, element));\\n  }\\n};\\nfunction createLayoutEngine(name) {\\n  return {\\n    matches(element, args, context, evaluator) {\\n      const maxDistance = args.length && typeof args[args.length - 1] === \\\"number\\\" ? args[args.length - 1] : void 0;\\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\\n        throw new Error(`\\\"${name}\\\" engine expects a selector list and optional maximum distance in pixels`);\\n      const inner = evaluator.query(context, queryArgs);\\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\\n      if (score === void 0)\\n        return false;\\n      evaluator._markScore(element, score);\\n      return true;\\n    }\\n  };\\n}\\nvar nthMatchEngine = {\\n  query(context, args, evaluator) {\\n    let index = args[args.length - 1];\\n    if (args.length < 2)\\n      throw new Error(`\\\"nth-match\\\" engine expects non-empty selector list and an index argument`);\\n    if (typeof index !== \\\"number\\\" || index < 1)\\n      throw new Error(`\\\"nth-match\\\" engine expects a one-based index as the last argument`);\\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\\n    index--;\\n    return index < elements.length ? [elements[index]] : [];\\n  }\\n};\\nfunction parentElementOrShadowHostInContext(element, context) {\\n  if (element === context.scope)\\n    return;\\n  if (!context.pierceShadow)\\n    return element.parentElement || void 0;\\n  return parentElementOrShadowHost(element);\\n}\\nfunction previousSiblingInContext(element, context) {\\n  if (element === context.scope)\\n    return;\\n  return element.previousElementSibling || void 0;\\n}\\nfunction sortInDOMOrder(elements) {\\n  const elementToEntry = /* @__PURE__ */ new Map();\\n  const roots = [];\\n  const result = [];\\n  function append(element) {\\n    let entry = elementToEntry.get(element);\\n    if (entry)\\n      return entry;\\n    const parent = parentElementOrShadowHost(element);\\n    if (parent) {\\n      const parentEntry = append(parent);\\n      parentEntry.children.push(element);\\n    } else {\\n      roots.push(element);\\n    }\\n    entry = { children: [], taken: false };\\n    elementToEntry.set(element, entry);\\n    return entry;\\n  }\\n  elements.forEach((e) => append(e).taken = true);\\n  function visit(element) {\\n    const entry = elementToEntry.get(element);\\n    if (entry.taken)\\n      result.push(element);\\n    if (entry.children.length > 1) {\\n      const set = new Set(entry.children);\\n      entry.children = [];\\n      let child = element.firstElementChild;\\n      while (child && entry.children.length < set.size) {\\n        if (set.has(child))\\n          entry.children.push(child);\\n        child = child.nextElementSibling;\\n      }\\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\\n      while (child && entry.children.length < set.size) {\\n        if (set.has(child))\\n          entry.children.push(child);\\n        child = child.nextElementSibling;\\n      }\\n    }\\n    entry.children.forEach(visit);\\n  }\\n  roots.forEach(visit);\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\\nvar cacheAllowText = /* @__PURE__ */ new Map();\\nvar cacheDisallowText = /* @__PURE__ */ new Map();\\nvar kTextScoreRange = 10;\\nvar kExactPenalty = kTextScoreRange / 2;\\nvar kTestIdScore = 1;\\nvar kOtherTestIdScore = 2;\\nvar kIframeByAttributeScore = 10;\\nvar kBeginPenalizedScore = 50;\\nvar kPlaceholderScore = 100;\\nvar kLabelScore = 120;\\nvar kRoleWithNameScore = 140;\\nvar kAltTextScore = 160;\\nvar kTextScore = 180;\\nvar kTitleScore = 200;\\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\\nvar kTextScoreExact = kTextScore + kExactPenalty;\\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\\nvar kEndPenalizedScore = 300;\\nvar kCSSIdScore = 500;\\nvar kRoleWithoutNameScore = 510;\\nvar kCSSInputTypeNameScore = 520;\\nvar kCSSTagNameScore = 530;\\nvar kNthScore = 1e4;\\nvar kCSSFallbackScore = 1e7;\\nfunction generateSelector(injectedScript, targetElement, testIdAttributeName) {\\n  injectedScript._evaluator.begin();\\n  try {\\n    targetElement = targetElement.closest(\\\"button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]\\\") || targetElement;\\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, testIdAttributeName);\\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement);\\n    const selector = joinTokens(bestTokens);\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    return {\\n      selector,\\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\\n    };\\n  } finally {\\n    cacheAllowText.clear();\\n    cacheDisallowText.clear();\\n    injectedScript._evaluator.end();\\n  }\\n}\\nfunction filterRegexTokens(textCandidates) {\\n  return textCandidates.filter((c) => c[0].selector[0] !== \\\"/\\\");\\n}\\nfunction generateSelectorFor(injectedScript, targetElement, testIdAttributeName) {\\n  if (targetElement.ownerDocument.documentElement === targetElement)\\n    return [{ engine: \\\"css\\\", selector: \\\"html\\\", score: 1 }];\\n  const accessibleNameCache = /* @__PURE__ */ new Map();\\n  const calculate = (element, allowText) => {\\n    const allowNthMatch = element === targetElement;\\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement, accessibleNameCache) : [];\\n    if (element !== targetElement) {\\n      textCandidates = filterRegexTokens(textCandidates);\\n    }\\n    const noTextCandidates = buildCandidates(injectedScript, element, testIdAttributeName, accessibleNameCache).map((token) => [token]);\\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\\n    textCandidates = filterRegexTokens(textCandidates);\\n    const checkWithText = (textCandidatesToUse) => {\\n      const allowParentText = allowText && !textCandidatesToUse.length;\\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\\n        if (!result)\\n          return true;\\n        return combineScores(c) < combineScores(result);\\n      });\\n      let bestPossibleInParent = candidates[0];\\n      if (!bestPossibleInParent)\\n        return;\\n      for (let parent = parentElementOrShadowHost2(element); parent; parent = parentElementOrShadowHost2(parent)) {\\n        const parentTokens = calculateCached(parent, allowParentText);\\n        if (!parentTokens)\\n          continue;\\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\\n          continue;\\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\\n        if (!bestPossibleInParent)\\n          return;\\n        const combined = [...parentTokens, ...bestPossibleInParent];\\n        if (!result || combineScores(combined) < combineScores(result))\\n          result = combined;\\n      }\\n    };\\n    checkWithText(textCandidates);\\n    if (element === targetElement && textCandidates.length)\\n      checkWithText([]);\\n    return result;\\n  };\\n  const calculateCached = (element, allowText) => {\\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\\n    let value = cache.get(element);\\n    if (value === void 0) {\\n      value = calculate(element, allowText);\\n      cache.set(element, value);\\n    }\\n    return value;\\n  };\\n  return calculateCached(targetElement, true);\\n}\\nfunction buildCandidates(injectedScript, element, testIdAttributeName, accessibleNameCache) {\\n  var _a;\\n  const candidates = [];\\n  for (const attr of [\\\"data-testid\\\", \\\"data-test-id\\\", \\\"data-test\\\"]) {\\n    if (attr !== testIdAttributeName && element.getAttribute(attr))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${attr}=${quoteAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\\n  }\\n  const idAttr = element.getAttribute(\\\"id\\\");\\n  if (idAttr && !isGuidLike(idAttr))\\n    candidates.push({ engine: \\\"css\\\", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\\n  candidates.push({ engine: \\\"css\\\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\\n  if (element.nodeName === \\\"IFRAME\\\") {\\n    for (const attribute of [\\\"name\\\", \\\"title\\\"]) {\\n      if (element.getAttribute(attribute))\\n        candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\\n    }\\n    if (element.getAttribute(testIdAttributeName))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(testIdAttributeName), true)}]`, score: kTestIdScore });\\n    penalizeScoreForLength([candidates]);\\n    return candidates;\\n  }\\n  if (element.getAttribute(testIdAttributeName))\\n    candidates.push({ engine: \\\"internal:testid\\\", selector: `[${testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(testIdAttributeName), true)}]`, score: kTestIdScore });\\n  if (element.nodeName === \\\"INPUT\\\" || element.nodeName === \\\"TEXTAREA\\\") {\\n    const input = element;\\n    if (input.placeholder) {\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, false)}]`, score: kPlaceholderScore });\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\\n    }\\n    const label = (_a = input.labels) == null ? void 0 : _a[0];\\n    if (label) {\\n      const labelText = elementText(injectedScript._evaluator._cacheText, label).full.trim();\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, false), score: kLabelScore });\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\\n    }\\n  }\\n  const ariaRole = getAriaRole(element);\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false, accessibleNameCache);\\n    if (ariaName) {\\n      candidates.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore });\\n      candidates.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact });\\n    } else {\\n      candidates.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n    }\\n  }\\n  if (element.getAttribute(\\\"alt\\\") && [\\\"APPLET\\\", \\\"AREA\\\", \\\"IMG\\\", \\\"INPUT\\\"].includes(element.nodeName)) {\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(element.getAttribute(\\\"alt\\\"), false)}]`, score: kAltTextScore });\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(element.getAttribute(\\\"alt\\\"), true)}]`, score: kAltTextScoreExact });\\n  }\\n  if (element.getAttribute(\\\"name\\\") && [\\\"BUTTON\\\", \\\"FORM\\\", \\\"FIELDSET\\\", \\\"FRAME\\\", \\\"IFRAME\\\", \\\"INPUT\\\", \\\"KEYGEN\\\", \\\"OBJECT\\\", \\\"OUTPUT\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\", \\\"MAP\\\", \\\"META\\\", \\\"PARAM\\\"].includes(element.nodeName))\\n    candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute(\\\"name\\\"))}]`, score: kCSSInputTypeNameScore });\\n  if (element.getAttribute(\\\"title\\\")) {\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(element.getAttribute(\\\"title\\\"), false)}]`, score: kTitleScore });\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(element.getAttribute(\\\"title\\\"), true)}]`, score: kTitleScoreExact });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\") {\\n    if (element.getAttribute(\\\"type\\\"))\\n      candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute(\\\"type\\\"))}]`, score: kCSSInputTypeNameScore });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\", \\\"SELECT\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\")\\n    candidates.push({ engine: \\\"css\\\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\\n  penalizeScoreForLength([candidates]);\\n  return candidates;\\n}\\nfunction buildTextCandidates(injectedScript, element, isTargetNode, accessibleNameCache) {\\n  if (element.nodeName === \\\"SELECT\\\")\\n    return [];\\n  const text = normalizeWhiteSpace(elementText(injectedScript._evaluator._cacheText, element).full).substring(0, 80);\\n  if (!text)\\n    return [];\\n  const candidates = [];\\n  const escaped = escapeForTextSelector(text, false);\\n  const exactEscaped = escapeForTextSelector(text, true);\\n  if (isTargetNode) {\\n    candidates.push([{ engine: \\\"internal:text\\\", selector: escaped, score: kTextScore }]);\\n    candidates.push([{ engine: \\\"internal:text\\\", selector: exactEscaped, score: kTextScoreExact }]);\\n  }\\n  const ariaRole = getAriaRole(element);\\n  const candidate = [];\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false, accessibleNameCache);\\n    if (ariaName) {\\n      candidate.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore });\\n      candidate.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact });\\n    } else {\\n      candidate.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n    }\\n  } else {\\n    candidate.push({ engine: \\\"css\\\", selector: element.nodeName.toLowerCase(), score: kCSSTagNameScore });\\n  }\\n  candidates.push([...candidate, { engine: \\\"internal:has-text\\\", selector: escaped, score: kTextScore }]);\\n  candidates.push([...candidate, { engine: \\\"internal:has-text\\\", selector: exactEscaped, score: kTextScoreExact }]);\\n  penalizeScoreForLength(candidates);\\n  return candidates;\\n}\\nfunction parentElementOrShadowHost2(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return null;\\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\\n    return element.parentNode.host;\\n  return null;\\n}\\nfunction makeSelectorForId(id) {\\n  return /^[a-zA-Z][a-zA-Z0-9\\\\-\\\\_]+$/.test(id) ? \\\"#\\\" + id : `[id=\\\"${cssEscape(id)}\\\"]`;\\n}\\nfunction cssFallback(injectedScript, targetElement) {\\n  const root = targetElement.ownerDocument;\\n  const tokens = [];\\n  function uniqueCSSSelector(prefix) {\\n    const path = tokens.slice();\\n    if (prefix)\\n      path.unshift(prefix);\\n    const selector = path.join(\\\" > \\\");\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\\n    return node === targetElement ? selector : void 0;\\n  }\\n  function makeStrict(selector) {\\n    const token = { engine: \\\"css\\\", selector, score: kCSSFallbackScore };\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\\n    if (elements.length === 1)\\n      return [token];\\n    const nth = { engine: \\\"nth\\\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\\n    return [token, nth];\\n  }\\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost2(element)) {\\n    const nodeName = element.nodeName.toLowerCase();\\n    let bestTokenForLevel = \\\"\\\";\\n    if (element.id) {\\n      const token = makeSelectorForId(element.id);\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      bestTokenForLevel = token;\\n    }\\n    const parent = element.parentNode;\\n    const classes = [...element.classList];\\n    for (let i = 0; i < classes.length; ++i) {\\n      const token = \\\".\\\" + cssEscape(classes.slice(0, i + 1).join(\\\".\\\"));\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel && parent) {\\n        const sameClassSiblings = parent.querySelectorAll(token);\\n        if (sameClassSiblings.length === 1)\\n          bestTokenForLevel = token;\\n      }\\n    }\\n    if (parent) {\\n      const siblings = [...parent.children];\\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel)\\n        bestTokenForLevel = token;\\n    } else if (!bestTokenForLevel) {\\n      bestTokenForLevel = nodeName;\\n    }\\n    tokens.unshift(bestTokenForLevel);\\n  }\\n  return makeStrict(uniqueCSSSelector());\\n}\\nfunction quoteAttributeValue(text) {\\n  return `\\\"${cssEscape(text).replace(/\\\\\\\\ /g, \\\" \\\")}\\\"`;\\n}\\nfunction penalizeScoreForLength(groups) {\\n  for (const group of groups) {\\n    for (const token of group) {\\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\\n    }\\n  }\\n}\\nfunction joinTokens(tokens) {\\n  const parts = [];\\n  let lastEngine = \\\"\\\";\\n  for (const { engine, selector } of tokens) {\\n    if (parts.length && (lastEngine !== \\\"css\\\" || engine !== \\\"css\\\" || selector.startsWith(\\\":nth-match(\\\")))\\n      parts.push(\\\">>\\\");\\n    lastEngine = engine;\\n    if (engine === \\\"css\\\")\\n      parts.push(selector);\\n    else\\n      parts.push(`${engine}=${selector}`);\\n  }\\n  return parts.join(\\\" \\\");\\n}\\nfunction combineScores(tokens) {\\n  let score = 0;\\n  for (let i = 0; i < tokens.length; i++)\\n    score += tokens[i].score * (tokens.length - i);\\n  return score;\\n}\\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\\n  joined.sort((a, b) => a.score - b.score);\\n  let bestWithIndex = null;\\n  for (const { tokens } of joined) {\\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\\n    if (result[0] === targetElement && result.length === 1) {\\n      return tokens;\\n    }\\n    const index = result.indexOf(targetElement);\\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\\n      continue;\\n    const nth = { engine: \\\"nth\\\", selector: String(index), score: kNthScore };\\n    bestWithIndex = [...tokens, nth];\\n  }\\n  return bestWithIndex;\\n}\\nfunction isGuidLike(id) {\\n  let lastCharacterType;\\n  let transitionCount = 0;\\n  for (let i = 0; i < id.length; ++i) {\\n    const c = id[i];\\n    let characterType;\\n    if (c === \\\"-\\\" || c === \\\"_\\\")\\n      continue;\\n    if (c >= \\\"a\\\" && c <= \\\"z\\\")\\n      characterType = \\\"lower\\\";\\n    else if (c >= \\\"A\\\" && c <= \\\"Z\\\")\\n      characterType = \\\"upper\\\";\\n    else if (c >= \\\"0\\\" && c <= \\\"9\\\")\\n      characterType = \\\"digit\\\";\\n    else\\n      characterType = \\\"other\\\";\\n    if (characterType === \\\"lower\\\" && lastCharacterType === \\\"upper\\\") {\\n      lastCharacterType = characterType;\\n      continue;\\n    }\\n    if (lastCharacterType && lastCharacterType !== characterType)\\n      ++transitionCount;\\n    lastCharacterType = characterType;\\n  }\\n  return transitionCount >= id.length / 4;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/locatorGenerators.ts\\nfunction asLocator(lang, selector, isFrameLocator = false) {\\n  return innerAsLocator(generators[lang], parseSelector(selector), isFrameLocator);\\n}\\nfunction innerAsLocator(factory, parsed, isFrameLocator = false) {\\n  const parts = [...parsed.parts];\\n  for (let index = 0; index < parts.length - 1; index++) {\\n    if (parts[index].name === \\\"nth\\\" && parts[index + 1].name === \\\"internal:control\\\" && parts[index + 1].body === \\\"enter-frame\\\") {\\n      const [nth] = parts.splice(index, 1);\\n      parts.splice(index + 1, 0, nth);\\n    }\\n  }\\n  const tokens = [];\\n  let nextBase = isFrameLocator ? \\\"frame-locator\\\" : \\\"page\\\";\\n  for (let index = 0; index < parts.length; index++) {\\n    const part = parts[index];\\n    const base = nextBase;\\n    nextBase = \\\"locator\\\";\\n    if (part.name === \\\"nth\\\") {\\n      if (part.body === \\\"0\\\")\\n        tokens.push(factory.generateLocator(base, \\\"first\\\", \\\"\\\"));\\n      else if (part.body === \\\"-1\\\")\\n        tokens.push(factory.generateLocator(base, \\\"last\\\", \\\"\\\"));\\n      else\\n        tokens.push(factory.generateLocator(base, \\\"nth\\\", part.body));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"text\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has-text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"has-text\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has\\\") {\\n      const inner = innerAsLocator(factory, part.body.parsed);\\n      tokens.push(factory.generateLocator(base, \\\"has\\\", inner));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:label\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"label\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:role\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const options = { attrs: [] };\\n      for (const attr of attrSelector.attributes) {\\n        if (attr.name === \\\"name\\\") {\\n          options.exact = attr.caseSensitive;\\n          options.name = attr.value;\\n        } else {\\n          if (attr.name === \\\"level\\\" && typeof attr.value === \\\"string\\\")\\n            attr.value = +attr.value;\\n          options.attrs.push({ name: attr.name === \\\"include-hidden\\\" ? \\\"includeHidden\\\" : attr.name, value: attr.value });\\n        }\\n      }\\n      tokens.push(factory.generateLocator(base, \\\"role\\\", attrSelector.name, options));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:testid\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { value } = attrSelector.attributes[0];\\n      tokens.push(factory.generateLocator(base, \\\"test-id\\\", value));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:attr\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\\n      const text = value;\\n      const exact = !!caseSensitive;\\n      if (name === \\\"placeholder\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"placeholder\\\", text, { exact }));\\n        continue;\\n      }\\n      if (name === \\\"alt\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"alt\\\", text, { exact }));\\n        continue;\\n      }\\n      if (name === \\\"title\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"title\\\", text, { exact }));\\n        continue;\\n      }\\n    }\\n    let locatorType = \\\"default\\\";\\n    const nextPart = parts[index + 1];\\n    if (nextPart && nextPart.name === \\\"internal:control\\\" && nextPart.body === \\\"enter-frame\\\") {\\n      locatorType = \\\"frame\\\";\\n      nextBase = \\\"frame-locator\\\";\\n      index++;\\n    }\\n    const p = { parts: [part] };\\n    tokens.push(factory.generateLocator(base, locatorType, stringifySelector(p)));\\n  }\\n  return tokens.join(\\\".\\\");\\n}\\nfunction detectExact(text) {\\n  let exact = false;\\n  const match = text.match(/^\\\\/(.*)\\\\/([igm]*)$/);\\n  if (match)\\n    return { text: new RegExp(match[1], match[2]) };\\n  if (text.endsWith('\\\"')) {\\n    text = JSON.parse(text);\\n    exact = true;\\n  } else if (text.endsWith('\\\"s')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = true;\\n  } else if (text.endsWith('\\\"i')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = false;\\n  }\\n  return { exact, text };\\n}\\nvar JavaScriptLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name: ${options.name}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name: ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact: true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${name}: ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `getByRole(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter({ hasText: ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `filter({ has: ${body} })`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${body})`;\\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return String(body);\\n    return this.quote(body);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, \\\"'\\\");\\n  }\\n};\\nvar PythonLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frame_locator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first`;\\n      case \\\"last\\\":\\n        return `last`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name=${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name=${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact=True`);\\n        }\\n        for (const { name, value } of options.attrs) {\\n          let valueString = typeof value === \\\"string\\\" ? this.quote(value) : value;\\n          if (typeof value === \\\"boolean\\\")\\n            valueString = value ? \\\"True\\\" : \\\"False\\\";\\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\\n        }\\n        const attrString = attrs.length ? `, ${attrs.join(\\\", \\\")}` : \\\"\\\";\\n        return `get_by_role(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(has_text=${this.toHasText(body)})`;\\n      case \\\"has\\\":\\n        return `filter(has=${body})`;\\n      case \\\"test-id\\\":\\n        return `get_by_test_id(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"get_by_text\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"get_by_alt_text\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"get_by_placeholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"get_by_label\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"get_by_title\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", re.IGNORECASE\\\" : \\\"\\\";\\n    return `re.compile(r\\\"${body.source.replace(/\\\\\\\\\\\\//, \\\"/\\\").replace(/\\\"/g, '\\\\\\\\\\\"')}\\\"${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, exact=True)`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return `${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar JavaLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    let clazz;\\n    switch (base) {\\n      case \\\"page\\\":\\n        clazz = \\\"Page\\\";\\n        break;\\n      case \\\"frame-locator\\\":\\n        clazz = \\\"FrameLocator\\\";\\n        break;\\n      case \\\"locator\\\":\\n        clazz = \\\"Locator\\\";\\n        break;\\n    }\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`.setName(${this.quote(options.name)})`);\\n          if (options.exact)\\n            attrs.push(`.setExact(true)`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === \\\"string\\\" ? this.quote(value) : value})`);\\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join(\\\"\\\")}` : \\\"\\\";\\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\\n      case \\\"has\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(clazz, \\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(clazz, \\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(clazz, \\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(clazz, \\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(clazz, \\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", Pattern.CASE_INSENSITIVE\\\" : \\\"\\\";\\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\\n  }\\n  toCallWithExact(clazz, method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return this.quote(body);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar CSharpLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `Locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `FrameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `Nth(${body})`;\\n      case \\\"first\\\":\\n        return `First`;\\n      case \\\"last\\\":\\n        return `Last`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`Name = ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`Exact = true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${toTitleCase(name)} = ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, new() { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `Filter(new() { ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `Filter(new() { Has = ${body} })`;\\n      case \\\"test-id\\\":\\n        return `GetByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"GetByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"GetByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"GetByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"GetByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"GetByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", RegexOptions.IgnoreCase\\\" : \\\"\\\";\\n    return `new Regex(${this.quote(body.source)}${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return `HasTextRegex = ${this.regexToString(body)}`;\\n    return `HasText = ${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar generators = {\\n  javascript: new JavaScriptLocatorFactory(),\\n  python: new PythonLocatorFactory(),\\n  java: new JavaLocatorFactory(),\\n  csharp: new CSharpLocatorFactory()\\n};\\nfunction isRegExp(obj) {\\n  return obj instanceof RegExp;\\n}\\n\\n// packages/playwright-core/src/server/injected/highlight.ts\\nvar Highlight = class {\\n  constructor(injectedScript) {\\n    this._highlightEntries = [];\\n    this._language = \\\"javascript\\\";\\n    this._injectedScript = injectedScript;\\n    this._isUnderTest = injectedScript.isUnderTest;\\n    this._glassPaneElement = document.createElement(\\\"x-pw-glass\\\");\\n    this._glassPaneElement.style.position = \\\"fixed\\\";\\n    this._glassPaneElement.style.top = \\\"0\\\";\\n    this._glassPaneElement.style.right = \\\"0\\\";\\n    this._glassPaneElement.style.bottom = \\\"0\\\";\\n    this._glassPaneElement.style.left = \\\"0\\\";\\n    this._glassPaneElement.style.zIndex = \\\"2147483647\\\";\\n    this._glassPaneElement.style.pointerEvents = \\\"none\\\";\\n    this._glassPaneElement.style.display = \\\"flex\\\";\\n    this._actionPointElement = document.createElement(\\\"x-pw-action-point\\\");\\n    this._actionPointElement.setAttribute(\\\"hidden\\\", \\\"true\\\");\\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? \\\"open\\\" : \\\"closed\\\" });\\n    this._glassPaneShadow.appendChild(this._actionPointElement);\\n    const styleElement = document.createElement(\\\"style\\\");\\n    styleElement.textContent = `\\n        x-pw-tooltip {\\n          align-items: center;\\n          backdrop-filter: blur(5px);\\n          background-color: rgba(0, 0, 0, 0.7);\\n          border-radius: 2px;\\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\\n          color: rgb(204, 204, 204);\\n          display: none;\\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\\n                      'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\\n          font-size: 12.8px;\\n          font-weight: normal;\\n          left: 0;\\n          line-height: 1.5;\\n          max-width: 600px;\\n          padding: 3.2px 5.12px 3.2px;\\n          position: absolute;\\n          top: 0;\\n        }\\n        x-pw-action-point {\\n          position: absolute;\\n          width: 20px;\\n          height: 20px;\\n          background: red;\\n          border-radius: 10px;\\n          pointer-events: none;\\n          margin: -10px 0 0 -10px;\\n          z-index: 2;\\n        }\\n        *[hidden] {\\n          display: none !important;\\n        }\\n    `;\\n    this._glassPaneShadow.appendChild(styleElement);\\n  }\\n  install() {\\n    document.documentElement.appendChild(this._glassPaneElement);\\n  }\\n  setLanguage(language) {\\n    this._language = language;\\n  }\\n  runHighlightOnRaf(selector) {\\n    if (this._rafRequest)\\n      cancelAnimationFrame(this._rafRequest);\\n    this.updateHighlight(this._injectedScript.querySelectorAll(selector, document.documentElement), stringifySelector(selector), false);\\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\\n  }\\n  uninstall() {\\n    if (this._rafRequest)\\n      cancelAnimationFrame(this._rafRequest);\\n    this._glassPaneElement.remove();\\n  }\\n  isInstalled() {\\n    return this._glassPaneElement.parentElement === document.documentElement && !this._glassPaneElement.nextElementSibling;\\n  }\\n  showActionPoint(x, y) {\\n    this._actionPointElement.style.top = y + \\\"px\\\";\\n    this._actionPointElement.style.left = x + \\\"px\\\";\\n    this._actionPointElement.hidden = false;\\n    if (this._isUnderTest)\\n      console.error(\\\"Action point for test: \\\" + JSON.stringify({ x, y }));\\n  }\\n  hideActionPoint() {\\n    this._actionPointElement.hidden = true;\\n  }\\n  clearHighlight() {\\n    var _a, _b;\\n    for (const entry of this._highlightEntries) {\\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\\n    }\\n    this._highlightEntries = [];\\n  }\\n  updateHighlight(elements, selector, isRecording) {\\n    let color;\\n    if (isRecording)\\n      color = \\\"#dc6f6f7f\\\";\\n    else\\n      color = elements.length > 1 ? \\\"#f6b26b7f\\\" : \\\"#6fa8dc7f\\\";\\n    this._innerUpdateHighlight(elements, { color, tooltipText: selector ? asLocator(this._language, selector) : \\\"\\\" });\\n  }\\n  maskElements(elements) {\\n    this._innerUpdateHighlight(elements, { color: \\\"#F0F\\\" });\\n  }\\n  _innerUpdateHighlight(elements, options) {\\n    if (this._highlightIsUpToDate(elements, options.tooltipText))\\n      return;\\n    this.clearHighlight();\\n    for (let i = 0; i < elements.length; ++i) {\\n      const highlightElement = this._createHighlightElement();\\n      this._glassPaneShadow.appendChild(highlightElement);\\n      let tooltipElement;\\n      if (options.tooltipText) {\\n        tooltipElement = document.createElement(\\\"x-pw-tooltip\\\");\\n        this._glassPaneShadow.appendChild(tooltipElement);\\n        const suffix = elements.length > 1 ? ` [${i + 1} of ${elements.length}]` : \\\"\\\";\\n        tooltipElement.textContent = options.tooltipText + suffix;\\n        tooltipElement.style.top = \\\"0\\\";\\n        tooltipElement.style.left = \\\"0\\\";\\n        tooltipElement.style.display = \\\"flex\\\";\\n      }\\n      this._highlightEntries.push({ targetElement: elements[i], tooltipElement, highlightElement, tooltipText: options.tooltipText });\\n    }\\n    for (const entry of this._highlightEntries) {\\n      entry.box = entry.targetElement.getBoundingClientRect();\\n      if (!entry.tooltipElement)\\n        continue;\\n      const tooltipWidth = entry.tooltipElement.offsetWidth;\\n      const tooltipHeight = entry.tooltipElement.offsetHeight;\\n      const totalWidth = this._glassPaneElement.offsetWidth;\\n      const totalHeight = this._glassPaneElement.offsetHeight;\\n      let anchorLeft = entry.box.left;\\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\\n        anchorLeft = totalWidth - tooltipWidth - 5;\\n      let anchorTop = entry.box.bottom + 5;\\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\\n        if (entry.box.top > tooltipHeight + 5) {\\n          anchorTop = entry.box.top - tooltipHeight - 5;\\n        } else {\\n          anchorTop = totalHeight - 5 - tooltipHeight;\\n        }\\n      }\\n      entry.tooltipTop = anchorTop;\\n      entry.tooltipLeft = anchorLeft;\\n    }\\n    for (const entry of this._highlightEntries) {\\n      if (entry.tooltipElement) {\\n        entry.tooltipElement.style.top = entry.tooltipTop + \\\"px\\\";\\n        entry.tooltipElement.style.left = entry.tooltipLeft + \\\"px\\\";\\n      }\\n      const box = entry.box;\\n      entry.highlightElement.style.backgroundColor = options.color;\\n      entry.highlightElement.style.left = box.x + \\\"px\\\";\\n      entry.highlightElement.style.top = box.y + \\\"px\\\";\\n      entry.highlightElement.style.width = box.width + \\\"px\\\";\\n      entry.highlightElement.style.height = box.height + \\\"px\\\";\\n      entry.highlightElement.style.display = \\\"block\\\";\\n      if (this._isUnderTest)\\n        console.error(\\\"Highlight box for test: \\\" + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\\n    }\\n  }\\n  _highlightIsUpToDate(elements, tooltipText) {\\n    if (elements.length !== this._highlightEntries.length)\\n      return false;\\n    for (let i = 0; i < this._highlightEntries.length; ++i) {\\n      if (tooltipText !== this._highlightEntries[i].tooltipText)\\n        return false;\\n      if (elements[i] !== this._highlightEntries[i].targetElement)\\n        return false;\\n      const oldBox = this._highlightEntries[i].box;\\n      if (!oldBox)\\n        return false;\\n      const box = elements[i].getBoundingClientRect();\\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\\n        return false;\\n    }\\n    return true;\\n  }\\n  _createHighlightElement() {\\n    const highlightElement = document.createElement(\\\"x-pw-highlight\\\");\\n    highlightElement.style.position = \\\"absolute\\\";\\n    highlightElement.style.top = \\\"0\\\";\\n    highlightElement.style.left = \\\"0\\\";\\n    highlightElement.style.width = \\\"0\\\";\\n    highlightElement.style.height = \\\"0\\\";\\n    highlightElement.style.boxSizing = \\\"border-box\\\";\\n    return highlightElement;\\n  }\\n};\\n\\n// packages/playwright-core/src/server/injected/injectedScript.ts\\nvar InjectedScript = class {\\n  constructor(isUnderTest, sdkLanguage, testIdAttributeNameForStrictErrorAndConsoleCodegen, stableRafCount, browserName, customEngines) {\\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = \\\"data-testid\\\";\\n    this._markedTargetElements = /* @__PURE__ */ new Set();\\n    this.isUnderTest = isUnderTest;\\n    this._sdkLanguage = sdkLanguage;\\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = testIdAttributeNameForStrictErrorAndConsoleCodegen;\\n    this._evaluator = new SelectorEvaluatorImpl(/* @__PURE__ */ new Map());\\n    this._engines = /* @__PURE__ */ new Map();\\n    this._engines.set(\\\"xpath\\\", XPathEngine);\\n    this._engines.set(\\\"xpath:light\\\", XPathEngine);\\n    this._engines.set(\\\"_react\\\", ReactEngine);\\n    this._engines.set(\\\"_vue\\\", VueEngine);\\n    this._engines.set(\\\"role\\\", createRoleEngine(false));\\n    this._engines.set(\\\"text\\\", this._createTextEngine(true, false));\\n    this._engines.set(\\\"text:light\\\", this._createTextEngine(false, false));\\n    this._engines.set(\\\"id\\\", this._createAttributeEngine(\\\"id\\\", true));\\n    this._engines.set(\\\"id:light\\\", this._createAttributeEngine(\\\"id\\\", false));\\n    this._engines.set(\\\"data-testid\\\", this._createAttributeEngine(\\\"data-testid\\\", true));\\n    this._engines.set(\\\"data-testid:light\\\", this._createAttributeEngine(\\\"data-testid\\\", false));\\n    this._engines.set(\\\"data-test-id\\\", this._createAttributeEngine(\\\"data-test-id\\\", true));\\n    this._engines.set(\\\"data-test-id:light\\\", this._createAttributeEngine(\\\"data-test-id\\\", false));\\n    this._engines.set(\\\"data-test\\\", this._createAttributeEngine(\\\"data-test\\\", true));\\n    this._engines.set(\\\"data-test:light\\\", this._createAttributeEngine(\\\"data-test\\\", false));\\n    this._engines.set(\\\"css\\\", this._createCSSEngine());\\n    this._engines.set(\\\"nth\\\", { queryAll: () => [] });\\n    this._engines.set(\\\"visible\\\", this._createVisibleEngine());\\n    this._engines.set(\\\"internal:control\\\", this._createControlEngine());\\n    this._engines.set(\\\"internal:has\\\", this._createHasEngine());\\n    this._engines.set(\\\"internal:label\\\", this._createInternalLabelEngine());\\n    this._engines.set(\\\"internal:text\\\", this._createTextEngine(true, true));\\n    this._engines.set(\\\"internal:has-text\\\", this._createInternalHasTextEngine());\\n    this._engines.set(\\\"internal:attr\\\", this._createNamedAttributeEngine());\\n    this._engines.set(\\\"internal:testid\\\", this._createNamedAttributeEngine());\\n    this._engines.set(\\\"internal:role\\\", createRoleEngine(true));\\n    for (const { name, engine } of customEngines)\\n      this._engines.set(name, engine);\\n    this._stableRafCount = stableRafCount;\\n    this._browserName = browserName;\\n    this._setupGlobalListenersRemovalDetection();\\n    this._setupHitTargetInterceptors();\\n    if (isUnderTest)\\n      window.__injectedScript = this;\\n  }\\n  eval(expression) {\\n    return globalThis.eval(expression);\\n  }\\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\\n  }\\n  parseSelector(selector) {\\n    const result = parseSelector(selector);\\n    for (const name of allEngineNames(result)) {\\n      if (!this._engines.has(name))\\n        throw this.createStacklessError(`Unknown engine \\\"${name}\\\" while parsing selector ${selector}`);\\n    }\\n    return result;\\n  }\\n  generateSelector(targetElement, testIdAttributeName) {\\n    return generateSelector(this, targetElement, testIdAttributeName).selector;\\n  }\\n  querySelector(selector, root, strict) {\\n    const result = this.querySelectorAll(selector, root);\\n    if (strict && result.length > 1)\\n      throw this.strictModeViolationError(selector, result);\\n    return result[0];\\n  }\\n  _queryNth(elements, part) {\\n    const list = [...elements];\\n    let nth = +part.body;\\n    if (nth === -1)\\n      nth = list.length - 1;\\n    return new Set(list.slice(nth, nth + 1));\\n  }\\n  _queryLayoutSelector(elements, part, originalRoot) {\\n    const name = part.name;\\n    const body = part.body;\\n    const result = [];\\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\\n    for (const element of elements) {\\n      const score = layoutSelectorScore(name, element, inner, body.distance);\\n      if (score !== void 0)\\n        result.push({ element, score });\\n    }\\n    result.sort((a, b) => a.score - b.score);\\n    return new Set(result.map((r) => r.element));\\n  }\\n  querySelectorAll(selector, root) {\\n    if (selector.capture !== void 0) {\\n      if (selector.parts.some((part) => part.name === \\\"nth\\\"))\\n        throw this.createStacklessError(`Can't query n-th element in a request with the capture.`);\\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\\n      if (selector.capture < selector.parts.length - 1) {\\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\\n        const has = { name: \\\"internal:has\\\", body: { parsed }, source: stringifySelector(parsed) };\\n        withHas.parts.push(has);\\n      }\\n      return this.querySelectorAll(withHas, root);\\n    }\\n    if (!root[\\\"querySelectorAll\\\"])\\n      throw this.createStacklessError(\\\"Node is not queryable.\\\");\\n    if (selector.capture !== void 0) {\\n      throw this.createStacklessError(\\\"Internal error: there should not be a capture in the selector.\\\");\\n    }\\n    this._evaluator.begin();\\n    try {\\n      let roots = /* @__PURE__ */ new Set([root]);\\n      for (const part of selector.parts) {\\n        if (part.name === \\\"nth\\\") {\\n          roots = this._queryNth(roots, part);\\n        } else if (kLayoutSelectorNames.includes(part.name)) {\\n          roots = this._queryLayoutSelector(roots, part, root);\\n        } else {\\n          const next = /* @__PURE__ */ new Set();\\n          for (const root2 of roots) {\\n            const all = this._queryEngineAll(part, root2);\\n            for (const one of all)\\n              next.add(one);\\n          }\\n          roots = next;\\n        }\\n      }\\n      return [...roots];\\n    } finally {\\n      this._evaluator.end();\\n    }\\n  }\\n  _queryEngineAll(part, root) {\\n    const result = this._engines.get(part.name).queryAll(root, part.body);\\n    for (const element of result) {\\n      if (!(\\\"nodeName\\\" in element))\\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\\n    }\\n    return result;\\n  }\\n  _createAttributeEngine(attribute, shadow) {\\n    const toCSS = (selector) => {\\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: \\\"\\\" }] }];\\n    };\\n    return {\\n      queryAll: (root, selector) => {\\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\\n      }\\n    };\\n  }\\n  _createCSSEngine() {\\n    return {\\n      queryAll: (root, body) => {\\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\\n      }\\n    };\\n  }\\n  _createTextEngine(shadow, internal) {\\n    const queryAll = (root, selector) => {\\n      const { matcher, kind } = createTextMatcher(selector, internal);\\n      const result = [];\\n      let lastDidNotMatchSelf = null;\\n      const appendElement = (element) => {\\n        if (kind === \\\"lax\\\" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\\n          return false;\\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\\n        if (matches === \\\"none\\\")\\n          lastDidNotMatchSelf = element;\\n        if (matches === \\\"self\\\" || matches === \\\"selfAndChildren\\\" && kind === \\\"strict\\\" && !internal)\\n          result.push(element);\\n      };\\n      if (root.nodeType === Node.ELEMENT_NODE)\\n        appendElement(root);\\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, \\\"*\\\");\\n      for (const element of elements)\\n        appendElement(element);\\n      return result;\\n    };\\n    return { queryAll };\\n  }\\n  _createInternalHasTextEngine() {\\n    return {\\n      queryAll: (root, selector) => {\\n        if (root.nodeType !== 1)\\n          return [];\\n        const element = root;\\n        const text = elementText(this._evaluator._cacheText, element);\\n        const { matcher } = createTextMatcher(selector, true);\\n        return matcher(text) ? [element] : [];\\n      }\\n    };\\n  }\\n  _createInternalLabelEngine() {\\n    return {\\n      queryAll: (root, selector) => {\\n        const { matcher } = createTextMatcher(selector, true);\\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, \\\"*\\\");\\n        return allElements.filter((element) => {\\n          let labels = getAriaLabelledByElements(element);\\n          if (labels === null) {\\n            const ariaLabel = element.getAttribute(\\\"aria-label\\\");\\n            if (ariaLabel !== null)\\n              return matcher({ full: ariaLabel, immediate: [ariaLabel] });\\n          }\\n          if (labels === null)\\n            labels = element.labels;\\n          return !!labels && [...labels].some((label) => matcher(elementText(this._evaluator._cacheText, label)));\\n        });\\n      }\\n    };\\n  }\\n  _createNamedAttributeEngine() {\\n    const queryAll = (root, selector) => {\\n      const parsed = parseAttributeSelector(selector, true);\\n      if (parsed.name || parsed.attributes.length !== 1)\\n        throw new Error(\\\"Malformed attribute selector: \\\" + selector);\\n      const { name, value, caseSensitive } = parsed.attributes[0];\\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\\n      let matcher;\\n      if (value instanceof RegExp)\\n        matcher = (s) => !!s.match(value);\\n      else if (caseSensitive)\\n        matcher = (s) => s === value;\\n      else\\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\\n      return elements.filter((e) => matcher(e.getAttribute(name)));\\n    };\\n    return { queryAll };\\n  }\\n  _createControlEngine() {\\n    return {\\n      queryAll(root, body) {\\n        if (body === \\\"enter-frame\\\")\\n          return [];\\n        if (body === \\\"return-empty\\\")\\n          return [];\\n        if (body === \\\"component\\\") {\\n          if (root.nodeType !== 1)\\n            return [];\\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\\n        }\\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\\n      }\\n    };\\n  }\\n  _createHasEngine() {\\n    const queryAll = (root, body) => {\\n      if (root.nodeType !== 1)\\n        return [];\\n      const has = !!this.querySelector(body.parsed, root, false);\\n      return has ? [root] : [];\\n    };\\n    return { queryAll };\\n  }\\n  _createVisibleEngine() {\\n    const queryAll = (root, body) => {\\n      if (root.nodeType !== 1)\\n        return [];\\n      return isElementVisible(root) === Boolean(body) ? [root] : [];\\n    };\\n    return { queryAll };\\n  }\\n  extend(source, params) {\\n    const constrFunction = globalThis.eval(`\\n    (() => {\\n      const module = {};\\n      ${source}\\n      return module.exports;\\n    })()`);\\n    return new constrFunction(this, params);\\n  }\\n  isVisible(element) {\\n    return isElementVisible(element);\\n  }\\n  async viewportRatio(element) {\\n    return await new Promise((resolve) => {\\n      const observer = new IntersectionObserver((entries) => {\\n        resolve(entries[0].intersectionRatio);\\n        observer.disconnect();\\n      });\\n      observer.observe(element);\\n      requestAnimationFrame(() => {\\n      });\\n    });\\n  }\\n  pollRaf(predicate) {\\n    return this.poll(predicate, (next) => requestAnimationFrame(next));\\n  }\\n  poll(predicate, scheduleNext) {\\n    return this._runAbortableTask((progress) => {\\n      let fulfill;\\n      let reject;\\n      const result = new Promise((f, r) => {\\n        fulfill = f;\\n        reject = r;\\n      });\\n      const next = () => {\\n        if (progress.aborted)\\n          return;\\n        try {\\n          const success = predicate(progress);\\n          if (success !== progress.continuePolling)\\n            fulfill(success);\\n          else\\n            scheduleNext(next);\\n        } catch (e) {\\n          progress.log(\\\"  \\\" + e.message);\\n          reject(e);\\n        }\\n      };\\n      next();\\n      return result;\\n    });\\n  }\\n  _runAbortableTask(task) {\\n    let unsentLog = [];\\n    let takeNextLogsCallback;\\n    let taskFinished = false;\\n    const logReady = () => {\\n      if (!takeNextLogsCallback)\\n        return;\\n      takeNextLogsCallback(unsentLog);\\n      unsentLog = [];\\n      takeNextLogsCallback = void 0;\\n    };\\n    const takeNextLogs = () => new Promise((fulfill) => {\\n      takeNextLogsCallback = fulfill;\\n      if (unsentLog.length || taskFinished)\\n        logReady();\\n    });\\n    let lastMessage = \\\"\\\";\\n    const progress = {\\n      injectedScript: this,\\n      aborted: false,\\n      continuePolling: Symbol(\\\"continuePolling\\\"),\\n      log: (message) => {\\n        lastMessage = message;\\n        unsentLog.push({ message });\\n        logReady();\\n      },\\n      logRepeating: (message) => {\\n        if (message !== lastMessage)\\n          progress.log(message);\\n      }\\n    };\\n    const run = () => {\\n      const result = task(progress);\\n      result.finally(() => {\\n        taskFinished = true;\\n        logReady();\\n      });\\n      return result;\\n    };\\n    return {\\n      takeNextLogs,\\n      run,\\n      cancel: () => {\\n        progress.aborted = true;\\n      },\\n      takeLastLogs: () => unsentLog\\n    };\\n  }\\n  getElementBorderWidth(node) {\\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\\n      return { left: 0, top: 0 };\\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\\n    return { left: parseInt(style.borderLeftWidth || \\\"\\\", 10), top: parseInt(style.borderTopWidth || \\\"\\\", 10) };\\n  }\\n  describeIFrameStyle(iframe) {\\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\\n      return \\\"error:notconnected\\\";\\n    const defaultView = iframe.ownerDocument.defaultView;\\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\\n      if (defaultView.getComputedStyle(e).transform !== \\\"none\\\")\\n        return \\\"transformed\\\";\\n    }\\n    const iframeStyle = defaultView.getComputedStyle(iframe);\\n    return {\\n      left: parseInt(iframeStyle.borderLeftWidth || \\\"\\\", 10) + parseInt(iframeStyle.paddingLeft || \\\"\\\", 10),\\n      top: parseInt(iframeStyle.borderTopWidth || \\\"\\\", 10) + parseInt(iframeStyle.paddingTop || \\\"\\\", 10)\\n    };\\n  }\\n  retarget(node, behavior) {\\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\\n    if (!element)\\n      return null;\\n    if (behavior === \\\"none\\\")\\n      return element;\\n    if (!element.matches(\\\"input, textarea, select\\\")) {\\n      if (behavior === \\\"button-link\\\")\\n        element = element.closest(\\\"button, [role=button], a, [role=link]\\\") || element;\\n      else\\n        element = element.closest(\\\"button, [role=button], [role=checkbox], [role=radio]\\\") || element;\\n    }\\n    if (behavior === \\\"follow-label\\\") {\\n      if (!element.matches(\\\"input, textarea, button, select, [role=button], [role=checkbox], [role=radio]\\\") && !element.isContentEditable) {\\n        element = element.closest(\\\"label\\\") || element;\\n      }\\n      if (element.nodeName === \\\"LABEL\\\")\\n        element = element.control || element;\\n    }\\n    return element;\\n  }\\n  waitForElementStatesAndPerformAction(node, states, force, callback) {\\n    let lastRect;\\n    let counter = 0;\\n    let samePositionCounter = 0;\\n    let lastTime = 0;\\n    return this.pollRaf((progress) => {\\n      if (force) {\\n        progress.log(`    forcing action`);\\n        return callback(node, progress);\\n      }\\n      for (const state of states) {\\n        if (state !== \\\"stable\\\") {\\n          const result = this.elementState(node, state);\\n          if (typeof result !== \\\"boolean\\\")\\n            return result;\\n          if (!result) {\\n            progress.logRepeating(`    element is not ${state} - waiting...`);\\n            return progress.continuePolling;\\n          }\\n          continue;\\n        }\\n        const element = this.retarget(node, \\\"no-follow-label\\\");\\n        if (!element)\\n          return \\\"error:notconnected\\\";\\n        if (++counter === 1)\\n          return progress.continuePolling;\\n        const time = performance.now();\\n        if (this._stableRafCount > 1 && time - lastTime < 15)\\n          return progress.continuePolling;\\n        lastTime = time;\\n        const clientRect = element.getBoundingClientRect();\\n        const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\\n        const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\\n        if (samePosition)\\n          ++samePositionCounter;\\n        else\\n          samePositionCounter = 0;\\n        const isStable = samePositionCounter >= this._stableRafCount;\\n        const isStableForLogs = isStable || !lastRect;\\n        lastRect = rect;\\n        if (!isStableForLogs)\\n          progress.logRepeating(`    element is not stable - waiting...`);\\n        if (!isStable)\\n          return progress.continuePolling;\\n      }\\n      return callback(node, progress);\\n    });\\n  }\\n  elementState(node, state) {\\n    const element = this.retarget(node, [\\\"stable\\\", \\\"visible\\\", \\\"hidden\\\"].includes(state) ? \\\"none\\\" : \\\"follow-label\\\");\\n    if (!element || !element.isConnected) {\\n      if (state === \\\"hidden\\\")\\n        return true;\\n      return \\\"error:notconnected\\\";\\n    }\\n    if (state === \\\"visible\\\")\\n      return this.isVisible(element);\\n    if (state === \\\"hidden\\\")\\n      return !this.isVisible(element);\\n    const disabled = getAriaDisabled(element);\\n    if (state === \\\"disabled\\\")\\n      return disabled;\\n    if (state === \\\"enabled\\\")\\n      return !disabled;\\n    const editable = !([\\\"INPUT\\\", \\\"TEXTAREA\\\", \\\"SELECT\\\"].includes(element.nodeName) && element.hasAttribute(\\\"readonly\\\"));\\n    if (state === \\\"editable\\\")\\n      return !disabled && editable;\\n    if (state === \\\"checked\\\" || state === \\\"unchecked\\\") {\\n      const need = state === \\\"checked\\\";\\n      const checked = getChecked(element, false);\\n      if (checked === \\\"error\\\")\\n        throw this.createStacklessError(\\\"Not a checkbox or radio button\\\");\\n      return need === checked;\\n    }\\n    throw this.createStacklessError(`Unexpected element state \\\"${state}\\\"`);\\n  }\\n  selectOptions(optionsToSelect, node, progress) {\\n    const element = this.retarget(node, \\\"follow-label\\\");\\n    if (!element)\\n      return \\\"error:notconnected\\\";\\n    if (element.nodeName.toLowerCase() !== \\\"select\\\")\\n      throw this.createStacklessError(\\\"Element is not a <select> element\\\");\\n    const select = element;\\n    const options = [...select.options];\\n    const selectedOptions = [];\\n    let remainingOptionsToSelect = optionsToSelect.slice();\\n    for (let index = 0; index < options.length; index++) {\\n      const option = options[index];\\n      const filter = (optionToSelect) => {\\n        if (optionToSelect instanceof Node)\\n          return option === optionToSelect;\\n        let matches = true;\\n        if (optionToSelect.valueOrLabel !== void 0)\\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\\n        if (optionToSelect.value !== void 0)\\n          matches = matches && optionToSelect.value === option.value;\\n        if (optionToSelect.label !== void 0)\\n          matches = matches && optionToSelect.label === option.label;\\n        if (optionToSelect.index !== void 0)\\n          matches = matches && optionToSelect.index === index;\\n        return matches;\\n      };\\n      if (!remainingOptionsToSelect.some(filter))\\n        continue;\\n      selectedOptions.push(option);\\n      if (select.multiple) {\\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\\n      } else {\\n        remainingOptionsToSelect = [];\\n        break;\\n      }\\n    }\\n    if (remainingOptionsToSelect.length) {\\n      progress.logRepeating(\\\"    did not find some options - waiting... \\\");\\n      return progress.continuePolling;\\n    }\\n    select.value = void 0;\\n    selectedOptions.forEach((option) => option.selected = true);\\n    progress.log(\\\"    selected specified option(s)\\\");\\n    select.dispatchEvent(new Event(\\\"input\\\", { \\\"bubbles\\\": true }));\\n    select.dispatchEvent(new Event(\\\"change\\\", { \\\"bubbles\\\": true }));\\n    return selectedOptions.map((option) => option.value);\\n  }\\n  fill(value, node, progress) {\\n    const element = this.retarget(node, \\\"follow-label\\\");\\n    if (!element)\\n      return \\\"error:notconnected\\\";\\n    if (element.nodeName.toLowerCase() === \\\"input\\\") {\\n      const input = element;\\n      const type = input.type.toLowerCase();\\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set([\\\"color\\\", \\\"date\\\", \\\"time\\\", \\\"datetime\\\", \\\"datetime-local\\\", \\\"month\\\", \\\"range\\\", \\\"week\\\"]);\\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set([\\\"\\\", \\\"email\\\", \\\"number\\\", \\\"password\\\", \\\"search\\\", \\\"tel\\\", \\\"text\\\", \\\"url\\\"]);\\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type)) {\\n        progress.log(`    input of type \\\"${type}\\\" cannot be filled`);\\n        throw this.createStacklessError(`Input of type \\\"${type}\\\" cannot be filled`);\\n      }\\n      if (type === \\\"number\\\") {\\n        value = value.trim();\\n        if (isNaN(Number(value)))\\n          throw this.createStacklessError(\\\"Cannot type text into input[type=number]\\\");\\n      }\\n      if (kInputTypesToSetValue.has(type)) {\\n        value = value.trim();\\n        input.focus();\\n        input.value = value;\\n        if (input.value !== value)\\n          throw this.createStacklessError(\\\"Malformed value\\\");\\n        element.dispatchEvent(new Event(\\\"input\\\", { \\\"bubbles\\\": true }));\\n        element.dispatchEvent(new Event(\\\"change\\\", { \\\"bubbles\\\": true }));\\n        return \\\"done\\\";\\n      }\\n    } else if (element.nodeName.toLowerCase() === \\\"textarea\\\") {\\n    } else if (!element.isContentEditable) {\\n      throw this.createStacklessError(\\\"Element is not an <input>, <textarea> or [contenteditable] element\\\");\\n    }\\n    this.selectText(element);\\n    return \\\"needsinput\\\";\\n  }\\n  selectText(node) {\\n    const element = this.retarget(node, \\\"follow-label\\\");\\n    if (!element)\\n      return \\\"error:notconnected\\\";\\n    if (element.nodeName.toLowerCase() === \\\"input\\\") {\\n      const input = element;\\n      input.select();\\n      input.focus();\\n      return \\\"done\\\";\\n    }\\n    if (element.nodeName.toLowerCase() === \\\"textarea\\\") {\\n      const textarea = element;\\n      textarea.selectionStart = 0;\\n      textarea.selectionEnd = textarea.value.length;\\n      textarea.focus();\\n      return \\\"done\\\";\\n    }\\n    const range = element.ownerDocument.createRange();\\n    range.selectNodeContents(element);\\n    const selection = element.ownerDocument.defaultView.getSelection();\\n    if (selection) {\\n      selection.removeAllRanges();\\n      selection.addRange(range);\\n    }\\n    element.focus();\\n    return \\\"done\\\";\\n  }\\n  _activelyFocused(node) {\\n    const activeElement = node.getRootNode().activeElement;\\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\\n    return { activeElement, isFocused };\\n  }\\n  focusNode(node, resetSelectionIfNotFocused) {\\n    if (!node.isConnected)\\n      return \\\"error:notconnected\\\";\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      throw this.createStacklessError(\\\"Node is not an element\\\");\\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\\n      activeElement.blur();\\n    }\\n    node.focus();\\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === \\\"input\\\") {\\n      try {\\n        const input = node;\\n        input.setSelectionRange(0, 0);\\n      } catch (e) {\\n      }\\n    }\\n    return \\\"done\\\";\\n  }\\n  blurNode(node) {\\n    if (!node.isConnected)\\n      return \\\"error:notconnected\\\";\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      throw this.createStacklessError(\\\"Node is not an element\\\");\\n    node.blur();\\n    return \\\"done\\\";\\n  }\\n  setInputFiles(node, payloads) {\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      return \\\"Node is not of type HTMLElement\\\";\\n    const element = node;\\n    if (element.nodeName !== \\\"INPUT\\\")\\n      return \\\"Not an <input> element\\\";\\n    const input = element;\\n    const type = (input.getAttribute(\\\"type\\\") || \\\"\\\").toLowerCase();\\n    if (type !== \\\"file\\\")\\n      return \\\"Not an input[type=file] element\\\";\\n    const files = payloads.map((file) => {\\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\\n      return new File([bytes], file.name, { type: file.mimeType });\\n    });\\n    const dt = new DataTransfer();\\n    for (const file of files)\\n      dt.items.add(file);\\n    input.files = dt.files;\\n    input.dispatchEvent(new Event(\\\"input\\\", { \\\"bubbles\\\": true }));\\n    input.dispatchEvent(new Event(\\\"change\\\", { \\\"bubbles\\\": true }));\\n  }\\n  expectHitTarget(hitPoint, targetElement) {\\n    var _a;\\n    const roots = [];\\n    let parentElement = targetElement;\\n    while (parentElement) {\\n      const root = enclosingShadowRootOrDocument(parentElement);\\n      if (!root)\\n        break;\\n      roots.push(root);\\n      if (root.nodeType === 9)\\n        break;\\n      parentElement = root.host;\\n    }\\n    let hitElement;\\n    for (let index = roots.length - 1; index >= 0; index--) {\\n      const root = roots[index];\\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\\n        const style = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(singleElement);\\n        if ((style == null ? void 0 : style.display) === \\\"contents\\\") {\\n          elements.unshift(singleElement);\\n        }\\n      }\\n      const innerElement = elements[0];\\n      if (!innerElement)\\n        break;\\n      hitElement = innerElement;\\n      if (index && innerElement !== roots[index - 1].host)\\n        break;\\n    }\\n    const hitParents = [];\\n    while (hitElement && hitElement !== targetElement) {\\n      hitParents.push(hitElement);\\n      hitElement = parentElementOrShadowHost(hitElement);\\n    }\\n    if (hitElement === targetElement)\\n      return \\\"done\\\";\\n    const hitTargetDescription = this.previewNode(hitParents[0] || document.documentElement);\\n    let rootHitTargetDescription;\\n    let element = targetElement;\\n    while (element) {\\n      const index = hitParents.indexOf(element);\\n      if (index !== -1) {\\n        if (index > 1)\\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\\n        break;\\n      }\\n      element = parentElementOrShadowHost(element);\\n    }\\n    if (rootHitTargetDescription)\\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\\n    return { hitTargetDescription };\\n  }\\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\\n    const element = this.retarget(node, \\\"button-link\\\");\\n    if (!element || !element.isConnected)\\n      return \\\"error:notconnected\\\";\\n    if (hitPoint) {\\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\\n      if (preliminaryResult !== \\\"done\\\")\\n        return preliminaryResult.hitTargetDescription;\\n    }\\n    if (action === \\\"drag\\\")\\n      return { stop: () => \\\"done\\\" };\\n    const events = {\\n      \\\"hover\\\": kHoverHitTargetInterceptorEvents,\\n      \\\"tap\\\": kTapHitTargetInterceptorEvents,\\n      \\\"mouse\\\": kMouseHitTargetInterceptorEvents\\n    }[action];\\n    let result;\\n    const listener = (event) => {\\n      if (!events.has(event.type))\\n        return;\\n      if (!event.isTrusted)\\n        return;\\n      const point = !!window.TouchEvent && event instanceof window.TouchEvent ? event.touches[0] : event;\\n      if (result === void 0 && point)\\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\\n      if (blockAllEvents || result !== \\\"done\\\" && result !== void 0) {\\n        event.preventDefault();\\n        event.stopPropagation();\\n        event.stopImmediatePropagation();\\n      }\\n    };\\n    const stop = () => {\\n      if (this._hitTargetInterceptor === listener)\\n        this._hitTargetInterceptor = void 0;\\n      return result || \\\"done\\\";\\n    };\\n    this._hitTargetInterceptor = listener;\\n    return { stop };\\n  }\\n  dispatchEvent(node, type, eventInit) {\\n    let event;\\n    eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInit };\\n    switch (eventType.get(type)) {\\n      case \\\"mouse\\\":\\n        event = new MouseEvent(type, eventInit);\\n        break;\\n      case \\\"keyboard\\\":\\n        event = new KeyboardEvent(type, eventInit);\\n        break;\\n      case \\\"touch\\\":\\n        event = new TouchEvent(type, eventInit);\\n        break;\\n      case \\\"pointer\\\":\\n        event = new PointerEvent(type, eventInit);\\n        break;\\n      case \\\"focus\\\":\\n        event = new FocusEvent(type, eventInit);\\n        break;\\n      case \\\"drag\\\":\\n        event = new DragEvent(type, eventInit);\\n        break;\\n      case \\\"wheel\\\":\\n        event = new WheelEvent(type, eventInit);\\n        break;\\n      default:\\n        event = new Event(type, eventInit);\\n        break;\\n    }\\n    node.dispatchEvent(event);\\n  }\\n  previewNode(node) {\\n    if (node.nodeType === Node.TEXT_NODE)\\n      return oneLine(`#text=${node.nodeValue || \\\"\\\"}`);\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\\n    const element = node;\\n    const attrs = [];\\n    for (let i = 0; i < element.attributes.length; i++) {\\n      const { name, value } = element.attributes[i];\\n      if (name === \\\"style\\\" || name.startsWith(\\\"__playwright\\\"))\\n        continue;\\n      if (!value && booleanAttributes.has(name))\\n        attrs.push(` ${name}`);\\n      else\\n        attrs.push(` ${name}=\\\"${value}\\\"`);\\n    }\\n    attrs.sort((a, b) => a.length - b.length);\\n    let attrText = attrs.join(\\\"\\\");\\n    if (attrText.length > 50)\\n      attrText = attrText.substring(0, 49) + \\\"\\\\u2026\\\";\\n    if (autoClosingTags.has(element.nodeName))\\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\\n    const children = element.childNodes;\\n    let onlyText = false;\\n    if (children.length <= 5) {\\n      onlyText = true;\\n      for (let i = 0; i < children.length; i++)\\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\\n    }\\n    let text = onlyText ? element.textContent || \\\"\\\" : children.length ? \\\"\\\\u2026\\\" : \\\"\\\";\\n    if (text.length > 50)\\n      text = text.substring(0, 49) + \\\"\\\\u2026\\\";\\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`);\\n  }\\n  strictModeViolationError(selector, matches) {\\n    const infos = matches.slice(0, 10).map((m) => ({\\n      preview: this.previewNode(m),\\n      selector: this.generateSelector(m, this._testIdAttributeNameForStrictErrorAndConsoleCodegen)\\n    }));\\n    const lines = infos.map((info, i) => `\\n    ${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\\n    if (infos.length < matches.length)\\n      lines.push(\\\"\\\\n    ...\\\");\\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join(\\\"\\\")}\\n`);\\n  }\\n  createStacklessError(message) {\\n    if (this._browserName === \\\"firefox\\\") {\\n      const error2 = new Error(\\\"Error: \\\" + message);\\n      error2.stack = \\\"\\\";\\n      return error2;\\n    }\\n    const error = new Error(message);\\n    delete error.stack;\\n    return error;\\n  }\\n  maskSelectors(selectors) {\\n    if (this._highlight)\\n      this.hideHighlight();\\n    this._highlight = new Highlight(this);\\n    this._highlight.install();\\n    const elements = [];\\n    for (const selector of selectors)\\n      elements.push(this.querySelectorAll(selector, document.documentElement));\\n    this._highlight.maskElements(elements.flat());\\n  }\\n  highlight(selector) {\\n    if (!this._highlight) {\\n      this._highlight = new Highlight(this);\\n      this._highlight.install();\\n    }\\n    this._highlight.runHighlightOnRaf(selector);\\n  }\\n  hideHighlight() {\\n    if (this._highlight) {\\n      this._highlight.uninstall();\\n      delete this._highlight;\\n    }\\n  }\\n  markTargetElements(markedElements, snapshotName) {\\n    for (const e of this._markedTargetElements) {\\n      if (!markedElements.has(e))\\n        e.removeAttribute(\\\"__playwright_target__\\\");\\n    }\\n    for (const e of markedElements) {\\n      if (!this._markedTargetElements.has(e))\\n        e.setAttribute(\\\"__playwright_target__\\\", snapshotName);\\n    }\\n    this._markedTargetElements = markedElements;\\n  }\\n  _setupGlobalListenersRemovalDetection() {\\n    const customEventName = \\\"__playwright_global_listeners_check__\\\";\\n    let seenEvent = false;\\n    const handleCustomEvent = () => seenEvent = true;\\n    window.addEventListener(customEventName, handleCustomEvent);\\n    new MutationObserver((entries) => {\\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));\\n      if (!newDocumentElement)\\n        return;\\n      seenEvent = false;\\n      window.dispatchEvent(new CustomEvent(customEventName));\\n      if (seenEvent)\\n        return;\\n      window.addEventListener(customEventName, handleCustomEvent);\\n      for (const callback of this.onGlobalListenersRemoved)\\n        callback();\\n    }).observe(document, { childList: true });\\n  }\\n  _setupHitTargetInterceptors() {\\n    const listener = (event) => {\\n      var _a;\\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\\n    };\\n    const addHitTargetInterceptorListeners = () => {\\n      for (const event of kAllHitTargetInterceptorEvents)\\n        window.addEventListener(event, listener, { capture: true, passive: false });\\n    };\\n    addHitTargetInterceptorListeners();\\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\\n  }\\n  async expect(element, options, elements) {\\n    const isArray = options.expression === \\\"to.have.count\\\" || options.expression.endsWith(\\\".array\\\");\\n    if (isArray)\\n      return this.expectArray(elements, options);\\n    if (!element) {\\n      if (!options.isNot && options.expression === \\\"to.be.hidden\\\")\\n        return { matches: true };\\n      if (options.isNot && options.expression === \\\"to.be.visible\\\")\\n        return { matches: false };\\n      if (options.isNot && options.expression === \\\"to.be.in.viewport\\\")\\n        return { matches: false };\\n      return { matches: options.isNot, missingRecevied: true };\\n    }\\n    return await this.expectSingleElement(element, options);\\n  }\\n  async expectSingleElement(element, options) {\\n    var _a, _b;\\n    const expression = options.expression;\\n    {\\n      let elementState;\\n      if (expression === \\\"to.be.checked\\\") {\\n        elementState = this.elementState(element, \\\"checked\\\");\\n      } else if (expression === \\\"to.be.unchecked\\\") {\\n        elementState = this.elementState(element, \\\"unchecked\\\");\\n      } else if (expression === \\\"to.be.disabled\\\") {\\n        elementState = this.elementState(element, \\\"disabled\\\");\\n      } else if (expression === \\\"to.be.editable\\\") {\\n        elementState = this.elementState(element, \\\"editable\\\");\\n      } else if (expression === \\\"to.be.readonly\\\") {\\n        elementState = !this.elementState(element, \\\"editable\\\");\\n      } else if (expression === \\\"to.be.empty\\\") {\\n        if (element.nodeName === \\\"INPUT\\\" || element.nodeName === \\\"TEXTAREA\\\")\\n          elementState = !element.value;\\n        else\\n          elementState = !((_a = element.textContent) == null ? void 0 : _a.trim());\\n      } else if (expression === \\\"to.be.enabled\\\") {\\n        elementState = this.elementState(element, \\\"enabled\\\");\\n      } else if (expression === \\\"to.be.focused\\\") {\\n        elementState = this._activelyFocused(element).isFocused;\\n      } else if (expression === \\\"to.be.hidden\\\") {\\n        elementState = this.elementState(element, \\\"hidden\\\");\\n      } else if (expression === \\\"to.be.visible\\\") {\\n        elementState = this.elementState(element, \\\"visible\\\");\\n      }\\n      if (elementState !== void 0) {\\n        if (elementState === \\\"error:notcheckbox\\\")\\n          throw this.createStacklessError(\\\"Element is not a checkbox\\\");\\n        if (elementState === \\\"error:notconnected\\\")\\n          throw this.createStacklessError(\\\"Element is not connected\\\");\\n        return { received: elementState, matches: elementState };\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.have.property\\\") {\\n        const received = element[options.expressionArg];\\n        const matches = deepEquals(received, options.expectedValue);\\n        return { received, matches };\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.be.in.viewport\\\") {\\n        const ratio = await this.viewportRatio(element);\\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.have.values\\\") {\\n        element = this.retarget(element, \\\"follow-label\\\");\\n        if (element.nodeName !== \\\"SELECT\\\" || !element.multiple)\\n          throw this.createStacklessError(\\\"Not a select element with a multiple attribute\\\");\\n        const received = [...element.selectedOptions].map((o) => o.value);\\n        if (received.length !== options.expectedText.length)\\n          return { received, matches: false };\\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\\n      }\\n    }\\n    {\\n      let received;\\n      if (expression === \\\"to.have.attribute\\\") {\\n        const value = element.getAttribute(options.expressionArg);\\n        if (value === null)\\n          return { received: null, matches: false };\\n        received = value;\\n      } else if (expression === \\\"to.have.class\\\") {\\n        received = element.classList.toString();\\n      } else if (expression === \\\"to.have.css\\\") {\\n        received = window.getComputedStyle(element).getPropertyValue(options.expressionArg);\\n      } else if (expression === \\\"to.have.id\\\") {\\n        received = element.id;\\n      } else if (expression === \\\"to.have.text\\\") {\\n        received = options.useInnerText ? element.innerText : elementText(/* @__PURE__ */ new Map(), element).full;\\n      } else if (expression === \\\"to.have.title\\\") {\\n        received = document.title;\\n      } else if (expression === \\\"to.have.url\\\") {\\n        received = document.location.href;\\n      } else if (expression === \\\"to.have.value\\\") {\\n        element = this.retarget(element, \\\"follow-label\\\");\\n        if (element.nodeName !== \\\"INPUT\\\" && element.nodeName !== \\\"TEXTAREA\\\" && element.nodeName !== \\\"SELECT\\\")\\n          throw this.createStacklessError(\\\"Not an input element\\\");\\n        received = element.value;\\n      }\\n      if (received !== void 0 && options.expectedText) {\\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\\n        return { received, matches: matcher.matches(received) };\\n      }\\n    }\\n    throw this.createStacklessError(\\\"Unknown expect matcher: \\\" + expression);\\n  }\\n  expectArray(elements, options) {\\n    const expression = options.expression;\\n    if (expression === \\\"to.have.count\\\") {\\n      const received2 = elements.length;\\n      const matches = received2 === options.expectedNumber;\\n      return { received: received2, matches };\\n    }\\n    let received;\\n    if (expression === \\\"to.have.text.array\\\" || expression === \\\"to.contain.text.array\\\")\\n      received = elements.map((e) => options.useInnerText ? e.innerText : elementText(/* @__PURE__ */ new Map(), e).full);\\n    else if (expression === \\\"to.have.class.array\\\")\\n      received = elements.map((e) => e.classList.toString());\\n    if (received && options.expectedText) {\\n      const lengthShouldMatch = expression !== \\\"to.contain.text.array\\\";\\n      const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\\n      if (!matchesLength)\\n        return { received, matches: false };\\n      const matchers = options.expectedText.map((e) => new ExpectedTextMatcher(e));\\n      let mIndex = 0, rIndex = 0;\\n      while (mIndex < matchers.length && rIndex < received.length) {\\n        if (matchers[mIndex].matches(received[rIndex]))\\n          ++mIndex;\\n        ++rIndex;\\n      }\\n      return { received, matches: mIndex === matchers.length };\\n    }\\n    throw this.createStacklessError(\\\"Unknown expect matcher: \\\" + expression);\\n  }\\n  getElementAccessibleName(element, includeHidden) {\\n    const hiddenCache = /* @__PURE__ */ new Map();\\n    return getElementAccessibleName(element, !!includeHidden, hiddenCache);\\n  }\\n  getAriaRole(element) {\\n    return getAriaRole(element);\\n  }\\n};\\nvar autoClosingTags = /* @__PURE__ */ new Set([\\\"AREA\\\", \\\"BASE\\\", \\\"BR\\\", \\\"COL\\\", \\\"COMMAND\\\", \\\"EMBED\\\", \\\"HR\\\", \\\"IMG\\\", \\\"INPUT\\\", \\\"KEYGEN\\\", \\\"LINK\\\", \\\"MENUITEM\\\", \\\"META\\\", \\\"PARAM\\\", \\\"SOURCE\\\", \\\"TRACK\\\", \\\"WBR\\\"]);\\nvar booleanAttributes = /* @__PURE__ */ new Set([\\\"checked\\\", \\\"selected\\\", \\\"disabled\\\", \\\"readonly\\\", \\\"multiple\\\"]);\\nfunction oneLine(s) {\\n  return s.replace(/\\\\n/g, \\\"\\\\u21B5\\\").replace(/\\\\t/g, \\\"\\\\u21C6\\\");\\n}\\nvar eventType = /* @__PURE__ */ new Map([\\n  [\\\"auxclick\\\", \\\"mouse\\\"],\\n  [\\\"click\\\", \\\"mouse\\\"],\\n  [\\\"dblclick\\\", \\\"mouse\\\"],\\n  [\\\"mousedown\\\", \\\"mouse\\\"],\\n  [\\\"mouseeenter\\\", \\\"mouse\\\"],\\n  [\\\"mouseleave\\\", \\\"mouse\\\"],\\n  [\\\"mousemove\\\", \\\"mouse\\\"],\\n  [\\\"mouseout\\\", \\\"mouse\\\"],\\n  [\\\"mouseover\\\", \\\"mouse\\\"],\\n  [\\\"mouseup\\\", \\\"mouse\\\"],\\n  [\\\"mouseleave\\\", \\\"mouse\\\"],\\n  [\\\"mousewheel\\\", \\\"mouse\\\"],\\n  [\\\"keydown\\\", \\\"keyboard\\\"],\\n  [\\\"keyup\\\", \\\"keyboard\\\"],\\n  [\\\"keypress\\\", \\\"keyboard\\\"],\\n  [\\\"textInput\\\", \\\"keyboard\\\"],\\n  [\\\"touchstart\\\", \\\"touch\\\"],\\n  [\\\"touchmove\\\", \\\"touch\\\"],\\n  [\\\"touchend\\\", \\\"touch\\\"],\\n  [\\\"touchcancel\\\", \\\"touch\\\"],\\n  [\\\"pointerover\\\", \\\"pointer\\\"],\\n  [\\\"pointerout\\\", \\\"pointer\\\"],\\n  [\\\"pointerenter\\\", \\\"pointer\\\"],\\n  [\\\"pointerleave\\\", \\\"pointer\\\"],\\n  [\\\"pointerdown\\\", \\\"pointer\\\"],\\n  [\\\"pointerup\\\", \\\"pointer\\\"],\\n  [\\\"pointermove\\\", \\\"pointer\\\"],\\n  [\\\"pointercancel\\\", \\\"pointer\\\"],\\n  [\\\"gotpointercapture\\\", \\\"pointer\\\"],\\n  [\\\"lostpointercapture\\\", \\\"pointer\\\"],\\n  [\\\"focus\\\", \\\"focus\\\"],\\n  [\\\"blur\\\", \\\"focus\\\"],\\n  [\\\"drag\\\", \\\"drag\\\"],\\n  [\\\"dragstart\\\", \\\"drag\\\"],\\n  [\\\"dragend\\\", \\\"drag\\\"],\\n  [\\\"dragover\\\", \\\"drag\\\"],\\n  [\\\"dragenter\\\", \\\"drag\\\"],\\n  [\\\"dragleave\\\", \\\"drag\\\"],\\n  [\\\"dragexit\\\", \\\"drag\\\"],\\n  [\\\"drop\\\", \\\"drag\\\"],\\n  [\\\"wheel\\\", \\\"wheel\\\"]\\n]);\\nvar kHoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\\\"mousemove\\\"]);\\nvar kTapHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\\\"pointerdown\\\", \\\"pointerup\\\", \\\"touchstart\\\", \\\"touchend\\\", \\\"touchcancel\\\"]);\\nvar kMouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\\\"mousedown\\\", \\\"mouseup\\\", \\\"pointerdown\\\", \\\"pointerup\\\", \\\"click\\\", \\\"auxclick\\\", \\\"dblclick\\\", \\\"contextmenu\\\"]);\\nvar kAllHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...kHoverHitTargetInterceptorEvents, ...kTapHitTargetInterceptorEvents, ...kMouseHitTargetInterceptorEvents]);\\nfunction cssUnquote(s) {\\n  s = s.substring(1, s.length - 1);\\n  if (!s.includes(\\\"\\\\\\\\\\\"))\\n    return s;\\n  const r = [];\\n  let i = 0;\\n  while (i < s.length) {\\n    if (s[i] === \\\"\\\\\\\\\\\" && i + 1 < s.length)\\n      i++;\\n    r.push(s[i++]);\\n  }\\n  return r.join(\\\"\\\");\\n}\\nfunction createTextMatcher(selector, internal) {\\n  if (selector[0] === \\\"/\\\" && selector.lastIndexOf(\\\"/\\\") > 0) {\\n    const lastSlash = selector.lastIndexOf(\\\"/\\\");\\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: \\\"regex\\\" };\\n  }\\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\\n  let strict = false;\\n  if (selector.length > 1 && selector[0] === '\\\"' && selector[selector.length - 1] === '\\\"') {\\n    selector = unquote(selector);\\n    strict = true;\\n  } else if (internal && selector.length > 1 && selector[0] === '\\\"' && selector[selector.length - 2] === '\\\"' && selector[selector.length - 1] === \\\"i\\\") {\\n    selector = unquote(selector.substring(0, selector.length - 1));\\n    strict = false;\\n  } else if (internal && selector.length > 1 && selector[0] === '\\\"' && selector[selector.length - 2] === '\\\"' && selector[selector.length - 1] === \\\"s\\\") {\\n    selector = unquote(selector.substring(0, selector.length - 1));\\n    strict = true;\\n  } else if (selector.length > 1 && selector[0] === \\\"'\\\" && selector[selector.length - 1] === \\\"'\\\") {\\n    selector = unquote(selector);\\n    strict = true;\\n  }\\n  selector = normalizeWhiteSpace(selector);\\n  if (strict) {\\n    if (internal)\\n      return { kind: \\\"strict\\\", matcher: (elementText2) => normalizeWhiteSpace(elementText2.full) === selector };\\n    const strictTextNodeMatcher = (elementText2) => {\\n      if (!selector && !elementText2.immediate.length)\\n        return true;\\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\\n    };\\n    return { matcher: strictTextNodeMatcher, kind: \\\"strict\\\" };\\n  }\\n  selector = selector.toLowerCase();\\n  return { kind: \\\"lax\\\", matcher: (elementText2) => normalizeWhiteSpace(elementText2.full).toLowerCase().includes(selector) };\\n}\\nvar ExpectedTextMatcher = class {\\n  constructor(expected) {\\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\\n    this._ignoreCase = expected.ignoreCase;\\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\\n    if (expected.regexSource) {\\n      const flags = new Set((expected.regexFlags || \\\"\\\").split(\\\"\\\"));\\n      if (expected.ignoreCase === false)\\n        flags.delete(\\\"i\\\");\\n      if (expected.ignoreCase === true)\\n        flags.add(\\\"i\\\");\\n      this._regex = new RegExp(expected.regexSource, [...flags].join(\\\"\\\"));\\n    }\\n  }\\n  matches(text) {\\n    if (!this._regex)\\n      text = this.normalize(text);\\n    if (this._string !== void 0)\\n      return text === this._string;\\n    if (this._substring !== void 0)\\n      return text.includes(this._substring);\\n    if (this._regex)\\n      return !!this._regex.test(text);\\n    return false;\\n  }\\n  normalize(s) {\\n    if (!s)\\n      return s;\\n    if (this._normalizeWhiteSpace)\\n      s = normalizeWhiteSpace(s);\\n    if (this._ignoreCase)\\n      s = s.toLocaleLowerCase();\\n    return s;\\n  }\\n};\\nfunction deepEquals(a, b) {\\n  if (a === b)\\n    return true;\\n  if (a && b && typeof a === \\\"object\\\" && typeof b === \\\"object\\\") {\\n    if (a.constructor !== b.constructor)\\n      return false;\\n    if (Array.isArray(a)) {\\n      if (a.length !== b.length)\\n        return false;\\n      for (let i = 0; i < a.length; ++i) {\\n        if (!deepEquals(a[i], b[i]))\\n          return false;\\n      }\\n      return true;\\n    }\\n    if (a instanceof RegExp)\\n      return a.source === b.source && a.flags === b.flags;\\n    if (a.valueOf !== Object.prototype.valueOf)\\n      return a.valueOf() === b.valueOf();\\n    if (a.toString !== Object.prototype.toString)\\n      return a.toString() === b.toString();\\n    const keys = Object.keys(a);\\n    if (keys.length !== Object.keys(b).length)\\n      return false;\\n    for (let i = 0; i < keys.length; ++i) {\\n      if (!b.hasOwnProperty(keys[i]))\\n        return false;\\n    }\\n    for (const key of keys) {\\n      if (!deepEquals(a[key], b[key]))\\n        return false;\\n    }\\n    return true;\\n  }\\n  if (typeof a === \\\"number\\\" && typeof b === \\\"number\\\")\\n    return isNaN(a) && isNaN(b);\\n  return false;\\n}\\nmodule.exports = InjectedScript;\\n\";\nexports.source = source;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.source = void 0;\nconst source = \"\\\"use strict\\\";\\n\\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\\nfunction escapeWithQuotes(text, char = \\\"'\\\") {\\n  const stringified = JSON.stringify(text);\\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\\\\\\\"/g, '\\\"');\\n  if (char === \\\"'\\\")\\n    return char + escapedText.replace(/[']/g, \\\"\\\\\\\\'\\\") + char;\\n  if (char === '\\\"')\\n    return char + escapedText.replace(/[\\\"]/g, '\\\\\\\\\\\"') + char;\\n  if (char === \\\"`\\\")\\n    return char + escapedText.replace(/[`]/g, \\\"`\\\") + char;\\n  throw new Error(\\\"Invalid escape char\\\");\\n}\\nfunction toTitleCase(name) {\\n  return name.charAt(0).toUpperCase() + name.substring(1);\\n}\\nfunction toSnakeCase(name) {\\n  return name.replace(/([a-z0-9])([A-Z])/g, \\\"$1_$2\\\").replace(/([A-Z])([A-Z][a-z])/g, \\\"$1_$2\\\").toLowerCase();\\n}\\nfunction cssEscape(s) {\\n  let result = \\\"\\\";\\n  for (let i = 0; i < s.length; i++)\\n    result += cssEscapeOne(s, i);\\n  return result;\\n}\\nfunction cssEscapeOne(s, i) {\\n  const c = s.charCodeAt(i);\\n  if (c === 0)\\n    return \\\"\\\\uFFFD\\\";\\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\\n    return \\\"\\\\\\\\\\\" + c.toString(16) + \\\" \\\";\\n  if (i === 0 && c === 45 && s.length === 1)\\n    return \\\"\\\\\\\\\\\" + s.charAt(i);\\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\\n    return s.charAt(i);\\n  return \\\"\\\\\\\\\\\" + s.charAt(i);\\n}\\nfunction normalizeWhiteSpace(text) {\\n  return text.replace(/\\\\u200b/g, \\\"\\\").trim().replace(/\\\\s+/g, \\\" \\\");\\n}\\nfunction escapeForTextSelector(text, exact) {\\n  if (typeof text !== \\\"string\\\")\\n    return String(text);\\n  return `${JSON.stringify(text)}${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\nfunction escapeForAttributeSelector(value, exact) {\\n  return `\\\"${value.replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\").replace(/[\\\"]/g, '\\\\\\\\\\\"')}\\\"${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\n\\n// packages/playwright-core/src/server/injected/domUtils.ts\\nfunction parentElementOrShadowHost(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return;\\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\\n    return element.parentNode.host;\\n}\\nfunction enclosingShadowRootOrDocument(element) {\\n  let node = element;\\n  while (node.parentNode)\\n    node = node.parentNode;\\n  if (node.nodeType === 11 || node.nodeType === 9)\\n    return node;\\n}\\nfunction enclosingShadowHost(element) {\\n  while (element.parentElement)\\n    element = element.parentElement;\\n  return parentElementOrShadowHost(element);\\n}\\nfunction closestCrossShadow(element, css) {\\n  while (element) {\\n    const closest = element.closest(css);\\n    if (closest)\\n      return closest;\\n    element = enclosingShadowHost(element);\\n  }\\n}\\nfunction getElementComputedStyle(element, pseudo) {\\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\\n}\\nfunction isElementStyleVisibilityVisible(element, style) {\\n  style = style != null ? style : getElementComputedStyle(element);\\n  if (!style)\\n    return true;\\n  if (Element.prototype.checkVisibility) {\\n    if (!element.checkVisibility({ checkOpacity: false, checkVisibilityCSS: false }))\\n      return false;\\n  } else {\\n    const detailsOrSummary = element.closest(\\\"details,summary\\\");\\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === \\\"DETAILS\\\" && !detailsOrSummary.open)\\n      return false;\\n  }\\n  if (style.visibility !== \\\"visible\\\")\\n    return false;\\n  return true;\\n}\\n\\n// packages/playwright-core/src/server/injected/roleUtils.ts\\nfunction hasExplicitAccessibleName(e) {\\n  return e.hasAttribute(\\\"aria-label\\\") || e.hasAttribute(\\\"aria-labelledby\\\");\\n}\\nvar kAncestorPreventingLandmark = \\\"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\\\";\\nvar kGlobalAriaAttributes = [\\n  \\\"aria-atomic\\\",\\n  \\\"aria-busy\\\",\\n  \\\"aria-controls\\\",\\n  \\\"aria-current\\\",\\n  \\\"aria-describedby\\\",\\n  \\\"aria-details\\\",\\n  \\\"aria-disabled\\\",\\n  \\\"aria-dropeffect\\\",\\n  \\\"aria-errormessage\\\",\\n  \\\"aria-flowto\\\",\\n  \\\"aria-grabbed\\\",\\n  \\\"aria-haspopup\\\",\\n  \\\"aria-hidden\\\",\\n  \\\"aria-invalid\\\",\\n  \\\"aria-keyshortcuts\\\",\\n  \\\"aria-label\\\",\\n  \\\"aria-labelledby\\\",\\n  \\\"aria-live\\\",\\n  \\\"aria-owns\\\",\\n  \\\"aria-relevant\\\",\\n  \\\"aria-roledescription\\\"\\n];\\nfunction hasGlobalAriaAttribute(e) {\\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\\n}\\nvar kImplicitRoleByTagName = {\\n  \\\"A\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"AREA\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"ARTICLE\\\": () => \\\"article\\\",\\n  \\\"ASIDE\\\": () => \\\"complementary\\\",\\n  \\\"BLOCKQUOTE\\\": () => \\\"blockquote\\\",\\n  \\\"BUTTON\\\": () => \\\"button\\\",\\n  \\\"CAPTION\\\": () => \\\"caption\\\",\\n  \\\"CODE\\\": () => \\\"code\\\",\\n  \\\"DATALIST\\\": () => \\\"listbox\\\",\\n  \\\"DD\\\": () => \\\"definition\\\",\\n  \\\"DEL\\\": () => \\\"deletion\\\",\\n  \\\"DETAILS\\\": () => \\\"group\\\",\\n  \\\"DFN\\\": () => \\\"term\\\",\\n  \\\"DIALOG\\\": () => \\\"dialog\\\",\\n  \\\"DT\\\": () => \\\"term\\\",\\n  \\\"EM\\\": () => \\\"emphasis\\\",\\n  \\\"FIELDSET\\\": () => \\\"group\\\",\\n  \\\"FIGURE\\\": () => \\\"figure\\\",\\n  \\\"FOOTER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"contentinfo\\\",\\n  \\\"FORM\\\": (e) => hasExplicitAccessibleName(e) ? \\\"form\\\" : null,\\n  \\\"H1\\\": () => \\\"heading\\\",\\n  \\\"H2\\\": () => \\\"heading\\\",\\n  \\\"H3\\\": () => \\\"heading\\\",\\n  \\\"H4\\\": () => \\\"heading\\\",\\n  \\\"H5\\\": () => \\\"heading\\\",\\n  \\\"H6\\\": () => \\\"heading\\\",\\n  \\\"HEADER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"banner\\\",\\n  \\\"HR\\\": () => \\\"separator\\\",\\n  \\\"HTML\\\": () => \\\"document\\\",\\n  \\\"IMG\\\": (e) => e.getAttribute(\\\"alt\\\") === \\\"\\\" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute(\\\"tabindex\\\")))) ? \\\"presentation\\\" : \\\"img\\\",\\n  \\\"INPUT\\\": (e) => {\\n    const type = e.type.toLowerCase();\\n    if (type === \\\"search\\\")\\n      return e.hasAttribute(\\\"list\\\") ? \\\"combobox\\\" : \\\"searchbox\\\";\\n    if ([\\\"email\\\", \\\"tel\\\", \\\"text\\\", \\\"url\\\", \\\"\\\"].includes(type)) {\\n      const list = getIdRefs(e, e.getAttribute(\\\"list\\\"))[0];\\n      return list && list.tagName === \\\"DATALIST\\\" ? \\\"combobox\\\" : \\\"textbox\\\";\\n    }\\n    if (type === \\\"hidden\\\")\\n      return \\\"\\\";\\n    return {\\n      \\\"button\\\": \\\"button\\\",\\n      \\\"checkbox\\\": \\\"checkbox\\\",\\n      \\\"image\\\": \\\"button\\\",\\n      \\\"number\\\": \\\"spinbutton\\\",\\n      \\\"radio\\\": \\\"radio\\\",\\n      \\\"range\\\": \\\"slider\\\",\\n      \\\"reset\\\": \\\"button\\\",\\n      \\\"submit\\\": \\\"button\\\"\\n    }[type] || \\\"textbox\\\";\\n  },\\n  \\\"INS\\\": () => \\\"insertion\\\",\\n  \\\"LI\\\": () => \\\"listitem\\\",\\n  \\\"MAIN\\\": () => \\\"main\\\",\\n  \\\"MARK\\\": () => \\\"mark\\\",\\n  \\\"MATH\\\": () => \\\"math\\\",\\n  \\\"MENU\\\": () => \\\"list\\\",\\n  \\\"METER\\\": () => \\\"meter\\\",\\n  \\\"NAV\\\": () => \\\"navigation\\\",\\n  \\\"OL\\\": () => \\\"list\\\",\\n  \\\"OPTGROUP\\\": () => \\\"group\\\",\\n  \\\"OPTION\\\": () => \\\"option\\\",\\n  \\\"OUTPUT\\\": () => \\\"status\\\",\\n  \\\"P\\\": () => \\\"paragraph\\\",\\n  \\\"PROGRESS\\\": () => \\\"progressbar\\\",\\n  \\\"SECTION\\\": (e) => hasExplicitAccessibleName(e) ? \\\"region\\\" : null,\\n  \\\"SELECT\\\": (e) => e.hasAttribute(\\\"multiple\\\") || e.size > 1 ? \\\"listbox\\\" : \\\"combobox\\\",\\n  \\\"STRONG\\\": () => \\\"strong\\\",\\n  \\\"SUB\\\": () => \\\"subscript\\\",\\n  \\\"SUP\\\": () => \\\"superscript\\\",\\n  \\\"TABLE\\\": () => \\\"table\\\",\\n  \\\"TBODY\\\": () => \\\"rowgroup\\\",\\n  \\\"TD\\\": (e) => {\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"TEXTAREA\\\": () => \\\"textbox\\\",\\n  \\\"TFOOT\\\": () => \\\"rowgroup\\\",\\n  \\\"TH\\\": (e) => {\\n    if (e.getAttribute(\\\"scope\\\") === \\\"col\\\")\\n      return \\\"columnheader\\\";\\n    if (e.getAttribute(\\\"scope\\\") === \\\"row\\\")\\n      return \\\"rowheader\\\";\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"THEAD\\\": () => \\\"rowgroup\\\",\\n  \\\"TIME\\\": () => \\\"time\\\",\\n  \\\"TR\\\": () => \\\"row\\\",\\n  \\\"UL\\\": () => \\\"list\\\"\\n};\\nvar kPresentationInheritanceParents = {\\n  \\\"DD\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"DIV\\\": [\\\"DL\\\"],\\n  \\\"DT\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"LI\\\": [\\\"OL\\\", \\\"UL\\\"],\\n  \\\"TBODY\\\": [\\\"TABLE\\\"],\\n  \\\"TD\\\": [\\\"TR\\\"],\\n  \\\"TFOOT\\\": [\\\"TABLE\\\"],\\n  \\\"TH\\\": [\\\"TR\\\"],\\n  \\\"THEAD\\\": [\\\"TABLE\\\"],\\n  \\\"TR\\\": [\\\"THEAD\\\", \\\"TBODY\\\", \\\"TFOOT\\\", \\\"TABLE\\\"]\\n};\\nfunction getImplicitAriaRole(element) {\\n  var _a;\\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \\\"\\\";\\n  if (!implicitRole)\\n    return null;\\n  let ancestor = element;\\n  while (ancestor) {\\n    const parent = parentElementOrShadowHost(ancestor);\\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\\n    if (!parents || !parent || !parents.includes(parent.tagName))\\n      break;\\n    const parentExplicitRole = getExplicitAriaRole(parent);\\n    if ((parentExplicitRole === \\\"none\\\" || parentExplicitRole === \\\"presentation\\\") && !hasPresentationConflictResolution(parent))\\n      return parentExplicitRole;\\n    ancestor = parent;\\n  }\\n  return implicitRole;\\n}\\nvar allRoles = [\\n  \\\"alert\\\",\\n  \\\"alertdialog\\\",\\n  \\\"application\\\",\\n  \\\"article\\\",\\n  \\\"banner\\\",\\n  \\\"blockquote\\\",\\n  \\\"button\\\",\\n  \\\"caption\\\",\\n  \\\"cell\\\",\\n  \\\"checkbox\\\",\\n  \\\"code\\\",\\n  \\\"columnheader\\\",\\n  \\\"combobox\\\",\\n  \\\"command\\\",\\n  \\\"complementary\\\",\\n  \\\"composite\\\",\\n  \\\"contentinfo\\\",\\n  \\\"definition\\\",\\n  \\\"deletion\\\",\\n  \\\"dialog\\\",\\n  \\\"directory\\\",\\n  \\\"document\\\",\\n  \\\"emphasis\\\",\\n  \\\"feed\\\",\\n  \\\"figure\\\",\\n  \\\"form\\\",\\n  \\\"generic\\\",\\n  \\\"grid\\\",\\n  \\\"gridcell\\\",\\n  \\\"group\\\",\\n  \\\"heading\\\",\\n  \\\"img\\\",\\n  \\\"input\\\",\\n  \\\"insertion\\\",\\n  \\\"landmark\\\",\\n  \\\"link\\\",\\n  \\\"list\\\",\\n  \\\"listbox\\\",\\n  \\\"listitem\\\",\\n  \\\"log\\\",\\n  \\\"main\\\",\\n  \\\"marquee\\\",\\n  \\\"math\\\",\\n  \\\"meter\\\",\\n  \\\"menu\\\",\\n  \\\"menubar\\\",\\n  \\\"menuitem\\\",\\n  \\\"menuitemcheckbox\\\",\\n  \\\"menuitemradio\\\",\\n  \\\"navigation\\\",\\n  \\\"none\\\",\\n  \\\"note\\\",\\n  \\\"option\\\",\\n  \\\"paragraph\\\",\\n  \\\"presentation\\\",\\n  \\\"progressbar\\\",\\n  \\\"radio\\\",\\n  \\\"radiogroup\\\",\\n  \\\"range\\\",\\n  \\\"region\\\",\\n  \\\"roletype\\\",\\n  \\\"row\\\",\\n  \\\"rowgroup\\\",\\n  \\\"rowheader\\\",\\n  \\\"scrollbar\\\",\\n  \\\"search\\\",\\n  \\\"searchbox\\\",\\n  \\\"section\\\",\\n  \\\"sectionhead\\\",\\n  \\\"select\\\",\\n  \\\"separator\\\",\\n  \\\"slider\\\",\\n  \\\"spinbutton\\\",\\n  \\\"status\\\",\\n  \\\"strong\\\",\\n  \\\"structure\\\",\\n  \\\"subscript\\\",\\n  \\\"superscript\\\",\\n  \\\"switch\\\",\\n  \\\"tab\\\",\\n  \\\"table\\\",\\n  \\\"tablist\\\",\\n  \\\"tabpanel\\\",\\n  \\\"term\\\",\\n  \\\"textbox\\\",\\n  \\\"time\\\",\\n  \\\"timer\\\",\\n  \\\"toolbar\\\",\\n  \\\"tooltip\\\",\\n  \\\"tree\\\",\\n  \\\"treegrid\\\",\\n  \\\"treeitem\\\",\\n  \\\"widget\\\",\\n  \\\"window\\\"\\n];\\nvar abstractRoles = [\\\"command\\\", \\\"composite\\\", \\\"input\\\", \\\"landmark\\\", \\\"range\\\", \\\"roletype\\\", \\\"section\\\", \\\"sectionhead\\\", \\\"select\\\", \\\"structure\\\", \\\"widget\\\", \\\"window\\\"];\\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\\nfunction getExplicitAriaRole(element) {\\n  const roles = (element.getAttribute(\\\"role\\\") || \\\"\\\").split(\\\" \\\").map((role) => role.trim());\\n  return roles.find((role) => validRoles.includes(role)) || null;\\n}\\nfunction hasPresentationConflictResolution(element) {\\n  return !hasGlobalAriaAttribute(element);\\n}\\nfunction getAriaRole(element) {\\n  const explicitRole = getExplicitAriaRole(element);\\n  if (!explicitRole)\\n    return getImplicitAriaRole(element);\\n  if ((explicitRole === \\\"none\\\" || explicitRole === \\\"presentation\\\") && hasPresentationConflictResolution(element))\\n    return getImplicitAriaRole(element);\\n  return explicitRole;\\n}\\nfunction getAriaBoolean(attr) {\\n  return attr === null ? void 0 : attr.toLowerCase() === \\\"true\\\";\\n}\\nfunction isElementHiddenForAria(element, cache) {\\n  if ([\\\"STYLE\\\", \\\"SCRIPT\\\", \\\"NOSCRIPT\\\", \\\"TEMPLATE\\\"].includes(element.tagName))\\n    return true;\\n  const isOptionInsideSelect = element.nodeName === \\\"OPTION\\\" && !!element.closest(\\\"select\\\");\\n  const isSlot = element.nodeName === \\\"SLOT\\\";\\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element))\\n    return true;\\n  return belongsToDisplayNoneOrAriaHidden(element, cache);\\n}\\nfunction belongsToDisplayNoneOrAriaHidden(element, cache) {\\n  if (!cache.has(element)) {\\n    const style = getElementComputedStyle(element);\\n    let hidden = !style || style.display === \\\"none\\\" || getAriaBoolean(element.getAttribute(\\\"aria-hidden\\\")) === true;\\n    if (!hidden) {\\n      const parent = parentElementOrShadowHost(element);\\n      if (parent)\\n        hidden = hidden || belongsToDisplayNoneOrAriaHidden(parent, cache);\\n    }\\n    cache.set(element, hidden);\\n  }\\n  return cache.get(element);\\n}\\nfunction getIdRefs(element, ref) {\\n  if (!ref)\\n    return [];\\n  const root = enclosingShadowRootOrDocument(element);\\n  if (!root)\\n    return [];\\n  try {\\n    const ids = ref.split(\\\" \\\").filter((id) => !!id);\\n    const set = /* @__PURE__ */ new Set();\\n    for (const id of ids) {\\n      const firstElement = root.querySelector(\\\"#\\\" + CSS.escape(id));\\n      if (firstElement)\\n        set.add(firstElement);\\n    }\\n    return [...set];\\n  } catch (e) {\\n    return [];\\n  }\\n}\\nfunction normalizeAccessbileName(s) {\\n  return s.replace(/\\\\r\\\\n/g, \\\"\\\\n\\\").replace(/\\\\u00A0/g, \\\" \\\").replace(/\\\\s\\\\s+/g, \\\" \\\").trim();\\n}\\nfunction queryInAriaOwned(element, selector) {\\n  const result = [...element.querySelectorAll(selector)];\\n  for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\"))) {\\n    if (owned.matches(selector))\\n      result.push(owned);\\n    result.push(...owned.querySelectorAll(selector));\\n  }\\n  return result;\\n}\\nfunction getPseudoContent(pseudoStyle) {\\n  if (!pseudoStyle)\\n    return \\\"\\\";\\n  const content = pseudoStyle.getPropertyValue(\\\"content\\\");\\n  if (content[0] === \\\"'\\\" && content[content.length - 1] === \\\"'\\\" || content[0] === '\\\"' && content[content.length - 1] === '\\\"') {\\n    const unquoted = content.substring(1, content.length - 1);\\n    const display = pseudoStyle.getPropertyValue(\\\"display\\\") || \\\"inline\\\";\\n    if (display !== \\\"inline\\\")\\n      return \\\" \\\" + unquoted + \\\" \\\";\\n    return unquoted;\\n  }\\n  return \\\"\\\";\\n}\\nfunction getAriaLabelledByElements(element) {\\n  const ref = element.getAttribute(\\\"aria-labelledby\\\");\\n  if (ref === null)\\n    return null;\\n  return getIdRefs(element, ref);\\n}\\nfunction allowsNameFromContent(role, targetDescendant) {\\n  const alwaysAllowsNameFromContent = [\\\"button\\\", \\\"cell\\\", \\\"checkbox\\\", \\\"columnheader\\\", \\\"gridcell\\\", \\\"heading\\\", \\\"link\\\", \\\"menuitem\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"option\\\", \\\"radio\\\", \\\"row\\\", \\\"rowheader\\\", \\\"switch\\\", \\\"tab\\\", \\\"tooltip\\\", \\\"treeitem\\\"].includes(role);\\n  const descendantAllowsNameFromContent = targetDescendant && [\\\"\\\", \\\"caption\\\", \\\"code\\\", \\\"contentinfo\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"insertion\\\", \\\"list\\\", \\\"listitem\\\", \\\"mark\\\", \\\"none\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"region\\\", \\\"row\\\", \\\"rowgroup\\\", \\\"section\\\", \\\"strong\\\", \\\"subscript\\\", \\\"superscript\\\", \\\"table\\\", \\\"term\\\", \\\"time\\\"].includes(role);\\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\\n}\\nfunction getElementAccessibleName(element, includeHidden, hiddenCache) {\\n  const elementProhibitsNaming = [\\\"caption\\\", \\\"code\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"generic\\\", \\\"insertion\\\", \\\"mark\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"strong\\\", \\\"subscript\\\", \\\"suggestion\\\", \\\"superscript\\\", \\\"term\\\", \\\"time\\\"].includes(getAriaRole(element) || \\\"\\\");\\n  if (elementProhibitsNaming)\\n    return \\\"\\\";\\n  const accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\\n    includeHidden,\\n    hiddenCache,\\n    visitedElements: /* @__PURE__ */ new Set(),\\n    embeddedInLabelledBy: \\\"none\\\",\\n    embeddedInLabel: \\\"none\\\",\\n    embeddedInTextAlternativeElement: false,\\n    embeddedInTargetElement: \\\"self\\\"\\n  }));\\n  return accessibleName;\\n}\\nfunction getElementAccessibleNameInternal(element, options) {\\n  if (options.visitedElements.has(element))\\n    return \\\"\\\";\\n  const childOptions = {\\n    ...options,\\n    embeddedInLabel: options.embeddedInLabel === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInLabel,\\n    embeddedInLabelledBy: options.embeddedInLabelledBy === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInLabelledBy,\\n    embeddedInTargetElement: options.embeddedInTargetElement === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInTargetElement\\n  };\\n  if (!options.includeHidden && options.embeddedInLabelledBy !== \\\"self\\\" && isElementHiddenForAria(element, options.hiddenCache)) {\\n    options.visitedElements.add(element);\\n    return \\\"\\\";\\n  }\\n  if (options.embeddedInLabelledBy === \\\"none\\\") {\\n    const refs = getAriaLabelledByElements(element) || [];\\n    const accessibleName = refs.map((ref) => getElementAccessibleNameInternal(ref, {\\n      ...options,\\n      embeddedInLabelledBy: \\\"self\\\",\\n      embeddedInTargetElement: \\\"none\\\",\\n      embeddedInLabel: \\\"none\\\",\\n      embeddedInTextAlternativeElement: false\\n    })).join(\\\" \\\");\\n    if (accessibleName)\\n      return accessibleName;\\n  }\\n  const role = getAriaRole(element) || \\\"\\\";\\n  if (options.embeddedInLabel !== \\\"none\\\" || options.embeddedInLabelledBy !== \\\"none\\\") {\\n    const isOwnLabel = [...element.labels || []].includes(element);\\n    const isOwnLabelledBy = getIdRefs(element, element.getAttribute(\\\"aria-labelledby\\\")).includes(element);\\n    if (!isOwnLabel && !isOwnLabelledBy) {\\n      if (role === \\\"textbox\\\") {\\n        options.visitedElements.add(element);\\n        if (element.tagName === \\\"INPUT\\\" || element.tagName === \\\"TEXTAREA\\\")\\n          return element.value;\\n        return element.textContent || \\\"\\\";\\n      }\\n      if ([\\\"combobox\\\", \\\"listbox\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        let selectedOptions;\\n        if (element.tagName === \\\"SELECT\\\") {\\n          selectedOptions = [...element.selectedOptions];\\n          if (!selectedOptions.length && element.options.length)\\n            selectedOptions.push(element.options[0]);\\n        } else {\\n          const listbox = role === \\\"combobox\\\" ? queryInAriaOwned(element, \\\"*\\\").find((e) => getAriaRole(e) === \\\"listbox\\\") : element;\\n          selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\\\"true\\\"]').filter((e) => getAriaRole(e) === \\\"option\\\") : [];\\n        }\\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(\\\" \\\");\\n      }\\n      if ([\\\"progressbar\\\", \\\"scrollbar\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"meter\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        if (element.hasAttribute(\\\"aria-valuetext\\\"))\\n          return element.getAttribute(\\\"aria-valuetext\\\") || \\\"\\\";\\n        if (element.hasAttribute(\\\"aria-valuenow\\\"))\\n          return element.getAttribute(\\\"aria-valuenow\\\") || \\\"\\\";\\n        return element.getAttribute(\\\"value\\\") || \\\"\\\";\\n      }\\n      if ([\\\"menu\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        return \\\"\\\";\\n      }\\n    }\\n  }\\n  const ariaLabel = element.getAttribute(\\\"aria-label\\\") || \\\"\\\";\\n  if (ariaLabel.trim()) {\\n    options.visitedElements.add(element);\\n    return ariaLabel;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role)) {\\n    if (element.tagName === \\\"INPUT\\\" && [\\\"button\\\", \\\"submit\\\", \\\"reset\\\"].includes(element.type)) {\\n      options.visitedElements.add(element);\\n      const value = element.value || \\\"\\\";\\n      if (value.trim())\\n        return value;\\n      if (element.type === \\\"submit\\\")\\n        return \\\"Submit\\\";\\n      if (element.type === \\\"reset\\\")\\n        return \\\"Reset\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"INPUT\\\" && element.type === \\\"image\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const labels = element.labels || [];\\n      if (labels.length) {\\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\\n          ...options,\\n          embeddedInLabel: \\\"self\\\",\\n          embeddedInTextAlternativeElement: false,\\n          embeddedInLabelledBy: \\\"none\\\",\\n          embeddedInTargetElement: \\\"none\\\"\\n        })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (title.trim())\\n        return title;\\n      return \\\"Submit\\\";\\n    }\\n    if (element.tagName === \\\"TEXTAREA\\\" || element.tagName === \\\"SELECT\\\" || element.tagName === \\\"INPUT\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length) {\\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\\n          ...options,\\n          embeddedInLabel: \\\"self\\\",\\n          embeddedInTextAlternativeElement: false,\\n          embeddedInLabelledBy: \\\"none\\\",\\n          embeddedInTargetElement: \\\"none\\\"\\n        })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n      }\\n      const usePlaceholder = element.tagName === \\\"INPUT\\\" && [\\\"text\\\", \\\"password\\\", \\\"search\\\", \\\"tel\\\", \\\"email\\\", \\\"url\\\"].includes(element.type) || element.tagName === \\\"TEXTAREA\\\";\\n      const placeholder = element.getAttribute(\\\"placeholder\\\") || \\\"\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (!usePlaceholder || title)\\n        return title;\\n      return placeholder;\\n    }\\n    if (element.tagName === \\\"FIELDSET\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"LEGEND\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"FIGURE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"FIGCAPTION\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"IMG\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"TABLE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"CAPTION\\\") {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n      const summary = element.getAttribute(\\\"summary\\\") || \\\"\\\";\\n      if (summary)\\n        return summary;\\n    }\\n    if (element.tagName === \\\"AREA\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (alt.trim())\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (element.tagName === \\\"SVG\\\" && element.ownerSVGElement) {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (child.tagName === \\\"TITLE\\\" && element.ownerSVGElement) {\\n          return getElementAccessibleNameInternal(child, {\\n            ...childOptions,\\n            embeddedInTextAlternativeElement: true\\n          });\\n        }\\n      }\\n    }\\n  }\\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === \\\"descendant\\\") || options.embeddedInLabelledBy !== \\\"none\\\" || options.embeddedInLabel !== \\\"none\\\" || options.embeddedInTextAlternativeElement) {\\n    options.visitedElements.add(element);\\n    const tokens = [];\\n    const visit = (node, skipSlotted) => {\\n      var _a;\\n      if (skipSlotted && node.assignedSlot)\\n        return;\\n      if (node.nodeType === 1) {\\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.getPropertyValue(\\\"display\\\")) || \\\"inline\\\";\\n        let token = getElementAccessibleNameInternal(node, childOptions);\\n        if (display !== \\\"inline\\\" || node.nodeName === \\\"BR\\\")\\n          token = \\\" \\\" + token + \\\" \\\";\\n        tokens.push(token);\\n      } else if (node.nodeType === 3) {\\n        tokens.push(node.textContent || \\\"\\\");\\n      }\\n    };\\n    tokens.push(getPseudoContent(getElementComputedStyle(element, \\\"::before\\\")));\\n    const assignedNodes = element.nodeName === \\\"SLOT\\\" ? element.assignedNodes() : [];\\n    if (assignedNodes.length) {\\n      for (const child of assignedNodes)\\n        visit(child, false);\\n    } else {\\n      for (let child = element.firstChild; child; child = child.nextSibling)\\n        visit(child, true);\\n      if (element.shadowRoot) {\\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\\n          visit(child, true);\\n      }\\n      for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\")))\\n        visit(owned, true);\\n    }\\n    tokens.push(getPseudoContent(getElementComputedStyle(element, \\\"::after\\\")));\\n    const accessibleName = tokens.join(\\\"\\\");\\n    if (accessibleName.trim())\\n      return accessibleName;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role) || element.tagName === \\\"IFRAME\\\") {\\n    options.visitedElements.add(element);\\n    const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n    if (title.trim())\\n      return title;\\n  }\\n  options.visitedElements.add(element);\\n  return \\\"\\\";\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorUtils.ts\\nfunction shouldSkipForTextMatching(element) {\\n  return element.nodeName === \\\"SCRIPT\\\" || element.nodeName === \\\"NOSCRIPT\\\" || element.nodeName === \\\"STYLE\\\" || document.head && document.head.contains(element);\\n}\\nfunction elementText(cache, root) {\\n  let value = cache.get(root);\\n  if (value === void 0) {\\n    value = { full: \\\"\\\", immediate: [] };\\n    if (!shouldSkipForTextMatching(root)) {\\n      let currentImmediate = \\\"\\\";\\n      if (root instanceof HTMLInputElement && (root.type === \\\"submit\\\" || root.type === \\\"button\\\")) {\\n        value = { full: root.value, immediate: [root.value] };\\n      } else {\\n        for (let child = root.firstChild; child; child = child.nextSibling) {\\n          if (child.nodeType === Node.TEXT_NODE) {\\n            value.full += child.nodeValue || \\\"\\\";\\n            currentImmediate += child.nodeValue || \\\"\\\";\\n          } else {\\n            if (currentImmediate)\\n              value.immediate.push(currentImmediate);\\n            currentImmediate = \\\"\\\";\\n            if (child.nodeType === Node.ELEMENT_NODE)\\n              value.full += elementText(cache, child).full;\\n          }\\n        }\\n        if (currentImmediate)\\n          value.immediate.push(currentImmediate);\\n        if (root.shadowRoot)\\n          value.full += elementText(cache, root.shadowRoot).full;\\n      }\\n    }\\n    cache.set(root, value);\\n  }\\n  return value;\\n}\\n\\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\\nvar cacheAllowText = /* @__PURE__ */ new Map();\\nvar cacheDisallowText = /* @__PURE__ */ new Map();\\nvar kTextScoreRange = 10;\\nvar kExactPenalty = kTextScoreRange / 2;\\nvar kTestIdScore = 1;\\nvar kOtherTestIdScore = 2;\\nvar kIframeByAttributeScore = 10;\\nvar kBeginPenalizedScore = 50;\\nvar kPlaceholderScore = 100;\\nvar kLabelScore = 120;\\nvar kRoleWithNameScore = 140;\\nvar kAltTextScore = 160;\\nvar kTextScore = 180;\\nvar kTitleScore = 200;\\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\\nvar kTextScoreExact = kTextScore + kExactPenalty;\\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\\nvar kEndPenalizedScore = 300;\\nvar kCSSIdScore = 500;\\nvar kRoleWithoutNameScore = 510;\\nvar kCSSInputTypeNameScore = 520;\\nvar kCSSTagNameScore = 530;\\nvar kNthScore = 1e4;\\nvar kCSSFallbackScore = 1e7;\\nfunction querySelector(injectedScript, selector, ownerDocument) {\\n  try {\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    return {\\n      selector,\\n      elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\\n    };\\n  } catch (e) {\\n    return {\\n      selector,\\n      elements: []\\n    };\\n  }\\n}\\nfunction generateSelector(injectedScript, targetElement, testIdAttributeName) {\\n  injectedScript._evaluator.begin();\\n  try {\\n    targetElement = targetElement.closest(\\\"button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]\\\") || targetElement;\\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, testIdAttributeName);\\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement);\\n    const selector = joinTokens(bestTokens);\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    return {\\n      selector,\\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\\n    };\\n  } finally {\\n    cacheAllowText.clear();\\n    cacheDisallowText.clear();\\n    injectedScript._evaluator.end();\\n  }\\n}\\nfunction filterRegexTokens(textCandidates) {\\n  return textCandidates.filter((c) => c[0].selector[0] !== \\\"/\\\");\\n}\\nfunction generateSelectorFor(injectedScript, targetElement, testIdAttributeName) {\\n  if (targetElement.ownerDocument.documentElement === targetElement)\\n    return [{ engine: \\\"css\\\", selector: \\\"html\\\", score: 1 }];\\n  const accessibleNameCache = /* @__PURE__ */ new Map();\\n  const calculate = (element, allowText) => {\\n    const allowNthMatch = element === targetElement;\\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement, accessibleNameCache) : [];\\n    if (element !== targetElement) {\\n      textCandidates = filterRegexTokens(textCandidates);\\n    }\\n    const noTextCandidates = buildCandidates(injectedScript, element, testIdAttributeName, accessibleNameCache).map((token) => [token]);\\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\\n    textCandidates = filterRegexTokens(textCandidates);\\n    const checkWithText = (textCandidatesToUse) => {\\n      const allowParentText = allowText && !textCandidatesToUse.length;\\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\\n        if (!result)\\n          return true;\\n        return combineScores(c) < combineScores(result);\\n      });\\n      let bestPossibleInParent = candidates[0];\\n      if (!bestPossibleInParent)\\n        return;\\n      for (let parent = parentElementOrShadowHost2(element); parent; parent = parentElementOrShadowHost2(parent)) {\\n        const parentTokens = calculateCached(parent, allowParentText);\\n        if (!parentTokens)\\n          continue;\\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\\n          continue;\\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\\n        if (!bestPossibleInParent)\\n          return;\\n        const combined = [...parentTokens, ...bestPossibleInParent];\\n        if (!result || combineScores(combined) < combineScores(result))\\n          result = combined;\\n      }\\n    };\\n    checkWithText(textCandidates);\\n    if (element === targetElement && textCandidates.length)\\n      checkWithText([]);\\n    return result;\\n  };\\n  const calculateCached = (element, allowText) => {\\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\\n    let value = cache.get(element);\\n    if (value === void 0) {\\n      value = calculate(element, allowText);\\n      cache.set(element, value);\\n    }\\n    return value;\\n  };\\n  return calculateCached(targetElement, true);\\n}\\nfunction buildCandidates(injectedScript, element, testIdAttributeName, accessibleNameCache) {\\n  var _a;\\n  const candidates = [];\\n  for (const attr of [\\\"data-testid\\\", \\\"data-test-id\\\", \\\"data-test\\\"]) {\\n    if (attr !== testIdAttributeName && element.getAttribute(attr))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${attr}=${quoteAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\\n  }\\n  const idAttr = element.getAttribute(\\\"id\\\");\\n  if (idAttr && !isGuidLike(idAttr))\\n    candidates.push({ engine: \\\"css\\\", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\\n  candidates.push({ engine: \\\"css\\\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\\n  if (element.nodeName === \\\"IFRAME\\\") {\\n    for (const attribute of [\\\"name\\\", \\\"title\\\"]) {\\n      if (element.getAttribute(attribute))\\n        candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\\n    }\\n    if (element.getAttribute(testIdAttributeName))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(testIdAttributeName), true)}]`, score: kTestIdScore });\\n    penalizeScoreForLength([candidates]);\\n    return candidates;\\n  }\\n  if (element.getAttribute(testIdAttributeName))\\n    candidates.push({ engine: \\\"internal:testid\\\", selector: `[${testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(testIdAttributeName), true)}]`, score: kTestIdScore });\\n  if (element.nodeName === \\\"INPUT\\\" || element.nodeName === \\\"TEXTAREA\\\") {\\n    const input = element;\\n    if (input.placeholder) {\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, false)}]`, score: kPlaceholderScore });\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\\n    }\\n    const label = (_a = input.labels) == null ? void 0 : _a[0];\\n    if (label) {\\n      const labelText = elementText(injectedScript._evaluator._cacheText, label).full.trim();\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, false), score: kLabelScore });\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\\n    }\\n  }\\n  const ariaRole = getAriaRole(element);\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false, accessibleNameCache);\\n    if (ariaName) {\\n      candidates.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore });\\n      candidates.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact });\\n    } else {\\n      candidates.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n    }\\n  }\\n  if (element.getAttribute(\\\"alt\\\") && [\\\"APPLET\\\", \\\"AREA\\\", \\\"IMG\\\", \\\"INPUT\\\"].includes(element.nodeName)) {\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(element.getAttribute(\\\"alt\\\"), false)}]`, score: kAltTextScore });\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(element.getAttribute(\\\"alt\\\"), true)}]`, score: kAltTextScoreExact });\\n  }\\n  if (element.getAttribute(\\\"name\\\") && [\\\"BUTTON\\\", \\\"FORM\\\", \\\"FIELDSET\\\", \\\"FRAME\\\", \\\"IFRAME\\\", \\\"INPUT\\\", \\\"KEYGEN\\\", \\\"OBJECT\\\", \\\"OUTPUT\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\", \\\"MAP\\\", \\\"META\\\", \\\"PARAM\\\"].includes(element.nodeName))\\n    candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute(\\\"name\\\"))}]`, score: kCSSInputTypeNameScore });\\n  if (element.getAttribute(\\\"title\\\")) {\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(element.getAttribute(\\\"title\\\"), false)}]`, score: kTitleScore });\\n    candidates.push({ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(element.getAttribute(\\\"title\\\"), true)}]`, score: kTitleScoreExact });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\") {\\n    if (element.getAttribute(\\\"type\\\"))\\n      candidates.push({ engine: \\\"css\\\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute(\\\"type\\\"))}]`, score: kCSSInputTypeNameScore });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\", \\\"SELECT\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\")\\n    candidates.push({ engine: \\\"css\\\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\\n  penalizeScoreForLength([candidates]);\\n  return candidates;\\n}\\nfunction buildTextCandidates(injectedScript, element, isTargetNode, accessibleNameCache) {\\n  if (element.nodeName === \\\"SELECT\\\")\\n    return [];\\n  const text = normalizeWhiteSpace(elementText(injectedScript._evaluator._cacheText, element).full).substring(0, 80);\\n  if (!text)\\n    return [];\\n  const candidates = [];\\n  const escaped = escapeForTextSelector(text, false);\\n  const exactEscaped = escapeForTextSelector(text, true);\\n  if (isTargetNode) {\\n    candidates.push([{ engine: \\\"internal:text\\\", selector: escaped, score: kTextScore }]);\\n    candidates.push([{ engine: \\\"internal:text\\\", selector: exactEscaped, score: kTextScoreExact }]);\\n  }\\n  const ariaRole = getAriaRole(element);\\n  const candidate = [];\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false, accessibleNameCache);\\n    if (ariaName) {\\n      candidate.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore });\\n      candidate.push({ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact });\\n    } else {\\n      candidate.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n    }\\n  } else {\\n    candidate.push({ engine: \\\"css\\\", selector: element.nodeName.toLowerCase(), score: kCSSTagNameScore });\\n  }\\n  candidates.push([...candidate, { engine: \\\"internal:has-text\\\", selector: escaped, score: kTextScore }]);\\n  candidates.push([...candidate, { engine: \\\"internal:has-text\\\", selector: exactEscaped, score: kTextScoreExact }]);\\n  penalizeScoreForLength(candidates);\\n  return candidates;\\n}\\nfunction parentElementOrShadowHost2(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return null;\\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\\n    return element.parentNode.host;\\n  return null;\\n}\\nfunction makeSelectorForId(id) {\\n  return /^[a-zA-Z][a-zA-Z0-9\\\\-\\\\_]+$/.test(id) ? \\\"#\\\" + id : `[id=\\\"${cssEscape(id)}\\\"]`;\\n}\\nfunction cssFallback(injectedScript, targetElement) {\\n  const root = targetElement.ownerDocument;\\n  const tokens = [];\\n  function uniqueCSSSelector(prefix) {\\n    const path = tokens.slice();\\n    if (prefix)\\n      path.unshift(prefix);\\n    const selector = path.join(\\\" > \\\");\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\\n    return node === targetElement ? selector : void 0;\\n  }\\n  function makeStrict(selector) {\\n    const token = { engine: \\\"css\\\", selector, score: kCSSFallbackScore };\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\\n    if (elements.length === 1)\\n      return [token];\\n    const nth = { engine: \\\"nth\\\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\\n    return [token, nth];\\n  }\\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost2(element)) {\\n    const nodeName = element.nodeName.toLowerCase();\\n    let bestTokenForLevel = \\\"\\\";\\n    if (element.id) {\\n      const token = makeSelectorForId(element.id);\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      bestTokenForLevel = token;\\n    }\\n    const parent = element.parentNode;\\n    const classes = [...element.classList];\\n    for (let i = 0; i < classes.length; ++i) {\\n      const token = \\\".\\\" + cssEscape(classes.slice(0, i + 1).join(\\\".\\\"));\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel && parent) {\\n        const sameClassSiblings = parent.querySelectorAll(token);\\n        if (sameClassSiblings.length === 1)\\n          bestTokenForLevel = token;\\n      }\\n    }\\n    if (parent) {\\n      const siblings = [...parent.children];\\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel)\\n        bestTokenForLevel = token;\\n    } else if (!bestTokenForLevel) {\\n      bestTokenForLevel = nodeName;\\n    }\\n    tokens.unshift(bestTokenForLevel);\\n  }\\n  return makeStrict(uniqueCSSSelector());\\n}\\nfunction quoteAttributeValue(text) {\\n  return `\\\"${cssEscape(text).replace(/\\\\\\\\ /g, \\\" \\\")}\\\"`;\\n}\\nfunction penalizeScoreForLength(groups) {\\n  for (const group of groups) {\\n    for (const token of group) {\\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\\n    }\\n  }\\n}\\nfunction joinTokens(tokens) {\\n  const parts = [];\\n  let lastEngine = \\\"\\\";\\n  for (const { engine, selector } of tokens) {\\n    if (parts.length && (lastEngine !== \\\"css\\\" || engine !== \\\"css\\\" || selector.startsWith(\\\":nth-match(\\\")))\\n      parts.push(\\\">>\\\");\\n    lastEngine = engine;\\n    if (engine === \\\"css\\\")\\n      parts.push(selector);\\n    else\\n      parts.push(`${engine}=${selector}`);\\n  }\\n  return parts.join(\\\" \\\");\\n}\\nfunction combineScores(tokens) {\\n  let score = 0;\\n  for (let i = 0; i < tokens.length; i++)\\n    score += tokens[i].score * (tokens.length - i);\\n  return score;\\n}\\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\\n  joined.sort((a, b) => a.score - b.score);\\n  let bestWithIndex = null;\\n  for (const { tokens } of joined) {\\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\\n    if (result[0] === targetElement && result.length === 1) {\\n      return tokens;\\n    }\\n    const index = result.indexOf(targetElement);\\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\\n      continue;\\n    const nth = { engine: \\\"nth\\\", selector: String(index), score: kNthScore };\\n    bestWithIndex = [...tokens, nth];\\n  }\\n  return bestWithIndex;\\n}\\nfunction isGuidLike(id) {\\n  let lastCharacterType;\\n  let transitionCount = 0;\\n  for (let i = 0; i < id.length; ++i) {\\n    const c = id[i];\\n    let characterType;\\n    if (c === \\\"-\\\" || c === \\\"_\\\")\\n      continue;\\n    if (c >= \\\"a\\\" && c <= \\\"z\\\")\\n      characterType = \\\"lower\\\";\\n    else if (c >= \\\"A\\\" && c <= \\\"Z\\\")\\n      characterType = \\\"upper\\\";\\n    else if (c >= \\\"0\\\" && c <= \\\"9\\\")\\n      characterType = \\\"digit\\\";\\n    else\\n      characterType = \\\"other\\\";\\n    if (characterType === \\\"lower\\\" && lastCharacterType === \\\"upper\\\") {\\n      lastCharacterType = characterType;\\n      continue;\\n    }\\n    if (lastCharacterType && lastCharacterType !== characterType)\\n      ++transitionCount;\\n    lastCharacterType = characterType;\\n  }\\n  return transitionCount >= id.length / 4;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.ts\\nvar between = function(num, first, last) {\\n  return num >= first && num <= last;\\n};\\nfunction digit(code) {\\n  return between(code, 48, 57);\\n}\\nfunction hexdigit(code) {\\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\\n}\\nfunction uppercaseletter(code) {\\n  return between(code, 65, 90);\\n}\\nfunction lowercaseletter(code) {\\n  return between(code, 97, 122);\\n}\\nfunction letter(code) {\\n  return uppercaseletter(code) || lowercaseletter(code);\\n}\\nfunction nonascii(code) {\\n  return code >= 128;\\n}\\nfunction namestartchar(code) {\\n  return letter(code) || nonascii(code) || code === 95;\\n}\\nfunction namechar(code) {\\n  return namestartchar(code) || digit(code) || code === 45;\\n}\\nfunction nonprintable(code) {\\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\\n}\\nfunction newline(code) {\\n  return code === 10;\\n}\\nfunction whitespace(code) {\\n  return newline(code) || code === 9 || code === 32;\\n}\\nvar maximumallowedcodepoint = 1114111;\\nvar InvalidCharacterError = class extends Error {\\n  constructor(message) {\\n    super(message);\\n    this.name = \\\"InvalidCharacterError\\\";\\n  }\\n};\\nfunction preprocess(str) {\\n  const codepoints = [];\\n  for (let i = 0; i < str.length; i++) {\\n    let code = str.charCodeAt(i);\\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\\n      code = 10;\\n      i++;\\n    }\\n    if (code === 13 || code === 12)\\n      code = 10;\\n    if (code === 0)\\n      code = 65533;\\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\\n      const lead = code - 55296;\\n      const trail = str.charCodeAt(i + 1) - 56320;\\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\\n      i++;\\n    }\\n    codepoints.push(code);\\n  }\\n  return codepoints;\\n}\\nfunction stringFromCode(code) {\\n  if (code <= 65535)\\n    return String.fromCharCode(code);\\n  code -= Math.pow(2, 16);\\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\\n  const trail = code % Math.pow(2, 10) + 56320;\\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\\n}\\nfunction tokenize(str1) {\\n  const str = preprocess(str1);\\n  let i = -1;\\n  const tokens = [];\\n  let code;\\n  let line = 0;\\n  let column = 0;\\n  let lastLineLength = 0;\\n  const incrLineno = function() {\\n    line += 1;\\n    lastLineLength = column;\\n    column = 0;\\n  };\\n  const locStart = { line, column };\\n  const codepoint = function(i2) {\\n    if (i2 >= str.length)\\n      return -1;\\n    return str[i2];\\n  };\\n  const next = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    if (num > 3)\\n      throw \\\"Spec Error: no more than three codepoints of lookahead.\\\";\\n    return codepoint(i + num);\\n  };\\n  const consume = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    i += num;\\n    code = codepoint(i);\\n    if (newline(code))\\n      incrLineno();\\n    else\\n      column += num;\\n    return true;\\n  };\\n  const reconsume = function() {\\n    i -= 1;\\n    if (newline(code)) {\\n      line -= 1;\\n      column = lastLineLength;\\n    } else {\\n      column -= 1;\\n    }\\n    locStart.line = line;\\n    locStart.column = column;\\n    return true;\\n  };\\n  const eof = function(codepoint2) {\\n    if (codepoint2 === void 0)\\n      codepoint2 = code;\\n    return codepoint2 === -1;\\n  };\\n  const donothing = function() {\\n  };\\n  const parseerror = function() {\\n  };\\n  const consumeAToken = function() {\\n    consumeComments();\\n    consume();\\n    if (whitespace(code)) {\\n      while (whitespace(next()))\\n        consume();\\n      return new WhitespaceToken();\\n    } else if (code === 34) {\\n      return consumeAStringToken();\\n    } else if (code === 35) {\\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\\n        const token = new HashToken(\\\"\\\");\\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n          token.type = \\\"id\\\";\\n        token.value = consumeAName();\\n        return token;\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 36) {\\n      if (next() === 61) {\\n        consume();\\n        return new SuffixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 39) {\\n      return consumeAStringToken();\\n    } else if (code === 40) {\\n      return new OpenParenToken();\\n    } else if (code === 41) {\\n      return new CloseParenToken();\\n    } else if (code === 42) {\\n      if (next() === 61) {\\n        consume();\\n        return new SubstringMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 43) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 44) {\\n      return new CommaToken();\\n    } else if (code === 45) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else if (next(1) === 45 && next(2) === 62) {\\n        consume(2);\\n        return new CDCToken();\\n      } else if (startsWithAnIdentifier()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 46) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 58) {\\n      return new ColonToken();\\n    } else if (code === 59) {\\n      return new SemicolonToken();\\n    } else if (code === 60) {\\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\\n        consume(3);\\n        return new CDOToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 64) {\\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n        return new AtKeywordToken(consumeAName());\\n      else\\n        return new DelimToken(code);\\n    } else if (code === 91) {\\n      return new OpenSquareToken();\\n    } else if (code === 92) {\\n      if (startsWithAValidEscape()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        parseerror();\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 93) {\\n      return new CloseSquareToken();\\n    } else if (code === 94) {\\n      if (next() === 61) {\\n        consume();\\n        return new PrefixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 123) {\\n      return new OpenCurlyToken();\\n    } else if (code === 124) {\\n      if (next() === 61) {\\n        consume();\\n        return new DashMatchToken();\\n      } else if (next() === 124) {\\n        consume();\\n        return new ColumnToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 125) {\\n      return new CloseCurlyToken();\\n    } else if (code === 126) {\\n      if (next() === 61) {\\n        consume();\\n        return new IncludeMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (digit(code)) {\\n      reconsume();\\n      return consumeANumericToken();\\n    } else if (namestartchar(code)) {\\n      reconsume();\\n      return consumeAnIdentlikeToken();\\n    } else if (eof()) {\\n      return new EOFToken();\\n    } else {\\n      return new DelimToken(code);\\n    }\\n  };\\n  const consumeComments = function() {\\n    while (next(1) === 47 && next(2) === 42) {\\n      consume(2);\\n      while (true) {\\n        consume();\\n        if (code === 42 && next() === 47) {\\n          consume();\\n          break;\\n        } else if (eof()) {\\n          parseerror();\\n          return;\\n        }\\n      }\\n    }\\n  };\\n  const consumeANumericToken = function() {\\n    const num = consumeANumber();\\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\\n      const token = new DimensionToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      token.unit = consumeAName();\\n      return token;\\n    } else if (next() === 37) {\\n      consume();\\n      const token = new PercentageToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      return token;\\n    } else {\\n      const token = new NumberToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      return token;\\n    }\\n  };\\n  const consumeAnIdentlikeToken = function() {\\n    const str2 = consumeAName();\\n    if (str2.toLowerCase() === \\\"url\\\" && next() === 40) {\\n      consume();\\n      while (whitespace(next(1)) && whitespace(next(2)))\\n        consume();\\n      if (next() === 34 || next() === 39)\\n        return new FunctionToken(str2);\\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\\n        return new FunctionToken(str2);\\n      else\\n        return consumeAURLToken();\\n    } else if (next() === 40) {\\n      consume();\\n      return new FunctionToken(str2);\\n    } else {\\n      return new IdentToken(str2);\\n    }\\n  };\\n  const consumeAStringToken = function(endingCodePoint) {\\n    if (endingCodePoint === void 0)\\n      endingCodePoint = code;\\n    let string = \\\"\\\";\\n    while (consume()) {\\n      if (code === endingCodePoint || eof()) {\\n        return new StringToken(string);\\n      } else if (newline(code)) {\\n        parseerror();\\n        reconsume();\\n        return new BadStringToken();\\n      } else if (code === 92) {\\n        if (eof(next()))\\n          donothing();\\n        else if (newline(next()))\\n          consume();\\n        else\\n          string += stringFromCode(consumeEscape());\\n      } else {\\n        string += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeAURLToken = function() {\\n    const token = new URLToken(\\\"\\\");\\n    while (whitespace(next()))\\n      consume();\\n    if (eof(next()))\\n      return token;\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return token;\\n      } else if (whitespace(code)) {\\n        while (whitespace(next()))\\n          consume();\\n        if (next() === 41 || eof(next())) {\\n          consume();\\n          return token;\\n        } else {\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\\n        parseerror();\\n        consumeTheRemnantsOfABadURL();\\n        return new BadURLToken();\\n      } else if (code === 92) {\\n        if (startsWithAValidEscape()) {\\n          token.value += stringFromCode(consumeEscape());\\n        } else {\\n          parseerror();\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else {\\n        token.value += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeEscape = function() {\\n    consume();\\n    if (hexdigit(code)) {\\n      const digits = [code];\\n      for (let total = 0; total < 5; total++) {\\n        if (hexdigit(next())) {\\n          consume();\\n          digits.push(code);\\n        } else {\\n          break;\\n        }\\n      }\\n      if (whitespace(next()))\\n        consume();\\n      let value = parseInt(digits.map(function(x) {\\n        return String.fromCharCode(x);\\n      }).join(\\\"\\\"), 16);\\n      if (value > maximumallowedcodepoint)\\n        value = 65533;\\n      return value;\\n    } else if (eof()) {\\n      return 65533;\\n    } else {\\n      return code;\\n    }\\n  };\\n  const areAValidEscape = function(c1, c2) {\\n    if (c1 !== 92)\\n      return false;\\n    if (newline(c2))\\n      return false;\\n    return true;\\n  };\\n  const startsWithAValidEscape = function() {\\n    return areAValidEscape(code, next());\\n  };\\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\\n    if (c1 === 45)\\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\\n    else if (namestartchar(c1))\\n      return true;\\n    else if (c1 === 92)\\n      return areAValidEscape(c1, c2);\\n    else\\n      return false;\\n  };\\n  const startsWithAnIdentifier = function() {\\n    return wouldStartAnIdentifier(code, next(1), next(2));\\n  };\\n  const wouldStartANumber = function(c1, c2, c3) {\\n    if (c1 === 43 || c1 === 45) {\\n      if (digit(c2))\\n        return true;\\n      if (c2 === 46 && digit(c3))\\n        return true;\\n      return false;\\n    } else if (c1 === 46) {\\n      if (digit(c2))\\n        return true;\\n      return false;\\n    } else if (digit(c1)) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  };\\n  const startsWithANumber = function() {\\n    return wouldStartANumber(code, next(1), next(2));\\n  };\\n  const consumeAName = function() {\\n    let result = \\\"\\\";\\n    while (consume()) {\\n      if (namechar(code)) {\\n        result += stringFromCode(code);\\n      } else if (startsWithAValidEscape()) {\\n        result += stringFromCode(consumeEscape());\\n      } else {\\n        reconsume();\\n        return result;\\n      }\\n    }\\n    throw new Error(\\\"Internal parse error\\\");\\n  };\\n  const consumeANumber = function() {\\n    let repr = \\\"\\\";\\n    let type = \\\"integer\\\";\\n    if (next() === 43 || next() === 45) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    while (digit(next())) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    if (next(1) === 46 && digit(next(2))) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const c1 = next(1), c2 = next(2), c3 = next(3);\\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const value = convertAStringToANumber(repr);\\n    return { type, value, repr };\\n  };\\n  const convertAStringToANumber = function(string) {\\n    return +string;\\n  };\\n  const consumeTheRemnantsOfABadURL = function() {\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return;\\n      } else if (startsWithAValidEscape()) {\\n        consumeEscape();\\n        donothing();\\n      } else {\\n        donothing();\\n      }\\n    }\\n  };\\n  let iterationCount = 0;\\n  while (!eof(next())) {\\n    tokens.push(consumeAToken());\\n    iterationCount++;\\n    if (iterationCount > str.length * 2)\\n      throw new Error(\\\"I'm infinite-looping!\\\");\\n  }\\n  return tokens;\\n}\\nvar CSSParserToken = class {\\n  constructor() {\\n    this.tokenType = \\\"\\\";\\n  }\\n  toJSON() {\\n    return { token: this.tokenType };\\n  }\\n  toString() {\\n    return this.tokenType;\\n  }\\n  toSource() {\\n    return \\\"\\\" + this;\\n  }\\n};\\nvar BadStringToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADSTRING\\\";\\n  }\\n};\\nvar BadURLToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADURL\\\";\\n  }\\n};\\nvar WhitespaceToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"WHITESPACE\\\";\\n  }\\n  toString() {\\n    return \\\"WS\\\";\\n  }\\n  toSource() {\\n    return \\\" \\\";\\n  }\\n};\\nvar CDOToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDO\\\";\\n  }\\n  toSource() {\\n    return \\\"<!--\\\";\\n  }\\n};\\nvar CDCToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDC\\\";\\n  }\\n  toSource() {\\n    return \\\"-->\\\";\\n  }\\n};\\nvar ColonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\":\\\";\\n  }\\n};\\nvar SemicolonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\";\\\";\\n  }\\n};\\nvar CommaToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\",\\\";\\n  }\\n};\\nvar GroupingToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n    this.mirror = \\\"\\\";\\n  }\\n};\\nvar OpenCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"{\\\";\\n    this.value = \\\"{\\\";\\n    this.mirror = \\\"}\\\";\\n  }\\n};\\nvar CloseCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"}\\\";\\n    this.value = \\\"}\\\";\\n    this.mirror = \\\"{\\\";\\n  }\\n};\\nvar OpenSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"[\\\";\\n    this.value = \\\"[\\\";\\n    this.mirror = \\\"]\\\";\\n  }\\n};\\nvar CloseSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"]\\\";\\n    this.value = \\\"]\\\";\\n    this.mirror = \\\"[\\\";\\n  }\\n};\\nvar OpenParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"(\\\";\\n    this.value = \\\"(\\\";\\n    this.mirror = \\\")\\\";\\n  }\\n};\\nvar CloseParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\")\\\";\\n    this.value = \\\")\\\";\\n    this.mirror = \\\"(\\\";\\n  }\\n};\\nvar IncludeMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"~=\\\";\\n  }\\n};\\nvar DashMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"|=\\\";\\n  }\\n};\\nvar PrefixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"^=\\\";\\n  }\\n};\\nvar SuffixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"$=\\\";\\n  }\\n};\\nvar SubstringMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"*=\\\";\\n  }\\n};\\nvar ColumnToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"||\\\";\\n  }\\n};\\nvar EOFToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"EOF\\\";\\n  }\\n  toSource() {\\n    return \\\"\\\";\\n  }\\n};\\nvar DelimToken = class extends CSSParserToken {\\n  constructor(code) {\\n    super();\\n    this.tokenType = \\\"DELIM\\\";\\n    this.value = \\\"\\\";\\n    this.value = stringFromCode(code);\\n  }\\n  toString() {\\n    return \\\"DELIM(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.value === \\\"\\\\\\\\\\\")\\n      return \\\"\\\\\\\\\\\\n\\\";\\n    else\\n      return this.value;\\n  }\\n};\\nvar StringValuedToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n  }\\n  ASCIIMatch(str) {\\n    return this.value.toLowerCase() === str.toLowerCase();\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n};\\nvar IdentToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"IDENT\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"IDENT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value);\\n  }\\n};\\nvar FunctionToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"FUNCTION\\\";\\n    this.value = val;\\n    this.mirror = \\\")\\\";\\n  }\\n  toString() {\\n    return \\\"FUNCTION(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value) + \\\"(\\\";\\n  }\\n};\\nvar AtKeywordToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"AT-KEYWORD\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"AT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return \\\"@\\\" + escapeIdent(this.value);\\n  }\\n};\\nvar HashToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"HASH\\\";\\n    this.value = val;\\n    this.type = \\\"unrestricted\\\";\\n  }\\n  toString() {\\n    return \\\"HASH(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.type === \\\"id\\\")\\n      return \\\"#\\\" + escapeIdent(this.value);\\n    else\\n      return \\\"#\\\" + escapeHash(this.value);\\n  }\\n};\\nvar StringToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"STRING\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return '\\\"' + escapeString(this.value) + '\\\"';\\n  }\\n};\\nvar URLToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"URL\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"URL(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return 'url(\\\"' + escapeString(this.value) + '\\\")';\\n  }\\n};\\nvar NumberToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"NUMBER\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    if (this.type === \\\"integer\\\")\\n      return \\\"INT(\\\" + this.value + \\\")\\\";\\n    return \\\"NUMBER(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = super.toJSON();\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr;\\n  }\\n};\\nvar PercentageToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"PERCENTAGE\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"PERCENTAGE(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr + \\\"%\\\";\\n  }\\n};\\nvar DimensionToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"DIMENSION\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n    this.unit = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"DIM(\\\" + this.value + \\\",\\\" + this.unit + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    json.unit = this.unit;\\n    return json;\\n  }\\n  toSource() {\\n    const source = this.repr;\\n    let unit = escapeIdent(this.unit);\\n    if (unit[0].toLowerCase() === \\\"e\\\" && (unit[1] === \\\"-\\\" || between(unit.charCodeAt(1), 48, 57))) {\\n      unit = \\\"\\\\\\\\65 \\\" + unit.slice(1, unit.length);\\n    }\\n    return source + unit;\\n  }\\n};\\nfunction escapeIdent(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  const firstcode = string.charCodeAt(0);\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n  }\\n  return result;\\n}\\nfunction escapeHash(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n  }\\n  return result;\\n}\\nfunction escapeString(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code === 34 || code === 92)\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n    else\\n      result += string[i];\\n  }\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\\nvar InvalidSelectorError = class extends Error {\\n};\\nfunction parseCSS(selector, customNames) {\\n  let tokens;\\n  try {\\n    tokens = tokenize(selector);\\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\\n      tokens.push(new EOFToken());\\n  } catch (e) {\\n    const newMessage = e.message + ` while parsing selector \\\"${selector}\\\"`;\\n    const index = (e.stack || \\\"\\\").indexOf(e.message);\\n    if (index !== -1)\\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\\n    e.message = newMessage;\\n    throw e;\\n  }\\n  const unsupportedToken = tokens.find((token) => {\\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || token instanceof URLToken || token instanceof PercentageToken;\\n  });\\n  if (unsupportedToken)\\n    throw new InvalidSelectorError(`Unsupported token \\\"${unsupportedToken.toSource()}\\\" while parsing selector \\\"${selector}\\\"`);\\n  let pos = 0;\\n  const names = /* @__PURE__ */ new Set();\\n  function unexpected() {\\n    return new InvalidSelectorError(`Unexpected token \\\"${tokens[pos].toSource()}\\\" while parsing selector \\\"${selector}\\\"`);\\n  }\\n  function skipWhitespace() {\\n    while (tokens[pos] instanceof WhitespaceToken)\\n      pos++;\\n  }\\n  function isIdent(p = pos) {\\n    return tokens[p] instanceof IdentToken;\\n  }\\n  function isString(p = pos) {\\n    return tokens[p] instanceof StringToken;\\n  }\\n  function isNumber(p = pos) {\\n    return tokens[p] instanceof NumberToken;\\n  }\\n  function isComma(p = pos) {\\n    return tokens[p] instanceof CommaToken;\\n  }\\n  function isCloseParen(p = pos) {\\n    return tokens[p] instanceof CloseParenToken;\\n  }\\n  function isStar(p = pos) {\\n    return tokens[p] instanceof DelimToken && tokens[p].value === \\\"*\\\";\\n  }\\n  function isEOF(p = pos) {\\n    return tokens[p] instanceof EOFToken;\\n  }\\n  function isClauseCombinator(p = pos) {\\n    return tokens[p] instanceof DelimToken && [\\\">\\\", \\\"+\\\", \\\"~\\\"].includes(tokens[p].value);\\n  }\\n  function isSelectorClauseEnd(p = pos) {\\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\\n  }\\n  function consumeFunctionArguments() {\\n    const result2 = [consumeArgument()];\\n    while (true) {\\n      skipWhitespace();\\n      if (!isComma())\\n        break;\\n      pos++;\\n      result2.push(consumeArgument());\\n    }\\n    return result2;\\n  }\\n  function consumeArgument() {\\n    skipWhitespace();\\n    if (isNumber())\\n      return tokens[pos++].value;\\n    if (isString())\\n      return tokens[pos++].value;\\n    return consumeComplexSelector();\\n  }\\n  function consumeComplexSelector() {\\n    const result2 = { simples: [] };\\n    skipWhitespace();\\n    if (isClauseCombinator()) {\\n      result2.simples.push({ selector: { functions: [{ name: \\\"scope\\\", args: [] }] }, combinator: \\\"\\\" });\\n    } else {\\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: \\\"\\\" });\\n    }\\n    while (true) {\\n      skipWhitespace();\\n      if (isClauseCombinator()) {\\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\\n        skipWhitespace();\\n      } else if (isSelectorClauseEnd()) {\\n        break;\\n      }\\n      result2.simples.push({ combinator: \\\"\\\", selector: consumeSimpleSelector() });\\n    }\\n    return result2;\\n  }\\n  function consumeSimpleSelector() {\\n    let rawCSSString = \\\"\\\";\\n    const functions = [];\\n    while (!isSelectorClauseEnd()) {\\n      if (isIdent() || isStar()) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof HashToken) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === \\\".\\\") {\\n        pos++;\\n        if (isIdent())\\n          rawCSSString += \\\".\\\" + tokens[pos++].toSource();\\n        else\\n          throw unexpected();\\n      } else if (tokens[pos] instanceof ColonToken) {\\n        pos++;\\n        if (isIdent()) {\\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\\n            rawCSSString += \\\":\\\" + tokens[pos++].toSource();\\n          } else {\\n            const name = tokens[pos++].value.toLowerCase();\\n            functions.push({ name, args: [] });\\n            names.add(name);\\n          }\\n        } else if (tokens[pos] instanceof FunctionToken) {\\n          const name = tokens[pos++].value.toLowerCase();\\n          if (!customNames.has(name)) {\\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\\n          } else {\\n            functions.push({ name, args: consumeFunctionArguments() });\\n            names.add(name);\\n          }\\n          skipWhitespace();\\n          if (!isCloseParen())\\n            throw unexpected();\\n          pos++;\\n        } else {\\n          throw unexpected();\\n        }\\n      } else if (tokens[pos] instanceof OpenSquareToken) {\\n        rawCSSString += \\\"[\\\";\\n        pos++;\\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\\n          rawCSSString += tokens[pos++].toSource();\\n        if (!(tokens[pos] instanceof CloseSquareToken))\\n          throw unexpected();\\n        rawCSSString += \\\"]\\\";\\n        pos++;\\n      } else {\\n        throw unexpected();\\n      }\\n    }\\n    if (!rawCSSString && !functions.length)\\n      throw unexpected();\\n    return { css: rawCSSString || void 0, functions };\\n  }\\n  function consumeBuiltinFunctionArguments() {\\n    let s = \\\"\\\";\\n    while (!isCloseParen() && !isEOF())\\n      s += tokens[pos++].toSource();\\n    return s;\\n  }\\n  const result = consumeFunctionArguments();\\n  if (!isEOF())\\n    throw new InvalidSelectorError(`Error while parsing selector \\\"${selector}\\\"`);\\n  if (result.some((arg) => typeof arg !== \\\"object\\\" || !(\\\"simples\\\" in arg)))\\n    throw new InvalidSelectorError(`Error while parsing selector \\\"${selector}\\\"`);\\n  return { selector: result, names: Array.from(names) };\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/selectorParser.ts\\nvar kNestedSelectorNames = /* @__PURE__ */ new Set([\\\"internal:has\\\", \\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set([\\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar customCSSNames = /* @__PURE__ */ new Set([\\\"not\\\", \\\"is\\\", \\\"where\\\", \\\"has\\\", \\\"scope\\\", \\\"light\\\", \\\"visible\\\", \\\"text\\\", \\\"text-matches\\\", \\\"text-is\\\", \\\"has-text\\\", \\\"above\\\", \\\"below\\\", \\\"right-of\\\", \\\"left-of\\\", \\\"near\\\", \\\"nth-match\\\"]);\\nfunction parseSelector(selector) {\\n  const result = parseSelectorString(selector);\\n  const parts = result.parts.map((part) => {\\n    if (part.name === \\\"css\\\" || part.name === \\\"css:light\\\") {\\n      if (part.name === \\\"css:light\\\")\\n        part.body = \\\":light(\\\" + part.body + \\\")\\\";\\n      const parsedCSS = parseCSS(part.body, customCSSNames);\\n      return {\\n        name: \\\"css\\\",\\n        body: parsedCSS.selector,\\n        source: part.body\\n      };\\n    }\\n    if (kNestedSelectorNames.has(part.name)) {\\n      let innerSelector;\\n      let distance;\\n      try {\\n        const unescaped = JSON.parse(\\\"[\\\" + part.body + \\\"]\\\");\\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== \\\"string\\\")\\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n        innerSelector = unescaped[0];\\n        if (unescaped.length === 2) {\\n          if (typeof unescaped[1] !== \\\"number\\\" || !kNestedSelectorNamesWithDistance.has(part.name))\\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n          distance = unescaped[1];\\n        }\\n      } catch (e) {\\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n      }\\n      const result2 = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\\n      if (result2.body.parsed.parts.some((part2) => part2.name === \\\"internal:control\\\" && part2.body === \\\"enter-frame\\\"))\\n        throw new InvalidSelectorError(`Frames are not allowed inside \\\"${part.name}\\\" selectors`);\\n      return result2;\\n    }\\n    return { ...part, source: part.body };\\n  });\\n  if (kNestedSelectorNames.has(parts[0].name))\\n    throw new InvalidSelectorError(`\\\"${parts[0].name}\\\" selector cannot be first`);\\n  return {\\n    capture: result.capture,\\n    parts\\n  };\\n}\\nfunction stringifySelector(selector) {\\n  if (typeof selector === \\\"string\\\")\\n    return selector;\\n  return selector.parts.map((p, i) => {\\n    const prefix = p.name === \\\"css\\\" ? \\\"\\\" : p.name + \\\"=\\\";\\n    return `${i === selector.capture ? \\\"*\\\" : \\\"\\\"}${prefix}${p.source}`;\\n  }).join(\\\" >> \\\");\\n}\\nfunction parseSelectorString(selector) {\\n  let index = 0;\\n  let quote;\\n  let start = 0;\\n  const result = { parts: [] };\\n  const append = () => {\\n    const part = selector.substring(start, index).trim();\\n    const eqIndex = part.indexOf(\\\"=\\\");\\n    let name;\\n    let body;\\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\\n      name = part.substring(0, eqIndex).trim();\\n      body = part.substring(eqIndex + 1);\\n    } else if (part.length > 1 && part[0] === '\\\"' && part[part.length - 1] === '\\\"') {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (part.length > 1 && part[0] === \\\"'\\\" && part[part.length - 1] === \\\"'\\\") {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (/^\\\\(*\\\\/\\\\//.test(part) || part.startsWith(\\\"..\\\")) {\\n      name = \\\"xpath\\\";\\n      body = part;\\n    } else {\\n      name = \\\"css\\\";\\n      body = part;\\n    }\\n    let capture = false;\\n    if (name[0] === \\\"*\\\") {\\n      capture = true;\\n      name = name.substring(1);\\n    }\\n    result.parts.push({ name, body });\\n    if (capture) {\\n      if (result.capture !== void 0)\\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\\n      result.capture = result.parts.length - 1;\\n    }\\n  };\\n  if (!selector.includes(\\\">>\\\")) {\\n    index = selector.length;\\n    append();\\n    return result;\\n  }\\n  const shouldIgnoreTextSelectorQuote = () => {\\n    const prefix = selector.substring(start, index);\\n    const match = prefix.match(/^\\\\s*text\\\\s*=(.*)$/);\\n    return !!match && !!match[1];\\n  };\\n  while (index < selector.length) {\\n    const c = selector[index];\\n    if (c === \\\"\\\\\\\\\\\" && index + 1 < selector.length) {\\n      index += 2;\\n    } else if (c === quote) {\\n      quote = void 0;\\n      index++;\\n    } else if (!quote && (c === '\\\"' || c === \\\"'\\\" || c === \\\"`\\\") && !shouldIgnoreTextSelectorQuote()) {\\n      quote = c;\\n      index++;\\n    } else if (!quote && c === \\\">\\\" && selector[index + 1] === \\\">\\\") {\\n      append();\\n      index += 2;\\n      start = index;\\n    } else {\\n      index++;\\n    }\\n  }\\n  append();\\n  return result;\\n}\\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\\n  let wp = 0;\\n  let EOL = selector.length === 0;\\n  const next = () => selector[wp] || \\\"\\\";\\n  const eat1 = () => {\\n    const result2 = next();\\n    ++wp;\\n    EOL = wp >= selector.length;\\n    return result2;\\n  };\\n  const syntaxError = (stage) => {\\n    if (EOL)\\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\\\`${selector}\\\\``);\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - unexpected symbol \\\"${next()}\\\" at position ${wp}` + (stage ? \\\" during \\\" + stage : \\\"\\\"));\\n  };\\n  function skipSpaces() {\\n    while (!EOL && /\\\\s/.test(next()))\\n      eat1();\\n  }\\n  function isCSSNameChar(char) {\\n    return char >= \\\"\\\\x80\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char >= \\\"A\\\" && char <= \\\"Z\\\" || char >= \\\"a\\\" && char <= \\\"z\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char === \\\"_\\\" || char === \\\"-\\\";\\n  }\\n  function readIdentifier() {\\n    let result2 = \\\"\\\";\\n    skipSpaces();\\n    while (!EOL && isCSSNameChar(next()))\\n      result2 += eat1();\\n    return result2;\\n  }\\n  function readQuotedString(quote) {\\n    let result2 = eat1();\\n    if (result2 !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    while (!EOL && next() !== quote) {\\n      if (next() === \\\"\\\\\\\\\\\")\\n        eat1();\\n      result2 += eat1();\\n    }\\n    if (next() !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    result2 += eat1();\\n    return result2;\\n  }\\n  function readRegularExpression() {\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let source = \\\"\\\";\\n    let inClass = false;\\n    while (!EOL) {\\n      if (next() === \\\"\\\\\\\\\\\") {\\n        source += eat1();\\n        if (EOL)\\n          syntaxError(\\\"parsing regular expressiion\\\");\\n      } else if (inClass && next() === \\\"]\\\") {\\n        inClass = false;\\n      } else if (!inClass && next() === \\\"[\\\") {\\n        inClass = true;\\n      } else if (!inClass && next() === \\\"/\\\") {\\n        break;\\n      }\\n      source += eat1();\\n    }\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let flags = \\\"\\\";\\n    while (!EOL && next().match(/[dgimsuy]/))\\n      flags += eat1();\\n    try {\\n      return new RegExp(source, flags);\\n    } catch (e) {\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\`: ${e.message}`);\\n    }\\n  }\\n  function readAttributeToken() {\\n    let token = \\\"\\\";\\n    skipSpaces();\\n    if (next() === `'` || next() === `\\\"`)\\n      token = readQuotedString(next()).slice(1, -1);\\n    else\\n      token = readIdentifier();\\n    if (!token)\\n      syntaxError(\\\"parsing property path\\\");\\n    return token;\\n  }\\n  function readOperator() {\\n    skipSpaces();\\n    let op = \\\"\\\";\\n    if (!EOL)\\n      op += eat1();\\n    if (!EOL && op !== \\\"=\\\")\\n      op += eat1();\\n    if (![\\\"=\\\", \\\"*=\\\", \\\"^=\\\", \\\"$=\\\", \\\"|=\\\", \\\"~=\\\"].includes(op))\\n      syntaxError(\\\"parsing operator\\\");\\n    return op;\\n  }\\n  function readAttribute() {\\n    eat1();\\n    const jsonPath = [];\\n    jsonPath.push(readAttributeToken());\\n    skipSpaces();\\n    while (next() === \\\".\\\") {\\n      eat1();\\n      jsonPath.push(readAttributeToken());\\n      skipSpaces();\\n    }\\n    if (next() === \\\"]\\\") {\\n      eat1();\\n      return { name: jsonPath.join(\\\".\\\"), jsonPath, op: \\\"<truthy>\\\", value: null, caseSensitive: false };\\n    }\\n    const operator = readOperator();\\n    let value = void 0;\\n    let caseSensitive = true;\\n    skipSpaces();\\n    if (next() === \\\"/\\\") {\\n      if (operator !== \\\"=\\\")\\n        throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with regular expression`);\\n      value = readRegularExpression();\\n    } else if (next() === `'` || next() === `\\\"`) {\\n      value = readQuotedString(next()).slice(1, -1);\\n      skipSpaces();\\n      if (next() === \\\"i\\\" || next() === \\\"I\\\") {\\n        caseSensitive = false;\\n        eat1();\\n      } else if (next() === \\\"s\\\" || next() === \\\"S\\\") {\\n        caseSensitive = true;\\n        eat1();\\n      }\\n    } else {\\n      value = \\\"\\\";\\n      while (!EOL && (isCSSNameChar(next()) || next() === \\\"+\\\" || next() === \\\".\\\"))\\n        value += eat1();\\n      if (value === \\\"true\\\") {\\n        value = true;\\n      } else if (value === \\\"false\\\") {\\n        value = false;\\n      } else {\\n        if (!allowUnquotedStrings) {\\n          value = +value;\\n          if (Number.isNaN(value))\\n            syntaxError(\\\"parsing attribute value\\\");\\n        }\\n      }\\n    }\\n    skipSpaces();\\n    if (next() !== \\\"]\\\")\\n      syntaxError(\\\"parsing attribute value\\\");\\n    eat1();\\n    if (operator !== \\\"=\\\" && typeof value !== \\\"string\\\")\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\\n    return { name: jsonPath.join(\\\".\\\"), jsonPath, op: operator, value, caseSensitive };\\n  }\\n  const result = {\\n    name: \\\"\\\",\\n    attributes: []\\n  };\\n  result.name = readIdentifier();\\n  skipSpaces();\\n  while (next() === \\\"[\\\") {\\n    result.attributes.push(readAttribute());\\n    skipSpaces();\\n  }\\n  if (!EOL)\\n    syntaxError(void 0);\\n  if (!result.name && !result.attributes.length)\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - selector cannot be empty`);\\n  return result;\\n}\\n\\n// packages/playwright-core/src/server/isomorphic/locatorGenerators.ts\\nfunction asLocator(lang, selector, isFrameLocator = false) {\\n  return innerAsLocator(generators[lang], parseSelector(selector), isFrameLocator);\\n}\\nfunction innerAsLocator(factory, parsed, isFrameLocator = false) {\\n  const parts = [...parsed.parts];\\n  for (let index = 0; index < parts.length - 1; index++) {\\n    if (parts[index].name === \\\"nth\\\" && parts[index + 1].name === \\\"internal:control\\\" && parts[index + 1].body === \\\"enter-frame\\\") {\\n      const [nth] = parts.splice(index, 1);\\n      parts.splice(index + 1, 0, nth);\\n    }\\n  }\\n  const tokens = [];\\n  let nextBase = isFrameLocator ? \\\"frame-locator\\\" : \\\"page\\\";\\n  for (let index = 0; index < parts.length; index++) {\\n    const part = parts[index];\\n    const base = nextBase;\\n    nextBase = \\\"locator\\\";\\n    if (part.name === \\\"nth\\\") {\\n      if (part.body === \\\"0\\\")\\n        tokens.push(factory.generateLocator(base, \\\"first\\\", \\\"\\\"));\\n      else if (part.body === \\\"-1\\\")\\n        tokens.push(factory.generateLocator(base, \\\"last\\\", \\\"\\\"));\\n      else\\n        tokens.push(factory.generateLocator(base, \\\"nth\\\", part.body));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"text\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has-text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"has-text\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has\\\") {\\n      const inner = innerAsLocator(factory, part.body.parsed);\\n      tokens.push(factory.generateLocator(base, \\\"has\\\", inner));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:label\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push(factory.generateLocator(base, \\\"label\\\", text, { exact }));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:role\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const options = { attrs: [] };\\n      for (const attr of attrSelector.attributes) {\\n        if (attr.name === \\\"name\\\") {\\n          options.exact = attr.caseSensitive;\\n          options.name = attr.value;\\n        } else {\\n          if (attr.name === \\\"level\\\" && typeof attr.value === \\\"string\\\")\\n            attr.value = +attr.value;\\n          options.attrs.push({ name: attr.name === \\\"include-hidden\\\" ? \\\"includeHidden\\\" : attr.name, value: attr.value });\\n        }\\n      }\\n      tokens.push(factory.generateLocator(base, \\\"role\\\", attrSelector.name, options));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:testid\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { value } = attrSelector.attributes[0];\\n      tokens.push(factory.generateLocator(base, \\\"test-id\\\", value));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:attr\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\\n      const text = value;\\n      const exact = !!caseSensitive;\\n      if (name === \\\"placeholder\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"placeholder\\\", text, { exact }));\\n        continue;\\n      }\\n      if (name === \\\"alt\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"alt\\\", text, { exact }));\\n        continue;\\n      }\\n      if (name === \\\"title\\\") {\\n        tokens.push(factory.generateLocator(base, \\\"title\\\", text, { exact }));\\n        continue;\\n      }\\n    }\\n    let locatorType = \\\"default\\\";\\n    const nextPart = parts[index + 1];\\n    if (nextPart && nextPart.name === \\\"internal:control\\\" && nextPart.body === \\\"enter-frame\\\") {\\n      locatorType = \\\"frame\\\";\\n      nextBase = \\\"frame-locator\\\";\\n      index++;\\n    }\\n    const p = { parts: [part] };\\n    tokens.push(factory.generateLocator(base, locatorType, stringifySelector(p)));\\n  }\\n  return tokens.join(\\\".\\\");\\n}\\nfunction detectExact(text) {\\n  let exact = false;\\n  const match = text.match(/^\\\\/(.*)\\\\/([igm]*)$/);\\n  if (match)\\n    return { text: new RegExp(match[1], match[2]) };\\n  if (text.endsWith('\\\"')) {\\n    text = JSON.parse(text);\\n    exact = true;\\n  } else if (text.endsWith('\\\"s')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = true;\\n  } else if (text.endsWith('\\\"i')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = false;\\n  }\\n  return { exact, text };\\n}\\nvar JavaScriptLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name: ${options.name}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name: ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact: true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${name}: ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `getByRole(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter({ hasText: ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `filter({ has: ${body} })`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${body})`;\\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return String(body);\\n    return this.quote(body);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, \\\"'\\\");\\n  }\\n};\\nvar PythonLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frame_locator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first`;\\n      case \\\"last\\\":\\n        return `last`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name=${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name=${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact=True`);\\n        }\\n        for (const { name, value } of options.attrs) {\\n          let valueString = typeof value === \\\"string\\\" ? this.quote(value) : value;\\n          if (typeof value === \\\"boolean\\\")\\n            valueString = value ? \\\"True\\\" : \\\"False\\\";\\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\\n        }\\n        const attrString = attrs.length ? `, ${attrs.join(\\\", \\\")}` : \\\"\\\";\\n        return `get_by_role(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(has_text=${this.toHasText(body)})`;\\n      case \\\"has\\\":\\n        return `filter(has=${body})`;\\n      case \\\"test-id\\\":\\n        return `get_by_test_id(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"get_by_text\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"get_by_alt_text\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"get_by_placeholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"get_by_label\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"get_by_title\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", re.IGNORECASE\\\" : \\\"\\\";\\n    return `re.compile(r\\\"${body.source.replace(/\\\\\\\\\\\\//, \\\"/\\\").replace(/\\\"/g, '\\\\\\\\\\\"')}\\\"${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, exact=True)`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return `${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar JavaLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    let clazz;\\n    switch (base) {\\n      case \\\"page\\\":\\n        clazz = \\\"Page\\\";\\n        break;\\n      case \\\"frame-locator\\\":\\n        clazz = \\\"FrameLocator\\\";\\n        break;\\n      case \\\"locator\\\":\\n        clazz = \\\"Locator\\\";\\n        break;\\n    }\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`.setName(${this.quote(options.name)})`);\\n          if (options.exact)\\n            attrs.push(`.setExact(true)`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === \\\"string\\\" ? this.quote(value) : value})`);\\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join(\\\"\\\")}` : \\\"\\\";\\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\\n      case \\\"has\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(clazz, \\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(clazz, \\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(clazz, \\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(clazz, \\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(clazz, \\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", Pattern.CASE_INSENSITIVE\\\" : \\\"\\\";\\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\\n  }\\n  toCallWithExact(clazz, method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return this.quote(body);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar CSharpLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        return `Locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `FrameLocator(${this.quote(body)})`;\\n      case \\\"nth\\\":\\n        return `Nth(${body})`;\\n      case \\\"first\\\":\\n        return `First`;\\n      case \\\"last\\\":\\n        return `Last`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`Name = ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`Exact = true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${toTitleCase(name)} = ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, new() { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `Filter(new() { ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `Filter(new() { Has = ${body} })`;\\n      case \\\"test-id\\\":\\n        return `GetByTestId(${this.quote(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"GetByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"GetByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"GetByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"GetByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"GetByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", RegexOptions.IgnoreCase\\\" : \\\"\\\";\\n    return `new Regex(${this.quote(body.source)}${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return `HasTextRegex = ${this.regexToString(body)}`;\\n    return `HasText = ${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar generators = {\\n  javascript: new JavaScriptLocatorFactory(),\\n  python: new PythonLocatorFactory(),\\n  java: new JavaLocatorFactory(),\\n  csharp: new CSharpLocatorFactory()\\n};\\nfunction isRegExp(obj) {\\n  return obj instanceof RegExp;\\n}\\n\\n// packages/playwright-core/src/server/injected/highlight.ts\\nvar Highlight = class {\\n  constructor(injectedScript) {\\n    this._highlightEntries = [];\\n    this._language = \\\"javascript\\\";\\n    this._injectedScript = injectedScript;\\n    this._isUnderTest = injectedScript.isUnderTest;\\n    this._glassPaneElement = document.createElement(\\\"x-pw-glass\\\");\\n    this._glassPaneElement.style.position = \\\"fixed\\\";\\n    this._glassPaneElement.style.top = \\\"0\\\";\\n    this._glassPaneElement.style.right = \\\"0\\\";\\n    this._glassPaneElement.style.bottom = \\\"0\\\";\\n    this._glassPaneElement.style.left = \\\"0\\\";\\n    this._glassPaneElement.style.zIndex = \\\"2147483647\\\";\\n    this._glassPaneElement.style.pointerEvents = \\\"none\\\";\\n    this._glassPaneElement.style.display = \\\"flex\\\";\\n    this._actionPointElement = document.createElement(\\\"x-pw-action-point\\\");\\n    this._actionPointElement.setAttribute(\\\"hidden\\\", \\\"true\\\");\\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? \\\"open\\\" : \\\"closed\\\" });\\n    this._glassPaneShadow.appendChild(this._actionPointElement);\\n    const styleElement = document.createElement(\\\"style\\\");\\n    styleElement.textContent = `\\n        x-pw-tooltip {\\n          align-items: center;\\n          backdrop-filter: blur(5px);\\n          background-color: rgba(0, 0, 0, 0.7);\\n          border-radius: 2px;\\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\\n          color: rgb(204, 204, 204);\\n          display: none;\\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\\n                      'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\\n          font-size: 12.8px;\\n          font-weight: normal;\\n          left: 0;\\n          line-height: 1.5;\\n          max-width: 600px;\\n          padding: 3.2px 5.12px 3.2px;\\n          position: absolute;\\n          top: 0;\\n        }\\n        x-pw-action-point {\\n          position: absolute;\\n          width: 20px;\\n          height: 20px;\\n          background: red;\\n          border-radius: 10px;\\n          pointer-events: none;\\n          margin: -10px 0 0 -10px;\\n          z-index: 2;\\n        }\\n        *[hidden] {\\n          display: none !important;\\n        }\\n    `;\\n    this._glassPaneShadow.appendChild(styleElement);\\n  }\\n  install() {\\n    document.documentElement.appendChild(this._glassPaneElement);\\n  }\\n  setLanguage(language) {\\n    this._language = language;\\n  }\\n  runHighlightOnRaf(selector) {\\n    if (this._rafRequest)\\n      cancelAnimationFrame(this._rafRequest);\\n    this.updateHighlight(this._injectedScript.querySelectorAll(selector, document.documentElement), stringifySelector(selector), false);\\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\\n  }\\n  uninstall() {\\n    if (this._rafRequest)\\n      cancelAnimationFrame(this._rafRequest);\\n    this._glassPaneElement.remove();\\n  }\\n  isInstalled() {\\n    return this._glassPaneElement.parentElement === document.documentElement && !this._glassPaneElement.nextElementSibling;\\n  }\\n  showActionPoint(x, y) {\\n    this._actionPointElement.style.top = y + \\\"px\\\";\\n    this._actionPointElement.style.left = x + \\\"px\\\";\\n    this._actionPointElement.hidden = false;\\n    if (this._isUnderTest)\\n      console.error(\\\"Action point for test: \\\" + JSON.stringify({ x, y }));\\n  }\\n  hideActionPoint() {\\n    this._actionPointElement.hidden = true;\\n  }\\n  clearHighlight() {\\n    var _a, _b;\\n    for (const entry of this._highlightEntries) {\\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\\n    }\\n    this._highlightEntries = [];\\n  }\\n  updateHighlight(elements, selector, isRecording) {\\n    let color;\\n    if (isRecording)\\n      color = \\\"#dc6f6f7f\\\";\\n    else\\n      color = elements.length > 1 ? \\\"#f6b26b7f\\\" : \\\"#6fa8dc7f\\\";\\n    this._innerUpdateHighlight(elements, { color, tooltipText: selector ? asLocator(this._language, selector) : \\\"\\\" });\\n  }\\n  maskElements(elements) {\\n    this._innerUpdateHighlight(elements, { color: \\\"#F0F\\\" });\\n  }\\n  _innerUpdateHighlight(elements, options) {\\n    if (this._highlightIsUpToDate(elements, options.tooltipText))\\n      return;\\n    this.clearHighlight();\\n    for (let i = 0; i < elements.length; ++i) {\\n      const highlightElement = this._createHighlightElement();\\n      this._glassPaneShadow.appendChild(highlightElement);\\n      let tooltipElement;\\n      if (options.tooltipText) {\\n        tooltipElement = document.createElement(\\\"x-pw-tooltip\\\");\\n        this._glassPaneShadow.appendChild(tooltipElement);\\n        const suffix = elements.length > 1 ? ` [${i + 1} of ${elements.length}]` : \\\"\\\";\\n        tooltipElement.textContent = options.tooltipText + suffix;\\n        tooltipElement.style.top = \\\"0\\\";\\n        tooltipElement.style.left = \\\"0\\\";\\n        tooltipElement.style.display = \\\"flex\\\";\\n      }\\n      this._highlightEntries.push({ targetElement: elements[i], tooltipElement, highlightElement, tooltipText: options.tooltipText });\\n    }\\n    for (const entry of this._highlightEntries) {\\n      entry.box = entry.targetElement.getBoundingClientRect();\\n      if (!entry.tooltipElement)\\n        continue;\\n      const tooltipWidth = entry.tooltipElement.offsetWidth;\\n      const tooltipHeight = entry.tooltipElement.offsetHeight;\\n      const totalWidth = this._glassPaneElement.offsetWidth;\\n      const totalHeight = this._glassPaneElement.offsetHeight;\\n      let anchorLeft = entry.box.left;\\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\\n        anchorLeft = totalWidth - tooltipWidth - 5;\\n      let anchorTop = entry.box.bottom + 5;\\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\\n        if (entry.box.top > tooltipHeight + 5) {\\n          anchorTop = entry.box.top - tooltipHeight - 5;\\n        } else {\\n          anchorTop = totalHeight - 5 - tooltipHeight;\\n        }\\n      }\\n      entry.tooltipTop = anchorTop;\\n      entry.tooltipLeft = anchorLeft;\\n    }\\n    for (const entry of this._highlightEntries) {\\n      if (entry.tooltipElement) {\\n        entry.tooltipElement.style.top = entry.tooltipTop + \\\"px\\\";\\n        entry.tooltipElement.style.left = entry.tooltipLeft + \\\"px\\\";\\n      }\\n      const box = entry.box;\\n      entry.highlightElement.style.backgroundColor = options.color;\\n      entry.highlightElement.style.left = box.x + \\\"px\\\";\\n      entry.highlightElement.style.top = box.y + \\\"px\\\";\\n      entry.highlightElement.style.width = box.width + \\\"px\\\";\\n      entry.highlightElement.style.height = box.height + \\\"px\\\";\\n      entry.highlightElement.style.display = \\\"block\\\";\\n      if (this._isUnderTest)\\n        console.error(\\\"Highlight box for test: \\\" + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\\n    }\\n  }\\n  _highlightIsUpToDate(elements, tooltipText) {\\n    if (elements.length !== this._highlightEntries.length)\\n      return false;\\n    for (let i = 0; i < this._highlightEntries.length; ++i) {\\n      if (tooltipText !== this._highlightEntries[i].tooltipText)\\n        return false;\\n      if (elements[i] !== this._highlightEntries[i].targetElement)\\n        return false;\\n      const oldBox = this._highlightEntries[i].box;\\n      if (!oldBox)\\n        return false;\\n      const box = elements[i].getBoundingClientRect();\\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\\n        return false;\\n    }\\n    return true;\\n  }\\n  _createHighlightElement() {\\n    const highlightElement = document.createElement(\\\"x-pw-highlight\\\");\\n    highlightElement.style.position = \\\"absolute\\\";\\n    highlightElement.style.top = \\\"0\\\";\\n    highlightElement.style.left = \\\"0\\\";\\n    highlightElement.style.width = \\\"0\\\";\\n    highlightElement.style.height = \\\"0\\\";\\n    highlightElement.style.boxSizing = \\\"border-box\\\";\\n    return highlightElement;\\n  }\\n};\\n\\n// packages/playwright-core/src/server/injected/recorder.ts\\nvar Recorder = class {\\n  constructor(injectedScript) {\\n    this._performingAction = false;\\n    this._listeners = [];\\n    this._hoveredModel = null;\\n    this._hoveredElement = null;\\n    this._activeModel = null;\\n    this._expectProgrammaticKeyUp = false;\\n    this._mode = \\\"none\\\";\\n    this._testIdAttributeName = \\\"data-testid\\\";\\n    this._injectedScript = injectedScript;\\n    this._highlight = new Highlight(injectedScript);\\n    this._refreshListenersIfNeeded();\\n    injectedScript.onGlobalListenersRemoved.add(() => this._refreshListenersIfNeeded());\\n    globalThis.__pw_refreshOverlay = () => {\\n      this._pollRecorderMode().catch((e) => console.log(e));\\n    };\\n    globalThis.__pw_refreshOverlay();\\n    if (injectedScript.isUnderTest)\\n      console.error(\\\"Recorder script ready for test\\\");\\n  }\\n  _refreshListenersIfNeeded() {\\n    if (this._highlight.isInstalled())\\n      return;\\n    removeEventListeners(this._listeners);\\n    this._listeners = [\\n      addEventListener(document, \\\"click\\\", (event) => this._onClick(event), true),\\n      addEventListener(document, \\\"auxclick\\\", (event) => this._onClick(event), true),\\n      addEventListener(document, \\\"input\\\", (event) => this._onInput(event), true),\\n      addEventListener(document, \\\"keydown\\\", (event) => this._onKeyDown(event), true),\\n      addEventListener(document, \\\"keyup\\\", (event) => this._onKeyUp(event), true),\\n      addEventListener(document, \\\"mousedown\\\", (event) => this._onMouseDown(event), true),\\n      addEventListener(document, \\\"mouseup\\\", (event) => this._onMouseUp(event), true),\\n      addEventListener(document, \\\"mousemove\\\", (event) => this._onMouseMove(event), true),\\n      addEventListener(document, \\\"mouseleave\\\", (event) => this._onMouseLeave(event), true),\\n      addEventListener(document, \\\"focus\\\", (event) => event.isTrusted && this._onFocus(true), true),\\n      addEventListener(document, \\\"scroll\\\", (event) => {\\n        if (!event.isTrusted)\\n          return;\\n        this._hoveredModel = null;\\n        this._highlight.hideActionPoint();\\n        this._updateHighlight();\\n      }, true)\\n    ];\\n    this._highlight.install();\\n  }\\n  async _pollRecorderMode() {\\n    var _a;\\n    const pollPeriod = 1e3;\\n    if (this._pollRecorderModeTimer)\\n      clearTimeout(this._pollRecorderModeTimer);\\n    const state = await globalThis.__pw_recorderState().catch((e) => null);\\n    if (!state) {\\n      this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\\n      return;\\n    }\\n    const { mode, actionPoint, actionSelector, language, testIdAttributeName } = state;\\n    this._testIdAttributeName = testIdAttributeName;\\n    this._highlight.setLanguage(language);\\n    if (mode !== this._mode) {\\n      this._mode = mode;\\n      this._clearHighlight();\\n    }\\n    if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {\\n    } else if (!actionPoint && !this._actionPoint) {\\n    } else {\\n      if (actionPoint)\\n        this._highlight.showActionPoint(actionPoint.x, actionPoint.y);\\n      else\\n        this._highlight.hideActionPoint();\\n      this._actionPoint = actionPoint;\\n    }\\n    if (this._actionSelector && !((_a = this._hoveredModel) == null ? void 0 : _a.elements.length))\\n      this._actionSelector = void 0;\\n    if (actionSelector !== this._actionSelector) {\\n      this._hoveredModel = actionSelector ? querySelector(this._injectedScript, actionSelector, document) : null;\\n      this._updateHighlight();\\n      this._actionSelector = actionSelector;\\n    }\\n    this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\\n  }\\n  _clearHighlight() {\\n    this._hoveredModel = null;\\n    this._activeModel = null;\\n    this._updateHighlight();\\n  }\\n  _actionInProgress(event) {\\n    if (this._performingAction)\\n      return true;\\n    consumeEvent(event);\\n    return false;\\n  }\\n  _consumedDueToNoModel(event, model) {\\n    if (model)\\n      return false;\\n    consumeEvent(event);\\n    return true;\\n  }\\n  _consumedDueWrongTarget(event) {\\n    if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))\\n      return false;\\n    consumeEvent(event);\\n    return true;\\n  }\\n  _onClick(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (this._mode === \\\"inspecting\\\")\\n      globalThis.__pw_recorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : \\\"\\\");\\n    if (this._shouldIgnoreMouseEvent(event))\\n      return;\\n    if (this._actionInProgress(event))\\n      return;\\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\\n      return;\\n    const checkbox = asCheckbox(this._deepEventTarget(event));\\n    if (checkbox) {\\n      this._performAction({\\n        name: checkbox.checked ? \\\"check\\\" : \\\"uncheck\\\",\\n        selector: this._hoveredModel.selector,\\n        signals: []\\n      });\\n      return;\\n    }\\n    this._performAction({\\n      name: \\\"click\\\",\\n      selector: this._hoveredModel.selector,\\n      position: positionForEvent(event),\\n      signals: [],\\n      button: buttonForEvent(event),\\n      modifiers: modifiersForEvent(event),\\n      clickCount: event.detail\\n    });\\n  }\\n  _shouldIgnoreMouseEvent(event) {\\n    const target = this._deepEventTarget(event);\\n    if (this._mode === \\\"none\\\")\\n      return true;\\n    if (this._mode === \\\"inspecting\\\") {\\n      consumeEvent(event);\\n      return true;\\n    }\\n    const nodeName = target.nodeName;\\n    if (nodeName === \\\"SELECT\\\" || nodeName === \\\"OPTION\\\")\\n      return true;\\n    if (nodeName === \\\"INPUT\\\" && [\\\"date\\\"].includes(target.type))\\n      return true;\\n    return false;\\n  }\\n  _onMouseDown(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (this._shouldIgnoreMouseEvent(event))\\n      return;\\n    if (!this._performingAction)\\n      consumeEvent(event);\\n    this._activeModel = this._hoveredModel;\\n  }\\n  _onMouseUp(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (this._shouldIgnoreMouseEvent(event))\\n      return;\\n    if (!this._performingAction)\\n      consumeEvent(event);\\n  }\\n  _onMouseMove(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (this._mode === \\\"none\\\")\\n      return;\\n    const target = this._deepEventTarget(event);\\n    if (this._hoveredElement === target)\\n      return;\\n    this._hoveredElement = target;\\n    this._updateModelForHoveredElement();\\n  }\\n  _onMouseLeave(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (window.top !== window && this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\\n      this._hoveredElement = null;\\n      this._updateModelForHoveredElement();\\n    }\\n  }\\n  _onFocus(userGesture) {\\n    if (this._mode === \\\"none\\\")\\n      return;\\n    const activeElement = this._deepActiveElement(document);\\n    if (userGesture && activeElement === document.body)\\n      return;\\n    const result = activeElement ? generateSelector(this._injectedScript, activeElement, this._testIdAttributeName) : null;\\n    this._activeModel = result && result.selector ? result : null;\\n    if (userGesture)\\n      this._hoveredElement = activeElement;\\n    this._updateModelForHoveredElement();\\n  }\\n  _updateModelForHoveredElement() {\\n    if (!this._hoveredElement) {\\n      this._hoveredModel = null;\\n      this._updateHighlight();\\n      return;\\n    }\\n    const hoveredElement = this._hoveredElement;\\n    const { selector, elements } = generateSelector(this._injectedScript, hoveredElement, this._testIdAttributeName);\\n    if (this._hoveredModel && this._hoveredModel.selector === selector)\\n      return;\\n    this._hoveredModel = selector ? { selector, elements } : null;\\n    this._updateHighlight();\\n  }\\n  _updateHighlight() {\\n    const elements = this._hoveredModel ? this._hoveredModel.elements : [];\\n    const selector = this._hoveredModel ? this._hoveredModel.selector : \\\"\\\";\\n    this._highlight.updateHighlight(elements, selector, this._mode === \\\"recording\\\");\\n  }\\n  _onInput(event) {\\n    if (this._mode !== \\\"recording\\\")\\n      return true;\\n    const target = this._deepEventTarget(event);\\n    if (target.nodeName === \\\"INPUT\\\" && target.type.toLowerCase() === \\\"file\\\") {\\n      globalThis.__pw_recorderRecordAction({\\n        name: \\\"setInputFiles\\\",\\n        selector: this._activeModel.selector,\\n        signals: [],\\n        files: [...target.files || []].map((file) => file.name)\\n      });\\n      return;\\n    }\\n    if ([\\\"INPUT\\\", \\\"TEXTAREA\\\"].includes(target.nodeName) || target.isContentEditable) {\\n      if (target.nodeName === \\\"INPUT\\\" && [\\\"checkbox\\\", \\\"radio\\\"].includes(target.type.toLowerCase())) {\\n        return;\\n      }\\n      if (this._consumedDueWrongTarget(event))\\n        return;\\n      globalThis.__pw_recorderRecordAction({\\n        name: \\\"fill\\\",\\n        selector: this._activeModel.selector,\\n        signals: [],\\n        text: target.isContentEditable ? target.innerText : target.value\\n      });\\n    }\\n    if (target.nodeName === \\\"SELECT\\\") {\\n      const selectElement = target;\\n      if (this._actionInProgress(event))\\n        return;\\n      this._performAction({\\n        name: \\\"select\\\",\\n        selector: this._hoveredModel.selector,\\n        options: [...selectElement.selectedOptions].map((option) => option.value),\\n        signals: []\\n      });\\n    }\\n  }\\n  _shouldGenerateKeyPressFor(event) {\\n    if ([\\\"Backspace\\\", \\\"Delete\\\", \\\"AltGraph\\\"].includes(event.key))\\n      return false;\\n    if (event.key === \\\"@\\\" && event.code === \\\"KeyL\\\")\\n      return false;\\n    if (navigator.platform.includes(\\\"Mac\\\")) {\\n      if (event.key === \\\"v\\\" && event.metaKey)\\n        return false;\\n    } else {\\n      if (event.key === \\\"v\\\" && event.ctrlKey)\\n        return false;\\n      if (event.key === \\\"Insert\\\" && event.shiftKey)\\n        return false;\\n    }\\n    if ([\\\"Shift\\\", \\\"Control\\\", \\\"Meta\\\", \\\"Alt\\\", \\\"Process\\\"].includes(event.key))\\n      return false;\\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\\n    if (event.key.length === 1 && !hasModifier)\\n      return !!asCheckbox(this._deepEventTarget(event));\\n    return true;\\n  }\\n  _onKeyDown(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (this._mode === \\\"inspecting\\\") {\\n      consumeEvent(event);\\n      return;\\n    }\\n    if (this._mode !== \\\"recording\\\")\\n      return;\\n    if (!this._shouldGenerateKeyPressFor(event))\\n      return;\\n    if (this._actionInProgress(event)) {\\n      this._expectProgrammaticKeyUp = true;\\n      return;\\n    }\\n    if (this._consumedDueWrongTarget(event))\\n      return;\\n    if (event.key === \\\" \\\") {\\n      const checkbox = asCheckbox(this._deepEventTarget(event));\\n      if (checkbox) {\\n        this._performAction({\\n          name: checkbox.checked ? \\\"uncheck\\\" : \\\"check\\\",\\n          selector: this._activeModel.selector,\\n          signals: []\\n        });\\n        return;\\n      }\\n    }\\n    this._performAction({\\n      name: \\\"press\\\",\\n      selector: this._activeModel.selector,\\n      signals: [],\\n      key: event.key,\\n      modifiers: modifiersForEvent(event)\\n    });\\n  }\\n  _onKeyUp(event) {\\n    if (!event.isTrusted)\\n      return;\\n    if (this._mode === \\\"none\\\")\\n      return;\\n    if (!this._shouldGenerateKeyPressFor(event))\\n      return;\\n    if (!this._expectProgrammaticKeyUp) {\\n      consumeEvent(event);\\n      return;\\n    }\\n    this._expectProgrammaticKeyUp = false;\\n  }\\n  async _performAction(action) {\\n    this._clearHighlight();\\n    this._performingAction = true;\\n    await globalThis.__pw_recorderPerformAction(action).catch(() => {\\n    });\\n    this._performingAction = false;\\n    this._onFocus(false);\\n    if (this._injectedScript.isUnderTest) {\\n      console.error(\\\"Action performed for test: \\\" + JSON.stringify({\\n        hovered: this._hoveredModel ? this._hoveredModel.selector : null,\\n        active: this._activeModel ? this._activeModel.selector : null\\n      }));\\n    }\\n  }\\n  _deepEventTarget(event) {\\n    return event.composedPath()[0];\\n  }\\n  _deepActiveElement(document2) {\\n    let activeElement = document2.activeElement;\\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\\n      activeElement = activeElement.shadowRoot.activeElement;\\n    return activeElement;\\n  }\\n};\\nfunction modifiersForEvent(event) {\\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\\n}\\nfunction buttonForEvent(event) {\\n  switch (event.which) {\\n    case 1:\\n      return \\\"left\\\";\\n    case 2:\\n      return \\\"middle\\\";\\n    case 3:\\n      return \\\"right\\\";\\n  }\\n  return \\\"left\\\";\\n}\\nfunction positionForEvent(event) {\\n  const targetElement = event.target;\\n  if (targetElement.nodeName !== \\\"CANVAS\\\")\\n    return;\\n  return {\\n    x: event.offsetX,\\n    y: event.offsetY\\n  };\\n}\\nfunction consumeEvent(e) {\\n  e.preventDefault();\\n  e.stopPropagation();\\n  e.stopImmediatePropagation();\\n}\\nfunction asCheckbox(node) {\\n  if (!node || node.nodeName !== \\\"INPUT\\\")\\n    return null;\\n  const inputElement = node;\\n  return [\\\"checkbox\\\", \\\"radio\\\"].includes(inputElement.type) ? inputElement : null;\\n}\\nfunction addEventListener(target, eventName, listener, useCapture) {\\n  target.addEventListener(eventName, listener, useCapture);\\n  const remove = () => {\\n    target.removeEventListener(eventName, listener, useCapture);\\n  };\\n  return remove;\\n}\\nfunction removeEventListeners(listeners) {\\n  for (const listener of listeners)\\n    listener();\\n  listeners.splice(0, listeners.length);\\n}\\nmodule.exports = Recorder;\\n\";\nexports.source = source;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.source = void 0;\nconst source = \"\\\"use strict\\\";\\nlet __export = (target, all) => {\\n  for (var name in all)\\n    target[name] = all[name];\\n};\\nlet __commonJS = cb => function __require() {\\n  let fn;\\n  for (const name in cb) {\\n    fn = cb[name];\\n    break;\\n  }\\n  const exports = {};\\n  fn(exports);\\n  return exports;\\n};\\nlet __toESM = mod => ({ ...mod, 'default': mod });\\nlet __toCommonJS = mod =>  ({ ...mod, __esModule: true });\\n// packages/playwright-core/src/server/injected/utilityScript.ts\\nvar utilityScript_exports = {};\\n__export(utilityScript_exports, {\\n  UtilityScript: () => UtilityScript\\n});\\nmodule.exports = __toCommonJS(utilityScript_exports);\\n\\n// packages/playwright-core/src/server/isomorphic/utilityScriptSerializers.ts\\nfunction source() {\\n  function isRegExp(obj) {\\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === \\\"[object RegExp]\\\";\\n  }\\n  function isDate(obj) {\\n    return obj instanceof Date || Object.prototype.toString.call(obj) === \\\"[object Date]\\\";\\n  }\\n  function isURL(obj) {\\n    return obj instanceof URL || Object.prototype.toString.call(obj) === \\\"[object URL]\\\";\\n  }\\n  function isError(obj) {\\n    var _a;\\n    try {\\n      return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \\\"Error\\\";\\n    } catch (error) {\\n      return false;\\n    }\\n  }\\n  function parseEvaluationResultValue2(value, handles = [], refs = /* @__PURE__ */ new Map()) {\\n    if (Object.is(value, void 0))\\n      return void 0;\\n    if (typeof value === \\\"object\\\" && value) {\\n      if (\\\"ref\\\" in value)\\n        return refs.get(value.ref);\\n      if (\\\"v\\\" in value) {\\n        if (value.v === \\\"undefined\\\")\\n          return void 0;\\n        if (value.v === \\\"null\\\")\\n          return null;\\n        if (value.v === \\\"NaN\\\")\\n          return NaN;\\n        if (value.v === \\\"Infinity\\\")\\n          return Infinity;\\n        if (value.v === \\\"-Infinity\\\")\\n          return -Infinity;\\n        if (value.v === \\\"-0\\\")\\n          return -0;\\n        return void 0;\\n      }\\n      if (\\\"d\\\" in value)\\n        return new Date(value.d);\\n      if (\\\"u\\\" in value)\\n        return new URL(value.u);\\n      if (\\\"r\\\" in value)\\n        return new RegExp(value.r.p, value.r.f);\\n      if (\\\"a\\\" in value) {\\n        const result2 = [];\\n        refs.set(value.id, result2);\\n        for (const a of value.a)\\n          result2.push(parseEvaluationResultValue2(a, handles, refs));\\n        return result2;\\n      }\\n      if (\\\"o\\\" in value) {\\n        const result2 = {};\\n        refs.set(value.id, result2);\\n        for (const { k, v } of value.o)\\n          result2[k] = parseEvaluationResultValue2(v, handles, refs);\\n        return result2;\\n      }\\n      if (\\\"h\\\" in value)\\n        return handles[value.h];\\n    }\\n    return value;\\n  }\\n  function serializeAsCallArgument2(value, handleSerializer) {\\n    return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\\n  }\\n  function serialize(value, handleSerializer, visitorInfo) {\\n    if (value && typeof value === \\\"object\\\") {\\n      if (typeof globalThis.Window === \\\"function\\\" && value instanceof globalThis.Window)\\n        return \\\"ref: <Window>\\\";\\n      if (typeof globalThis.Document === \\\"function\\\" && value instanceof globalThis.Document)\\n        return \\\"ref: <Document>\\\";\\n      if (typeof globalThis.Node === \\\"function\\\" && value instanceof globalThis.Node)\\n        return \\\"ref: <Node>\\\";\\n    }\\n    return innerSerialize(value, handleSerializer, visitorInfo);\\n  }\\n  function innerSerialize(value, handleSerializer, visitorInfo) {\\n    const result2 = handleSerializer(value);\\n    if (\\\"fallThrough\\\" in result2)\\n      value = result2.fallThrough;\\n    else\\n      return result2;\\n    if (typeof value === \\\"symbol\\\")\\n      return { v: \\\"undefined\\\" };\\n    if (Object.is(value, void 0))\\n      return { v: \\\"undefined\\\" };\\n    if (Object.is(value, null))\\n      return { v: \\\"null\\\" };\\n    if (Object.is(value, NaN))\\n      return { v: \\\"NaN\\\" };\\n    if (Object.is(value, Infinity))\\n      return { v: \\\"Infinity\\\" };\\n    if (Object.is(value, -Infinity))\\n      return { v: \\\"-Infinity\\\" };\\n    if (Object.is(value, -0))\\n      return { v: \\\"-0\\\" };\\n    if (typeof value === \\\"boolean\\\")\\n      return value;\\n    if (typeof value === \\\"number\\\")\\n      return value;\\n    if (typeof value === \\\"string\\\")\\n      return value;\\n    if (isError(value)) {\\n      const error = value;\\n      if (\\\"captureStackTrace\\\" in globalThis.Error) {\\n        return error.stack || \\\"\\\";\\n      }\\n      return `${error.name}: ${error.message}\\n${error.stack}`;\\n    }\\n    if (isDate(value))\\n      return { d: value.toJSON() };\\n    if (isURL(value))\\n      return { u: value.toJSON() };\\n    if (isRegExp(value))\\n      return { r: { p: value.source, f: value.flags } };\\n    const id = visitorInfo.visited.get(value);\\n    if (id)\\n      return { ref: id };\\n    if (Array.isArray(value)) {\\n      const a = [];\\n      const id2 = ++visitorInfo.lastId;\\n      visitorInfo.visited.set(value, id2);\\n      for (let i = 0; i < value.length; ++i)\\n        a.push(serialize(value[i], handleSerializer, visitorInfo));\\n      return { a, id: id2 };\\n    }\\n    if (typeof value === \\\"object\\\") {\\n      const o = [];\\n      const id2 = ++visitorInfo.lastId;\\n      visitorInfo.visited.set(value, id2);\\n      for (const name of Object.keys(value)) {\\n        let item;\\n        try {\\n          item = value[name];\\n        } catch (e) {\\n          continue;\\n        }\\n        if (name === \\\"toJSON\\\" && typeof item === \\\"function\\\")\\n          o.push({ k: name, v: { o: [], id: 0 } });\\n        else\\n          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\\n      }\\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === \\\"function\\\")\\n        return innerSerialize(value.toJSON(), handleSerializer, visitorInfo);\\n      return { o, id: id2 };\\n    }\\n  }\\n  return { parseEvaluationResultValue: parseEvaluationResultValue2, serializeAsCallArgument: serializeAsCallArgument2 };\\n}\\nvar result = source();\\nvar parseEvaluationResultValue = result.parseEvaluationResultValue;\\nvar serializeAsCallArgument = result.serializeAsCallArgument;\\n\\n// packages/playwright-core/src/server/injected/utilityScript.ts\\nvar UtilityScript = class {\\n  constructor() {\\n    this.serializeAsCallArgument = serializeAsCallArgument;\\n    this.parseEvaluationResultValue = parseEvaluationResultValue;\\n  }\\n  evaluate(isFunction, returnByValue, exposeUtilityScript, expression, argCount, ...argsAndHandles) {\\n    const args = argsAndHandles.slice(0, argCount);\\n    const handles = argsAndHandles.slice(argCount);\\n    const parameters = args.map((a) => parseEvaluationResultValue(a, handles));\\n    if (exposeUtilityScript)\\n      parameters.unshift(this);\\n    let result2 = globalThis.eval(expression);\\n    if (isFunction === true) {\\n      result2 = result2(...parameters);\\n    } else if (isFunction === false) {\\n      result2 = result2;\\n    } else {\\n      if (typeof result2 === \\\"function\\\")\\n        result2 = result2(...parameters);\\n    }\\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result2) : result2;\\n  }\\n  jsonValue(returnByValue, value) {\\n    if (Object.is(value, void 0))\\n      return void 0;\\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\\n  }\\n  _promiseAwareJsonValueNoThrow(value) {\\n    const safeJson = (value2) => {\\n      try {\\n        return this.jsonValue(true, value2);\\n      } catch (e) {\\n        return void 0;\\n      }\\n    };\\n    if (value && typeof value === \\\"object\\\" && typeof value.then === \\\"function\\\") {\\n      return (async () => {\\n        const promiseValue = await value;\\n        return safeJson(promiseValue);\\n      })();\\n    }\\n    return safeJson(value);\\n  }\\n};\\nmodule.exports = UtilityScript;\\n\";\nexports.source = source;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blendWithWhite = blendWithWhite;\nexports.colorDeltaE94 = colorDeltaE94;\nexports.rgb2gray = rgb2gray;\nexports.srgb2xyz = srgb2xyz;\nexports.xyz2lab = xyz2lab;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction blendWithWhite(c, a) {\n  return 255 + (c - 255) * a;\n}\nfunction rgb2gray(r, g, b) {\n  // NOTE: this is the exact integer formula from SSIM.js.\n  // See https://github.com/obartra/ssim/blob/ca8e3c6a6ff5f4f2e232239e0c3d91806f3c97d5/src/matlab/rgb2gray.ts#L56\n  return 77 * r + 150 * g + 29 * b + 128 >> 8;\n}\n\n// Percieved color difference defined by CIE94.\n// See https://en.wikipedia.org/wiki/Color_difference#CIE94\n//\n// The result of 1.0 is a \"just-noticiable difference\".\n//\n// Other results interpretation (taken from http://zschuessler.github.io/DeltaE/learn/):\n//   < 1.0     Not perceptible by human eyes.\n//   1-2        Perceptible through close observation.\n//   2-10       Perceptible at a glance.\n//   11-49      Colors are more similar than opposite\n//   100        Colors are exact opposite\nfunction colorDeltaE94(rgb1, rgb2) {\n  const [l1, a1, b1] = xyz2lab(srgb2xyz(rgb1));\n  const [l2, a2, b2] = xyz2lab(srgb2xyz(rgb2));\n  const deltaL = l1 - l2;\n  const deltaA = a1 - a2;\n  const deltaB = b1 - b2;\n  const c1 = Math.sqrt(a1 ** 2 + b1 ** 2);\n  const c2 = Math.sqrt(a2 ** 2 + b2 ** 2);\n  const deltaC = c1 - c2;\n  let deltaH = deltaA ** 2 + deltaB ** 2 - deltaC ** 2;\n  deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n  // The k1, k2, kL, kC, kH values for \"graphic arts\" applications.\n  // See https://en.wikipedia.org/wiki/Color_difference#CIE94\n  const k1 = 0.045;\n  const k2 = 0.015;\n  const kL = 1;\n  const kC = 1;\n  const kH = 1;\n  const sC = 1.0 + k1 * c1;\n  const sH = 1.0 + k2 * c1;\n  const sL = 1;\n  return Math.sqrt((deltaL / sL / kL) ** 2 + (deltaC / sC / kC) ** 2 + (deltaH / sH / kH) ** 2);\n}\n\n// sRGB -> 1-normalized XYZ (i.e. Y ∈ [0, 1]) with D65 illuminant\n// See https://en.wikipedia.org/wiki/SRGB#From_sRGB_to_CIE_XYZ\nfunction srgb2xyz(rgb) {\n  let r = rgb[0] / 255;\n  let g = rgb[1] / 255;\n  let b = rgb[2] / 255;\n  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n  return [r * 0.4124 + g * 0.3576 + b * 0.1805, r * 0.2126 + g * 0.7152 + b * 0.0722, r * 0.0193 + g * 0.1192 + b * 0.9505];\n}\nconst sigma_pow2 = 6 * 6 / 29 / 29;\nconst sigma_pow3 = 6 * 6 * 6 / 29 / 29 / 29;\n\n// 1-normalized CIE XYZ with D65 to L*a*b*\n// See https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB\nfunction xyz2lab(xyz) {\n  const x = xyz[0] / 0.950489;\n  const y = xyz[1];\n  const z = xyz[2] / 1.088840;\n  const fx = x > sigma_pow3 ? x ** (1 / 3) : x / 3 / sigma_pow2 + 4 / 29;\n  const fy = y > sigma_pow3 ? y ** (1 / 3) : y / 3 / sigma_pow2 + 4 / 29;\n  const fz = z > sigma_pow3 ? z ** (1 / 3) : z / 3 / sigma_pow2 + 4 / 29;\n  const l = 116 * fy - 16;\n  const a = 500 * (fx - fy);\n  const b = 200 * (fy - fz);\n  return [l, a, b];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compare = compare;\nvar _colorUtils = require(\"./colorUtils\");\nvar _imageChannel = require(\"./imageChannel\");\nvar _stats = require(\"./stats\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst SSIM_WINDOW_RADIUS = 15;\nconst VARIANCE_WINDOW_RADIUS = 1;\nfunction drawPixel(width, data, x, y, r, g, b) {\n  const idx = (y * width + x) * 4;\n  data[idx + 0] = r;\n  data[idx + 1] = g;\n  data[idx + 2] = b;\n  data[idx + 3] = 255;\n}\nfunction compare(actual, expected, diff, width, height, options = {}) {\n  const {\n    maxColorDeltaE94 = 1.0\n  } = options;\n  const paddingSize = Math.max(VARIANCE_WINDOW_RADIUS, SSIM_WINDOW_RADIUS);\n  const paddingColorEven = [255, 0, 255];\n  const paddingColorOdd = [0, 255, 0];\n  const [r1, g1, b1] = _imageChannel.ImageChannel.intoRGB(width, height, expected, {\n    paddingSize,\n    paddingColorEven,\n    paddingColorOdd\n  });\n  const [r2, g2, b2] = _imageChannel.ImageChannel.intoRGB(width, height, actual, {\n    paddingSize,\n    paddingColorEven,\n    paddingColorOdd\n  });\n  const noop = (x, y) => {};\n  const drawRedPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 0, 0) : noop;\n  const drawYellowPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 255, 0) : noop;\n  const drawGrayPixel = diff ? (x, y) => {\n    const gray = (0, _colorUtils.rgb2gray)(r1.get(x, y), g1.get(x, y), b1.get(x, y));\n    const value = (0, _colorUtils.blendWithWhite)(gray, 0.1);\n    drawPixel(width, diff, x - paddingSize, y - paddingSize, value, value, value);\n  } : noop;\n  let fastR, fastG, fastB;\n  let diffCount = 0;\n  for (let y = paddingSize; y < r1.height - paddingSize; ++y) {\n    for (let x = paddingSize; x < r1.width - paddingSize; ++x) {\n      // Fast-path: equal pixels.\n      if (r1.get(x, y) === r2.get(x, y) && g1.get(x, y) === g2.get(x, y) && b1.get(x, y) === b2.get(x, y)) {\n        drawGrayPixel(x, y);\n        continue;\n      }\n\n      // Compare pixel colors using the dE94 color difference formulae.\n      // The dE94 is normalized so that the value of 1.0 is the \"just-noticeable-difference\".\n      // Color difference below 1.0 is not noticeable to a human eye, so we can disregard it.\n      // See https://en.wikipedia.org/wiki/Color_difference\n      const delta = (0, _colorUtils.colorDeltaE94)([r1.get(x, y), g1.get(x, y), b1.get(x, y)], [r2.get(x, y), g2.get(x, y), b2.get(x, y)]);\n      if (delta <= maxColorDeltaE94) {\n        drawGrayPixel(x, y);\n        continue;\n      }\n\n      // if this pixel is a part of a flood fill of a 3x3 square then it cannot be\n      // anti-aliasing pixel so it must be a pixel difference.\n      if (!fastR || !fastG || !fastB) {\n        fastR = new _stats.FastStats(r1, r2);\n        fastG = new _stats.FastStats(g1, g2);\n        fastB = new _stats.FastStats(b1, b2);\n      }\n      const [varX1, varY1] = r1.boundXY(x - VARIANCE_WINDOW_RADIUS, y - VARIANCE_WINDOW_RADIUS);\n      const [varX2, varY2] = r1.boundXY(x + VARIANCE_WINDOW_RADIUS, y + VARIANCE_WINDOW_RADIUS);\n      const var1 = fastR.varianceC1(varX1, varY1, varX2, varY2) + fastG.varianceC1(varX1, varY1, varX2, varY2) + fastB.varianceC1(varX1, varY1, varX2, varY2);\n      const var2 = fastR.varianceC2(varX1, varY1, varX2, varY2) + fastG.varianceC2(varX1, varY1, varX2, varY2) + fastB.varianceC2(varX1, varY1, varX2, varY2);\n      if (var1 === 0 && var2 === 0) {\n        drawRedPixel(x, y);\n        ++diffCount;\n        continue;\n      }\n      const [ssimX1, ssimY1] = r1.boundXY(x - SSIM_WINDOW_RADIUS, y - SSIM_WINDOW_RADIUS);\n      const [ssimX2, ssimY2] = r1.boundXY(x + SSIM_WINDOW_RADIUS, y + SSIM_WINDOW_RADIUS);\n      const ssimRGB = ((0, _stats.ssim)(fastR, ssimX1, ssimY1, ssimX2, ssimY2) + (0, _stats.ssim)(fastG, ssimX1, ssimY1, ssimX2, ssimY2) + (0, _stats.ssim)(fastB, ssimX1, ssimY1, ssimX2, ssimY2)) / 3.0;\n      const isAntialiassed = ssimRGB >= 0.99;\n      if (isAntialiassed) {\n        drawYellowPixel(x, y);\n      } else {\n        drawRedPixel(x, y);\n        ++diffCount;\n      }\n    }\n  }\n  return diffCount;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImageChannel = void 0;\nvar _colorUtils = require(\"./colorUtils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ImageChannel {\n  static intoRGB(width, height, data, options = {}) {\n    const {\n      paddingSize = 0,\n      paddingColorOdd = [255, 0, 255],\n      paddingColorEven = [0, 255, 0]\n    } = options;\n    const newWidth = width + 2 * paddingSize;\n    const newHeight = height + 2 * paddingSize;\n    const r = new Uint8Array(newWidth * newHeight);\n    const g = new Uint8Array(newWidth * newHeight);\n    const b = new Uint8Array(newWidth * newHeight);\n    for (let y = 0; y < newHeight; ++y) {\n      for (let x = 0; x < newWidth; ++x) {\n        const index = y * newWidth + x;\n        if (y >= paddingSize && y < newHeight - paddingSize && x >= paddingSize && x < newWidth - paddingSize) {\n          const offset = ((y - paddingSize) * width + (x - paddingSize)) * 4;\n          const alpha = data[offset + 3] === 255 ? 1 : data[offset + 3] / 255;\n          r[index] = (0, _colorUtils.blendWithWhite)(data[offset], alpha);\n          g[index] = (0, _colorUtils.blendWithWhite)(data[offset + 1], alpha);\n          b[index] = (0, _colorUtils.blendWithWhite)(data[offset + 2], alpha);\n        } else {\n          const color = (y + x) % 2 === 0 ? paddingColorEven : paddingColorOdd;\n          r[index] = color[0];\n          g[index] = color[1];\n          b[index] = color[2];\n        }\n      }\n    }\n    return [new ImageChannel(newWidth, newHeight, r), new ImageChannel(newWidth, newHeight, g), new ImageChannel(newWidth, newHeight, b)];\n  }\n  constructor(width, height, data) {\n    this.data = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.data = data;\n    this.width = width;\n    this.height = height;\n  }\n  get(x, y) {\n    return this.data[y * this.width + x];\n  }\n  boundXY(x, y) {\n    return [Math.min(Math.max(x, 0), this.width - 1), Math.min(Math.max(y, 0), this.height - 1)];\n  }\n}\nexports.ImageChannel = ImageChannel;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FastStats = void 0;\nexports.ssim = ssim;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Image channel has a 8-bit depth.\nconst DYNAMIC_RANGE = 2 ** 8 - 1;\nfunction ssim(stats, x1, y1, x2, y2) {\n  const mean1 = stats.meanC1(x1, y1, x2, y2);\n  const mean2 = stats.meanC2(x1, y1, x2, y2);\n  const var1 = stats.varianceC1(x1, y1, x2, y2);\n  const var2 = stats.varianceC2(x1, y1, x2, y2);\n  const cov = stats.covariance(x1, y1, x2, y2);\n  const c1 = (0.01 * DYNAMIC_RANGE) ** 2;\n  const c2 = (0.03 * DYNAMIC_RANGE) ** 2;\n  return (2 * mean1 * mean2 + c1) * (2 * cov + c2) / (mean1 ** 2 + mean2 ** 2 + c1) / (var1 + var2 + c2);\n}\nclass FastStats {\n  constructor(c1, c2) {\n    this.c1 = void 0;\n    this.c2 = void 0;\n    this._partialSumC1 = void 0;\n    this._partialSumC2 = void 0;\n    this._partialSumMult = void 0;\n    this._partialSumSq1 = void 0;\n    this._partialSumSq2 = void 0;\n    this.c1 = c1;\n    this.c2 = c2;\n    const {\n      width,\n      height\n    } = c1;\n    this._partialSumC1 = new Array(width * height);\n    this._partialSumC2 = new Array(width * height);\n    this._partialSumSq1 = new Array(width * height);\n    this._partialSumSq2 = new Array(width * height);\n    this._partialSumMult = new Array(width * height);\n    const recalc = (mx, idx, initial, x, y) => {\n      mx[idx] = initial;\n      if (y > 0) mx[idx] += mx[(y - 1) * width + x];\n      if (x > 0) mx[idx] += mx[y * width + x - 1];\n      if (x > 0 && y > 0) mx[idx] -= mx[(y - 1) * width + x - 1];\n    };\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        const idx = y * width + x;\n        recalc(this._partialSumC1, idx, this.c1.data[idx], x, y);\n        recalc(this._partialSumC2, idx, this.c2.data[idx], x, y);\n        recalc(this._partialSumSq1, idx, this.c1.data[idx] * this.c1.data[idx], x, y);\n        recalc(this._partialSumSq2, idx, this.c2.data[idx] * this.c2.data[idx], x, y);\n        recalc(this._partialSumMult, idx, this.c1.data[idx] * this.c2.data[idx], x, y);\n      }\n    }\n  }\n  _sum(partialSum, x1, y1, x2, y2) {\n    const width = this.c1.width;\n    let result = partialSum[y2 * width + x2];\n    if (y1 > 0) result -= partialSum[(y1 - 1) * width + x2];\n    if (x1 > 0) result -= partialSum[y2 * width + x1 - 1];\n    if (x1 > 0 && y1 > 0) result += partialSum[(y1 - 1) * width + x1 - 1];\n    return result;\n  }\n  meanC1(x1, y1, x2, y2) {\n    const N = (y2 - y1 + 1) * (x2 - x1 + 1);\n    return this._sum(this._partialSumC1, x1, y1, x2, y2) / N;\n  }\n  meanC2(x1, y1, x2, y2) {\n    const N = (y2 - y1 + 1) * (x2 - x1 + 1);\n    return this._sum(this._partialSumC2, x1, y1, x2, y2) / N;\n  }\n  varianceC1(x1, y1, x2, y2) {\n    const N = (y2 - y1 + 1) * (x2 - x1 + 1);\n    return (this._sum(this._partialSumSq1, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) ** 2 / N) / N;\n  }\n  varianceC2(x1, y1, x2, y2) {\n    const N = (y2 - y1 + 1) * (x2 - x1 + 1);\n    return (this._sum(this._partialSumSq2, x1, y1, x2, y2) - this._sum(this._partialSumC2, x1, y1, x2, y2) ** 2 / N) / N;\n  }\n  covariance(x1, y1, x2, y2) {\n    const N = (y2 - y1 + 1) * (x2 - x1 + 1);\n    return (this._sum(this._partialSumMult, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) * this._sum(this._partialSumC2, x1, y1, x2, y2) / N) / N;\n  }\n}\nexports.FastStats = FastStats;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInProcessPlaywright = createInProcessPlaywright;\nvar _server = require(\"./server\");\nvar _connection = require(\"./client/connection\");\nvar _browserServerImpl = require(\"./browserServerImpl\");\nvar _androidServerImpl = require(\"./androidServerImpl\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction createInProcessPlaywright() {\n  const playwright = (0, _server.createPlaywright)(process.env.PW_LANG_NAME || 'javascript');\n  const clientConnection = new _connection.Connection();\n  const dispatcherConnection = new _server.DispatcherConnection(true /* local */);\n\n  // Dispatch synchronously at first.\n  dispatcherConnection.onmessage = message => clientConnection.dispatch(message);\n  clientConnection.onmessage = message => dispatcherConnection.dispatch(message);\n  const rootScope = new _server.RootDispatcher(dispatcherConnection);\n\n  // Initialize Playwright channel.\n  new _server.PlaywrightDispatcher(rootScope, playwright);\n  const playwrightAPI = clientConnection.getObjectWithKnownName('Playwright');\n  playwrightAPI.chromium._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl('chromium');\n  playwrightAPI.firefox._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl('firefox');\n  playwrightAPI.webkit._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl('webkit');\n  playwrightAPI._android._serverLauncher = new _androidServerImpl.AndroidServerLauncherImpl();\n\n  // Switch to async dispatch after we got Playwright object.\n  dispatcherConnection.onmessage = message => setImmediate(() => clientConnection.dispatch(message));\n  clientConnection.onmessage = message => setImmediate(() => dispatcherConnection.dispatch(message));\n  clientConnection.toImpl = x => x ? dispatcherConnection._dispatchers.get(x._guid)._object : dispatcherConnection._dispatchers.get('');\n  playwrightAPI._toImpl = clientConnection.toImpl;\n  return playwrightAPI;\n}","\"use strict\";\n\nvar _inProcessFactory = require(\"./inProcessFactory\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nmodule.exports = (0, _inProcessFactory.createInProcessPlaywright)();","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pausesBeforeInputActions = exports.commandsWithTracingSnapshots = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This file is generated by generate_channels.js, do not edit manually.\n\nconst commandsWithTracingSnapshots = new Set(['EventTarget.waitForEventInfo', 'BrowserContext.waitForEventInfo', 'Page.waitForEventInfo', 'WebSocket.waitForEventInfo', 'ElectronApplication.waitForEventInfo', 'AndroidDevice.waitForEventInfo', 'Page.emulateMedia', 'Page.goBack', 'Page.goForward', 'Page.reload', 'Page.expectScreenshot', 'Page.screenshot', 'Page.setViewportSize', 'Page.keyboardDown', 'Page.keyboardUp', 'Page.keyboardInsertText', 'Page.keyboardType', 'Page.keyboardPress', 'Page.mouseMove', 'Page.mouseDown', 'Page.mouseUp', 'Page.mouseClick', 'Page.mouseWheel', 'Page.touchscreenTap', 'Frame.evalOnSelector', 'Frame.evalOnSelectorAll', 'Frame.addScriptTag', 'Frame.addStyleTag', 'Frame.blur', 'Frame.check', 'Frame.click', 'Frame.dragAndDrop', 'Frame.dblclick', 'Frame.dispatchEvent', 'Frame.evaluateExpression', 'Frame.evaluateExpressionHandle', 'Frame.fill', 'Frame.focus', 'Frame.getAttribute', 'Frame.goto', 'Frame.hover', 'Frame.innerHTML', 'Frame.innerText', 'Frame.inputValue', 'Frame.isChecked', 'Frame.isDisabled', 'Frame.isEnabled', 'Frame.isHidden', 'Frame.isVisible', 'Frame.isEditable', 'Frame.press', 'Frame.selectOption', 'Frame.setContent', 'Frame.setInputFiles', 'Frame.setInputFilePaths', 'Frame.tap', 'Frame.textContent', 'Frame.type', 'Frame.uncheck', 'Frame.waitForTimeout', 'Frame.waitForFunction', 'Frame.waitForSelector', 'Frame.expect', 'JSHandle.evaluateExpression', 'ElementHandle.evaluateExpression', 'JSHandle.evaluateExpressionHandle', 'ElementHandle.evaluateExpressionHandle', 'ElementHandle.evalOnSelector', 'ElementHandle.evalOnSelectorAll', 'ElementHandle.check', 'ElementHandle.click', 'ElementHandle.dblclick', 'ElementHandle.dispatchEvent', 'ElementHandle.fill', 'ElementHandle.focus', 'ElementHandle.hover', 'ElementHandle.innerHTML', 'ElementHandle.innerText', 'ElementHandle.inputValue', 'ElementHandle.isChecked', 'ElementHandle.isDisabled', 'ElementHandle.isEditable', 'ElementHandle.isEnabled', 'ElementHandle.isHidden', 'ElementHandle.isVisible', 'ElementHandle.press', 'ElementHandle.screenshot', 'ElementHandle.scrollIntoViewIfNeeded', 'ElementHandle.selectOption', 'ElementHandle.selectText', 'ElementHandle.setInputFiles', 'ElementHandle.setInputFilePaths', 'ElementHandle.tap', 'ElementHandle.textContent', 'ElementHandle.type', 'ElementHandle.uncheck', 'ElementHandle.waitForElementState', 'ElementHandle.waitForSelector']);\nexports.commandsWithTracingSnapshots = commandsWithTracingSnapshots;\nconst pausesBeforeInputActions = new Set(['Frame.check', 'Frame.click', 'Frame.dragAndDrop', 'Frame.dblclick', 'Frame.fill', 'Frame.hover', 'Frame.press', 'Frame.selectOption', 'Frame.setInputFiles', 'Frame.setInputFilePaths', 'Frame.tap', 'Frame.type', 'Frame.uncheck', 'ElementHandle.check', 'ElementHandle.click', 'ElementHandle.dblclick', 'ElementHandle.fill', 'ElementHandle.hover', 'ElementHandle.press', 'ElementHandle.selectOption', 'ElementHandle.setInputFiles', 'ElementHandle.setInputFilePaths', 'ElementHandle.tap', 'ElementHandle.type', 'ElementHandle.uncheck']);\nexports.pausesBeforeInputActions = pausesBeforeInputActions;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseError = parseError;\nexports.parseSerializedValue = parseSerializedValue;\nexports.serializeError = serializeError;\nexports.serializeValue = serializeValue;\nvar _errors = require(\"../common/errors\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction serializeError(e) {\n  if (isError(e)) return {\n    error: {\n      message: e.message,\n      stack: e.stack,\n      name: e.name\n    }\n  };\n  return {\n    value: serializeValue(e, value => ({\n      fallThrough: value\n    }))\n  };\n}\nfunction parseError(error) {\n  if (!error.error) {\n    if (error.value === undefined) throw new Error('Serialized error must have either an error or a value');\n    return parseSerializedValue(error.value, undefined);\n  }\n  if (error.error.name === 'TimeoutError') {\n    const e = new _errors.TimeoutError(error.error.message);\n    e.stack = error.error.stack || '';\n    return e;\n  }\n  const e = new Error(error.error.message);\n  e.stack = error.error.stack || '';\n  e.name = error.error.name;\n  return e;\n}\nfunction parseSerializedValue(value, handles) {\n  return innerParseSerializedValue(value, handles, new Map());\n}\nfunction innerParseSerializedValue(value, handles, refs) {\n  if (value.ref !== undefined) return refs.get(value.ref);\n  if (value.n !== undefined) return value.n;\n  if (value.s !== undefined) return value.s;\n  if (value.b !== undefined) return value.b;\n  if (value.v !== undefined) {\n    if (value.v === 'undefined') return undefined;\n    if (value.v === 'null') return null;\n    if (value.v === 'NaN') return NaN;\n    if (value.v === 'Infinity') return Infinity;\n    if (value.v === '-Infinity') return -Infinity;\n    if (value.v === '-0') return -0;\n  }\n  if (value.d !== undefined) return new Date(value.d);\n  if (value.u !== undefined) return new URL(value.u);\n  if (value.r !== undefined) return new RegExp(value.r.p, value.r.f);\n  if (value.a !== undefined) {\n    const result = [];\n    refs.set(value.id, result);\n    for (const v of value.a) result.push(innerParseSerializedValue(v, handles, refs));\n    return result;\n  }\n  if (value.o !== undefined) {\n    const result = {};\n    refs.set(value.id, result);\n    for (const {\n      k,\n      v\n    } of value.o) result[k] = innerParseSerializedValue(v, handles, refs);\n    return result;\n  }\n  if (value.h !== undefined) {\n    if (handles === undefined) throw new Error('Unexpected handle');\n    return handles[value.h];\n  }\n  throw new Error('Unexpected value');\n}\nfunction serializeValue(value, handleSerializer) {\n  return innerSerializeValue(value, handleSerializer, {\n    lastId: 0,\n    visited: new Map()\n  });\n}\nfunction innerSerializeValue(value, handleSerializer, visitorInfo) {\n  const handle = handleSerializer(value);\n  if ('fallThrough' in handle) value = handle.fallThrough;else return handle;\n  if (typeof value === 'symbol') return {\n    v: 'undefined'\n  };\n  if (Object.is(value, undefined)) return {\n    v: 'undefined'\n  };\n  if (Object.is(value, null)) return {\n    v: 'null'\n  };\n  if (Object.is(value, NaN)) return {\n    v: 'NaN'\n  };\n  if (Object.is(value, Infinity)) return {\n    v: 'Infinity'\n  };\n  if (Object.is(value, -Infinity)) return {\n    v: '-Infinity'\n  };\n  if (Object.is(value, -0)) return {\n    v: '-0'\n  };\n  if (typeof value === 'boolean') return {\n    b: value\n  };\n  if (typeof value === 'number') return {\n    n: value\n  };\n  if (typeof value === 'string') return {\n    s: value\n  };\n  if (isError(value)) {\n    const error = value;\n    if ('captureStackTrace' in globalThis.Error) {\n      // v8\n      return {\n        s: error.stack || ''\n      };\n    }\n    return {\n      s: `${error.name}: ${error.message}\\n${error.stack}`\n    };\n  }\n  if (isDate(value)) return {\n    d: value.toJSON()\n  };\n  if (isURL(value)) return {\n    u: value.toJSON()\n  };\n  if (isRegExp(value)) return {\n    r: {\n      p: value.source,\n      f: value.flags\n    }\n  };\n  const id = visitorInfo.visited.get(value);\n  if (id) return {\n    ref: id\n  };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id);\n    for (let i = 0; i < value.length; ++i) a.push(innerSerializeValue(value[i], handleSerializer, visitorInfo));\n    return {\n      a,\n      id\n    };\n  }\n  if (typeof value === 'object') {\n    const o = [];\n    const id = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id);\n    for (const name of Object.keys(value)) o.push({\n      k: name,\n      v: innerSerializeValue(value[name], handleSerializer, visitorInfo)\n    });\n    return {\n      o,\n      id\n    };\n  }\n  throw new Error('Unexpected value');\n}\nfunction isRegExp(obj) {\n  return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nfunction isDate(obj) {\n  return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';\n}\nfunction isURL(obj) {\n  return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';\n}\nfunction isError(obj) {\n  const proto = obj ? Object.getPrototypeOf(obj) : null;\n  return obj instanceof Error || (proto === null || proto === void 0 ? void 0 : proto.name) === 'Error' || proto && isError(proto);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PipeTransport = exports.IpcTransport = void 0;\nvar _utils = require(\"../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass PipeTransport {\n  constructor(pipeWrite, pipeRead, closeable, endian = 'le') {\n    this._pipeWrite = void 0;\n    this._data = Buffer.from([]);\n    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();\n    this._closed = false;\n    this._bytesLeft = 0;\n    this.onmessage = void 0;\n    this.onclose = void 0;\n    this._endian = void 0;\n    this._closeableStream = void 0;\n    this._pipeWrite = pipeWrite;\n    this._endian = endian;\n    this._closeableStream = closeable;\n    pipeRead.on('data', buffer => this._dispatch(buffer));\n    pipeRead.on('close', () => {\n      this._closed = true;\n      if (this.onclose) this.onclose();\n    });\n    this.onmessage = undefined;\n    this.onclose = undefined;\n  }\n  send(message) {\n    if (this._closed) throw new Error('Pipe has been closed');\n    const data = Buffer.from(message, 'utf-8');\n    const dataLength = Buffer.alloc(4);\n    if (this._endian === 'be') dataLength.writeUInt32BE(data.length, 0);else dataLength.writeUInt32LE(data.length, 0);\n    this._pipeWrite.write(dataLength);\n    this._pipeWrite.write(data);\n  }\n  close() {\n    // Let it throw.\n    this._closeableStream.close();\n  }\n  _dispatch(buffer) {\n    this._data = Buffer.concat([this._data, buffer]);\n    while (true) {\n      if (!this._bytesLeft && this._data.length < 4) {\n        // Need more data.\n        break;\n      }\n      if (!this._bytesLeft) {\n        this._bytesLeft = this._endian === 'be' ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);\n        this._data = this._data.slice(4);\n      }\n      if (!this._bytesLeft || this._data.length < this._bytesLeft) {\n        // Need more data.\n        break;\n      }\n      const message = this._data.slice(0, this._bytesLeft);\n      this._data = this._data.slice(this._bytesLeft);\n      this._bytesLeft = 0;\n      this._waitForNextTask(() => {\n        if (this.onmessage) this.onmessage(message.toString('utf-8'));\n      });\n    }\n  }\n}\nexports.PipeTransport = PipeTransport;\nclass IpcTransport {\n  constructor(process) {\n    this._process = void 0;\n    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();\n    this.onmessage = void 0;\n    this.onclose = void 0;\n    this._process = process;\n    this._process.on('message', message => this._waitForNextTask(() => {\n      var _this$onclose, _this$onmessage;\n      if (message === '<eof>') (_this$onclose = this.onclose) === null || _this$onclose === void 0 ? void 0 : _this$onclose.call(this);else (_this$onmessage = this.onmessage) === null || _this$onmessage === void 0 ? void 0 : _this$onmessage.call(this, message);\n    }));\n  }\n  send(message) {\n    this._process.send(message);\n  }\n  close() {\n    this._process.send('<eof>');\n  }\n}\nexports.IpcTransport = IpcTransport;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ValidationError\", {\n  enumerable: true,\n  get: function () {\n    return _validatorPrimitives.ValidationError;\n  }\n});\nObject.defineProperty(exports, \"createMetadataValidator\", {\n  enumerable: true,\n  get: function () {\n    return _validatorPrimitives.createMetadataValidator;\n  }\n});\nObject.defineProperty(exports, \"findValidator\", {\n  enumerable: true,\n  get: function () {\n    return _validatorPrimitives.findValidator;\n  }\n});\nObject.defineProperty(exports, \"maybeFindValidator\", {\n  enumerable: true,\n  get: function () {\n    return _validatorPrimitives.maybeFindValidator;\n  }\n});\nvar _validatorPrimitives = require(\"./validatorPrimitives\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This file is generated by generate_channels.js, do not edit manually.\n\n_validatorPrimitives.scheme.StackFrame = (0, _validatorPrimitives.tObject)({\n  file: _validatorPrimitives.tString,\n  line: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  column: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  function: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.Metadata = (0, _validatorPrimitives.tObject)({\n  stack: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('StackFrame'))),\n  apiName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  internal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.Point = (0, _validatorPrimitives.tObject)({\n  x: _validatorPrimitives.tNumber,\n  y: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.Rect = (0, _validatorPrimitives.tObject)({\n  x: _validatorPrimitives.tNumber,\n  y: _validatorPrimitives.tNumber,\n  width: _validatorPrimitives.tNumber,\n  height: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.SerializedValue = (0, _validatorPrimitives.tObject)({\n  n: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  b: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  s: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  v: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['null', 'undefined', 'NaN', 'Infinity', '-Infinity', '-0'])),\n  d: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  u: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  r: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    p: _validatorPrimitives.tString,\n    f: _validatorPrimitives.tString\n  })),\n  a: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SerializedValue'))),\n  o: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    k: _validatorPrimitives.tString,\n    v: (0, _validatorPrimitives.tType)('SerializedValue')\n  }))),\n  h: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  id: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  ref: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.SerializedArgument = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue'),\n  handles: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)('*'))\n});\n_validatorPrimitives.scheme.ExpectedTextValue = (0, _validatorPrimitives.tObject)({\n  string: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  matchSubstring: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  ignoreCase: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  normalizeWhiteSpace: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.AXNode = (0, _validatorPrimitives.tObject)({\n  role: _validatorPrimitives.tString,\n  name: _validatorPrimitives.tString,\n  valueString: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  valueNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  description: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  keyshortcuts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  roledescription: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  valuetext: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  disabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  expanded: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  multiline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  multiselectable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  readonly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  required: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  checked: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['checked', 'unchecked', 'mixed'])),\n  pressed: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['pressed', 'released', 'mixed'])),\n  level: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  valuemin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  valuemax: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  autocomplete: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  haspopup: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  invalid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  orientation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('AXNode')))\n});\n_validatorPrimitives.scheme.SetNetworkCookie = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  value: _validatorPrimitives.tString,\n  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  domain: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  expires: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  httpOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  secure: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  sameSite: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['Strict', 'Lax', 'None']))\n});\n_validatorPrimitives.scheme.NetworkCookie = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  value: _validatorPrimitives.tString,\n  domain: _validatorPrimitives.tString,\n  path: _validatorPrimitives.tString,\n  expires: _validatorPrimitives.tNumber,\n  httpOnly: _validatorPrimitives.tBoolean,\n  secure: _validatorPrimitives.tBoolean,\n  sameSite: (0, _validatorPrimitives.tEnum)(['Strict', 'Lax', 'None'])\n});\n_validatorPrimitives.scheme.NameValue = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.OriginStorage = (0, _validatorPrimitives.tObject)({\n  origin: _validatorPrimitives.tString,\n  localStorage: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.SerializedError = (0, _validatorPrimitives.tObject)({\n  error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    message: _validatorPrimitives.tString,\n    name: _validatorPrimitives.tString,\n    stack: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })),\n  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedValue'))\n});\n_validatorPrimitives.scheme.RecordHarOptions = (0, _validatorPrimitives.tObject)({\n  path: _validatorPrimitives.tString,\n  content: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['embed', 'attach', 'omit'])),\n  mode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['full', 'minimal'])),\n  urlGlob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  urlRegexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  urlRegexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FormField = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  file: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    name: _validatorPrimitives.tString,\n    mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    buffer: _validatorPrimitives.tBinary\n  }))\n});\n_validatorPrimitives.scheme.APIRequestContextInitializer = (0, _validatorPrimitives.tObject)({\n  tracing: (0, _validatorPrimitives.tChannel)(['Tracing'])\n});\n_validatorPrimitives.scheme.APIRequestContextFetchParams = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString,\n  params: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  jsonData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),\n  formData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  multipartData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('FormField'))),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  failOnStatusCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  maxRedirects: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.APIRequestContextFetchResult = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tType)('APIResponse')\n});\n_validatorPrimitives.scheme.APIRequestContextFetchResponseBodyParams = (0, _validatorPrimitives.tObject)({\n  fetchUid: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.APIRequestContextFetchResponseBodyResult = (0, _validatorPrimitives.tObject)({\n  binary: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)\n});\n_validatorPrimitives.scheme.APIRequestContextFetchLogParams = (0, _validatorPrimitives.tObject)({\n  fetchUid: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.APIRequestContextFetchLogResult = (0, _validatorPrimitives.tObject)({\n  log: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.APIRequestContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.APIRequestContextStorageStateResult = (0, _validatorPrimitives.tObject)({\n  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie')),\n  origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage'))\n});\n_validatorPrimitives.scheme.APIRequestContextDisposeAPIResponseParams = (0, _validatorPrimitives.tObject)({\n  fetchUid: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.APIRequestContextDisposeAPIResponseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.APIRequestContextDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.APIRequestContextDisposeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.APIResponse = (0, _validatorPrimitives.tObject)({\n  fetchUid: _validatorPrimitives.tString,\n  url: _validatorPrimitives.tString,\n  status: _validatorPrimitives.tNumber,\n  statusText: _validatorPrimitives.tString,\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.LifecycleEvent = (0, _validatorPrimitives.tEnum)(['load', 'domcontentloaded', 'networkidle', 'commit']);\n_validatorPrimitives.scheme.LocalUtilsInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.LocalUtilsZipParams = (0, _validatorPrimitives.tObject)({\n  zipFile: _validatorPrimitives.tString,\n  entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.LocalUtilsZipResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.LocalUtilsHarOpenParams = (0, _validatorPrimitives.tObject)({\n  file: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.LocalUtilsHarOpenResult = (0, _validatorPrimitives.tObject)({\n  harId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.LocalUtilsHarLookupParams = (0, _validatorPrimitives.tObject)({\n  harId: _validatorPrimitives.tString,\n  url: _validatorPrimitives.tString,\n  method: _validatorPrimitives.tString,\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')),\n  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  isNavigationRequest: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.LocalUtilsHarLookupResult = (0, _validatorPrimitives.tObject)({\n  action: (0, _validatorPrimitives.tEnum)(['error', 'redirect', 'fulfill', 'noentry']),\n  message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  redirectURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)\n});\n_validatorPrimitives.scheme.LocalUtilsHarCloseParams = (0, _validatorPrimitives.tObject)({\n  harId: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.LocalUtilsHarCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.LocalUtilsHarUnzipParams = (0, _validatorPrimitives.tObject)({\n  zipFile: _validatorPrimitives.tString,\n  harFile: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.LocalUtilsHarUnzipResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.LocalUtilsConnectParams = (0, _validatorPrimitives.tObject)({\n  wsEndpoint: _validatorPrimitives.tString,\n  headers: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),\n  exposeNetwork: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  socksProxyRedirectPortForTest: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.LocalUtilsConnectResult = (0, _validatorPrimitives.tObject)({\n  pipe: (0, _validatorPrimitives.tChannel)(['JsonPipe'])\n});\n_validatorPrimitives.scheme.RootInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.RootInitializeParams = (0, _validatorPrimitives.tObject)({\n  sdkLanguage: (0, _validatorPrimitives.tEnum)(['javascript', 'python', 'java', 'csharp'])\n});\n_validatorPrimitives.scheme.RootInitializeResult = (0, _validatorPrimitives.tObject)({\n  playwright: (0, _validatorPrimitives.tChannel)(['Playwright'])\n});\n_validatorPrimitives.scheme.PlaywrightInitializer = (0, _validatorPrimitives.tObject)({\n  chromium: (0, _validatorPrimitives.tChannel)(['BrowserType']),\n  firefox: (0, _validatorPrimitives.tChannel)(['BrowserType']),\n  webkit: (0, _validatorPrimitives.tChannel)(['BrowserType']),\n  android: (0, _validatorPrimitives.tChannel)(['Android']),\n  electron: (0, _validatorPrimitives.tChannel)(['Electron']),\n  utils: (0, _validatorPrimitives.tChannel)(['LocalUtils']),\n  deviceDescriptors: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    name: _validatorPrimitives.tString,\n    descriptor: (0, _validatorPrimitives.tObject)({\n      userAgent: _validatorPrimitives.tString,\n      viewport: (0, _validatorPrimitives.tObject)({\n        width: _validatorPrimitives.tNumber,\n        height: _validatorPrimitives.tNumber\n      }),\n      screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n        width: _validatorPrimitives.tNumber,\n        height: _validatorPrimitives.tNumber\n      })),\n      deviceScaleFactor: _validatorPrimitives.tNumber,\n      isMobile: _validatorPrimitives.tBoolean,\n      hasTouch: _validatorPrimitives.tBoolean,\n      defaultBrowserType: (0, _validatorPrimitives.tEnum)(['chromium', 'firefox', 'webkit'])\n    })\n  })),\n  selectors: (0, _validatorPrimitives.tChannel)(['Selectors']),\n  preLaunchedBrowser: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Browser'])),\n  preConnectedAndroidDevice: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['AndroidDevice'])),\n  socksSupport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['SocksSupport']))\n});\n_validatorPrimitives.scheme.PlaywrightNewRequestParams = (0, _validatorPrimitives.tObject)({\n  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  })),\n  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    server: _validatorPrimitives.tString,\n    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie')),\n    origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage'))\n  })),\n  tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.PlaywrightNewRequestResult = (0, _validatorPrimitives.tObject)({\n  request: (0, _validatorPrimitives.tChannel)(['APIRequestContext'])\n});\n_validatorPrimitives.scheme.RecorderSource = (0, _validatorPrimitives.tObject)({\n  isRecorded: _validatorPrimitives.tBoolean,\n  id: _validatorPrimitives.tString,\n  label: _validatorPrimitives.tString,\n  text: _validatorPrimitives.tString,\n  language: _validatorPrimitives.tString,\n  highlight: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    line: _validatorPrimitives.tNumber,\n    type: _validatorPrimitives.tString\n  })),\n  revealLine: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  group: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.DebugControllerInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerInspectRequestedEvent = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  locator: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.DebugControllerStateChangedEvent = (0, _validatorPrimitives.tObject)({\n  pageCount: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.DebugControllerSourceChangedEvent = (0, _validatorPrimitives.tObject)({\n  text: _validatorPrimitives.tString,\n  header: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  footer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  actions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))\n});\n_validatorPrimitives.scheme.DebugControllerPausedEvent = (0, _validatorPrimitives.tObject)({\n  paused: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.DebugControllerBrowsersChangedEvent = (0, _validatorPrimitives.tObject)({\n  browsers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    contexts: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n      pages: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)\n    }))\n  }))\n});\n_validatorPrimitives.scheme.DebugControllerInitializeParams = (0, _validatorPrimitives.tObject)({\n  codegenId: _validatorPrimitives.tString,\n  sdkLanguage: (0, _validatorPrimitives.tEnum)(['javascript', 'python', 'java', 'csharp'])\n});\n_validatorPrimitives.scheme.DebugControllerInitializeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerSetReportStateChangedParams = (0, _validatorPrimitives.tObject)({\n  enabled: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.DebugControllerSetReportStateChangedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerResetForReuseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerResetForReuseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerNavigateParams = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.DebugControllerNavigateResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerSetRecorderModeParams = (0, _validatorPrimitives.tObject)({\n  mode: (0, _validatorPrimitives.tEnum)(['inspecting', 'recording', 'none']),\n  testIdAttributeName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.DebugControllerSetRecorderModeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerHighlightParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.DebugControllerHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerHideHighlightParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerHideHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerResumeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerResumeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerKillParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerKillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerCloseAllBrowsersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DebugControllerCloseAllBrowsersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SocksSupportInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SocksSupportSocksRequestedEvent = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString,\n  host: _validatorPrimitives.tString,\n  port: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.SocksSupportSocksDataEvent = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString,\n  data: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.SocksSupportSocksClosedEvent = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.SocksSupportSocksConnectedParams = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString,\n  host: _validatorPrimitives.tString,\n  port: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.SocksSupportSocksConnectedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SocksSupportSocksFailedParams = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString,\n  errorCode: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.SocksSupportSocksFailedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SocksSupportSocksDataParams = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString,\n  data: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.SocksSupportSocksDataResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SocksSupportSocksErrorParams = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString,\n  error: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.SocksSupportSocksErrorResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SocksSupportSocksEndParams = (0, _validatorPrimitives.tObject)({\n  uid: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.SocksSupportSocksEndResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SelectorsInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SelectorsRegisterParams = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  source: _validatorPrimitives.tString,\n  contentScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.SelectorsRegisterResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.SelectorsSetTestIdAttributeNameParams = (0, _validatorPrimitives.tObject)({\n  testIdAttributeName: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.SelectorsSetTestIdAttributeNameResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserTypeInitializer = (0, _validatorPrimitives.tObject)({\n  executablePath: _validatorPrimitives.tString,\n  name: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.BrowserTypeLaunchParams = (0, _validatorPrimitives.tObject)({\n  channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    server: _validatorPrimitives.tString,\n    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })),\n  downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  firefoxUserPrefs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),\n  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.BrowserTypeLaunchResult = (0, _validatorPrimitives.tObject)({\n  browser: (0, _validatorPrimitives.tChannel)(['Browser'])\n});\n_validatorPrimitives.scheme.BrowserTypeLaunchPersistentContextParams = (0, _validatorPrimitives.tObject)({\n  channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    server: _validatorPrimitives.tString,\n    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })),\n  downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    longitude: _validatorPrimitives.tNumber,\n    latitude: _validatorPrimitives.tNumber,\n    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  })),\n  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'no-override'])),\n  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference', 'no-override'])),\n  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none', 'no-override'])),\n  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    dir: _validatorPrimitives.tString,\n    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n      width: _validatorPrimitives.tNumber,\n      height: _validatorPrimitives.tNumber\n    }))\n  })),\n  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),\n  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),\n  userDataDir: _validatorPrimitives.tString,\n  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.BrowserTypeLaunchPersistentContextResult = (0, _validatorPrimitives.tObject)({\n  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])\n});\n_validatorPrimitives.scheme.BrowserTypeConnectOverCDPParams = (0, _validatorPrimitives.tObject)({\n  endpointURL: _validatorPrimitives.tString,\n  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.BrowserTypeConnectOverCDPResult = (0, _validatorPrimitives.tObject)({\n  browser: (0, _validatorPrimitives.tChannel)(['Browser']),\n  defaultContext: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['BrowserContext']))\n});\n_validatorPrimitives.scheme.BrowserInitializer = (0, _validatorPrimitives.tObject)({\n  version: _validatorPrimitives.tString,\n  name: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.BrowserCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserKillForTestsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserKillForTestsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserNewContextParams = (0, _validatorPrimitives.tObject)({\n  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    longitude: _validatorPrimitives.tNumber,\n    latitude: _validatorPrimitives.tNumber,\n    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  })),\n  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'no-override'])),\n  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference', 'no-override'])),\n  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none', 'no-override'])),\n  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    dir: _validatorPrimitives.tString,\n    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n      width: _validatorPrimitives.tNumber,\n      height: _validatorPrimitives.tNumber\n    }))\n  })),\n  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),\n  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),\n  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    server: _validatorPrimitives.tString,\n    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })),\n  storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SetNetworkCookie'))),\n    origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage')))\n  }))\n});\n_validatorPrimitives.scheme.BrowserNewContextResult = (0, _validatorPrimitives.tObject)({\n  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])\n});\n_validatorPrimitives.scheme.BrowserNewContextForReuseParams = (0, _validatorPrimitives.tObject)({\n  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    longitude: _validatorPrimitives.tNumber,\n    latitude: _validatorPrimitives.tNumber,\n    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  })),\n  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'no-override'])),\n  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference', 'no-override'])),\n  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none', 'no-override'])),\n  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    dir: _validatorPrimitives.tString,\n    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n      width: _validatorPrimitives.tNumber,\n      height: _validatorPrimitives.tNumber\n    }))\n  })),\n  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),\n  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),\n  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    server: _validatorPrimitives.tString,\n    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })),\n  storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SetNetworkCookie'))),\n    origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage')))\n  }))\n});\n_validatorPrimitives.scheme.BrowserNewContextForReuseResult = (0, _validatorPrimitives.tObject)({\n  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])\n});\n_validatorPrimitives.scheme.BrowserNewBrowserCDPSessionParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserNewBrowserCDPSessionResult = (0, _validatorPrimitives.tObject)({\n  session: (0, _validatorPrimitives.tChannel)(['CDPSession'])\n});\n_validatorPrimitives.scheme.BrowserStartTracingParams = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page'])),\n  path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  categories: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))\n});\n_validatorPrimitives.scheme.BrowserStartTracingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserStopTracingParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserStopTracingResult = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.EventTargetInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.EventTargetWaitForEventInfoParams = (0, _validatorPrimitives.tObject)({\n  info: (0, _validatorPrimitives.tObject)({\n    waitId: _validatorPrimitives.tString,\n    phase: (0, _validatorPrimitives.tEnum)(['before', 'after', 'log']),\n    event: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  })\n});\n_validatorPrimitives.scheme.BrowserContextWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');\n_validatorPrimitives.scheme.PageWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');\n_validatorPrimitives.scheme.WebSocketWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');\n_validatorPrimitives.scheme.ElectronApplicationWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');\n_validatorPrimitives.scheme.AndroidDeviceWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');\n_validatorPrimitives.scheme.EventTargetWaitForEventInfoResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');\n_validatorPrimitives.scheme.PageWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');\n_validatorPrimitives.scheme.WebSocketWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');\n_validatorPrimitives.scheme.ElectronApplicationWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');\n_validatorPrimitives.scheme.AndroidDeviceWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');\n_validatorPrimitives.scheme.BrowserContextInitializer = (0, _validatorPrimitives.tObject)({\n  isChromium: _validatorPrimitives.tBoolean,\n  requestContext: (0, _validatorPrimitives.tChannel)(['APIRequestContext']),\n  tracing: (0, _validatorPrimitives.tChannel)(['Tracing'])\n});\n_validatorPrimitives.scheme.BrowserContextBindingCallEvent = (0, _validatorPrimitives.tObject)({\n  binding: (0, _validatorPrimitives.tChannel)(['BindingCall'])\n});\n_validatorPrimitives.scheme.BrowserContextCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextPageEvent = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tChannel)(['Page'])\n});\n_validatorPrimitives.scheme.BrowserContextRouteEvent = (0, _validatorPrimitives.tObject)({\n  route: (0, _validatorPrimitives.tChannel)(['Route'])\n});\n_validatorPrimitives.scheme.BrowserContextVideoEvent = (0, _validatorPrimitives.tObject)({\n  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])\n});\n_validatorPrimitives.scheme.BrowserContextBackgroundPageEvent = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tChannel)(['Page'])\n});\n_validatorPrimitives.scheme.BrowserContextServiceWorkerEvent = (0, _validatorPrimitives.tObject)({\n  worker: (0, _validatorPrimitives.tChannel)(['Worker'])\n});\n_validatorPrimitives.scheme.BrowserContextRequestEvent = (0, _validatorPrimitives.tObject)({\n  request: (0, _validatorPrimitives.tChannel)(['Request']),\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))\n});\n_validatorPrimitives.scheme.BrowserContextRequestFailedEvent = (0, _validatorPrimitives.tObject)({\n  request: (0, _validatorPrimitives.tChannel)(['Request']),\n  failureText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  responseEndTiming: _validatorPrimitives.tNumber,\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))\n});\n_validatorPrimitives.scheme.BrowserContextRequestFinishedEvent = (0, _validatorPrimitives.tObject)({\n  request: (0, _validatorPrimitives.tChannel)(['Request']),\n  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response'])),\n  responseEndTiming: _validatorPrimitives.tNumber,\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))\n});\n_validatorPrimitives.scheme.BrowserContextResponseEvent = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tChannel)(['Response']),\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))\n});\n_validatorPrimitives.scheme.BrowserContextAddCookiesParams = (0, _validatorPrimitives.tObject)({\n  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SetNetworkCookie'))\n});\n_validatorPrimitives.scheme.BrowserContextAddCookiesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextAddInitScriptParams = (0, _validatorPrimitives.tObject)({\n  source: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.BrowserContextAddInitScriptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextClearCookiesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextClearCookiesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextClearPermissionsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextClearPermissionsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextCookiesParams = (0, _validatorPrimitives.tObject)({\n  urls: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.BrowserContextCookiesResult = (0, _validatorPrimitives.tObject)({\n  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie'))\n});\n_validatorPrimitives.scheme.BrowserContextExposeBindingParams = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.BrowserContextExposeBindingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextGrantPermissionsParams = (0, _validatorPrimitives.tObject)({\n  permissions: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString),\n  origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.BrowserContextGrantPermissionsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextNewPageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextNewPageResult = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tChannel)(['Page'])\n});\n_validatorPrimitives.scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.BrowserContextSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.BrowserContextSetExtraHTTPHeadersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextSetGeolocationParams = (0, _validatorPrimitives.tObject)({\n  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    longitude: _validatorPrimitives.tNumber,\n    latitude: _validatorPrimitives.tNumber,\n    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  }))\n});\n_validatorPrimitives.scheme.BrowserContextSetGeolocationResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextSetHTTPCredentialsParams = (0, _validatorPrimitives.tObject)({\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  }))\n});\n_validatorPrimitives.scheme.BrowserContextSetHTTPCredentialsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextSetNetworkInterceptionPatternsParams = (0, _validatorPrimitives.tObject)({\n  patterns: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    glob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  }))\n});\n_validatorPrimitives.scheme.BrowserContextSetNetworkInterceptionPatternsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextSetOfflineParams = (0, _validatorPrimitives.tObject)({\n  offline: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.BrowserContextSetOfflineResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextStorageStateResult = (0, _validatorPrimitives.tObject)({\n  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie')),\n  origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage'))\n});\n_validatorPrimitives.scheme.BrowserContextPauseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextPauseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextRecorderSupplementEnableParams = (0, _validatorPrimitives.tObject)({\n  language: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  mode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['inspecting', 'recording'])),\n  pauseOnNextStatement: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  launchOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),\n  contextOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),\n  device: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  saveStorage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  outputFile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  omitCallTracking: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.BrowserContextRecorderSupplementEnableResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BrowserContextNewCDPSessionParams = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page'])),\n  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame']))\n});\n_validatorPrimitives.scheme.BrowserContextNewCDPSessionResult = (0, _validatorPrimitives.tObject)({\n  session: (0, _validatorPrimitives.tChannel)(['CDPSession'])\n});\n_validatorPrimitives.scheme.BrowserContextHarStartParams = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page'])),\n  options: (0, _validatorPrimitives.tType)('RecordHarOptions')\n});\n_validatorPrimitives.scheme.BrowserContextHarStartResult = (0, _validatorPrimitives.tObject)({\n  harId: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.BrowserContextHarExportParams = (0, _validatorPrimitives.tObject)({\n  harId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.BrowserContextHarExportResult = (0, _validatorPrimitives.tObject)({\n  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])\n});\n_validatorPrimitives.scheme.BrowserContextCreateTempFileParams = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.BrowserContextCreateTempFileResult = (0, _validatorPrimitives.tObject)({\n  writableStream: (0, _validatorPrimitives.tChannel)(['WritableStream'])\n});\n_validatorPrimitives.scheme.BrowserContextUpdateSubscriptionParams = (0, _validatorPrimitives.tObject)({\n  event: (0, _validatorPrimitives.tEnum)(['request', 'response', 'requestFinished', 'requestFailed']),\n  enabled: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.BrowserContextUpdateSubscriptionResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageInitializer = (0, _validatorPrimitives.tObject)({\n  mainFrame: (0, _validatorPrimitives.tChannel)(['Frame']),\n  viewportSize: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  isClosed: _validatorPrimitives.tBoolean,\n  opener: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))\n});\n_validatorPrimitives.scheme.PageBindingCallEvent = (0, _validatorPrimitives.tObject)({\n  binding: (0, _validatorPrimitives.tChannel)(['BindingCall'])\n});\n_validatorPrimitives.scheme.PageCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageConsoleEvent = (0, _validatorPrimitives.tObject)({\n  message: (0, _validatorPrimitives.tChannel)(['ConsoleMessage'])\n});\n_validatorPrimitives.scheme.PageCrashEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageDialogEvent = (0, _validatorPrimitives.tObject)({\n  dialog: (0, _validatorPrimitives.tChannel)(['Dialog'])\n});\n_validatorPrimitives.scheme.PageDownloadEvent = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString,\n  suggestedFilename: _validatorPrimitives.tString,\n  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])\n});\n_validatorPrimitives.scheme.PageFileChooserEvent = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tChannel)(['ElementHandle']),\n  isMultiple: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.PageFrameAttachedEvent = (0, _validatorPrimitives.tObject)({\n  frame: (0, _validatorPrimitives.tChannel)(['Frame'])\n});\n_validatorPrimitives.scheme.PageFrameDetachedEvent = (0, _validatorPrimitives.tObject)({\n  frame: (0, _validatorPrimitives.tChannel)(['Frame'])\n});\n_validatorPrimitives.scheme.PagePageErrorEvent = (0, _validatorPrimitives.tObject)({\n  error: (0, _validatorPrimitives.tType)('SerializedError')\n});\n_validatorPrimitives.scheme.PageRouteEvent = (0, _validatorPrimitives.tObject)({\n  route: (0, _validatorPrimitives.tChannel)(['Route'])\n});\n_validatorPrimitives.scheme.PageVideoEvent = (0, _validatorPrimitives.tObject)({\n  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])\n});\n_validatorPrimitives.scheme.PageWebSocketEvent = (0, _validatorPrimitives.tObject)({\n  webSocket: (0, _validatorPrimitives.tChannel)(['WebSocket'])\n});\n_validatorPrimitives.scheme.PageWorkerEvent = (0, _validatorPrimitives.tObject)({\n  worker: (0, _validatorPrimitives.tChannel)(['Worker'])\n});\n_validatorPrimitives.scheme.PageSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageSetDefaultNavigationTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageAddInitScriptParams = (0, _validatorPrimitives.tObject)({\n  source: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.PageAddInitScriptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageCloseParams = (0, _validatorPrimitives.tObject)({\n  runBeforeUnload: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.PageCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageEmulateMediaParams = (0, _validatorPrimitives.tObject)({\n  media: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['screen', 'print', 'no-override'])),\n  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'no-override'])),\n  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference', 'no-override'])),\n  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none', 'no-override']))\n});\n_validatorPrimitives.scheme.PageEmulateMediaResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageExposeBindingParams = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString,\n  needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.PageExposeBindingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageGoBackParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))\n});\n_validatorPrimitives.scheme.PageGoBackResult = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))\n});\n_validatorPrimitives.scheme.PageGoForwardParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))\n});\n_validatorPrimitives.scheme.PageGoForwardResult = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))\n});\n_validatorPrimitives.scheme.PageReloadParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))\n});\n_validatorPrimitives.scheme.PageReloadResult = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))\n});\n_validatorPrimitives.scheme.PageExpectScreenshotParams = (0, _validatorPrimitives.tObject)({\n  expected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  isNot: _validatorPrimitives.tBoolean,\n  locator: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    frame: (0, _validatorPrimitives.tChannel)(['Frame']),\n    selector: _validatorPrimitives.tString\n  })),\n  comparatorOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    comparator: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    maxDiffPixels: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n    maxDiffPixelRatio: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n    threshold: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  screenshotOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n    clip: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Rect')),\n    omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n    caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['hide', 'initial'])),\n    animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['disabled', 'allow'])),\n    scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['css', 'device'])),\n    mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n      frame: (0, _validatorPrimitives.tChannel)(['Frame']),\n      selector: _validatorPrimitives.tString\n    })))\n  }))\n});\n_validatorPrimitives.scheme.PageExpectScreenshotResult = (0, _validatorPrimitives.tObject)({\n  diff: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  errorMessage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  actual: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  previous: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  log: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))\n});\n_validatorPrimitives.scheme.PageScreenshotParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['png', 'jpeg'])),\n  quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  clip: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Rect')),\n  omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['hide', 'initial'])),\n  animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['disabled', 'allow'])),\n  scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['css', 'device'])),\n  mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    frame: (0, _validatorPrimitives.tChannel)(['Frame']),\n    selector: _validatorPrimitives.tString\n  })))\n});\n_validatorPrimitives.scheme.PageScreenshotResult = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.PageSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.PageSetExtraHTTPHeadersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageSetNetworkInterceptionPatternsParams = (0, _validatorPrimitives.tObject)({\n  patterns: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    glob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  }))\n});\n_validatorPrimitives.scheme.PageSetNetworkInterceptionPatternsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageSetViewportSizeParams = (0, _validatorPrimitives.tObject)({\n  viewportSize: (0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })\n});\n_validatorPrimitives.scheme.PageSetViewportSizeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageKeyboardDownParams = (0, _validatorPrimitives.tObject)({\n  key: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.PageKeyboardDownResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageKeyboardUpParams = (0, _validatorPrimitives.tObject)({\n  key: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.PageKeyboardUpResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageKeyboardInsertTextParams = (0, _validatorPrimitives.tObject)({\n  text: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.PageKeyboardInsertTextResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageKeyboardTypeParams = (0, _validatorPrimitives.tObject)({\n  text: _validatorPrimitives.tString,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageKeyboardTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageKeyboardPressParams = (0, _validatorPrimitives.tObject)({\n  key: _validatorPrimitives.tString,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageKeyboardPressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageMouseMoveParams = (0, _validatorPrimitives.tObject)({\n  x: _validatorPrimitives.tNumber,\n  y: _validatorPrimitives.tNumber,\n  steps: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageMouseMoveResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageMouseDownParams = (0, _validatorPrimitives.tObject)({\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageMouseDownResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageMouseUpParams = (0, _validatorPrimitives.tObject)({\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageMouseUpResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageMouseClickParams = (0, _validatorPrimitives.tObject)({\n  x: _validatorPrimitives.tNumber,\n  y: _validatorPrimitives.tNumber,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.PageMouseClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageMouseWheelParams = (0, _validatorPrimitives.tObject)({\n  deltaX: _validatorPrimitives.tNumber,\n  deltaY: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.PageMouseWheelResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageTouchscreenTapParams = (0, _validatorPrimitives.tObject)({\n  x: _validatorPrimitives.tNumber,\n  y: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.PageTouchscreenTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageAccessibilitySnapshotParams = (0, _validatorPrimitives.tObject)({\n  interestingOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  root: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.PageAccessibilitySnapshotResult = (0, _validatorPrimitives.tObject)({\n  rootAXNode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('AXNode'))\n});\n_validatorPrimitives.scheme.PagePdfParams = (0, _validatorPrimitives.tObject)({\n  scale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  displayHeaderFooter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  headerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  footerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  printBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  landscape: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  pageRanges: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  format: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  width: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  height: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  preferCSSPageSize: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  margin: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    top: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    bottom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    left: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    right: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  }))\n});\n_validatorPrimitives.scheme.PagePdfResult = (0, _validatorPrimitives.tObject)({\n  pdf: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.PageStartJSCoverageParams = (0, _validatorPrimitives.tObject)({\n  resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  reportAnonymousScripts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.PageStartJSCoverageResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageStopJSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageStopJSCoverageResult = (0, _validatorPrimitives.tObject)({\n  entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    url: _validatorPrimitives.tString,\n    scriptId: _validatorPrimitives.tString,\n    source: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    functions: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n      functionName: _validatorPrimitives.tString,\n      isBlockCoverage: _validatorPrimitives.tBoolean,\n      ranges: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n        startOffset: _validatorPrimitives.tNumber,\n        endOffset: _validatorPrimitives.tNumber,\n        count: _validatorPrimitives.tNumber\n      }))\n    }))\n  }))\n});\n_validatorPrimitives.scheme.PageStartCSSCoverageParams = (0, _validatorPrimitives.tObject)({\n  resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.PageStartCSSCoverageResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageStopCSSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageStopCSSCoverageResult = (0, _validatorPrimitives.tObject)({\n  entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    url: _validatorPrimitives.tString,\n    text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    ranges: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n      start: _validatorPrimitives.tNumber,\n      end: _validatorPrimitives.tNumber\n    }))\n  }))\n});\n_validatorPrimitives.scheme.PageBringToFrontParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageBringToFrontResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.PageUpdateSubscriptionParams = (0, _validatorPrimitives.tObject)({\n  event: (0, _validatorPrimitives.tEnum)(['fileChooser', 'request', 'response', 'requestFinished', 'requestFailed']),\n  enabled: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.PageUpdateSubscriptionResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameInitializer = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString,\n  name: _validatorPrimitives.tString,\n  parentFrame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame'])),\n  loadStates: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('LifecycleEvent'))\n});\n_validatorPrimitives.scheme.FrameLoadstateEvent = (0, _validatorPrimitives.tObject)({\n  add: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent')),\n  remove: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))\n});\n_validatorPrimitives.scheme.FrameNavigatedEvent = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString,\n  name: _validatorPrimitives.tString,\n  newDocument: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    request: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Request']))\n  })),\n  error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.FrameEvalOnSelectorResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.FrameEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.FrameEvalOnSelectorAllResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.FrameAddScriptTagParams = (0, _validatorPrimitives.tObject)({\n  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  type: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameAddScriptTagResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tChannel)(['ElementHandle'])\n});\n_validatorPrimitives.scheme.FrameAddStyleTagParams = (0, _validatorPrimitives.tObject)({\n  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameAddStyleTagResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tChannel)(['ElementHandle'])\n});\n_validatorPrimitives.scheme.FrameBlurParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameBlurResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameCheckParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameCheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameClickParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameContentResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameDragAndDropParams = (0, _validatorPrimitives.tObject)({\n  source: _validatorPrimitives.tString,\n  target: _validatorPrimitives.tString,\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  sourcePosition: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  targetPosition: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameDragAndDropResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameDblclickParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameDblclickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameDispatchEventParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  type: _validatorPrimitives.tString,\n  eventInit: (0, _validatorPrimitives.tType)('SerializedArgument'),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameDispatchEventResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  exposeUtilityScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.FrameEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.FrameEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.FrameEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.FrameFillParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  value: _validatorPrimitives.tString,\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameFocusParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameFocusResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameFrameElementParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameFrameElementResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tChannel)(['ElementHandle'])\n});\n_validatorPrimitives.scheme.FrameHighlightParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameGetAttributeParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  name: _validatorPrimitives.tString,\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameGetAttributeResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameGotoParams = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString,\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent')),\n  referer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameGotoResult = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))\n});\n_validatorPrimitives.scheme.FrameHoverParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameHoverResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameInnerHTMLParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameInnerHTMLResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameInnerTextParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameInnerTextResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameInputValueParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameInputValueResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameIsCheckedParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameIsCheckedResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.FrameIsDisabledParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameIsDisabledResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.FrameIsEnabledParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameIsEnabledResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.FrameIsHiddenParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameIsHiddenResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.FrameIsVisibleParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameIsVisibleResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.FrameIsEditableParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameIsEditableResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.FramePressParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  key: _validatorPrimitives.tString,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FramePressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameQuerySelectorParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameQuerySelectorResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.FrameQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameQuerySelectorAllResult = (0, _validatorPrimitives.tObject)({\n  elements: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.FrameQueryCountParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameQueryCountResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.FrameSelectOptionParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))),\n  options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    valueOrLabel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  }))),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameSelectOptionResult = (0, _validatorPrimitives.tObject)({\n  values: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameSetContentParams = (0, _validatorPrimitives.tObject)({\n  html: _validatorPrimitives.tString,\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))\n});\n_validatorPrimitives.scheme.FrameSetContentResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameSetInputFilesParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    name: _validatorPrimitives.tString,\n    mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    buffer: _validatorPrimitives.tBinary\n  })),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameSetInputFilesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['WritableStream']))),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameSetInputFilePathsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameTapParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameTextContentParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameTextContentResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.FrameTitleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameTitleResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.FrameTypeParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  text: _validatorPrimitives.tString,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameUncheckParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameUncheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameWaitForTimeoutParams = (0, _validatorPrimitives.tObject)({\n  timeout: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.FrameWaitForTimeoutResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.FrameWaitForFunctionParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument'),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  pollingInterval: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameWaitForFunctionResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.FrameWaitForSelectorParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['attached', 'detached', 'visible', 'hidden'])),\n  omitReturnValue: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.FrameWaitForSelectorResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.FrameExpectParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  expression: _validatorPrimitives.tString,\n  expressionArg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),\n  expectedText: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('ExpectedTextValue'))),\n  expectedNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  expectedValue: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedArgument')),\n  useInnerText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  isNot: _validatorPrimitives.tBoolean,\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.FrameExpectResult = (0, _validatorPrimitives.tObject)({\n  matches: _validatorPrimitives.tBoolean,\n  received: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedValue')),\n  timedOut: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  log: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))\n});\n_validatorPrimitives.scheme.WorkerInitializer = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.WorkerCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.WorkerEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.WorkerEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.WorkerEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.WorkerEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.JSHandleInitializer = (0, _validatorPrimitives.tObject)({\n  preview: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.JSHandlePreviewUpdatedEvent = (0, _validatorPrimitives.tObject)({\n  preview: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandlePreviewUpdatedEvent = (0, _validatorPrimitives.tType)('JSHandlePreviewUpdatedEvent');\n_validatorPrimitives.scheme.JSHandleDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleDisposeParams = (0, _validatorPrimitives.tType)('JSHandleDisposeParams');\n_validatorPrimitives.scheme.JSHandleDisposeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleDisposeResult = (0, _validatorPrimitives.tType)('JSHandleDisposeResult');\n_validatorPrimitives.scheme.JSHandleEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElementHandleEvaluateExpressionParams = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionParams');\n_validatorPrimitives.scheme.JSHandleEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.ElementHandleEvaluateExpressionResult = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionResult');\n_validatorPrimitives.scheme.JSHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElementHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionHandleParams');\n_validatorPrimitives.scheme.JSHandleEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.ElementHandleEvaluateExpressionHandleResult = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionHandleResult');\n_validatorPrimitives.scheme.JSHandleGetPropertyListParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleGetPropertyListParams = (0, _validatorPrimitives.tType)('JSHandleGetPropertyListParams');\n_validatorPrimitives.scheme.JSHandleGetPropertyListResult = (0, _validatorPrimitives.tObject)({\n  properties: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    name: _validatorPrimitives.tString,\n    value: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n  }))\n});\n_validatorPrimitives.scheme.ElementHandleGetPropertyListResult = (0, _validatorPrimitives.tType)('JSHandleGetPropertyListResult');\n_validatorPrimitives.scheme.JSHandleGetPropertyParams = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleGetPropertyParams = (0, _validatorPrimitives.tType)('JSHandleGetPropertyParams');\n_validatorPrimitives.scheme.JSHandleGetPropertyResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.ElementHandleGetPropertyResult = (0, _validatorPrimitives.tType)('JSHandleGetPropertyResult');\n_validatorPrimitives.scheme.JSHandleJsonValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleJsonValueParams = (0, _validatorPrimitives.tType)('JSHandleJsonValueParams');\n_validatorPrimitives.scheme.JSHandleJsonValueResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.ElementHandleJsonValueResult = (0, _validatorPrimitives.tType)('JSHandleJsonValueResult');\n_validatorPrimitives.scheme.ElementHandleInitializer = (0, _validatorPrimitives.tObject)({\n  preview: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElementHandleEvalOnSelectorResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.ElementHandleEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElementHandleEvalOnSelectorAllResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.ElementHandleBoundingBoxParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleBoundingBoxResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Rect'))\n});\n_validatorPrimitives.scheme.ElementHandleCheckParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleCheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleClickParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleContentFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleContentFrameResult = (0, _validatorPrimitives.tObject)({\n  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame']))\n});\n_validatorPrimitives.scheme.ElementHandleDblclickParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleDblclickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleDispatchEventParams = (0, _validatorPrimitives.tObject)({\n  type: _validatorPrimitives.tString,\n  eventInit: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElementHandleDispatchEventResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleFillParams = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString,\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleFocusParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleFocusResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleGetAttributeParams = (0, _validatorPrimitives.tObject)({\n  name: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleGetAttributeResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.ElementHandleHoverParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleHoverResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleInnerHTMLParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleInnerHTMLResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleInnerTextParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleInnerTextResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleInputValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleInputValueResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleIsCheckedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleIsCheckedResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ElementHandleIsDisabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleIsDisabledResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ElementHandleIsEditableParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleIsEditableResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ElementHandleIsEnabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleIsEnabledResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ElementHandleIsHiddenParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleIsHiddenResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ElementHandleIsVisibleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleIsVisibleResult = (0, _validatorPrimitives.tObject)({\n  value: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ElementHandleOwnerFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleOwnerFrameResult = (0, _validatorPrimitives.tObject)({\n  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame']))\n});\n_validatorPrimitives.scheme.ElementHandlePressParams = (0, _validatorPrimitives.tObject)({\n  key: _validatorPrimitives.tString,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandlePressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleQuerySelectorParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleQuerySelectorResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.ElementHandleQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ElementHandleQuerySelectorAllResult = (0, _validatorPrimitives.tObject)({\n  elements: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.ElementHandleScreenshotParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['png', 'jpeg'])),\n  quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['hide', 'initial'])),\n  animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['disabled', 'allow'])),\n  scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['css', 'device'])),\n  mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    frame: (0, _validatorPrimitives.tChannel)(['Frame']),\n    selector: _validatorPrimitives.tString\n  })))\n});\n_validatorPrimitives.scheme.ElementHandleScreenshotResult = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.ElementHandleScrollIntoViewIfNeededParams = (0, _validatorPrimitives.tObject)({\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.ElementHandleScrollIntoViewIfNeededResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleSelectOptionParams = (0, _validatorPrimitives.tObject)({\n  elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))),\n  options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    valueOrLabel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  }))),\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleSelectOptionResult = (0, _validatorPrimitives.tObject)({\n  values: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.ElementHandleSelectTextParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.ElementHandleSelectTextResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleSetInputFilesParams = (0, _validatorPrimitives.tObject)({\n  files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({\n    name: _validatorPrimitives.tString,\n    mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    buffer: _validatorPrimitives.tBinary\n  })),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleSetInputFilesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({\n  localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['WritableStream']))),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleSetInputFilePathsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleTapParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleTextContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleTextContentResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.ElementHandleTypeParams = (0, _validatorPrimitives.tObject)({\n  text: _validatorPrimitives.tString,\n  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.ElementHandleTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleUncheckParams = (0, _validatorPrimitives.tObject)({\n  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.ElementHandleUncheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleWaitForElementStateParams = (0, _validatorPrimitives.tObject)({\n  state: (0, _validatorPrimitives.tEnum)(['visible', 'hidden', 'stable', 'enabled', 'disabled', 'editable']),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.ElementHandleWaitForElementStateResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElementHandleWaitForSelectorParams = (0, _validatorPrimitives.tObject)({\n  selector: _validatorPrimitives.tString,\n  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['attached', 'detached', 'visible', 'hidden']))\n});\n_validatorPrimitives.scheme.ElementHandleWaitForSelectorResult = (0, _validatorPrimitives.tObject)({\n  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))\n});\n_validatorPrimitives.scheme.RequestInitializer = (0, _validatorPrimitives.tObject)({\n  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame'])),\n  serviceWorker: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Worker'])),\n  url: _validatorPrimitives.tString,\n  resourceType: _validatorPrimitives.tString,\n  method: _validatorPrimitives.tString,\n  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')),\n  isNavigationRequest: _validatorPrimitives.tBoolean,\n  redirectedFrom: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Request']))\n});\n_validatorPrimitives.scheme.RequestResponseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.RequestResponseResult = (0, _validatorPrimitives.tObject)({\n  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))\n});\n_validatorPrimitives.scheme.RequestRawRequestHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.RequestRawRequestHeadersResult = (0, _validatorPrimitives.tObject)({\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.RouteInitializer = (0, _validatorPrimitives.tObject)({\n  request: (0, _validatorPrimitives.tChannel)(['Request'])\n});\n_validatorPrimitives.scheme.RouteRedirectNavigationRequestParams = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.RouteRedirectNavigationRequestResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.RouteAbortParams = (0, _validatorPrimitives.tObject)({\n  errorCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.RouteAbortResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.RouteContinueParams = (0, _validatorPrimitives.tObject)({\n  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)\n});\n_validatorPrimitives.scheme.RouteContinueResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.RouteFulfillParams = (0, _validatorPrimitives.tObject)({\n  status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  isBase64: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  fetchResponseUid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.RouteFulfillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ResourceTiming = (0, _validatorPrimitives.tObject)({\n  startTime: _validatorPrimitives.tNumber,\n  domainLookupStart: _validatorPrimitives.tNumber,\n  domainLookupEnd: _validatorPrimitives.tNumber,\n  connectStart: _validatorPrimitives.tNumber,\n  secureConnectionStart: _validatorPrimitives.tNumber,\n  connectEnd: _validatorPrimitives.tNumber,\n  requestStart: _validatorPrimitives.tNumber,\n  responseStart: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.ResponseInitializer = (0, _validatorPrimitives.tObject)({\n  request: (0, _validatorPrimitives.tChannel)(['Request']),\n  url: _validatorPrimitives.tString,\n  status: _validatorPrimitives.tNumber,\n  statusText: _validatorPrimitives.tString,\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')),\n  timing: (0, _validatorPrimitives.tType)('ResourceTiming'),\n  fromServiceWorker: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.ResponseBodyParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ResponseBodyResult = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.ResponseSecurityDetailsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ResponseSecurityDetailsResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SecurityDetails'))\n});\n_validatorPrimitives.scheme.ResponseServerAddrParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ResponseServerAddrResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RemoteAddr'))\n});\n_validatorPrimitives.scheme.ResponseRawResponseHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ResponseRawResponseHeadersResult = (0, _validatorPrimitives.tObject)({\n  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))\n});\n_validatorPrimitives.scheme.ResponseSizesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ResponseSizesResult = (0, _validatorPrimitives.tObject)({\n  sizes: (0, _validatorPrimitives.tType)('RequestSizes')\n});\n_validatorPrimitives.scheme.SecurityDetails = (0, _validatorPrimitives.tObject)({\n  issuer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  protocol: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  subjectName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  validFrom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  validTo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.RequestSizes = (0, _validatorPrimitives.tObject)({\n  requestBodySize: _validatorPrimitives.tNumber,\n  requestHeadersSize: _validatorPrimitives.tNumber,\n  responseBodySize: _validatorPrimitives.tNumber,\n  responseHeadersSize: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.RemoteAddr = (0, _validatorPrimitives.tObject)({\n  ipAddress: _validatorPrimitives.tString,\n  port: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.WebSocketInitializer = (0, _validatorPrimitives.tObject)({\n  url: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.WebSocketOpenEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.WebSocketFrameSentEvent = (0, _validatorPrimitives.tObject)({\n  opcode: _validatorPrimitives.tNumber,\n  data: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.WebSocketFrameReceivedEvent = (0, _validatorPrimitives.tObject)({\n  opcode: _validatorPrimitives.tNumber,\n  data: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.WebSocketSocketErrorEvent = (0, _validatorPrimitives.tObject)({\n  error: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.WebSocketCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ConsoleMessageInitializer = (0, _validatorPrimitives.tObject)({\n  type: _validatorPrimitives.tString,\n  text: _validatorPrimitives.tString,\n  args: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])),\n  location: (0, _validatorPrimitives.tObject)({\n    url: _validatorPrimitives.tString,\n    lineNumber: _validatorPrimitives.tNumber,\n    columnNumber: _validatorPrimitives.tNumber\n  })\n});\n_validatorPrimitives.scheme.BindingCallInitializer = (0, _validatorPrimitives.tObject)({\n  frame: (0, _validatorPrimitives.tChannel)(['Frame']),\n  name: _validatorPrimitives.tString,\n  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SerializedValue'))),\n  handle: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle']))\n});\n_validatorPrimitives.scheme.BindingCallRejectParams = (0, _validatorPrimitives.tObject)({\n  error: (0, _validatorPrimitives.tType)('SerializedError')\n});\n_validatorPrimitives.scheme.BindingCallRejectResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.BindingCallResolveParams = (0, _validatorPrimitives.tObject)({\n  result: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.BindingCallResolveResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DialogInitializer = (0, _validatorPrimitives.tObject)({\n  type: _validatorPrimitives.tString,\n  message: _validatorPrimitives.tString,\n  defaultValue: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.DialogAcceptParams = (0, _validatorPrimitives.tObject)({\n  promptText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.DialogAcceptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DialogDismissParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.DialogDismissResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.TracingInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.TracingTracingStartParams = (0, _validatorPrimitives.tObject)({\n  name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  snapshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  sources: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.TracingTracingStartResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.TracingTracingStartChunkParams = (0, _validatorPrimitives.tObject)({\n  title: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.TracingTracingStartChunkResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.TracingTracingStopChunkParams = (0, _validatorPrimitives.tObject)({\n  mode: (0, _validatorPrimitives.tEnum)(['doNotSave', 'compressTrace', 'compressTraceAndSources'])\n});\n_validatorPrimitives.scheme.TracingTracingStopChunkResult = (0, _validatorPrimitives.tObject)({\n  artifact: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Artifact'])),\n  sourceEntries: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')))\n});\n_validatorPrimitives.scheme.TracingTracingStopParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.TracingTracingStopResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactInitializer = (0, _validatorPrimitives.tObject)({\n  absolutePath: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ArtifactPathAfterFinishedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactPathAfterFinishedResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.ArtifactSaveAsParams = (0, _validatorPrimitives.tObject)({\n  path: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.ArtifactSaveAsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactSaveAsStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactSaveAsStreamResult = (0, _validatorPrimitives.tObject)({\n  stream: (0, _validatorPrimitives.tChannel)(['Stream'])\n});\n_validatorPrimitives.scheme.ArtifactFailureParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactFailureResult = (0, _validatorPrimitives.tObject)({\n  error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.ArtifactStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactStreamResult = (0, _validatorPrimitives.tObject)({\n  stream: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Stream']))\n});\n_validatorPrimitives.scheme.ArtifactCancelParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactCancelResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactDeleteParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ArtifactDeleteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.StreamInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.StreamReadParams = (0, _validatorPrimitives.tObject)({\n  size: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.StreamReadResult = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.StreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.StreamCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.WritableStreamInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.WritableStreamWriteParams = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.WritableStreamWriteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.WritableStreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.WritableStreamCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.CDPSessionInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.CDPSessionEventEvent = (0, _validatorPrimitives.tObject)({\n  method: _validatorPrimitives.tString,\n  params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)\n});\n_validatorPrimitives.scheme.CDPSessionSendParams = (0, _validatorPrimitives.tObject)({\n  method: _validatorPrimitives.tString,\n  params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)\n});\n_validatorPrimitives.scheme.CDPSessionSendResult = (0, _validatorPrimitives.tObject)({\n  result: _validatorPrimitives.tAny\n});\n_validatorPrimitives.scheme.CDPSessionDetachParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.CDPSessionDetachResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElectronInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElectronLaunchParams = (0, _validatorPrimitives.tObject)({\n  executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  cwd: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'no-override'])),\n  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    longitude: _validatorPrimitives.tNumber,\n    latitude: _validatorPrimitives.tNumber,\n    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  })),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),\n  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    dir: _validatorPrimitives.tString,\n    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n      width: _validatorPrimitives.tNumber,\n      height: _validatorPrimitives.tNumber\n    }))\n  })),\n  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.ElectronLaunchResult = (0, _validatorPrimitives.tObject)({\n  electronApplication: (0, _validatorPrimitives.tChannel)(['ElectronApplication'])\n});\n_validatorPrimitives.scheme.ElectronApplicationInitializer = (0, _validatorPrimitives.tObject)({\n  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])\n});\n_validatorPrimitives.scheme.ElectronApplicationCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElectronApplicationBrowserWindowParams = (0, _validatorPrimitives.tObject)({\n  page: (0, _validatorPrimitives.tChannel)(['Page'])\n});\n_validatorPrimitives.scheme.ElectronApplicationBrowserWindowResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({\n  value: (0, _validatorPrimitives.tType)('SerializedValue')\n});\n_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({\n  expression: _validatorPrimitives.tString,\n  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  arg: (0, _validatorPrimitives.tType)('SerializedArgument')\n});\n_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({\n  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])\n});\n_validatorPrimitives.scheme.ElectronApplicationCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.ElectronApplicationCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDevicesParams = (0, _validatorPrimitives.tObject)({\n  host: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  port: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  omitDriverInstall: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)\n});\n_validatorPrimitives.scheme.AndroidDevicesResult = (0, _validatorPrimitives.tObject)({\n  devices: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['AndroidDevice']))\n});\n_validatorPrimitives.scheme.AndroidSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({\n  timeout: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.AndroidSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidSocketInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidSocketDataEvent = (0, _validatorPrimitives.tObject)({\n  data: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.AndroidSocketCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidSocketWriteParams = (0, _validatorPrimitives.tObject)({\n  data: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.AndroidSocketWriteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidSocketCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidSocketCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceInitializer = (0, _validatorPrimitives.tObject)({\n  model: _validatorPrimitives.tString,\n  serial: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceWebViewAddedEvent = (0, _validatorPrimitives.tObject)({\n  webView: (0, _validatorPrimitives.tType)('AndroidWebView')\n});\n_validatorPrimitives.scheme.AndroidDeviceWebViewRemovedEvent = (0, _validatorPrimitives.tObject)({\n  socketName: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceWaitParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['gone'])),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceWaitResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceFillParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  text: _validatorPrimitives.tString,\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceTapParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  duration: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceDragParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  dest: (0, _validatorPrimitives.tType)('Point'),\n  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceDragResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceFlingParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  direction: (0, _validatorPrimitives.tEnum)(['up', 'down', 'left', 'right']),\n  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceFlingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceLongTapParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceLongTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDevicePinchCloseParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  percent: _validatorPrimitives.tNumber,\n  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDevicePinchCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDevicePinchOpenParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  percent: _validatorPrimitives.tNumber,\n  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDevicePinchOpenResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceScrollParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  direction: (0, _validatorPrimitives.tEnum)(['up', 'down', 'left', 'right']),\n  percent: _validatorPrimitives.tNumber,\n  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceScrollResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceSwipeParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n  direction: (0, _validatorPrimitives.tEnum)(['up', 'down', 'left', 'right']),\n  percent: _validatorPrimitives.tNumber,\n  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDeviceSwipeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceInfoParams = (0, _validatorPrimitives.tObject)({\n  selector: (0, _validatorPrimitives.tType)('AndroidSelector')\n});\n_validatorPrimitives.scheme.AndroidDeviceInfoResult = (0, _validatorPrimitives.tObject)({\n  info: (0, _validatorPrimitives.tType)('AndroidElementInfo')\n});\n_validatorPrimitives.scheme.AndroidDeviceScreenshotParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceScreenshotResult = (0, _validatorPrimitives.tObject)({\n  binary: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.AndroidDeviceInputTypeParams = (0, _validatorPrimitives.tObject)({\n  text: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceInputTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceInputPressParams = (0, _validatorPrimitives.tObject)({\n  key: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceInputPressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceInputTapParams = (0, _validatorPrimitives.tObject)({\n  point: (0, _validatorPrimitives.tType)('Point')\n});\n_validatorPrimitives.scheme.AndroidDeviceInputTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceInputSwipeParams = (0, _validatorPrimitives.tObject)({\n  segments: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('Point')),\n  steps: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.AndroidDeviceInputSwipeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceInputDragParams = (0, _validatorPrimitives.tObject)({\n  from: (0, _validatorPrimitives.tType)('Point'),\n  to: (0, _validatorPrimitives.tType)('Point'),\n  steps: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.AndroidDeviceInputDragResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceLaunchBrowserParams = (0, _validatorPrimitives.tObject)({\n  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    width: _validatorPrimitives.tNumber,\n    height: _validatorPrimitives.tNumber\n  })),\n  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    longitude: _validatorPrimitives.tNumber,\n    latitude: _validatorPrimitives.tNumber,\n    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),\n  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    username: _validatorPrimitives.tString,\n    password: _validatorPrimitives.tString\n  })),\n  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'no-override'])),\n  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference', 'no-override'])),\n  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none', 'no-override'])),\n  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    dir: _validatorPrimitives.tString,\n    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n      width: _validatorPrimitives.tNumber,\n      height: _validatorPrimitives.tNumber\n    }))\n  })),\n  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),\n  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),\n  pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),\n  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    server: _validatorPrimitives.tString,\n    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n  }))\n});\n_validatorPrimitives.scheme.AndroidDeviceLaunchBrowserResult = (0, _validatorPrimitives.tObject)({\n  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])\n});\n_validatorPrimitives.scheme.AndroidDeviceOpenParams = (0, _validatorPrimitives.tObject)({\n  command: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceOpenResult = (0, _validatorPrimitives.tObject)({\n  socket: (0, _validatorPrimitives.tChannel)(['AndroidSocket'])\n});\n_validatorPrimitives.scheme.AndroidDeviceShellParams = (0, _validatorPrimitives.tObject)({\n  command: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceShellResult = (0, _validatorPrimitives.tObject)({\n  result: _validatorPrimitives.tBinary\n});\n_validatorPrimitives.scheme.AndroidDeviceInstallApkParams = (0, _validatorPrimitives.tObject)({\n  file: _validatorPrimitives.tBinary,\n  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))\n});\n_validatorPrimitives.scheme.AndroidDeviceInstallApkResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDevicePushParams = (0, _validatorPrimitives.tObject)({\n  file: _validatorPrimitives.tBinary,\n  path: _validatorPrimitives.tString,\n  mode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n});\n_validatorPrimitives.scheme.AndroidDevicePushResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({\n  timeout: _validatorPrimitives.tNumber\n});\n_validatorPrimitives.scheme.AndroidDeviceSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceConnectToWebViewParams = (0, _validatorPrimitives.tObject)({\n  socketName: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidDeviceConnectToWebViewResult = (0, _validatorPrimitives.tObject)({\n  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])\n});\n_validatorPrimitives.scheme.AndroidDeviceCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidDeviceCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.AndroidWebView = (0, _validatorPrimitives.tObject)({\n  pid: _validatorPrimitives.tNumber,\n  pkg: _validatorPrimitives.tString,\n  socketName: _validatorPrimitives.tString\n});\n_validatorPrimitives.scheme.AndroidSelector = (0, _validatorPrimitives.tObject)({\n  checkable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  checked: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  clazz: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  clickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  depth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),\n  desc: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  enabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  focusable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  hasChild: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    selector: (0, _validatorPrimitives.tType)('AndroidSelector')\n  })),\n  hasDescendant: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({\n    selector: (0, _validatorPrimitives.tType)('AndroidSelector'),\n    maxDepth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)\n  })),\n  longClickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  res: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),\n  scrollable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),\n  text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)\n});\n_validatorPrimitives.scheme.AndroidElementInfo = (0, _validatorPrimitives.tObject)({\n  children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('AndroidElementInfo'))),\n  clazz: _validatorPrimitives.tString,\n  desc: _validatorPrimitives.tString,\n  res: _validatorPrimitives.tString,\n  pkg: _validatorPrimitives.tString,\n  text: _validatorPrimitives.tString,\n  bounds: (0, _validatorPrimitives.tType)('Rect'),\n  checkable: _validatorPrimitives.tBoolean,\n  checked: _validatorPrimitives.tBoolean,\n  clickable: _validatorPrimitives.tBoolean,\n  enabled: _validatorPrimitives.tBoolean,\n  focusable: _validatorPrimitives.tBoolean,\n  focused: _validatorPrimitives.tBoolean,\n  longClickable: _validatorPrimitives.tBoolean,\n  scrollable: _validatorPrimitives.tBoolean,\n  selected: _validatorPrimitives.tBoolean\n});\n_validatorPrimitives.scheme.JsonPipeInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.JsonPipeMessageEvent = (0, _validatorPrimitives.tObject)({\n  message: _validatorPrimitives.tAny\n});\n_validatorPrimitives.scheme.JsonPipeClosedEvent = (0, _validatorPrimitives.tObject)({\n  error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedError'))\n});\n_validatorPrimitives.scheme.JsonPipeSendParams = (0, _validatorPrimitives.tObject)({\n  message: _validatorPrimitives.tAny\n});\n_validatorPrimitives.scheme.JsonPipeSendResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.JsonPipeCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));\n_validatorPrimitives.scheme.JsonPipeCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidationError = void 0;\nexports.createMetadataValidator = createMetadataValidator;\nexports.findValidator = findValidator;\nexports.maybeFindValidator = maybeFindValidator;\nexports.tUndefined = exports.tType = exports.tString = exports.tOptional = exports.tObject = exports.tNumber = exports.tEnum = exports.tChannel = exports.tBoolean = exports.tBinary = exports.tArray = exports.tAny = exports.scheme = void 0;\nvar _utils = require(\"../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ValidationError extends Error {}\nexports.ValidationError = ValidationError;\nconst scheme = {};\nexports.scheme = scheme;\nfunction findValidator(type, method, kind) {\n  const validator = maybeFindValidator(type, method, kind);\n  if (!validator) throw new ValidationError(`Unknown scheme for ${kind}: ${type}.${method}`);\n  return validator;\n}\nfunction maybeFindValidator(type, method, kind) {\n  const schemeName = type + (kind === 'Initializer' ? '' : method[0].toUpperCase() + method.substring(1)) + kind;\n  return scheme[schemeName];\n}\nfunction createMetadataValidator() {\n  return tOptional(scheme['Metadata']);\n}\nconst tNumber = (arg, path, context) => {\n  if (arg instanceof Number) return arg.valueOf();\n  if (typeof arg === 'number') return arg;\n  throw new ValidationError(`${path}: expected number, got ${typeof arg}`);\n};\nexports.tNumber = tNumber;\nconst tBoolean = (arg, path, context) => {\n  if (arg instanceof Boolean) return arg.valueOf();\n  if (typeof arg === 'boolean') return arg;\n  throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);\n};\nexports.tBoolean = tBoolean;\nconst tString = (arg, path, context) => {\n  if (arg instanceof String) return arg.valueOf();\n  if (typeof arg === 'string') return arg;\n  throw new ValidationError(`${path}: expected string, got ${typeof arg}`);\n};\nexports.tString = tString;\nconst tBinary = (arg, path, context) => {\n  if (context.binary === 'fromBase64') {\n    if (arg instanceof String) return Buffer.from(arg.valueOf(), 'base64');\n    if (typeof arg === 'string') return Buffer.from(arg, 'base64');\n    throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);\n  }\n  if (context.binary === 'toBase64') {\n    if (!(arg instanceof Buffer)) throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);\n    return arg.toString('base64');\n  }\n  if (context.binary === 'buffer') {\n    if (!(arg instanceof Buffer)) throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);\n    return arg;\n  }\n  throw new ValidationError(`Unsupported binary behavior \"${context.binary}\"`);\n};\nexports.tBinary = tBinary;\nconst tUndefined = (arg, path, context) => {\n  if (Object.is(arg, undefined)) return arg;\n  throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);\n};\nexports.tUndefined = tUndefined;\nconst tAny = (arg, path, context) => {\n  return arg;\n};\nexports.tAny = tAny;\nconst tOptional = v => {\n  return (arg, path, context) => {\n    if (Object.is(arg, undefined)) return arg;\n    return v(arg, path, context);\n  };\n};\nexports.tOptional = tOptional;\nconst tArray = v => {\n  return (arg, path, context) => {\n    if (!Array.isArray(arg)) throw new ValidationError(`${path}: expected array, got ${typeof arg}`);\n    return arg.map((x, index) => v(x, path + '[' + index + ']', context));\n  };\n};\nexports.tArray = tArray;\nconst tObject = s => {\n  return (arg, path, context) => {\n    if (Object.is(arg, null)) throw new ValidationError(`${path}: expected object, got null`);\n    if (typeof arg !== 'object') throw new ValidationError(`${path}: expected object, got ${typeof arg}`);\n    const result = {};\n    for (const [key, v] of Object.entries(s)) {\n      const value = v(arg[key], path ? path + '.' + key : key, context);\n      if (!Object.is(value, undefined)) result[key] = value;\n    }\n    if ((0, _utils.isUnderTest)()) {\n      for (const [key, value] of Object.entries(arg)) {\n        if (key.startsWith('__testHook')) result[key] = value;\n      }\n    }\n    return result;\n  };\n};\nexports.tObject = tObject;\nconst tEnum = e => {\n  return (arg, path, context) => {\n    if (!e.includes(arg)) throw new ValidationError(`${path}: expected one of (${e.join('|')})`);\n    return arg;\n  };\n};\nexports.tEnum = tEnum;\nconst tChannel = names => {\n  return (arg, path, context) => {\n    return context.tChannelImpl(names, arg, path, context);\n  };\n};\nexports.tChannel = tChannel;\nconst tType = name => {\n  return (arg, path, context) => {\n    const v = scheme[name];\n    if (!v) throw new ValidationError(path + ': unknown type \"' + name + '\"');\n    return v(arg, path, context);\n  };\n};\nexports.tType = tType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PlaywrightConnection = void 0;\nvar _server = require(\"../server\");\nvar _browser = require(\"../server/browser\");\nvar _instrumentation = require(\"../server/instrumentation\");\nvar _socksProxy = require(\"../common/socksProxy\");\nvar _utils = require(\"../utils\");\nvar _android = require(\"../server/android/android\");\nvar _debugControllerDispatcher = require(\"../server/dispatchers/debugControllerDispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass PlaywrightConnection {\n  constructor(lock, clientType, ws, options, preLaunched, log, onClose) {\n    this._ws = void 0;\n    this._onClose = void 0;\n    this._dispatcherConnection = void 0;\n    this._cleanups = [];\n    this._debugLog = void 0;\n    this._disconnected = false;\n    this._preLaunched = void 0;\n    this._options = void 0;\n    this._root = void 0;\n    this._ws = ws;\n    this._preLaunched = preLaunched;\n    this._options = options;\n    if (clientType === 'reuse-browser' || clientType === 'pre-launched-browser-or-android') (0, _utils.assert)(preLaunched.playwright);\n    if (clientType === 'pre-launched-browser-or-android') (0, _utils.assert)(preLaunched.browser || preLaunched.androidDevice);\n    this._onClose = onClose;\n    this._debugLog = log;\n    this._dispatcherConnection = new _server.DispatcherConnection();\n    this._dispatcherConnection.onmessage = async message => {\n      await lock;\n      if (ws.readyState !== ws.CLOSING) ws.send(JSON.stringify(message));\n    };\n    ws.on('message', async message => {\n      await lock;\n      this._dispatcherConnection.dispatch(JSON.parse(Buffer.from(message).toString()));\n    });\n    ws.on('close', () => this._onDisconnect());\n    ws.on('error', error => this._onDisconnect(error));\n    if (clientType === 'controller') {\n      this._root = this._initDebugControllerMode();\n      return;\n    }\n    this._root = new _server.RootDispatcher(this._dispatcherConnection, async scope => {\n      if (clientType === 'reuse-browser') return await this._initReuseBrowsersMode(scope);\n      if (clientType === 'pre-launched-browser-or-android') return this._preLaunched.browser ? await this._initPreLaunchedBrowserMode(scope) : await this._initPreLaunchedAndroidMode(scope);\n      if (clientType === 'launch-browser') return await this._initLaunchBrowserMode(scope);\n      if (clientType === 'playwright') return await this._initPlaywrightConnectMode(scope);\n      throw new Error('Unsupported client type: ' + clientType);\n    });\n  }\n  async _initPlaywrightConnectMode(scope) {\n    this._debugLog(`engaged playwright.connect mode`);\n    const playwright = (0, _server.createPlaywright)('javascript');\n    // Close all launched browsers on disconnect.\n    this._cleanups.push(async () => {\n      await Promise.all(playwright.allBrowsers().map(browser => browser.close()));\n    });\n    const ownedSocksProxy = await this._createOwnedSocksProxy(playwright);\n    return new _server.PlaywrightDispatcher(scope, playwright, ownedSocksProxy);\n  }\n  async _initLaunchBrowserMode(scope) {\n    this._debugLog(`engaged launch mode for \"${this._options.browserName}\"`);\n    const playwright = (0, _server.createPlaywright)('javascript');\n    const ownedSocksProxy = await this._createOwnedSocksProxy(playwright);\n    const browser = await playwright[this._options.browserName].launch((0, _instrumentation.serverSideCallMetadata)(), this._options.launchOptions);\n    this._cleanups.push(async () => {\n      for (const browser of playwright.allBrowsers()) await browser.close();\n    });\n    browser.on(_browser.Browser.Events.Disconnected, () => {\n      // Underlying browser did close for some reason - force disconnect the client.\n      this.close({\n        code: 1001,\n        reason: 'Browser closed'\n      });\n    });\n    return new _server.PlaywrightDispatcher(scope, playwright, ownedSocksProxy, browser);\n  }\n  async _initPreLaunchedBrowserMode(scope) {\n    var _this$_preLaunched$so;\n    this._debugLog(`engaged pre-launched (browser) mode`);\n    const playwright = this._preLaunched.playwright;\n\n    // Note: connected client owns the socks proxy and configures the pattern.\n    (_this$_preLaunched$so = this._preLaunched.socksProxy) === null || _this$_preLaunched$so === void 0 ? void 0 : _this$_preLaunched$so.setPattern(this._options.socksProxyPattern);\n    const browser = this._preLaunched.browser;\n    browser.on(_browser.Browser.Events.Disconnected, () => {\n      // Underlying browser did close for some reason - force disconnect the client.\n      this.close({\n        code: 1001,\n        reason: 'Browser closed'\n      });\n    });\n    const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, this._preLaunched.socksProxy, browser);\n    // In pre-launched mode, keep only the pre-launched browser.\n    for (const b of playwright.allBrowsers()) {\n      if (b !== browser) await b.close();\n    }\n    this._cleanups.push(() => playwrightDispatcher.cleanup());\n    return playwrightDispatcher;\n  }\n  async _initPreLaunchedAndroidMode(scope) {\n    this._debugLog(`engaged pre-launched (Android) mode`);\n    const playwright = this._preLaunched.playwright;\n    const androidDevice = this._preLaunched.androidDevice;\n    androidDevice.on(_android.AndroidDevice.Events.Close, () => {\n      // Underlying browser did close for some reason - force disconnect the client.\n      this.close({\n        code: 1001,\n        reason: 'Android device disconnected'\n      });\n    });\n    const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, undefined, undefined, androidDevice);\n    this._cleanups.push(() => playwrightDispatcher.cleanup());\n    return playwrightDispatcher;\n  }\n  _initDebugControllerMode() {\n    this._debugLog(`engaged reuse controller mode`);\n    const playwright = this._preLaunched.playwright;\n    // Always create new instance based on the reused Playwright instance.\n    return new _debugControllerDispatcher.DebugControllerDispatcher(this._dispatcherConnection, playwright.debugController);\n  }\n  async _initReuseBrowsersMode(scope) {\n    // Note: reuse browser mode does not support socks proxy, because\n    // clients come and go, while the browser stays the same.\n\n    this._debugLog(`engaged reuse browsers mode for ${this._options.browserName}`);\n    const playwright = this._preLaunched.playwright;\n    const requestedOptions = launchOptionsHash(this._options.launchOptions);\n    let browser = playwright.allBrowsers().find(b => {\n      if (b.options.name !== this._options.browserName) return false;\n      const existingOptions = launchOptionsHash(b.options.originalLaunchOptions);\n      return existingOptions === requestedOptions;\n    });\n\n    // Close remaining browsers of this type+channel. Keep different browser types for the speed.\n    for (const b of playwright.allBrowsers()) {\n      if (b === browser) continue;\n      if (b.options.name === this._options.browserName && b.options.channel === this._options.launchOptions.channel) await b.close();\n    }\n    if (!browser) {\n      browser = await playwright[this._options.browserName || 'chromium'].launch((0, _instrumentation.serverSideCallMetadata)(), {\n        ...this._options.launchOptions,\n        headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS\n      });\n      browser.on(_browser.Browser.Events.Disconnected, () => {\n        // Underlying browser did close for some reason - force disconnect the client.\n        this.close({\n          code: 1001,\n          reason: 'Browser closed'\n        });\n      });\n    }\n    this._cleanups.push(async () => {\n      // Don't close the pages so that user could debug them,\n      // but close all the empty browsers and contexts to clean up.\n      for (const browser of playwright.allBrowsers()) {\n        for (const context of browser.contexts()) {\n          if (!context.pages().length) await context.close((0, _instrumentation.serverSideCallMetadata)());else await context.stopPendingOperations();\n        }\n        if (!browser.contexts()) await browser.close();\n      }\n    });\n    const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, undefined, browser);\n    return playwrightDispatcher;\n  }\n  async _createOwnedSocksProxy(playwright) {\n    const socksProxy = new _socksProxy.SocksProxy();\n    socksProxy.setPattern(this._options.socksProxyPattern);\n    playwright.options.socksProxyPort = await socksProxy.listen(0);\n    this._debugLog(`started socks proxy on port ${playwright.options.socksProxyPort}`);\n    this._cleanups.push(() => socksProxy.close());\n    return socksProxy;\n  }\n  async _onDisconnect(error) {\n    this._disconnected = true;\n    this._debugLog(`disconnected. error: ${error}`);\n    this._root._dispose();\n    this._debugLog(`starting cleanup`);\n    for (const cleanup of this._cleanups) await cleanup().catch(() => {});\n    this._onClose();\n    this._debugLog(`finished cleanup`);\n  }\n  async close(reason) {\n    if (this._disconnected) return;\n    this._debugLog(`force closing connection: ${(reason === null || reason === void 0 ? void 0 : reason.reason) || ''} (${(reason === null || reason === void 0 ? void 0 : reason.code) || 0})`);\n    try {\n      this._ws.close(reason === null || reason === void 0 ? void 0 : reason.code, reason === null || reason === void 0 ? void 0 : reason.reason);\n    } catch (e) {}\n  }\n}\nexports.PlaywrightConnection = PlaywrightConnection;\nfunction launchOptionsHash(options) {\n  const copy = {\n    ...options\n  };\n  for (const k of Object.keys(copy)) {\n    const key = k;\n    if (copy[key] === defaultLaunchOptions[key]) delete copy[key];\n  }\n  for (const key of optionsThatAllowBrowserReuse) delete copy[key];\n  return JSON.stringify(copy);\n}\nconst defaultLaunchOptions = {\n  ignoreAllDefaultArgs: false,\n  handleSIGINT: false,\n  handleSIGTERM: false,\n  handleSIGHUP: false,\n  headless: true,\n  devtools: false\n};\nconst optionsThatAllowBrowserReuse = ['headless'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Semaphore = exports.PlaywrightServer = void 0;\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _http = _interopRequireDefault(require(\"http\"));\nvar _playwright = require(\"../server/playwright\");\nvar _playwrightConnection = require(\"./playwrightConnection\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst debugLog = (0, _utilsBundle.debug)('pw:server');\nlet lastConnectionId = 0;\nconst kConnectionSymbol = Symbol('kConnection');\nfunction newLogger() {\n  const id = ++lastConnectionId;\n  return message => debugLog(`[id=${id}] ${message}`);\n}\nclass PlaywrightServer {\n  constructor(options) {\n    this._preLaunchedPlaywright = void 0;\n    this._wsServer = void 0;\n    this._options = void 0;\n    this._options = options;\n    if (options.preLaunchedBrowser) this._preLaunchedPlaywright = options.preLaunchedBrowser.options.rootSdkObject;\n    if (options.preLaunchedAndroidDevice) this._preLaunchedPlaywright = options.preLaunchedAndroidDevice._android._playwrightOptions.rootSdkObject;\n  }\n  async listen(port = 0) {\n    const server = _http.default.createServer((request, response) => {\n      if (request.method === 'GET' && request.url === '/json') {\n        response.setHeader('Content-Type', 'application/json');\n        response.end(JSON.stringify({\n          wsEndpointPath: this._options.path\n        }));\n        return;\n      }\n      response.end('Running');\n    });\n    server.on('error', error => debugLog(error));\n    const wsEndpoint = await new Promise((resolve, reject) => {\n      server.listen(port, () => {\n        const address = server.address();\n        if (!address) {\n          reject(new Error('Could not bind server socket'));\n          return;\n        }\n        const wsEndpoint = typeof address === 'string' ? `${address}${this._options.path}` : `ws://127.0.0.1:${address.port}${this._options.path}`;\n        resolve(wsEndpoint);\n      }).on('error', reject);\n    });\n    debugLog('Listening at ' + wsEndpoint);\n    this._wsServer = new _utilsBundle.wsServer({\n      server,\n      path: this._options.path\n    });\n    const browserSemaphore = new Semaphore(this._options.maxConnections);\n    const controllerSemaphore = new Semaphore(1);\n    const reuseBrowserSemaphore = new Semaphore(1);\n    this._wsServer.on('connection', (ws, request) => {\n      const url = new URL('http://localhost' + (request.url || ''));\n      const browserHeader = request.headers['x-playwright-browser'];\n      const browserName = url.searchParams.get('browser') || (Array.isArray(browserHeader) ? browserHeader[0] : browserHeader) || null;\n      const proxyHeader = request.headers['x-playwright-proxy'];\n      const proxyValue = url.searchParams.get('proxy') || (Array.isArray(proxyHeader) ? proxyHeader[0] : proxyHeader);\n      const launchOptionsHeader = request.headers['x-playwright-launch-options'] || '';\n      let launchOptions = {};\n      try {\n        launchOptions = JSON.parse(Array.isArray(launchOptionsHeader) ? launchOptionsHeader[0] : launchOptionsHeader);\n      } catch (e) {}\n      const log = newLogger();\n      log(`serving connection: ${request.url}`);\n      const isDebugControllerClient = !!request.headers['x-playwright-debug-controller'];\n      const shouldReuseBrowser = !!request.headers['x-playwright-reuse-context'];\n\n      // If we started in the legacy reuse-browser mode, create this._preLaunchedPlaywright.\n      // If we get a debug-controller request, create this._preLaunchedPlaywright.\n      if (isDebugControllerClient || shouldReuseBrowser) {\n        if (!this._preLaunchedPlaywright) this._preLaunchedPlaywright = (0, _playwright.createPlaywright)('javascript');\n      }\n      let clientType = 'playwright';\n      let semaphore = browserSemaphore;\n      if (isDebugControllerClient) {\n        clientType = 'controller';\n        semaphore = controllerSemaphore;\n      } else if (shouldReuseBrowser) {\n        clientType = 'reuse-browser';\n        semaphore = reuseBrowserSemaphore;\n      } else if (this._options.preLaunchedBrowser || this._options.preLaunchedAndroidDevice) {\n        clientType = 'pre-launched-browser-or-android';\n        semaphore = browserSemaphore;\n      } else if (browserName) {\n        clientType = 'launch-browser';\n        semaphore = browserSemaphore;\n      }\n      const connection = new _playwrightConnection.PlaywrightConnection(semaphore.aquire(), clientType, ws, {\n        socksProxyPattern: proxyValue,\n        browserName,\n        launchOptions\n      }, {\n        playwright: this._preLaunchedPlaywright,\n        browser: this._options.preLaunchedBrowser,\n        androidDevice: this._options.preLaunchedAndroidDevice,\n        socksProxy: this._options.preLaunchedSocksProxy\n      }, log, () => semaphore.release());\n      ws[kConnectionSymbol] = connection;\n    });\n    return wsEndpoint;\n  }\n  async close() {\n    const server = this._wsServer;\n    if (!server) return;\n    debugLog('closing websocket server');\n    const waitForClose = new Promise(f => server.close(f));\n    // First disconnect all remaining clients.\n    await Promise.all(Array.from(server.clients).map(async ws => {\n      const connection = ws[kConnectionSymbol];\n      if (connection) await connection.close();\n      try {\n        ws.terminate();\n      } catch (e) {}\n    }));\n    await waitForClose;\n    debugLog('closing http server');\n    await new Promise(f => server.options.server.close(f));\n    this._wsServer = undefined;\n    debugLog('closed server');\n    debugLog('closing browsers');\n    if (this._preLaunchedPlaywright) await Promise.all(this._preLaunchedPlaywright.allBrowsers().map(browser => browser.close()));\n    debugLog('closed browsers');\n  }\n}\nexports.PlaywrightServer = PlaywrightServer;\nclass Semaphore {\n  constructor(max) {\n    this._max = void 0;\n    this._aquired = 0;\n    this._queue = [];\n    this._max = max;\n  }\n  setMax(max) {\n    this._max = max;\n  }\n  aquire() {\n    const lock = new _manualPromise.ManualPromise();\n    this._queue.push(lock);\n    this._flush();\n    return lock;\n  }\n  release() {\n    --this._aquired;\n    this._flush();\n  }\n  _flush() {\n    while (this._aquired < this._max && this._queue.length) {\n      ++this._aquired;\n      this._queue.shift().resolve();\n    }\n  }\n}\nexports.Semaphore = Semaphore;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Accessibility = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Accessibility {\n  constructor(getAXTree) {\n    this._getAXTree = void 0;\n    this._getAXTree = getAXTree;\n  }\n  async snapshot(options = {}) {\n    const {\n      interestingOnly = true,\n      root = null\n    } = options;\n    const {\n      tree,\n      needle\n    } = await this._getAXTree(root || undefined);\n    if (!interestingOnly) {\n      if (root) return needle && serializeTree(needle)[0];\n      return serializeTree(tree)[0];\n    }\n    const interestingNodes = new Set();\n    collectInterestingNodes(interestingNodes, tree, false);\n    if (root && (!needle || !interestingNodes.has(needle))) return null;\n    return serializeTree(needle || tree, interestingNodes)[0];\n  }\n}\nexports.Accessibility = Accessibility;\nfunction collectInterestingNodes(collection, node, insideControl) {\n  if (node.isInteresting(insideControl)) collection.add(node);\n  if (node.isLeafNode()) return;\n  insideControl = insideControl || node.isControl();\n  for (const child of node.children()) collectInterestingNodes(collection, child, insideControl);\n}\nfunction serializeTree(node, whitelistedNodes) {\n  const children = [];\n  for (const child of node.children()) children.push(...serializeTree(child, whitelistedNodes));\n  if (whitelistedNodes && !whitelistedNodes.has(node)) return children;\n  const serializedNode = node.serialize();\n  if (children.length) serializedNode.children = children;\n  return [serializedNode];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AndroidDevice = exports.Android = void 0;\nvar _utilsBundle = require(\"../../utilsBundle\");\nvar _events = require(\"events\");\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _utils = require(\"../../utils\");\nvar _fileUtils = require(\"../../utils/fileUtils\");\nvar _browserContext = require(\"../browserContext\");\nvar _progress = require(\"../progress\");\nvar _crBrowser = require(\"../chromium/crBrowser\");\nvar _helper = require(\"../helper\");\nvar _transport = require(\"../../protocol/transport\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _processLauncher = require(\"../../utils/processLauncher\");\nvar _timeoutSettings = require(\"../../common/timeoutSettings\");\nvar _instrumentation = require(\"../instrumentation\");\nvar _chromiumSwitches = require(\"../chromium/chromiumSwitches\");\nvar _registry = require(\"../registry\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), 'playwright-artifacts-');\nclass Android extends _instrumentation.SdkObject {\n  constructor(backend, playwrightOptions) {\n    super(playwrightOptions.rootSdkObject, 'android');\n    this._backend = void 0;\n    this._devices = new Map();\n    this._timeoutSettings = void 0;\n    this._playwrightOptions = void 0;\n    this._backend = backend;\n    this._playwrightOptions = playwrightOptions;\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n  async devices(options) {\n    const devices = (await this._backend.devices(options)).filter(d => d.status === 'device');\n    const newSerials = new Set();\n    for (const d of devices) {\n      newSerials.add(d.serial);\n      if (this._devices.has(d.serial)) continue;\n      const device = await AndroidDevice.create(this, d, options);\n      this._devices.set(d.serial, device);\n    }\n    for (const d of this._devices.keys()) {\n      if (!newSerials.has(d)) this._devices.delete(d);\n    }\n    return [...this._devices.values()];\n  }\n  _deviceClosed(device) {\n    this._devices.delete(device.serial);\n  }\n}\nexports.Android = Android;\nclass AndroidDevice extends _instrumentation.SdkObject {\n  constructor(android, backend, model, options) {\n    super(android, 'android-device');\n    this._backend = void 0;\n    this.model = void 0;\n    this.serial = void 0;\n    this._options = void 0;\n    this._driverPromise = void 0;\n    this._lastId = 0;\n    this._callbacks = new Map();\n    this._pollingWebViews = void 0;\n    this._timeoutSettings = void 0;\n    this._webViews = new Map();\n    this._browserConnections = new Set();\n    this._android = void 0;\n    this._isClosed = false;\n    this._android = android;\n    this._backend = backend;\n    this.model = model;\n    this.serial = backend.serial;\n    this._options = options;\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(android._timeoutSettings);\n  }\n  static async create(android, backend, options) {\n    await backend.init();\n    const model = await backend.runCommand('shell:getprop ro.product.model');\n    const device = new AndroidDevice(android, backend, model.toString().trim(), options);\n    await device._init();\n    return device;\n  }\n  async _init() {\n    await this._refreshWebViews();\n    const poll = () => {\n      this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {\n        this.close().catch(() => {});\n      }), 500);\n    };\n    poll();\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n  async shell(command) {\n    const result = await this._backend.runCommand(`shell:${command}`);\n    await this._refreshWebViews();\n    return result;\n  }\n  async open(command) {\n    return await this._backend.open(`${command}`);\n  }\n  async screenshot() {\n    return await this._backend.runCommand(`shell:screencap -p`);\n  }\n  async _driver() {\n    if (this._isClosed) return;\n    if (!this._driverPromise) this._driverPromise = this._installDriver();\n    return this._driverPromise;\n  }\n  async _installDriver() {\n    (0, _utilsBundle.debug)('pw:android')('Stopping the old driver');\n    await this.shell(`am force-stop com.microsoft.playwright.androiddriver`);\n\n    // uninstall and install driver on every excution\n    if (!this._options.omitDriverInstall) {\n      (0, _utilsBundle.debug)('pw:android')('Uninstalling the old driver');\n      await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);\n      await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);\n      (0, _utilsBundle.debug)('pw:android')('Installing the new driver');\n      const executable = _registry.registry.findExecutable('android');\n      for (const file of ['android-driver.apk', 'android-driver-target.apk']) {\n        const fullName = _path.default.join(executable.directory, file);\n        if (!_fs.default.existsSync(fullName)) throw new Error('Please install Android driver apk using `npx playwright install android`');\n        await this.installApk(await _fs.default.promises.readFile(fullName));\n      }\n    } else {\n      (0, _utilsBundle.debug)('pw:android')('Skipping the driver installation');\n    }\n    (0, _utilsBundle.debug)('pw:android')('Starting the new driver');\n    this.shell('am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner').catch(e => (0, _utilsBundle.debug)('pw:android')(e));\n    const socket = await this._waitForLocalAbstract('playwright_android_driver_socket');\n    const transport = new _transport.PipeTransport(socket, socket, socket, 'be');\n    transport.onmessage = message => {\n      const response = JSON.parse(message);\n      const {\n        id,\n        result,\n        error\n      } = response;\n      const callback = this._callbacks.get(id);\n      if (!callback) return;\n      if (error) callback.reject(new Error(error));else callback.fulfill(result);\n      this._callbacks.delete(id);\n    };\n    return transport;\n  }\n  async _waitForLocalAbstract(socketName) {\n    let socket;\n    (0, _utilsBundle.debug)('pw:android')(`Polling the socket localabstract:${socketName}`);\n    while (!socket) {\n      try {\n        socket = await this._backend.open(`localabstract:${socketName}`);\n      } catch (e) {\n        await new Promise(f => setTimeout(f, 250));\n      }\n    }\n    (0, _utilsBundle.debug)('pw:android')(`Connected to localabstract:${socketName}`);\n    return socket;\n  }\n  async send(method, params = {}) {\n    // Patch the timeout in!\n    params.timeout = this._timeoutSettings.timeout(params);\n    const driver = await this._driver();\n    if (!driver) throw new Error('Device is closed');\n    const id = ++this._lastId;\n    const result = new Promise((fulfill, reject) => this._callbacks.set(id, {\n      fulfill,\n      reject\n    }));\n    driver.send(JSON.stringify({\n      id,\n      method,\n      params\n    }));\n    return result;\n  }\n  async close() {\n    if (this._isClosed) return;\n    this._isClosed = true;\n    if (this._pollingWebViews) clearTimeout(this._pollingWebViews);\n    for (const connection of this._browserConnections) await connection.close();\n    if (this._driverPromise) {\n      const driver = await this._driver();\n      driver === null || driver === void 0 ? void 0 : driver.close();\n    }\n    await this._backend.close();\n    this._android._deviceClosed(this);\n    this.emit(AndroidDevice.Events.Close);\n  }\n  async launchBrowser(pkg = 'com.android.chrome', options) {\n    (0, _utilsBundle.debug)('pw:android')('Force-stopping', pkg);\n    await this._backend.runCommand(`shell:am force-stop ${pkg}`);\n    const socketName = (0, _utils.isUnderTest)() ? 'webview_devtools_remote_playwright_test' : 'playwright-' + (0, _utils.createGuid)();\n    const commandLine = this._defaultArgs(options, socketName).join(' ');\n    (0, _utilsBundle.debug)('pw:android')('Starting', pkg, commandLine);\n    // encode commandLine to base64 to avoid issues (bash encoding) with special characters\n    await this._backend.runCommand(`shell:echo \"${Buffer.from(commandLine).toString('base64')}\" | base64 -d > /data/local/tmp/chrome-command-line`);\n    await this._backend.runCommand(`shell:am start -a android.intent.action.VIEW -d about:blank ${pkg}`);\n    return await this._connectToBrowser(socketName, options);\n  }\n  _defaultArgs(options, socketName) {\n    const chromeArguments = ['_', '--disable-fre', '--no-default-browser-check', `--remote-debugging-socket-name=${socketName}`, ..._chromiumSwitches.chromiumSwitches, ...this._innerDefaultArgs(options)];\n    return chromeArguments;\n  }\n  _innerDefaultArgs(options) {\n    const {\n      args = [],\n      proxy\n    } = options;\n    const chromeArguments = [];\n    if (proxy) {\n      chromeArguments.push(`--proxy-server=${proxy.server}`);\n      const proxyBypassRules = [];\n      if (proxy.bypass) proxyBypassRules.push(...proxy.bypass.split(',').map(t => t.trim()).map(t => t.startsWith('.') ? '*' + t : t));\n      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes('<-loopback>')) proxyBypassRules.push('<-loopback>');\n      if (proxyBypassRules.length > 0) chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(';')}`);\n    }\n    chromeArguments.push(...args);\n    return chromeArguments;\n  }\n  async connectToWebView(socketName) {\n    const webView = this._webViews.get(socketName);\n    if (!webView) throw new Error('WebView has been closed');\n    return await this._connectToBrowser(socketName);\n  }\n  async _connectToBrowser(socketName, options = {}) {\n    const socket = await this._waitForLocalAbstract(socketName);\n    const androidBrowser = new AndroidBrowser(this, socket);\n    await androidBrowser._init();\n    this._browserConnections.add(androidBrowser);\n    const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);\n    const cleanupArtifactsDir = async () => {\n      const errors = await (0, _fileUtils.removeFolders)([artifactsDir]);\n      for (let i = 0; i < (errors || []).length; ++i) (0, _utilsBundle.debug)('pw:android')(`exception while removing ${artifactsDir}: ${errors[i]}`);\n    };\n    _processLauncher.gracefullyCloseSet.add(cleanupArtifactsDir);\n    socket.on('close', async () => {\n      _processLauncher.gracefullyCloseSet.delete(cleanupArtifactsDir);\n      cleanupArtifactsDir().catch(e => (0, _utilsBundle.debug)('pw:android')(`could not cleanup artifacts dir: ${e}`));\n    });\n    const browserOptions = {\n      ...this._android._playwrightOptions,\n      name: 'clank',\n      isChromium: true,\n      slowMo: 0,\n      persistent: {\n        ...options,\n        noDefaultViewport: true\n      },\n      artifactsDir,\n      downloadsPath: artifactsDir,\n      tracesDir: artifactsDir,\n      browserProcess: new ClankBrowserProcess(androidBrowser),\n      proxy: options.proxy,\n      protocolLogger: _helper.helper.debugProtocolLogger(),\n      browserLogsCollector: new _debugLogger.RecentLogsCollector(),\n      originalLaunchOptions: {}\n    };\n    (0, _browserContext.validateBrowserContextOptions)(options, browserOptions);\n    const browser = await _crBrowser.CRBrowser.connect(androidBrowser, browserOptions);\n    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);\n    const defaultContext = browser._defaultContext;\n    await controller.run(async progress => {\n      await defaultContext._loadDefaultContextAsIs(progress);\n    });\n    return defaultContext;\n  }\n  webViews() {\n    return [...this._webViews.values()];\n  }\n  async installApk(content, options) {\n    const args = options && options.args ? options.args : ['-r', '-t', '-S'];\n    (0, _utilsBundle.debug)('pw:android')('Opening install socket');\n    const installSocket = await this._backend.open(`shell:cmd package install ${args.join(' ')} ${content.length}`);\n    (0, _utilsBundle.debug)('pw:android')('Writing driver bytes: ' + content.length);\n    await installSocket.write(content);\n    const success = await new Promise(f => installSocket.on('data', f));\n    (0, _utilsBundle.debug)('pw:android')('Written driver bytes: ' + success);\n    installSocket.close();\n  }\n  async push(content, path, mode = 0o644) {\n    const socket = await this._backend.open(`sync:`);\n    const sendHeader = async (command, length) => {\n      const buffer = Buffer.alloc(command.length + 4);\n      buffer.write(command, 0);\n      buffer.writeUInt32LE(length, command.length);\n      await socket.write(buffer);\n    };\n    const send = async (command, data) => {\n      await sendHeader(command, data.length);\n      await socket.write(data);\n    };\n    await send('SEND', Buffer.from(`${path},${mode}`));\n    const maxChunk = 65535;\n    for (let i = 0; i < content.length; i += maxChunk) await send('DATA', content.slice(i, i + maxChunk));\n    await sendHeader('DONE', Date.now() / 1000 | 0);\n    const result = await new Promise(f => socket.once('data', f));\n    const code = result.slice(0, 4).toString();\n    if (code !== 'OKAY') throw new Error('Could not push: ' + code);\n    socket.close();\n  }\n  async _refreshWebViews() {\n    // possible socketName, eg: webview_devtools_remote_32327, webview_devtools_remote_32327_zeus, webview_devtools_remote_zeus\n    const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split('\\n');\n    if (this._isClosed) return;\n    const socketNames = new Set();\n    for (const line of sockets) {\n      const matchSocketName = line.match(/[^@]+@(.*?webview_devtools_remote_?.*)/);\n      if (!matchSocketName) continue;\n      const socketName = matchSocketName[1];\n      socketNames.add(socketName);\n      if (this._webViews.has(socketName)) continue;\n\n      // possible line: 0000000000000000: 00000002 00000000 00010000 0001 01 5841881 @webview_devtools_remote_zeus\n      // the result: match[1] = ''\n      const match = line.match(/[^@]+@.*?webview_devtools_remote_?(\\d*)/);\n      let pid = -1;\n      if (match && match[1]) pid = +match[1];\n      const pkg = await this._extractPkg(pid);\n      if (this._isClosed) return;\n      const webView = {\n        pid,\n        pkg,\n        socketName\n      };\n      this._webViews.set(socketName, webView);\n      this.emit(AndroidDevice.Events.WebViewAdded, webView);\n    }\n    for (const p of this._webViews.keys()) {\n      if (!socketNames.has(p)) {\n        this._webViews.delete(p);\n        this.emit(AndroidDevice.Events.WebViewRemoved, p);\n      }\n    }\n  }\n  async _extractPkg(pid) {\n    let pkg = '';\n    if (pid === -1) return pkg;\n    const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split('\\n');\n    for (const proc of procs) {\n      const match = proc.match(/[^\\s]+\\s+(\\d+).*$/);\n      if (!match) continue;\n      pkg = proc.substring(proc.lastIndexOf(' ') + 1);\n    }\n    return pkg;\n  }\n}\nexports.AndroidDevice = AndroidDevice;\nAndroidDevice.Events = {\n  WebViewAdded: 'webViewAdded',\n  WebViewRemoved: 'webViewRemoved',\n  Close: 'close'\n};\nclass AndroidBrowser extends _events.EventEmitter {\n  constructor(device, socket) {\n    super();\n    this.device = void 0;\n    this._socket = void 0;\n    this._receiver = void 0;\n    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();\n    this.onmessage = void 0;\n    this.onclose = void 0;\n    this.setMaxListeners(0);\n    this.device = device;\n    this._socket = socket;\n    this._socket.on('close', () => {\n      this._waitForNextTask(() => {\n        if (this.onclose) this.onclose();\n      });\n    });\n    this._receiver = new _utilsBundle.wsReceiver();\n    this._receiver.on('message', message => {\n      this._waitForNextTask(() => {\n        if (this.onmessage) this.onmessage(JSON.parse(message));\n      });\n    });\n  }\n  async _init() {\n    await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\\r\nUpgrade: WebSocket\\r\nConnection: Upgrade\\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\nSec-WebSocket-Version: 13\\r\n\\r\n`));\n    // HTTP Upgrade response.\n    await new Promise(f => this._socket.once('data', f));\n\n    // Start sending web frame to receiver.\n    this._socket.on('data', data => this._receiver._write(data, 'binary', () => {}));\n  }\n  async send(s) {\n    await this._socket.write(encodeWebFrame(JSON.stringify(s)));\n  }\n  async close() {\n    this._socket.close();\n  }\n}\nfunction encodeWebFrame(data) {\n  return _utilsBundle.wsSender.frame(Buffer.from(data), {\n    opcode: 1,\n    mask: true,\n    fin: true,\n    readOnly: true\n  })[0];\n}\nclass ClankBrowserProcess {\n  constructor(browser) {\n    this._browser = void 0;\n    this.onclose = void 0;\n    this._browser = browser;\n  }\n  async kill() {}\n  async close() {\n    await this._browser.close();\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AdbBackend = void 0;\nvar _utilsBundle = require(\"../../utilsBundle\");\nvar net = _interopRequireWildcard(require(\"net\"));\nvar _events = require(\"events\");\nvar _utils = require(\"../../utils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass AdbBackend {\n  async devices(options = {}) {\n    const result = await runCommand('host:devices', options.host, options.port);\n    const lines = result.toString().trim().split('\\n');\n    return lines.map(line => {\n      const [serial, status] = line.trim().split('\\t');\n      return new AdbDevice(serial, status, options.host, options.port);\n    });\n  }\n}\nexports.AdbBackend = AdbBackend;\nclass AdbDevice {\n  constructor(serial, status, host, port) {\n    this.serial = void 0;\n    this.status = void 0;\n    this.host = void 0;\n    this.port = void 0;\n    this._closed = false;\n    this.serial = serial;\n    this.status = status;\n    this.host = host;\n    this.port = port;\n  }\n  async init() {}\n  async close() {\n    this._closed = true;\n  }\n  runCommand(command) {\n    if (this._closed) throw new Error('Device is closed');\n    return runCommand(command, this.host, this.port, this.serial);\n  }\n  async open(command) {\n    if (this._closed) throw new Error('Device is closed');\n    const result = await open(command, this.host, this.port, this.serial);\n    result.becomeSocket();\n    return result;\n  }\n}\nasync function runCommand(command, host = '127.0.0.1', port = 5037, serial) {\n  (0, _utilsBundle.debug)('pw:adb:runCommand')(command, serial);\n  const socket = new BufferedSocketWrapper(command, net.createConnection({\n    host,\n    port\n  }));\n  try {\n    if (serial) {\n      await socket.write(encodeMessage(`host:transport:${serial}`));\n      const status = await socket.read(4);\n      (0, _utils.assert)(status.toString() === 'OKAY', status.toString());\n    }\n    await socket.write(encodeMessage(command));\n    const status = await socket.read(4);\n    (0, _utils.assert)(status.toString() === 'OKAY', status.toString());\n    let commandOutput;\n    if (!command.startsWith('shell:')) {\n      const remainingLength = parseInt((await socket.read(4)).toString(), 16);\n      commandOutput = await socket.read(remainingLength);\n    } else {\n      commandOutput = await socket.readAll();\n    }\n    return commandOutput;\n  } finally {\n    socket.close();\n  }\n}\nasync function open(command, host = '127.0.0.1', port = 5037, serial) {\n  const socket = new BufferedSocketWrapper(command, net.createConnection({\n    host,\n    port\n  }));\n  if (serial) {\n    await socket.write(encodeMessage(`host:transport:${serial}`));\n    const status = await socket.read(4);\n    (0, _utils.assert)(status.toString() === 'OKAY', status.toString());\n  }\n  await socket.write(encodeMessage(command));\n  const status = await socket.read(4);\n  (0, _utils.assert)(status.toString() === 'OKAY', status.toString());\n  return socket;\n}\nfunction encodeMessage(message) {\n  let lenHex = message.length.toString(16);\n  lenHex = '0'.repeat(4 - lenHex.length) + lenHex;\n  return Buffer.from(lenHex + message);\n}\nclass BufferedSocketWrapper extends _events.EventEmitter {\n  constructor(command, socket) {\n    super();\n    this.guid = (0, _utils.createGuid)();\n    this._socket = void 0;\n    this._buffer = Buffer.from([]);\n    this._isSocket = false;\n    this._notifyReader = void 0;\n    this._connectPromise = void 0;\n    this._isClosed = false;\n    this._command = void 0;\n    this._command = command;\n    this._socket = socket;\n    this._connectPromise = new Promise(f => this._socket.on('connect', f));\n    this._socket.on('data', data => {\n      (0, _utilsBundle.debug)('pw:adb:data')(data.toString());\n      if (this._isSocket) {\n        this.emit('data', data);\n        return;\n      }\n      this._buffer = Buffer.concat([this._buffer, data]);\n      if (this._notifyReader) this._notifyReader();\n    });\n    this._socket.on('close', () => {\n      this._isClosed = true;\n      if (this._notifyReader) this._notifyReader();\n      this.close();\n      this.emit('close');\n    });\n    this._socket.on('error', error => this.emit('error', error));\n  }\n  async write(data) {\n    (0, _utilsBundle.debug)('pw:adb:send')(data.toString().substring(0, 100) + '...');\n    await this._connectPromise;\n    await new Promise(f => this._socket.write(data, f));\n  }\n  close() {\n    if (this._isClosed) return;\n    (0, _utilsBundle.debug)('pw:adb')('Close ' + this._command);\n    this._socket.destroy();\n  }\n  async read(length) {\n    await this._connectPromise;\n    (0, _utils.assert)(!this._isSocket, 'Can not read by length in socket mode');\n    while (this._buffer.length < length) await new Promise(f => this._notifyReader = f);\n    const result = this._buffer.slice(0, length);\n    this._buffer = this._buffer.slice(length);\n    (0, _utilsBundle.debug)('pw:adb:recv')(result.toString().substring(0, 100) + '...');\n    return result;\n  }\n  async readAll() {\n    while (!this._isClosed) await new Promise(f => this._notifyReader = f);\n    return this._buffer;\n  }\n  becomeSocket() {\n    (0, _utils.assert)(!this._buffer.length);\n    this._isSocket = true;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Artifact = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _utils = require(\"../utils\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nvar _instrumentation = require(\"./instrumentation\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Artifact extends _instrumentation.SdkObject {\n  constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {\n    super(parent, 'artifact');\n    this._localPath = void 0;\n    this._unaccessibleErrorMessage = void 0;\n    this._cancelCallback = void 0;\n    this._finishedPromise = new _manualPromise.ManualPromise();\n    this._saveCallbacks = [];\n    this._finished = false;\n    this._deleted = false;\n    this._failureError = null;\n    this._localPath = localPath;\n    this._unaccessibleErrorMessage = unaccessibleErrorMessage;\n    this._cancelCallback = cancelCallback;\n  }\n  finishedPromise() {\n    return this._finishedPromise;\n  }\n  localPath() {\n    return this._localPath;\n  }\n  async localPathAfterFinished() {\n    if (this._unaccessibleErrorMessage) throw new Error(this._unaccessibleErrorMessage);\n    await this._finishedPromise;\n    if (this._failureError) return null;\n    return this._localPath;\n  }\n  saveAs(saveCallback) {\n    if (this._unaccessibleErrorMessage) throw new Error(this._unaccessibleErrorMessage);\n    if (this._deleted) throw new Error(`File already deleted. Save before deleting.`);\n    if (this._failureError) throw new Error(`File not found on disk. Check download.failure() for details.`);\n    if (this._finished) {\n      saveCallback(this._localPath).catch(e => {});\n      return;\n    }\n    this._saveCallbacks.push(saveCallback);\n  }\n  async failureError() {\n    if (this._unaccessibleErrorMessage) return this._unaccessibleErrorMessage;\n    await this._finishedPromise;\n    return this._failureError;\n  }\n  async cancel() {\n    (0, _utils.assert)(this._cancelCallback !== undefined);\n    return this._cancelCallback();\n  }\n  async delete() {\n    if (this._unaccessibleErrorMessage) return;\n    const fileName = await this.localPathAfterFinished();\n    if (this._deleted) return;\n    this._deleted = true;\n    if (fileName) await _fs.default.promises.unlink(fileName).catch(e => {});\n  }\n  async deleteOnContextClose() {\n    // Compared to \"delete\", this method does not wait for the artifact to finish.\n    // We use it when closing the context to avoid stalling.\n    if (this._deleted) return;\n    this._deleted = true;\n    if (!this._unaccessibleErrorMessage) await _fs.default.promises.unlink(this._localPath).catch(e => {});\n    await this.reportFinished('File deleted upon browser context closure.');\n  }\n  async reportFinished(error) {\n    if (this._finished) return;\n    this._finished = true;\n    this._failureError = error || null;\n    if (error) {\n      for (const callback of this._saveCallbacks) await callback('', error);\n    } else {\n      for (const callback of this._saveCallbacks) await callback(this._localPath);\n    }\n    this._saveCallbacks = [];\n    this._finishedPromise.resolve();\n  }\n}\nexports.Artifact = Artifact;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Browser = void 0;\nvar _browserContext = require(\"./browserContext\");\nvar _page = require(\"./page\");\nvar _download = require(\"./download\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _artifact = require(\"./artifact\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Browser extends _instrumentation.SdkObject {\n  constructor(options) {\n    super(options.rootSdkObject, 'browser');\n    this.options = void 0;\n    this._downloads = new Map();\n    this._defaultContext = null;\n    this._startedClosing = false;\n    this._idToVideo = new Map();\n    this._contextForReuse = void 0;\n    this.attribution.browser = this;\n    this.options = options;\n    this.instrumentation.onBrowserOpen(this);\n  }\n  async newContext(metadata, options) {\n    (0, _browserContext.validateBrowserContextOptions)(options, this.options);\n    const context = await this.doCreateNewContext(options);\n    if (options.storageState) await context.setStorageState(metadata, options.storageState);\n    return context;\n  }\n  async newContextForReuse(params, metadata) {\n    const hash = _browserContext.BrowserContext.reusableContextHash(params);\n    if (!this._contextForReuse || hash !== this._contextForReuse.hash || !this._contextForReuse.context.canResetForReuse()) {\n      if (this._contextForReuse) await this._contextForReuse.context.close(metadata);\n      this._contextForReuse = {\n        context: await this.newContext(metadata, params),\n        hash\n      };\n      return {\n        context: this._contextForReuse.context,\n        needsReset: false\n      };\n    }\n    await this._contextForReuse.context.stopPendingOperations();\n    return {\n      context: this._contextForReuse.context,\n      needsReset: true\n    };\n  }\n  _downloadCreated(page, uuid, url, suggestedFilename) {\n    const download = new _download.Download(page, this.options.downloadsPath || '', uuid, url, suggestedFilename);\n    this._downloads.set(uuid, download);\n  }\n  _downloadFilenameSuggested(uuid, suggestedFilename) {\n    const download = this._downloads.get(uuid);\n    if (!download) return;\n    download._filenameSuggested(suggestedFilename);\n  }\n  _downloadFinished(uuid, error) {\n    const download = this._downloads.get(uuid);\n    if (!download) return;\n    download.artifact.reportFinished(error);\n    this._downloads.delete(uuid);\n  }\n  _videoStarted(context, videoId, path, pageOrError) {\n    const artifact = new _artifact.Artifact(context, path);\n    this._idToVideo.set(videoId, {\n      context,\n      artifact\n    });\n    pageOrError.then(page => {\n      if (page instanceof _page.Page) {\n        page._video = artifact;\n        page.emitOnContext(_browserContext.BrowserContext.Events.VideoStarted, artifact);\n        page.emit(_page.Page.Events.Video, artifact);\n      }\n    });\n  }\n  _takeVideo(videoId) {\n    const video = this._idToVideo.get(videoId);\n    this._idToVideo.delete(videoId);\n    return video === null || video === void 0 ? void 0 : video.artifact;\n  }\n  _didClose() {\n    for (const context of this.contexts()) context._browserClosed();\n    if (this._defaultContext) this._defaultContext._browserClosed();\n    this.emit(Browser.Events.Disconnected);\n    this.instrumentation.onBrowserClose(this);\n  }\n  async close() {\n    if (!this._startedClosing) {\n      this._startedClosing = true;\n      await this.options.browserProcess.close();\n    }\n    if (this.isConnected()) await new Promise(x => this.once(Browser.Events.Disconnected, x));\n  }\n  async killForTests() {\n    await this.options.browserProcess.kill();\n  }\n}\nexports.Browser = Browser;\nBrowser.Events = {\n  Disconnected: 'disconnected'\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserContext = void 0;\nexports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;\nexports.normalizeProxySettings = normalizeProxySettings;\nexports.validateBrowserContextOptions = validateBrowserContextOptions;\nexports.verifyGeolocation = verifyGeolocation;\nvar os = _interopRequireWildcard(require(\"os\"));\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _utils = require(\"../utils\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _helper = require(\"./helper\");\nvar network = _interopRequireWildcard(require(\"./network\"));\nvar _page6 = require(\"./page\");\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _instrumentation = require(\"./instrumentation\");\nvar _debugger = require(\"./debugger\");\nvar _tracing = require(\"./trace/recorder/tracing\");\nvar _harRecorder = require(\"./har/harRecorder\");\nvar _recorder = require(\"./recorder\");\nvar consoleApiSource = _interopRequireWildcard(require(\"../generated/consoleApiSource\"));\nvar _fetch = require(\"./fetch\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserContext extends _instrumentation.SdkObject {\n  constructor(browser, options, browserContextId) {\n    super(browser, 'browser-context');\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();\n    this._pageBindings = new Map();\n    this._activeProgressControllers = new Set();\n    this._options = void 0;\n    this._requestInterceptor = void 0;\n    this._isPersistentContext = void 0;\n    this._closedStatus = 'open';\n    this._closePromise = void 0;\n    this._closePromiseFulfill = void 0;\n    this._permissions = new Map();\n    this._downloads = new Set();\n    this._browser = void 0;\n    this._browserContextId = void 0;\n    this._selectors = void 0;\n    this._origins = new Set();\n    this._harRecorders = new Map();\n    this.tracing = void 0;\n    this.fetchRequest = void 0;\n    this._customCloseHandler = void 0;\n    this._tempDirs = [];\n    this._settingStorageState = false;\n    this.initScripts = [];\n    this._routesInFlight = new Set();\n    this._debugger = void 0;\n    this.attribution.context = this;\n    this._browser = browser;\n    this._options = options;\n    this._browserContextId = browserContextId;\n    this._isPersistentContext = !browserContextId;\n    this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);\n    this.fetchRequest = new _fetch.BrowserContextAPIRequestContext(this);\n    if (this._options.recordHar) this._harRecorders.set('', new _harRecorder.HarRecorder(this, null, this._options.recordHar));\n    this.tracing = new _tracing.Tracing(this, browser.options.tracesDir);\n  }\n  isPersistentContext() {\n    return this._isPersistentContext;\n  }\n  setSelectors(selectors) {\n    this._selectors = selectors;\n    for (const page of this.pages()) page.selectors = selectors;\n  }\n  selectors() {\n    return this._selectors || this._browser.options.selectors;\n  }\n  async _initialize() {\n    if (this.attribution.isInternalPlaywright) return;\n    // Debugger will pause execution upon page.pause in headed mode.\n    this._debugger = new _debugger.Debugger(this);\n\n    // When PWDEBUG=1, show inspector for each context.\n    if ((0, _utils.debugMode)() === 'inspector') await _recorder.Recorder.show(this, {\n      pauseOnNextStatement: true\n    });\n\n    // When paused, show inspector.\n    if (this._debugger.isPaused()) _recorder.Recorder.showInspector(this);\n    this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => {\n      _recorder.Recorder.showInspector(this);\n    });\n    if ((0, _utils.debugMode)() === 'console') await this.extendInjectedScript(consoleApiSource.source);\n    if (this._options.serviceWorkers === 'block') await this.addInitScript(`\\nnavigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\\n`);\n    if (this._options.permissions) await this.grantPermissions(this._options.permissions);\n  }\n  debugger() {\n    return this._debugger;\n  }\n  async _ensureVideosPath() {\n    if (this._options.recordVideo) await (0, _fileUtils.mkdirIfNeeded)(_path.default.join(this._options.recordVideo.dir, 'dummy'));\n  }\n  canResetForReuse() {\n    if (this._closedStatus !== 'open') return false;\n    return true;\n  }\n  async stopPendingOperations() {\n    for (const controller of this._activeProgressControllers) controller.abort(new Error(`Context was reset for reuse.`));\n  }\n  static reusableContextHash(params) {\n    const paramsCopy = {\n      ...params\n    };\n    for (const k of Object.keys(paramsCopy)) {\n      const key = k;\n      if (paramsCopy[key] === defaultNewContextParamValues[key]) delete paramsCopy[key];\n    }\n    for (const key of paramsThatAllowContextReuse) delete paramsCopy[key];\n    return JSON.stringify(paramsCopy);\n  }\n  async resetForReuse(metadata, params) {\n    var _page, _page2, _page3, _page4, _page5;\n    this.setDefaultNavigationTimeout(undefined);\n    this.setDefaultTimeout(undefined);\n    this.tracing.resetForReuse();\n    if (params) {\n      for (const key of paramsThatAllowContextReuse) this._options[key] = params[key];\n    }\n    await this._cancelAllRoutesInFlight();\n\n    // Close extra pages early.\n    let page = this.pages()[0];\n    const [, ...otherPages] = this.pages();\n    for (const p of otherPages) await p.close(metadata);\n    if (page && page._crashedPromise.isDone()) {\n      await page.close(metadata);\n      page = undefined;\n    }\n\n    // Unless dialogs are dismissed, setting extra http headers below does not respond.\n    (_page = page) === null || _page === void 0 ? void 0 : _page._frameManager.setCloseAllOpeningDialogs(true);\n    await ((_page2 = page) === null || _page2 === void 0 ? void 0 : _page2._frameManager.closeOpenDialogs());\n    // Navigate to about:blank first to ensure no page scripts are running after this point.\n    await ((_page3 = page) === null || _page3 === void 0 ? void 0 : _page3.mainFrame().goto(metadata, 'about:blank', {\n      timeout: 0\n    }));\n    (_page4 = page) === null || _page4 === void 0 ? void 0 : _page4._frameManager.setCloseAllOpeningDialogs(false);\n    await this._resetStorage();\n    await this._removeExposedBindings();\n    await this._removeInitScripts();\n    // TODO: following can be optimized to not perform noops.\n    if (this._options.permissions) await this.grantPermissions(this._options.permissions);else await this.clearPermissions();\n    await this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []);\n    await this.setGeolocation(this._options.geolocation);\n    await this.setOffline(!!this._options.offline);\n    await this.setUserAgent(this._options.userAgent);\n    await this._resetCookies();\n    await ((_page5 = page) === null || _page5 === void 0 ? void 0 : _page5.resetForReuse(metadata));\n  }\n  _browserClosed() {\n    for (const page of this.pages()) page._didClose();\n    this._didCloseInternal();\n  }\n  _didCloseInternal() {\n    if (this._closedStatus === 'closed') {\n      // We can come here twice if we close browser context and browser\n      // at the same time.\n      return;\n    }\n    this._closedStatus = 'closed';\n    this._deleteAllDownloads();\n    this._downloads.clear();\n    this.tracing.dispose().catch(() => {});\n    if (this._isPersistentContext) this.onClosePersistent();\n    this._closePromiseFulfill(new Error('Context closed'));\n    this.emit(BrowserContext.Events.Close);\n  }\n\n  // BrowserContext methods.\n\n  async cookies(urls = []) {\n    if (urls && !Array.isArray(urls)) urls = [urls];\n    return await this.doGetCookies(urls);\n  }\n  setHTTPCredentials(httpCredentials) {\n    return this.doSetHTTPCredentials(httpCredentials);\n  }\n  async exposeBinding(name, needsHandle, playwrightBinding) {\n    if (this._pageBindings.has(name)) throw new Error(`Function \"${name}\" has been already registered`);\n    for (const page of this.pages()) {\n      if (page.getBinding(name)) throw new Error(`Function \"${name}\" has been already registered in one of the pages`);\n    }\n    const binding = new _page6.PageBinding(name, playwrightBinding, needsHandle);\n    this._pageBindings.set(name, binding);\n    await this.doExposeBinding(binding);\n  }\n  async _removeExposedBindings() {\n    for (const key of this._pageBindings.keys()) {\n      if (!key.startsWith('__pw')) this._pageBindings.delete(key);\n    }\n    await this.doRemoveExposedBindings();\n  }\n  async grantPermissions(permissions, origin) {\n    let resolvedOrigin = '*';\n    if (origin) {\n      const url = new URL(origin);\n      resolvedOrigin = url.origin;\n    }\n    const existing = new Set(this._permissions.get(resolvedOrigin) || []);\n    permissions.forEach(p => existing.add(p));\n    const list = [...existing.values()];\n    this._permissions.set(resolvedOrigin, list);\n    await this.doGrantPermissions(resolvedOrigin, list);\n  }\n  async clearPermissions() {\n    this._permissions.clear();\n    await this.doClearPermissions();\n  }\n  setDefaultNavigationTimeout(timeout) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n  async _loadDefaultContextAsIs(progress) {\n    if (!this.pages().length) {\n      const waitForEvent = _helper.helper.waitForEvent(progress, this, BrowserContext.Events.Page);\n      progress.cleanupWhenAborted(() => waitForEvent.dispose);\n      const page = await waitForEvent.promise;\n      if (page._pageIsError) throw page._pageIsError;\n    }\n    const pages = this.pages();\n    if (pages[0]._pageIsError) throw pages[0]._pageIsError;\n    await pages[0].mainFrame()._waitForLoadState(progress, 'load');\n    return pages;\n  }\n  async _loadDefaultContext(progress) {\n    const pages = await this._loadDefaultContextAsIs(progress);\n    const browserName = this._browser.options.name;\n    if (this._options.isMobile && browserName === 'chromium' || this._options.locale && browserName === 'webkit') {\n      // Workaround for:\n      // - chromium fails to change isMobile for existing page;\n      // - webkit fails to change locale for existing page.\n      const oldPage = pages[0];\n      await this.newPage(progress.metadata);\n      await oldPage.close(progress.metadata);\n    }\n  }\n  _authenticateProxyViaHeader() {\n    const proxy = this._options.proxy || this._browser.options.proxy || {\n      username: undefined,\n      password: undefined\n    };\n    const {\n      username,\n      password\n    } = proxy;\n    if (username) {\n      this._options.httpCredentials = {\n        username,\n        password: password\n      };\n      const token = Buffer.from(`${username}:${password}`).toString('base64');\n      this._options.extraHTTPHeaders = network.mergeHeaders([this._options.extraHTTPHeaders, network.singleHeader('Proxy-Authorization', `Basic ${token}`)]);\n    }\n  }\n  _authenticateProxyViaCredentials() {\n    const proxy = this._options.proxy || this._browser.options.proxy;\n    if (!proxy) return;\n    const {\n      username,\n      password\n    } = proxy;\n    if (username) this._options.httpCredentials = {\n      username,\n      password: password || ''\n    };\n  }\n  async addInitScript(script) {\n    this.initScripts.push(script);\n    await this.doAddInitScript(script);\n  }\n  async _removeInitScripts() {\n    this.initScripts.splice(0, this.initScripts.length);\n    await this.doRemoveInitScripts();\n  }\n  async setRequestInterceptor(handler) {\n    this._requestInterceptor = handler;\n    await this.doUpdateRequestInterception();\n  }\n  isClosingOrClosed() {\n    return this._closedStatus !== 'open';\n  }\n  async _deleteAllDownloads() {\n    await Promise.all(Array.from(this._downloads).map(download => download.artifact.deleteOnContextClose()));\n  }\n  async _deleteAllTempDirs() {\n    await Promise.all(this._tempDirs.map(async dir => await _fs.default.promises.unlink(dir).catch(e => {})));\n  }\n  setCustomCloseHandler(handler) {\n    this._customCloseHandler = handler;\n  }\n  async close(metadata) {\n    if (this._closedStatus === 'open') {\n      this.emit(BrowserContext.Events.BeforeClose);\n      this._closedStatus = 'closing';\n      for (const harRecorder of this._harRecorders.values()) await harRecorder.flush();\n      await this.tracing.dispose();\n\n      // Cleanup.\n      const promises = [];\n      for (const {\n        context,\n        artifact\n      } of this._browser._idToVideo.values()) {\n        // Wait for the videos to finish.\n        if (context === this) promises.push(artifact.finishedPromise());\n      }\n      if (this._customCloseHandler) {\n        await this._customCloseHandler();\n      } else {\n        // Close the context.\n        await this.doClose();\n      }\n\n      // We delete downloads after context closure\n      // so that browser does not write to the download file anymore.\n      promises.push(this._deleteAllDownloads());\n      promises.push(this._deleteAllTempDirs());\n      await Promise.all(promises);\n\n      // Custom handler should trigger didCloseInternal itself.\n      if (!this._customCloseHandler) this._didCloseInternal();\n    }\n    await this._closePromise;\n  }\n  async newPage(metadata) {\n    const pageDelegate = await this.newPageDelegate();\n    if (metadata.isServerSide) pageDelegate.potentiallyUninitializedPage().markAsServerSideOnly();\n    const pageOrError = await pageDelegate.pageOrError();\n    if (pageOrError instanceof _page6.Page) {\n      if (pageOrError.isClosed()) throw new Error('Page has been closed.');\n      return pageOrError;\n    }\n    throw pageOrError;\n  }\n  addVisitedOrigin(origin) {\n    this._origins.add(origin);\n  }\n  async storageState() {\n    const result = {\n      cookies: await this.cookies(),\n      origins: []\n    };\n    if (this._origins.size) {\n      const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();\n      const page = await this.newPage(internalMetadata);\n      await page._setServerRequestInterceptor(handler => {\n        handler.fulfill({\n          body: '<html></html>'\n        }).catch(() => {});\n        return true;\n      });\n      for (const origin of this._origins) {\n        const originStorage = {\n          origin,\n          localStorage: []\n        };\n        const frame = page.mainFrame();\n        await frame.goto(internalMetadata, origin);\n        const storage = await frame.evaluateExpression(`({\n          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),\n        })`, false, undefined, 'utility');\n        originStorage.localStorage = storage.localStorage;\n        if (storage.localStorage.length) result.origins.push(originStorage);\n      }\n      await page.close(internalMetadata);\n    }\n    return result;\n  }\n  async _resetStorage() {\n    var _this$_options$storag, _this$_options$storag2;\n    const oldOrigins = this._origins;\n    const newOrigins = new Map(((_this$_options$storag = this._options.storageState) === null || _this$_options$storag === void 0 ? void 0 : (_this$_options$storag2 = _this$_options$storag.origins) === null || _this$_options$storag2 === void 0 ? void 0 : _this$_options$storag2.map(p => [p.origin, p])) || []);\n    if (!oldOrigins.size && !newOrigins.size) return;\n    let page = this.pages()[0];\n    const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();\n    page = page || (await this.newPage(internalMetadata));\n    await page._setServerRequestInterceptor(handler => {\n      handler.fulfill({\n        body: '<html></html>'\n      }).catch(() => {});\n      return true;\n    });\n    for (const origin of new Set([...oldOrigins, ...newOrigins.keys()])) {\n      const frame = page.mainFrame();\n      await frame.goto(internalMetadata, origin);\n      await frame.resetStorageForCurrentOriginBestEffort(newOrigins.get(origin));\n    }\n    await page._setServerRequestInterceptor(undefined);\n    this._origins = new Set([...newOrigins.keys()]);\n    // It is safe to not restore the URL to about:blank since we are doing it in Page::resetForReuse.\n  }\n\n  async _resetCookies() {\n    var _this$_options$storag3, _this$_options$storag4;\n    await this.clearCookies();\n    if ((_this$_options$storag3 = this._options.storageState) !== null && _this$_options$storag3 !== void 0 && _this$_options$storag3.cookies) await this.addCookies((_this$_options$storag4 = this._options.storageState) === null || _this$_options$storag4 === void 0 ? void 0 : _this$_options$storag4.cookies);\n  }\n  isSettingStorageState() {\n    return this._settingStorageState;\n  }\n  async setStorageState(metadata, state) {\n    this._settingStorageState = true;\n    try {\n      if (state.cookies) await this.addCookies(state.cookies);\n      if (state.origins && state.origins.length) {\n        const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();\n        const page = await this.newPage(internalMetadata);\n        await page._setServerRequestInterceptor(handler => {\n          handler.fulfill({\n            body: '<html></html>'\n          }).catch(() => {});\n          return true;\n        });\n        for (const originState of state.origins) {\n          const frame = page.mainFrame();\n          await frame.goto(metadata, originState.origin);\n          await frame.evaluateExpression(`\n            originState => {\n              for (const { name, value } of (originState.localStorage || []))\n                localStorage.setItem(name, value);\n            }`, true, originState, 'utility');\n        }\n        await page.close(internalMetadata);\n      }\n    } finally {\n      this._settingStorageState = false;\n    }\n  }\n  async extendInjectedScript(source, arg) {\n    const installInFrame = frame => frame.extendInjectedScript(source, arg).catch(() => {});\n    const installInPage = page => {\n      page.on(_page6.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);\n      return Promise.all(page.frames().map(installInFrame));\n    };\n    this.on(BrowserContext.Events.Page, installInPage);\n    return Promise.all(this.pages().map(installInPage));\n  }\n  async _harStart(page, options) {\n    const harId = (0, _utils.createGuid)();\n    this._harRecorders.set(harId, new _harRecorder.HarRecorder(this, page, options));\n    return harId;\n  }\n  async _harExport(harId) {\n    const recorder = this._harRecorders.get(harId || '');\n    return recorder.export();\n  }\n  addRouteInFlight(route) {\n    this._routesInFlight.add(route);\n  }\n  removeRouteInFlight(route) {\n    this._routesInFlight.delete(route);\n  }\n  async _cancelAllRoutesInFlight() {\n    await Promise.all([...this._routesInFlight].map(r => r.abort())).catch(() => {});\n    this._routesInFlight.clear();\n  }\n}\nexports.BrowserContext = BrowserContext;\nBrowserContext.Events = {\n  Close: 'close',\n  Page: 'page',\n  Request: 'request',\n  Response: 'response',\n  RequestFailed: 'requestfailed',\n  RequestFinished: 'requestfinished',\n  BeforeClose: 'beforeclose',\n  VideoStarted: 'videostarted'\n};\nfunction assertBrowserContextIsNotOwned(context) {\n  for (const page of context.pages()) {\n    if (page._ownedContext) throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');\n  }\n}\nfunction validateBrowserContextOptions(options, browserOptions) {\n  if (options.noDefaultViewport && options.deviceScaleFactor !== undefined) throw new Error(`\"deviceScaleFactor\" option is not supported with null \"viewport\"`);\n  if (options.noDefaultViewport && !!options.isMobile) throw new Error(`\"isMobile\" option is not supported with null \"viewport\"`);\n  if (options.acceptDownloads === undefined) options.acceptDownloads = true;\n  if (!options.viewport && !options.noDefaultViewport) options.viewport = {\n    width: 1280,\n    height: 720\n  };\n  if (options.recordVideo) {\n    if (!options.recordVideo.size) {\n      if (options.noDefaultViewport) {\n        options.recordVideo.size = {\n          width: 800,\n          height: 600\n        };\n      } else {\n        const size = options.viewport;\n        const scale = Math.min(1, 800 / Math.max(size.width, size.height));\n        options.recordVideo.size = {\n          width: Math.floor(size.width * scale),\n          height: Math.floor(size.height * scale)\n        };\n      }\n    }\n    // Make sure both dimensions are odd, this is required for vp8\n    options.recordVideo.size.width &= ~1;\n    options.recordVideo.size.height &= ~1;\n  }\n  if (options.proxy) {\n    if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === 'win32') throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example \"launch({ proxy: { server: 'http://per-context' } })\"`);\n    options.proxy = normalizeProxySettings(options.proxy);\n  }\n  verifyGeolocation(options.geolocation);\n}\nfunction verifyGeolocation(geolocation) {\n  if (!geolocation) return;\n  geolocation.accuracy = geolocation.accuracy || 0;\n  const {\n    longitude,\n    latitude,\n    accuracy\n  } = geolocation;\n  if (longitude < -180 || longitude > 180) throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);\n  if (latitude < -90 || latitude > 90) throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);\n  if (accuracy < 0) throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);\n}\nfunction normalizeProxySettings(proxy) {\n  let {\n    server,\n    bypass\n  } = proxy;\n  let url;\n  try {\n    // new URL('127.0.0.1:8080') throws\n    // new URL('localhost:8080') fails to parse host or protocol\n    // In both of these cases, we need to try re-parse URL with `http://` prefix.\n    url = new URL(server);\n    if (!url.host || !url.protocol) url = new URL('http://' + server);\n  } catch (e) {\n    url = new URL('http://' + server);\n  }\n  if (url.protocol === 'socks4:' && (proxy.username || proxy.password)) throw new Error(`Socks4 proxy protocol does not support authentication`);\n  if (url.protocol === 'socks5:' && (proxy.username || proxy.password)) throw new Error(`Browser does not support socks5 proxy authentication`);\n  server = url.protocol + '//' + url.host;\n  if (bypass) bypass = bypass.split(',').map(t => t.trim()).join(',');\n  return {\n    ...proxy,\n    server,\n    bypass\n  };\n}\nconst paramsThatAllowContextReuse = ['colorScheme', 'forcedColors', 'reducedMotion', 'screen', 'userAgent', 'viewport'];\nconst defaultNewContextParamValues = {\n  noDefaultViewport: false,\n  ignoreHTTPSErrors: false,\n  javaScriptEnabled: true,\n  bypassCSP: false,\n  offline: false,\n  isMobile: false,\n  hasTouch: false,\n  acceptDownloads: true,\n  strictSelectors: false,\n  serviceWorkers: 'allow',\n  locale: 'en-US'\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.kNoXServerRunningError = exports.BrowserType = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar os = _interopRequireWildcard(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _browserContext = require(\"./browserContext\");\nvar _registry = require(\"./registry\");\nvar _transport = require(\"./transport\");\nvar _processLauncher = require(\"../utils/processLauncher\");\nvar _pipeTransport = require(\"./pipeTransport\");\nvar _progress = require(\"./progress\");\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _utils = require(\"../utils\");\nvar _fileUtils = require(\"../utils/fileUtils\");\nvar _helper = require(\"./helper\");\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst kNoXServerRunningError = 'Looks like you launched a headed browser without having a XServer running.\\n' + 'Set either \\'headless: true\\' or use \\'xvfb-run <your-playwright-app>\\' before running Playwright.\\n\\n<3 Playwright Team';\nexports.kNoXServerRunningError = kNoXServerRunningError;\nclass BrowserType extends _instrumentation.SdkObject {\n  constructor(browserName, playwrightOptions) {\n    super(playwrightOptions.rootSdkObject, 'browser-type');\n    this._name = void 0;\n    this._playwrightOptions = void 0;\n    this.attribution.browserType = this;\n    this._playwrightOptions = playwrightOptions;\n    this._name = browserName;\n  }\n  executablePath() {\n    return _registry.registry.findExecutable(this._name).executablePath(this._playwrightOptions.sdkLanguage) || '';\n  }\n  name() {\n    return this._name;\n  }\n  async launch(metadata, options, protocolLogger) {\n    options = this._validateLaunchOptions(options);\n    const controller = new _progress.ProgressController(metadata, this);\n    controller.setLogName('browser');\n    const browser = await controller.run(progress => {\n      const seleniumHubUrl = options.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;\n      if (seleniumHubUrl) return this._launchWithSeleniumHub(progress, seleniumHubUrl, options);\n      return this._innerLaunchWithRetries(progress, options, undefined, _helper.helper.debugProtocolLogger(protocolLogger)).catch(e => {\n        throw this._rewriteStartupError(e);\n      });\n    }, _timeoutSettings.TimeoutSettings.launchTimeout(options));\n    return browser;\n  }\n  async launchPersistentContext(metadata, userDataDir, options) {\n    options = this._validateLaunchOptions(options);\n    const controller = new _progress.ProgressController(metadata, this);\n    const persistent = options;\n    controller.setLogName('browser');\n    const browser = await controller.run(progress => {\n      return this._innerLaunchWithRetries(progress, options, persistent, _helper.helper.debugProtocolLogger(), userDataDir).catch(e => {\n        throw this._rewriteStartupError(e);\n      });\n    }, _timeoutSettings.TimeoutSettings.launchTimeout(options));\n    return browser._defaultContext;\n  }\n  async _innerLaunchWithRetries(progress, options, persistent, protocolLogger, userDataDir) {\n    try {\n      return await this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);\n    } catch (error) {\n      // @see https://github.com/microsoft/playwright/issues/5214\n      const errorMessage = typeof error === 'object' && typeof error.message === 'string' ? error.message : '';\n      if (errorMessage.includes('Inconsistency detected by ld.so')) {\n        progress.log(`<restarting browser due to hitting race condition in glibc>`);\n        return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);\n      }\n      throw error;\n    }\n  }\n  async _innerLaunch(progress, options, persistent, protocolLogger, maybeUserDataDir) {\n    options.proxy = options.proxy ? (0, _browserContext.normalizeProxySettings)(options.proxy) : undefined;\n    const browserLogsCollector = new _debugLogger.RecentLogsCollector();\n    const {\n      browserProcess,\n      userDataDir,\n      artifactsDir,\n      transport\n    } = await this._launchProcess(progress, options, !!persistent, browserLogsCollector, maybeUserDataDir);\n    if (options.__testHookBeforeCreateBrowser) await options.__testHookBeforeCreateBrowser();\n    const browserOptions = {\n      ...this._playwrightOptions,\n      name: this._name,\n      isChromium: this._name === 'chromium',\n      channel: options.channel,\n      slowMo: options.slowMo,\n      persistent,\n      headful: !options.headless,\n      artifactsDir,\n      downloadsPath: options.downloadsPath || artifactsDir,\n      tracesDir: options.tracesDir || artifactsDir,\n      browserProcess,\n      customExecutablePath: options.executablePath,\n      proxy: options.proxy,\n      protocolLogger,\n      browserLogsCollector,\n      wsEndpoint: options.useWebSocket ? transport.wsEndpoint : undefined,\n      originalLaunchOptions: options\n    };\n    if (persistent) (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);\n    copyTestHooks(options, browserOptions);\n    const browser = await this._connectToTransport(transport, browserOptions);\n    browser._userDataDirForTest = userDataDir;\n    // We assume no control when using custom arguments, and do not prepare the default context in that case.\n    if (persistent && !options.ignoreAllDefaultArgs) await browser._defaultContext._loadDefaultContext(progress);\n    return browser;\n  }\n  async _launchProcess(progress, options, isPersistent, browserLogsCollector, userDataDir) {\n    var _options$args;\n    const {\n      ignoreDefaultArgs,\n      ignoreAllDefaultArgs,\n      args = [],\n      executablePath = null,\n      handleSIGINT = true,\n      handleSIGTERM = true,\n      handleSIGHUP = true\n    } = options;\n    const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;\n    const tempDirectories = [];\n    if (options.downloadsPath) await _fs.default.promises.mkdir(options.downloadsPath, {\n      recursive: true\n    });\n    if (options.tracesDir) await _fs.default.promises.mkdir(options.tracesDir, {\n      recursive: true\n    });\n    const artifactsDir = await _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), 'playwright-artifacts-'));\n    tempDirectories.push(artifactsDir);\n    if (userDataDir) {\n      // Firefox bails if the profile directory does not exist, Chrome creates it. We ensure consistent behavior here.\n      if (!(await (0, _fileUtils.existsAsync)(userDataDir))) await _fs.default.promises.mkdir(userDataDir, {\n        recursive: true,\n        mode: 0o700\n      });\n    } else {\n      userDataDir = await _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));\n      tempDirectories.push(userDataDir);\n    }\n    const browserArguments = [];\n    if (ignoreAllDefaultArgs) browserArguments.push(...args);else if (ignoreDefaultArgs) browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter(arg => ignoreDefaultArgs.indexOf(arg) === -1));else browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));\n    let executable;\n    if (executablePath) {\n      if (!(await (0, _fileUtils.existsAsync)(executablePath))) throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);\n      executable = executablePath;\n    } else {\n      const registryExecutable = _registry.registry.findExecutable(options.channel || this._name);\n      if (!registryExecutable || registryExecutable.browserName !== this._name) throw new Error(`Unsupported ${this._name} channel \"${options.channel}\"`);\n      executable = registryExecutable.executablePathOrDie(this._playwrightOptions.sdkLanguage);\n      await registryExecutable.validateHostRequirements(this._playwrightOptions.sdkLanguage);\n    }\n    const waitForWSEndpoint = options.useWebSocket || (_options$args = options.args) !== null && _options$args !== void 0 && _options$args.some(a => a.startsWith('--remote-debugging-port')) ? new _manualPromise.ManualPromise() : undefined;\n    const waitForJuggler = this._name === 'firefox' ? new _manualPromise.ManualPromise() : undefined;\n    // Note: it is important to define these variables before launchProcess, so that we don't get\n    // \"Cannot access 'browserServer' before initialization\" if something went wrong.\n    let transport = undefined;\n    let browserProcess = undefined;\n    const {\n      launchedProcess,\n      gracefullyClose,\n      kill\n    } = await (0, _processLauncher.launchProcess)({\n      command: executable,\n      args: browserArguments,\n      env: this._amendEnvironment(env, userDataDir, executable, browserArguments),\n      handleSIGINT,\n      handleSIGTERM,\n      handleSIGHUP,\n      log: message => {\n        if (waitForWSEndpoint) {\n          const match = message.match(/DevTools listening on (.*)/);\n          if (match) waitForWSEndpoint.resolve(match[1]);\n        }\n        if (waitForJuggler && message.includes('Juggler listening to the pipe')) waitForJuggler.resolve();\n        progress.log(message);\n        browserLogsCollector.log(message);\n      },\n      stdio: 'pipe',\n      tempDirectories,\n      attemptToGracefullyClose: async () => {\n        if (options.__testHookGracefullyClose) await options.__testHookGracefullyClose();\n        // We try to gracefully close to prevent crash reporting and core dumps.\n        // Note that it's fine to reuse the pipe transport, since\n        // our connection ignores kBrowserCloseMessageId.\n        this._attemptToGracefullyCloseBrowser(transport);\n      },\n      onExit: (exitCode, signal) => {\n        // Unblock launch when browser prematurely exits.\n        waitForJuggler === null || waitForJuggler === void 0 ? void 0 : waitForJuggler.resolve();\n        if (browserProcess && browserProcess.onclose) browserProcess.onclose(exitCode, signal);\n      }\n    });\n    async function closeOrKill(timeout) {\n      let timer;\n      try {\n        await Promise.race([gracefullyClose(), new Promise((resolve, reject) => timer = setTimeout(reject, timeout))]);\n      } catch (ignored) {\n        await kill().catch(ignored => {}); // Make sure to await actual process exit.\n      } finally {\n        clearTimeout(timer);\n      }\n    }\n    browserProcess = {\n      onclose: undefined,\n      process: launchedProcess,\n      close: () => closeOrKill(options.__testHookBrowserCloseTimeout || _timeoutSettings.DEFAULT_TIMEOUT),\n      kill\n    };\n    progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));\n    const wsEndpoint = await waitForWSEndpoint;\n    await waitForJuggler;\n    if (options.useWebSocket) {\n      transport = await _transport.WebSocketTransport.connect(progress, wsEndpoint);\n    } else {\n      const stdio = launchedProcess.stdio;\n      transport = new _pipeTransport.PipeTransport(stdio[3], stdio[4]);\n    }\n    return {\n      browserProcess,\n      artifactsDir,\n      userDataDir,\n      transport\n    };\n  }\n  async connectOverCDP(metadata, endpointURL, options, timeout) {\n    throw new Error('CDP connections are only supported by Chromium');\n  }\n  async _launchWithSeleniumHub(progress, hubUrl, options) {\n    throw new Error('Connecting to SELENIUM_REMOTE_URL is only supported by Chromium');\n  }\n  _validateLaunchOptions(options) {\n    const {\n      devtools = false\n    } = options;\n    let {\n      headless = !devtools,\n      downloadsPath,\n      proxy\n    } = options;\n    if ((0, _utils.debugMode)()) headless = false;\n    if (downloadsPath && !_path.default.isAbsolute(downloadsPath)) downloadsPath = _path.default.join(process.cwd(), downloadsPath);\n    if (this._playwrightOptions.socksProxyPort) proxy = {\n      server: `socks5://127.0.0.1:${this._playwrightOptions.socksProxyPort}`\n    };\n    return {\n      ...options,\n      devtools,\n      headless,\n      downloadsPath,\n      proxy\n    };\n  }\n}\nexports.BrowserType = BrowserType;\nfunction copyTestHooks(from, to) {\n  for (const [key, value] of Object.entries(from)) {\n    if (key.startsWith('__testHook')) to[key] = value;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chromium = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _crBrowser = require(\"./crBrowser\");\nvar _processLauncher = require(\"../../utils/processLauncher\");\nvar _crConnection = require(\"./crConnection\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _browserType = require(\"../browserType\");\nvar _transport = require(\"../transport\");\nvar _crDevTools = require(\"./crDevTools\");\nvar _browser = require(\"../browser\");\nvar _network = require(\"../../utils/network\");\nvar _userAgent = require(\"../../utils/userAgent\");\nvar _ascii = require(\"../../utils/ascii\");\nvar _utils = require(\"../../utils\");\nvar _fileUtils = require(\"../../utils/fileUtils\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _progress = require(\"../progress\");\nvar _timeoutSettings = require(\"../../common/timeoutSettings\");\nvar _helper = require(\"../helper\");\nvar _http = _interopRequireDefault(require(\"http\"));\nvar _https = _interopRequireDefault(require(\"https\"));\nvar _registry = require(\"../registry\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nvar _browserContext = require(\"../browserContext\");\nvar _chromiumSwitches = require(\"./chromiumSwitches\");\nvar _happyEyeballs = require(\"../happy-eyeballs\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), 'playwright-artifacts-');\nclass Chromium extends _browserType.BrowserType {\n  constructor(playwrightOptions) {\n    super('chromium', playwrightOptions);\n    this._devtools = void 0;\n    if ((0, _utils.debugMode)()) this._devtools = this._createDevTools();\n  }\n  async connectOverCDP(metadata, endpointURL, options, timeout) {\n    const controller = new _progress.ProgressController(metadata, this);\n    controller.setLogName('browser');\n    return controller.run(async progress => {\n      return await this._connectOverCDPInternal(progress, endpointURL, options);\n    }, _timeoutSettings.TimeoutSettings.timeout({\n      timeout\n    }));\n  }\n  async _connectOverCDPInternal(progress, endpointURL, options, onClose) {\n    let headersMap;\n    if (options.headers) headersMap = (0, _utils.headersArrayToObject)(options.headers, false);\n    if (!headersMap) headersMap = {\n      'User-Agent': (0, _userAgent.getUserAgent)()\n    };else if (headersMap && !Object.keys(headersMap).some(key => key.toLowerCase() === 'user-agent')) headersMap['User-Agent'] = (0, _userAgent.getUserAgent)();\n    const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);\n    const wsEndpoint = await urlToWSEndpoint(progress, endpointURL);\n    progress.throwIfAborted();\n    const chromeTransport = await _transport.WebSocketTransport.connect(progress, wsEndpoint, headersMap);\n    const cleanedUp = new _manualPromise.ManualPromise();\n    const doCleanup = async () => {\n      await (0, _fileUtils.removeFolders)([artifactsDir]);\n      await (onClose === null || onClose === void 0 ? void 0 : onClose());\n      cleanedUp.resolve();\n    };\n    const doClose = async () => {\n      await chromeTransport.closeAndWait();\n      await cleanedUp;\n    };\n    const browserProcess = {\n      close: doClose,\n      kill: doClose\n    };\n    const persistent = {\n      noDefaultViewport: true\n    };\n    const browserOptions = {\n      ...this._playwrightOptions,\n      slowMo: options.slowMo,\n      name: 'chromium',\n      isChromium: true,\n      persistent,\n      browserProcess,\n      protocolLogger: _helper.helper.debugProtocolLogger(),\n      browserLogsCollector: new _debugLogger.RecentLogsCollector(),\n      artifactsDir,\n      downloadsPath: artifactsDir,\n      tracesDir: artifactsDir,\n      // On Windows context level proxies only work, if there isn't a global proxy\n      // set. This is currently a bug in the CR/Windows networking stack. By\n      // passing an arbitrary value we disable the check in PW land which warns\n      // users in normal (launch/launchServer) mode since otherwise connectOverCDP\n      // does not work at all with proxies on Windows.\n      proxy: {\n        server: 'per-context'\n      },\n      originalLaunchOptions: {}\n    };\n    (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);\n    progress.throwIfAborted();\n    const browser = await _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);\n    browser.on(_browser.Browser.Events.Disconnected, doCleanup);\n    return browser;\n  }\n  _createDevTools() {\n    // TODO: this is totally wrong when using channels.\n    const directory = _registry.registry.findExecutable('chromium').directory;\n    return directory ? new _crDevTools.CRDevTools(_path.default.join(directory, 'devtools-preferences.json')) : undefined;\n  }\n  async _connectToTransport(transport, options) {\n    let devtools = this._devtools;\n    if (options.__testHookForDevTools) {\n      devtools = this._createDevTools();\n      await options.__testHookForDevTools(devtools);\n    }\n    return _crBrowser.CRBrowser.connect(transport, options, devtools);\n  }\n  _rewriteStartupError(error) {\n    if (error.message.includes('Missing X server')) return (0, _stackTrace.rewriteErrorMessage)(error, '\\n' + (0, _ascii.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));\n    // These error messages are taken from Chromium source code as of July, 2020:\n    // https://github.com/chromium/chromium/blob/70565f67e79f79e17663ad1337dc6e63ee207ce9/content/browser/zygote_host/zygote_host_impl_linux.cc\n    if (!error.message.includes('crbug.com/357670') && !error.message.includes('No usable sandbox!') && !error.message.includes('crbug.com/638180')) return error;\n    return (0, _stackTrace.rewriteErrorMessage)(error, [`Chromium sandboxing failed!`, `================================`, `To workaround sandboxing issues, do either of the following:`, `  - (preferred): Configure environment to support sandboxing: https://playwright.dev/docs/troubleshooting`, `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`, `================================`, ``].join('\\n'));\n  }\n  _amendEnvironment(env, userDataDir, executable, browserArguments) {\n    return env;\n  }\n  _attemptToGracefullyCloseBrowser(transport) {\n    const message = {\n      method: 'Browser.close',\n      id: _crConnection.kBrowserCloseMessageId,\n      params: {}\n    };\n    transport.send(message);\n  }\n  async _launchWithSeleniumHub(progress, hubUrl, options) {\n    if (!hubUrl.endsWith('/')) hubUrl = hubUrl + '/';\n    const args = this._innerDefaultArgs(options);\n    args.push('--remote-debugging-port=0');\n    const isEdge = options.channel && options.channel.startsWith('msedge');\n    let desiredCapabilities = {\n      'browserName': isEdge ? 'MicrosoftEdge' : 'chrome',\n      [isEdge ? 'ms:edgeOptions' : 'goog:chromeOptions']: {\n        args\n      }\n    };\n    try {\n      if (process.env.SELENIUM_REMOTE_CAPABILITIES) {\n        const parsed = JSON.parse(process.env.SELENIUM_REMOTE_CAPABILITIES);\n        desiredCapabilities = {\n          ...desiredCapabilities,\n          ...parsed\n        };\n        progress.log(`<selenium> using additional capabilities \"${process.env.SELENIUM_REMOTE_CAPABILITIES}\"`);\n      }\n    } catch (e) {\n      progress.log(`<selenium> ignoring additional capabilities \"${process.env.SELENIUM_REMOTE_CAPABILITIES}\": ${e}`);\n    }\n    progress.log(`<selenium> connecting to ${hubUrl}`);\n    const response = await (0, _network.fetchData)({\n      url: hubUrl + 'session',\n      method: 'POST',\n      data: JSON.stringify({\n        desiredCapabilities,\n        capabilities: {\n          alwaysMatch: desiredCapabilities\n        }\n      }),\n      timeout: progress.timeUntilDeadline()\n    }, seleniumErrorHandler);\n    const value = JSON.parse(response).value;\n    const sessionId = value.sessionId;\n    progress.log(`<selenium> connected to sessionId=${sessionId}`);\n    const disconnectFromSelenium = async () => {\n      progress.log(`<selenium> disconnecting from sessionId=${sessionId}`);\n      await (0, _network.fetchData)({\n        url: hubUrl + 'session/' + sessionId,\n        method: 'DELETE'\n      }).catch(error => progress.log(`<error disconnecting from selenium>: ${error}`));\n      progress.log(`<selenium> disconnected from sessionId=${sessionId}`);\n      _processLauncher.gracefullyCloseSet.delete(disconnectFromSelenium);\n    };\n    _processLauncher.gracefullyCloseSet.add(disconnectFromSelenium);\n    try {\n      const capabilities = value.capabilities;\n      let endpointURL;\n      if (capabilities['se:cdp']) {\n        // Selenium 4 - use built-in CDP websocket proxy.\n        progress.log(`<selenium> using selenium v4`);\n        const endpointURLString = addProtocol(capabilities['se:cdp']);\n        endpointURL = new URL(endpointURLString);\n        if (endpointURL.hostname === 'localhost' || endpointURL.hostname === '127.0.0.1') endpointURL.hostname = new URL(hubUrl).hostname;\n        progress.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);\n      } else {\n        // Selenium 3 - resolve target node IP to use instead of localhost ws url.\n        progress.log(`<selenium> using selenium v3`);\n        const maybeChromeOptions = capabilities['goog:chromeOptions'];\n        const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === 'object' ? maybeChromeOptions : undefined;\n        const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === 'string' ? chromeOptions.debuggerAddress : undefined;\n        const chromeOptionsURL = typeof maybeChromeOptions === 'string' ? maybeChromeOptions : undefined;\n        // TODO(dgozman): figure out if we can make ChromeDriver to return 127.0.0.1 instead of localhost.\n        const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL).replace('localhost', '127.0.0.1');\n        progress.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);\n        endpointURL = new URL(endpointURLString);\n        if (endpointURL.hostname === 'localhost' || endpointURL.hostname === '127.0.0.1') {\n          const sessionInfoUrl = new URL(hubUrl).origin + '/grid/api/testsession?session=' + sessionId;\n          try {\n            const sessionResponse = await (0, _network.fetchData)({\n              url: sessionInfoUrl,\n              method: 'GET',\n              timeout: progress.timeUntilDeadline()\n            }, seleniumErrorHandler);\n            const proxyId = JSON.parse(sessionResponse).proxyId;\n            endpointURL.hostname = new URL(proxyId).hostname;\n            progress.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);\n          } catch (e) {\n            progress.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);\n          }\n        }\n      }\n      return await this._connectOverCDPInternal(progress, endpointURL.toString(), {\n        slowMo: options.slowMo\n      }, disconnectFromSelenium);\n    } catch (e) {\n      await disconnectFromSelenium();\n      throw e;\n    }\n  }\n  _defaultArgs(options, isPersistent, userDataDir) {\n    const chromeArguments = this._innerDefaultArgs(options);\n    chromeArguments.push(`--user-data-dir=${userDataDir}`);\n    if (options.useWebSocket) chromeArguments.push('--remote-debugging-port=0');else chromeArguments.push('--remote-debugging-pipe');\n    if (isPersistent) chromeArguments.push('about:blank');else chromeArguments.push('--no-startup-window');\n    return chromeArguments;\n  }\n  _innerDefaultArgs(options) {\n    const {\n      args = [],\n      proxy\n    } = options;\n    const userDataDirArg = args.find(arg => arg.startsWith('--user-data-dir'));\n    if (userDataDirArg) throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument');\n    if (args.find(arg => arg.startsWith('--remote-debugging-pipe'))) throw new Error('Playwright manages remote debugging connection itself.');\n    if (args.find(arg => !arg.startsWith('-'))) throw new Error('Arguments can not specify page to be opened');\n    const chromeArguments = [..._chromiumSwitches.chromiumSwitches];\n    if (_os.default.platform() === 'darwin') {\n      // See https://github.com/microsoft/playwright/issues/7362\n      chromeArguments.push('--enable-use-zoom-for-dsf=false');\n      // See https://bugs.chromium.org/p/chromium/issues/detail?id=1407025.\n      if (options.headless) chromeArguments.push('--use-angle');\n    }\n    if (options.devtools) chromeArguments.push('--auto-open-devtools-for-tabs');\n    if (options.headless) {\n      chromeArguments.push('--headless', '--hide-scrollbars', '--mute-audio', '--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4');\n    }\n    if (options.chromiumSandbox !== true) chromeArguments.push('--no-sandbox');\n    if (proxy) {\n      const proxyURL = new URL(proxy.server);\n      const isSocks = proxyURL.protocol === 'socks5:';\n      // https://www.chromium.org/developers/design-documents/network-settings\n      if (isSocks && !this._playwrightOptions.socksProxyPort) {\n        // https://www.chromium.org/developers/design-documents/network-stack/socks-proxy\n        chromeArguments.push(`--host-resolver-rules=\"MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}\"`);\n      }\n      chromeArguments.push(`--proxy-server=${proxy.server}`);\n      const proxyBypassRules = [];\n      // https://source.chromium.org/chromium/chromium/src/+/master:net/docs/proxy.md;l=548;drc=71698e610121078e0d1a811054dcf9fd89b49578\n      if (this._playwrightOptions.socksProxyPort) proxyBypassRules.push('<-loopback>');\n      if (proxy.bypass) proxyBypassRules.push(...proxy.bypass.split(',').map(t => t.trim()).map(t => t.startsWith('.') ? '*' + t : t));\n      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes('<-loopback>')) proxyBypassRules.push('<-loopback>');\n      if (proxyBypassRules.length > 0) chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(';')}`);\n    }\n    chromeArguments.push(...args);\n    return chromeArguments;\n  }\n}\nexports.Chromium = Chromium;\nasync function urlToWSEndpoint(progress, endpointURL) {\n  if (endpointURL.startsWith('ws')) return endpointURL;\n  progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);\n  const httpURL = endpointURL.endsWith('/') ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;\n  const isHTTPS = endpointURL.startsWith('https://');\n  const json = await new Promise((resolve, reject) => {\n    (isHTTPS ? _https.default : _http.default).get(httpURL, {\n      timeout: _network.NET_DEFAULT_TIMEOUT,\n      agent: isHTTPS ? _happyEyeballs.httpsHappyEyeballsAgent : _happyEyeballs.httpHappyEyeballsAgent\n    }, resp => {\n      if (resp.statusCode < 200 || resp.statusCode >= 400) {\n        reject(new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.\\n` + `This does not look like a DevTools server, try connecting via ws://.`));\n      }\n      let data = '';\n      resp.on('data', chunk => data += chunk);\n      resp.on('end', () => resolve(data));\n    }).on('error', reject);\n  });\n  return JSON.parse(json).webSocketDebuggerUrl;\n}\nasync function seleniumErrorHandler(params, response) {\n  const body = await streamToString(response);\n  let message = body;\n  try {\n    const json = JSON.parse(body);\n    message = json.value.localizedMessage || json.value.message;\n  } catch (e) {}\n  return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);\n}\nfunction addProtocol(url) {\n  if (!['ws://', 'wss://', 'http://', 'https://'].some(protocol => url.startsWith(protocol))) return 'http://' + url;\n  return url;\n}\nfunction streamToString(stream) {\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n    stream.on('data', chunk => chunks.push(Buffer.from(chunk)));\n    stream.on('error', reject);\n    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chromiumSwitches = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// No dependencies as it is used from the Electron loader.\n\nconst chromiumSwitches = ['--disable-field-trial-config',\n// https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md\n'--disable-background-networking', '--enable-features=NetworkService,NetworkServiceInProcess', '--disable-background-timer-throttling', '--disable-backgrounding-occluded-windows', '--disable-back-forward-cache',\n// Avoids surprises like main request not being intercepted during page.goBack().\n'--disable-breakpad', '--disable-client-side-phishing-detection', '--disable-component-extensions-with-background-pages', '--disable-component-update',\n// Avoids unneeded network activity after startup.\n'--no-default-browser-check', '--disable-default-apps', '--disable-dev-shm-usage', '--disable-extensions',\n// AvoidUnnecessaryBeforeUnloadCheckSync - https://github.com/microsoft/playwright/issues/14047\n// Translate - https://github.com/microsoft/playwright/issues/16126\n'--disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate', '--allow-pre-commit-input', '--disable-hang-monitor', '--disable-ipc-flooding-protection', '--disable-popup-blocking', '--disable-prompt-on-repost', '--disable-renderer-backgrounding', '--disable-sync', '--force-color-profile=srgb', '--metrics-recording-only', '--no-first-run', '--enable-automation', '--password-store=basic', '--use-mock-keychain',\n// See https://chromium-review.googlesource.com/c/chromium/src/+/2436773\n'--no-service-autorun', '--export-tagged-pdf'];\nexports.chromiumSwitches = chromiumSwitches;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAccessibilityTree = getAccessibilityTree;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nasync function getAccessibilityTree(client, needle) {\n  const {\n    nodes\n  } = await client.send('Accessibility.getFullAXTree');\n  const tree = CRAXNode.createTree(client, nodes);\n  return {\n    tree,\n    needle: needle ? await tree._findElement(needle) : null\n  };\n}\nclass CRAXNode {\n  constructor(client, payload) {\n    this._payload = void 0;\n    this._children = [];\n    this._richlyEditable = false;\n    this._editable = false;\n    this._focusable = false;\n    this._expanded = false;\n    this._hidden = false;\n    this._name = void 0;\n    this._role = void 0;\n    this._cachedHasFocusableChild = void 0;\n    this._client = void 0;\n    this._client = client;\n    this._payload = payload;\n    this._name = this._payload.name ? this._payload.name.value : '';\n    this._role = this._payload.role ? this._payload.role.value : 'Unknown';\n    for (const property of this._payload.properties || []) {\n      if (property.name === 'editable') {\n        this._richlyEditable = property.value.value === 'richtext';\n        this._editable = true;\n      }\n      if (property.name === 'focusable') this._focusable = property.value.value;\n      if (property.name === 'expanded') this._expanded = property.value.value;\n      if (property.name === 'hidden') this._hidden = property.value.value;\n    }\n  }\n  _isPlainTextField() {\n    if (this._richlyEditable) return false;\n    if (this._editable) return true;\n    return this._role === 'textbox' || this._role === 'ComboBox' || this._role === 'searchbox';\n  }\n  _isTextOnlyObject() {\n    const role = this._role;\n    return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox' || role === 'StaticText';\n  }\n  _hasFocusableChild() {\n    if (this._cachedHasFocusableChild === undefined) {\n      this._cachedHasFocusableChild = false;\n      for (const child of this._children) {\n        if (child._focusable || child._hasFocusableChild()) {\n          this._cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n    return this._cachedHasFocusableChild;\n  }\n  children() {\n    return this._children;\n  }\n  async _findElement(element) {\n    const objectId = element._objectId;\n    const {\n      node: {\n        backendNodeId\n      }\n    } = await this._client.send('DOM.describeNode', {\n      objectId\n    });\n    const needle = this.find(node => node._payload.backendDOMNodeId === backendNodeId);\n    return needle || null;\n  }\n  find(predicate) {\n    if (predicate(this)) return this;\n    for (const child of this._children) {\n      const result = child.find(predicate);\n      if (result) return result;\n    }\n    return null;\n  }\n  isLeafNode() {\n    if (!this._children.length) return true;\n\n    // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n    if (this._isPlainTextField() || this._isTextOnlyObject()) return true;\n\n    // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n    switch (this._role) {\n      case 'doc-cover':\n      case 'graphics-symbol':\n      case 'img':\n      case 'Meter':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n      default:\n        break;\n    }\n\n    // Here and below: Android heuristics\n    if (this._hasFocusableChild()) return false;\n    if (this._focusable && this._role !== 'WebArea' && this._role !== 'RootWebArea' && this._name) return true;\n    if (this._role === 'heading' && this._name) return true;\n    return false;\n  }\n  isControl() {\n    switch (this._role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'tree':\n        return true;\n      default:\n        return false;\n    }\n  }\n  isInteresting(insideControl) {\n    const role = this._role;\n    if (role === 'Ignored' || this._hidden) return false;\n    if (this._focusable || this._richlyEditable) return true;\n\n    // If it's not focusable but has a control role, then it's interesting.\n    if (this.isControl()) return true;\n\n    // A non focusable child of a control is not interesting\n    if (insideControl) return false;\n    return this.isLeafNode() && !!this._name;\n  }\n  normalizedRole() {\n    switch (this._role) {\n      case 'RootWebArea':\n        return 'WebArea';\n      case 'StaticText':\n        return 'text';\n      default:\n        return this._role;\n    }\n  }\n  serialize() {\n    const properties = new Map();\n    for (const property of this._payload.properties || []) properties.set(property.name.toLowerCase(), property.value.value);\n    if (this._payload.description) properties.set('description', this._payload.description.value);\n    const node = {\n      role: this.normalizedRole(),\n      name: this._payload.name ? this._payload.name.value || '' : ''\n    };\n    const userStringProperties = ['description', 'keyshortcuts', 'roledescription', 'valuetext'];\n    for (const userStringProperty of userStringProperties) {\n      if (!properties.has(userStringProperty)) continue;\n      node[userStringProperty] = properties.get(userStringProperty);\n    }\n    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];\n    for (const booleanProperty of booleanProperties) {\n      // WebArea's treat focus differently than other nodes. They report whether their frame  has focus,\n      // not whether focus is specifically on the root node.\n      if (booleanProperty === 'focused' && (this._role === 'WebArea' || this._role === 'RootWebArea')) continue;\n      const value = properties.get(booleanProperty);\n      if (!value) continue;\n      node[booleanProperty] = value;\n    }\n    const numericalProperties = ['level', 'valuemax', 'valuemin'];\n    for (const numericalProperty of numericalProperties) {\n      if (!properties.has(numericalProperty)) continue;\n      node[numericalProperty] = properties.get(numericalProperty);\n    }\n    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];\n    for (const tokenProperty of tokenProperties) {\n      const value = properties.get(tokenProperty);\n      if (!value || value === 'false') continue;\n      node[tokenProperty] = value;\n    }\n    const axNode = node;\n    if (this._payload.value) {\n      if (typeof this._payload.value.value === 'string') axNode.valueString = this._payload.value.value;\n      if (typeof this._payload.value.value === 'number') axNode.valueNumber = this._payload.value.value;\n    }\n    if (properties.has('checked')) axNode.checked = properties.get('checked') === 'true' ? 'checked' : properties.get('checked') === 'false' ? 'unchecked' : 'mixed';\n    if (properties.has('pressed')) axNode.pressed = properties.get('pressed') === 'true' ? 'pressed' : properties.get('pressed') === 'false' ? 'released' : 'mixed';\n    return axNode;\n  }\n  static createTree(client, payloads) {\n    const nodeById = new Map();\n    for (const payload of payloads) nodeById.set(payload.nodeId, new CRAXNode(client, payload));\n    for (const node of nodeById.values()) {\n      for (const childId of node._payload.childIds || []) node._children.push(nodeById.get(childId));\n    }\n    return nodeById.values().next().value;\n  }\n}",null,"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRBrowserContext = exports.CRBrowser = void 0;\nvar _browser = require(\"../browser\");\nvar _browserContext = require(\"../browserContext\");\nvar _utils = require(\"../../utils\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _page = require(\"../page\");\nvar _frames = require(\"../frames\");\nvar _crConnection = require(\"./crConnection\");\nvar _crPage = require(\"./crPage\");\nvar _crProtocolHelper = require(\"./crProtocolHelper\");\nvar _crServiceWorker = require(\"./crServiceWorker\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CRBrowser extends _browser.Browser {\n  static async connect(transport, options, devtools) {\n    // Make a copy in case we need to update `headful` property below.\n    options = {\n      ...options\n    };\n    const connection = new _crConnection.CRConnection(transport, options.protocolLogger, options.browserLogsCollector);\n    const browser = new CRBrowser(connection, options);\n    browser._devtools = devtools;\n    const session = connection.rootSession;\n    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();\n    const version = await session.send('Browser.getVersion');\n    browser._version = version.product.substring(version.product.indexOf('/') + 1);\n    browser._userAgent = version.userAgent;\n    // We don't trust the option as it may lie in case of connectOverCDP where remote browser\n    // may have been launched with different options.\n    browser.options.headful = !version.userAgent.includes('Headless');\n    if (!options.persistent) {\n      await session.send('Target.setAutoAttach', {\n        autoAttach: true,\n        waitForDebuggerOnStart: true,\n        flatten: true\n      });\n      return browser;\n    }\n    browser._defaultContext = new CRBrowserContext(browser, undefined, options.persistent);\n    await Promise.all([session.send('Target.setAutoAttach', {\n      autoAttach: true,\n      waitForDebuggerOnStart: true,\n      flatten: true\n    }).then(async () => {\n      // Target.setAutoAttach has a bug where it does not wait for new Targets being attached.\n      // However making a dummy call afterwards fixes this.\n      // This can be removed after https://chromium-review.googlesource.com/c/chromium/src/+/2885888 lands in stable.\n      await session.send('Target.getTargetInfo');\n    }), browser._defaultContext._initialize()]);\n    await browser._waitForAllPagesToBeInitialized();\n    return browser;\n  }\n  constructor(connection, options) {\n    super(options);\n    this._connection = void 0;\n    this._session = void 0;\n    this._clientRootSessionPromise = null;\n    this._contexts = new Map();\n    this._crPages = new Map();\n    this._backgroundPages = new Map();\n    this._serviceWorkers = new Map();\n    this._devtools = void 0;\n    this._version = '';\n    this._tracingRecording = false;\n    this._tracingPath = '';\n    this._tracingClient = void 0;\n    this._userAgent = '';\n    this._connection = connection;\n    this._session = this._connection.rootSession;\n    this._connection.on(_crConnection.ConnectionEvents.Disconnected, () => this._didClose());\n    this._session.on('Target.attachedToTarget', this._onAttachedToTarget.bind(this));\n    this._session.on('Target.detachedFromTarget', this._onDetachedFromTarget.bind(this));\n    this._session.on('Browser.downloadWillBegin', this._onDownloadWillBegin.bind(this));\n    this._session.on('Browser.downloadProgress', this._onDownloadProgress.bind(this));\n  }\n  async doCreateNewContext(options) {\n    let proxyBypassList = undefined;\n    if (options.proxy) {\n      if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK) proxyBypassList = options.proxy.bypass;else proxyBypassList = '<-loopback>' + (options.proxy.bypass ? `,${options.proxy.bypass}` : '');\n    }\n    const {\n      browserContextId\n    } = await this._session.send('Target.createBrowserContext', {\n      disposeOnDetach: true,\n      proxyServer: options.proxy ? options.proxy.server : undefined,\n      proxyBypassList\n    });\n    const context = new CRBrowserContext(this, browserContextId, options);\n    await context._initialize();\n    this._contexts.set(browserContextId, context);\n    return context;\n  }\n  contexts() {\n    return Array.from(this._contexts.values());\n  }\n  version() {\n    return this._version;\n  }\n  userAgent() {\n    return this._userAgent;\n  }\n  _platform() {\n    if (this._userAgent.includes('Windows')) return 'win';\n    if (this._userAgent.includes('Macintosh')) return 'mac';\n    return 'linux';\n  }\n  isClank() {\n    return this.options.name === 'clank';\n  }\n  async _waitForAllPagesToBeInitialized() {\n    await Promise.all([...this._crPages.values()].map(page => page.pageOrError()));\n  }\n  _onAttachedToTarget({\n    targetInfo,\n    sessionId,\n    waitingForDebugger\n  }) {\n    if (targetInfo.type === 'browser') return;\n    const session = this._connection.session(sessionId);\n    (0, _utils.assert)(targetInfo.browserContextId, 'targetInfo: ' + JSON.stringify(targetInfo, null, 2));\n    let context = this._contexts.get(targetInfo.browserContextId) || null;\n    if (!context) {\n      // TODO: auto attach only to pages from our contexts.\n      // assert(this._defaultContext);\n      context = this._defaultContext;\n    }\n    if (targetInfo.type === 'other' && targetInfo.url.startsWith('devtools://devtools') && this._devtools) {\n      this._devtools.install(session);\n      return;\n    }\n    const treatOtherAsPage = targetInfo.type === 'other' && process.env.PW_CHROMIUM_ATTACH_TO_OTHER;\n    if (!context || targetInfo.type === 'other' && !treatOtherAsPage) {\n      if (waitingForDebugger) {\n        // Ideally, detaching should resume any target, but there is a bug in the backend.\n        session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {\n          this._session._sendMayFail('Target.detachFromTarget', {\n            sessionId\n          });\n        });\n      }\n      return;\n    }\n    (0, _utils.assert)(!this._crPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);\n    (0, _utils.assert)(!this._backgroundPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);\n    (0, _utils.assert)(!this._serviceWorkers.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);\n    if (targetInfo.type === 'background_page') {\n      const backgroundPage = new _crPage.CRPage(session, targetInfo.targetId, context, null, {\n        hasUIWindow: false,\n        isBackgroundPage: true\n      });\n      this._backgroundPages.set(targetInfo.targetId, backgroundPage);\n      return;\n    }\n    if (targetInfo.type === 'page' || treatOtherAsPage) {\n      const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;\n      const crPage = new _crPage.CRPage(session, targetInfo.targetId, context, opener, {\n        hasUIWindow: targetInfo.type === 'page',\n        isBackgroundPage: false\n      });\n      this._crPages.set(targetInfo.targetId, crPage);\n      return;\n    }\n    if (targetInfo.type === 'service_worker') {\n      const serviceWorker = new _crServiceWorker.CRServiceWorker(context, session, targetInfo.url);\n      this._serviceWorkers.set(targetInfo.targetId, serviceWorker);\n      context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);\n      return;\n    }\n\n    // Detach from any targets we are not interested in, to avoid side-effects.\n    //\n    // One example of a side effect: upon shared worker restart, we receive\n    // Inspector.targetReloadedAfterCrash and backend waits for Runtime.runIfWaitingForDebugger\n    // from any attached client. If we do not resume, shared worker will stall.\n    //\n    // Ideally, detaching should resume any target, but there is a bug in the backend,\n    // so we must Runtime.runIfWaitingForDebugger first.\n    session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {\n      this._session._sendMayFail('Target.detachFromTarget', {\n        sessionId\n      });\n    });\n  }\n  _onDetachedFromTarget(payload) {\n    const targetId = payload.targetId;\n    const crPage = this._crPages.get(targetId);\n    if (crPage) {\n      this._crPages.delete(targetId);\n      crPage.didClose();\n      return;\n    }\n    const backgroundPage = this._backgroundPages.get(targetId);\n    if (backgroundPage) {\n      this._backgroundPages.delete(targetId);\n      backgroundPage.didClose();\n      return;\n    }\n    const serviceWorker = this._serviceWorkers.get(targetId);\n    if (serviceWorker) {\n      this._serviceWorkers.delete(targetId);\n      serviceWorker.didClose();\n      return;\n    }\n  }\n  _findOwningPage(frameId) {\n    for (const crPage of this._crPages.values()) {\n      const frame = crPage._page._frameManager.frame(frameId);\n      if (frame) return crPage;\n    }\n    return null;\n  }\n  _onDownloadWillBegin(payload) {\n    const page = this._findOwningPage(payload.frameId);\n    (0, _utils.assert)(page, 'Download started in unknown page: ' + JSON.stringify(payload));\n    page.willBeginDownload();\n    let originPage = page._initializedPage;\n    // If it's a new window download, report it on the opener page.\n    if (!originPage && page._opener) originPage = page._opener._initializedPage;\n    if (!originPage) return;\n    this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);\n  }\n  _onDownloadProgress(payload) {\n    if (payload.state === 'completed') this._downloadFinished(payload.guid, '');\n    if (payload.state === 'canceled') this._downloadFinished(payload.guid, 'canceled');\n  }\n  async _closePage(crPage) {\n    await this._session.send('Target.closeTarget', {\n      targetId: crPage._targetId\n    });\n  }\n  async newBrowserCDPSession() {\n    return await this._connection.createBrowserSession();\n  }\n  async startTracing(page, options = {}) {\n    (0, _utils.assert)(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');\n    this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;\n    const defaultCategories = ['-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline', 'disabled-by-default-devtools.timeline.frame', 'toplevel', 'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack', 'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'];\n    const {\n      path = null,\n      screenshots = false,\n      categories = defaultCategories\n    } = options;\n    if (screenshots) categories.push('disabled-by-default-devtools.screenshot');\n    this._tracingPath = path;\n    this._tracingRecording = true;\n    await this._tracingClient.send('Tracing.start', {\n      transferMode: 'ReturnAsStream',\n      categories: categories.join(',')\n    });\n  }\n  async stopTracing() {\n    (0, _utils.assert)(this._tracingClient, 'Tracing was not started.');\n    const [event] = await Promise.all([new Promise(f => this._tracingClient.once('Tracing.tracingComplete', f)), this._tracingClient.send('Tracing.end')]);\n    const result = await (0, _crProtocolHelper.readProtocolStream)(this._tracingClient, event.stream, this._tracingPath);\n    this._tracingRecording = false;\n    return result;\n  }\n  isConnected() {\n    return !this._connection._closed;\n  }\n  async _clientRootSession() {\n    if (!this._clientRootSessionPromise) this._clientRootSessionPromise = this._connection.createBrowserSession();\n    return this._clientRootSessionPromise;\n  }\n}\nexports.CRBrowser = CRBrowser;\nclass CRBrowserContext extends _browserContext.BrowserContext {\n  constructor(browser, browserContextId, options) {\n    super(browser, options, browserContextId);\n    this._authenticateProxyViaCredentials();\n  }\n  async _initialize() {\n    (0, _utils.assert)(!Array.from(this._browser._crPages.values()).some(page => page._browserContext === this));\n    const promises = [super._initialize()];\n    if (this._browser.options.name !== 'electron' && this._browser.options.name !== 'clank') {\n      promises.push(this._browser._session.send('Browser.setDownloadBehavior', {\n        behavior: this._options.acceptDownloads ? 'allowAndName' : 'deny',\n        browserContextId: this._browserContextId,\n        downloadPath: this._browser.options.downloadsPath,\n        eventsEnabled: true\n      }));\n    }\n    await Promise.all(promises);\n  }\n  _crPages() {\n    return [...this._browser._crPages.values()].filter(crPage => crPage._browserContext === this);\n  }\n  pages() {\n    return this._crPages().map(crPage => crPage._initializedPage).filter(Boolean);\n  }\n  async newPageDelegate() {\n    (0, _browserContext.assertBrowserContextIsNotOwned)(this);\n    const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : undefined;\n    let {\n      targetId\n    } = await this._browser._session.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: this._browserContextId\n    });\n    if (oldKeys) {\n      // Chrome for Android returns tab ids (1, 2, 3, 4, 5) instead of content target ids here, work around it via the\n      // heuristic assuming that there is only one page created at a time.\n      const newKeys = new Set(this._browser._crPages.keys());\n      // Remove old keys.\n      for (const key of oldKeys) newKeys.delete(key);\n      // Remove potential concurrent popups.\n      for (const key of newKeys) {\n        const page = this._browser._crPages.get(key);\n        if (page._opener) newKeys.delete(key);\n      }\n      (0, _utils.assert)(newKeys.size === 1);\n      [targetId] = [...newKeys];\n    }\n    return this._browser._crPages.get(targetId);\n  }\n  async doGetCookies(urls) {\n    const {\n      cookies\n    } = await this._browser._session.send('Storage.getCookies', {\n      browserContextId: this._browserContextId\n    });\n    return network.filterCookies(cookies.map(c => {\n      const copy = {\n        sameSite: 'Lax',\n        ...c\n      };\n      delete copy.size;\n      delete copy.priority;\n      delete copy.session;\n      delete copy.sameParty;\n      delete copy.sourceScheme;\n      delete copy.sourcePort;\n      return copy;\n    }), urls);\n  }\n  async addCookies(cookies) {\n    await this._browser._session.send('Storage.setCookies', {\n      cookies: network.rewriteCookies(cookies),\n      browserContextId: this._browserContextId\n    });\n  }\n  async clearCookies() {\n    await this._browser._session.send('Storage.clearCookies', {\n      browserContextId: this._browserContextId\n    });\n  }\n  async doGrantPermissions(origin, permissions) {\n    const webPermissionToProtocol = new Map([['geolocation', 'geolocation'], ['midi', 'midi'], ['notifications', 'notifications'], ['camera', 'videoCapture'], ['microphone', 'audioCapture'], ['background-sync', 'backgroundSync'], ['ambient-light-sensor', 'sensors'], ['accelerometer', 'sensors'], ['gyroscope', 'sensors'], ['magnetometer', 'sensors'], ['accessibility-events', 'accessibilityEvents'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-write', 'clipboardSanitizedWrite'], ['payment-handler', 'paymentHandler'],\n    // chrome-specific permissions we have.\n    ['midi-sysex', 'midiSysex']]);\n    const filtered = permissions.map(permission => {\n      const protocolPermission = webPermissionToProtocol.get(permission);\n      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);\n      return protocolPermission;\n    });\n    await this._browser._session.send('Browser.grantPermissions', {\n      origin: origin === '*' ? undefined : origin,\n      browserContextId: this._browserContextId,\n      permissions: filtered\n    });\n  }\n  async doClearPermissions() {\n    await this._browser._session.send('Browser.resetPermissions', {\n      browserContextId: this._browserContextId\n    });\n  }\n  async setGeolocation(geolocation) {\n    (0, _browserContext.verifyGeolocation)(geolocation);\n    this._options.geolocation = geolocation;\n    for (const page of this.pages()) await page._delegate.updateGeolocation();\n  }\n  async setExtraHTTPHeaders(headers) {\n    this._options.extraHTTPHeaders = headers;\n    for (const page of this.pages()) await page._delegate.updateExtraHTTPHeaders();\n    for (const sw of this.serviceWorkers()) await sw.updateExtraHTTPHeaders(false);\n  }\n  async setUserAgent(userAgent) {\n    this._options.userAgent = userAgent;\n    for (const page of this.pages()) await page._delegate.updateUserAgent();\n    // TODO: service workers don't have Emulation domain?\n  }\n\n  async setOffline(offline) {\n    this._options.offline = offline;\n    for (const page of this.pages()) await page._delegate.updateOffline();\n    for (const sw of this.serviceWorkers()) await sw.updateOffline(false);\n  }\n  async doSetHTTPCredentials(httpCredentials) {\n    this._options.httpCredentials = httpCredentials;\n    for (const page of this.pages()) await page._delegate.updateHttpCredentials();\n    for (const sw of this.serviceWorkers()) await sw.updateHttpCredentials(false);\n  }\n  async doAddInitScript(source) {\n    for (const page of this.pages()) await page._delegate.addInitScript(source);\n  }\n  async doRemoveInitScripts() {\n    for (const page of this.pages()) await page._delegate.removeInitScripts();\n  }\n  async doExposeBinding(binding) {\n    for (const page of this.pages()) await page._delegate.exposeBinding(binding);\n  }\n  async doRemoveExposedBindings() {\n    for (const page of this.pages()) await page._delegate.removeExposedBindings();\n  }\n  async doUpdateRequestInterception() {\n    for (const page of this.pages()) await page._delegate.updateRequestInterception();\n    for (const sw of this.serviceWorkers()) await sw.updateRequestInterception();\n  }\n  async doClose() {\n    // Headful chrome cannot dispose browser context with opened 'beforeunload'\n    // dialogs, so we should close all that are currently opened.\n    // We also won't get new ones since `Target.disposeBrowserContext` does not trigger\n    // beforeunload.\n    const openedBeforeUnloadDialogs = [];\n    for (const crPage of this._crPages()) {\n      const dialogs = [...crPage._page._frameManager._openedDialogs].filter(dialog => dialog.type() === 'beforeunload');\n      openedBeforeUnloadDialogs.push(...dialogs);\n    }\n    await Promise.all(openedBeforeUnloadDialogs.map(dialog => dialog.dismiss()));\n    if (!this._browserContextId) {\n      await Promise.all(this._crPages().map(crPage => crPage._mainFrameSession._stopVideoRecording()));\n      // Closing persistent context should close the browser.\n      await this._browser.close();\n      return;\n    }\n    await this._browser._session.send('Target.disposeBrowserContext', {\n      browserContextId: this._browserContextId\n    });\n    this._browser._contexts.delete(this._browserContextId);\n    for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {\n      if (serviceWorker._browserContext !== this) continue;\n      // When closing a browser context, service workers are shutdown\n      // asynchronously and we get detached from them later.\n      // To avoid the wrong order of notifications, we manually fire\n      // \"close\" event here and forget about the serivce worker.\n      serviceWorker.didClose();\n      this._browser._serviceWorkers.delete(targetId);\n    }\n  }\n  onClosePersistent() {\n    // When persistent context is closed, we do not necessary get Target.detachedFromTarget\n    // for all the background pages.\n    for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {\n      if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {\n        backgroundPage.didClose();\n        this._browser._backgroundPages.delete(targetId);\n      }\n    }\n  }\n  async cancelDownload(guid) {\n    // The upstream CDP method is implemented in a way that no explicit error would be given\n    // regarding the requested `guid`, even if the download is in a state not suitable for\n    // cancellation (finished, cancelled, etc.) or the guid is invalid at all.\n    await this._browser._session.send('Browser.cancelDownload', {\n      guid: guid,\n      browserContextId: this._browserContextId\n    });\n  }\n  backgroundPages() {\n    const result = [];\n    for (const backgroundPage of this._browser._backgroundPages.values()) {\n      if (backgroundPage._browserContext === this && backgroundPage._initializedPage) result.push(backgroundPage._initializedPage);\n    }\n    return result;\n  }\n  serviceWorkers() {\n    return Array.from(this._browser._serviceWorkers.values()).filter(serviceWorker => serviceWorker._browserContext === this);\n  }\n  async newCDPSession(page) {\n    let targetId = null;\n    if (page instanceof _page.Page) {\n      targetId = page._delegate._targetId;\n    } else if (page instanceof _frames.Frame) {\n      const session = page._page._delegate._sessions.get(page._id);\n      if (!session) throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);\n      targetId = session._targetId;\n    } else {\n      throw new Error('page: expected Page or Frame');\n    }\n    const rootSession = await this._browser._clientRootSession();\n    const {\n      sessionId\n    } = await rootSession.send('Target.attachToTarget', {\n      targetId,\n      flatten: true\n    });\n    return this._browser._connection.session(sessionId);\n  }\n}\nexports.CRBrowserContext = CRBrowserContext;\nCRBrowserContext.CREvents = {\n  BackgroundPage: 'backgroundpage',\n  ServiceWorker: 'serviceworker'\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.kBrowserCloseMessageId = exports.ConnectionEvents = exports.CRSessionEvents = exports.CRSession = exports.CRConnection = void 0;\nvar _utils = require(\"../../utils\");\nvar _events = require(\"events\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _helper = require(\"../helper\");\nvar _protocolError = require(\"../protocolError\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst ConnectionEvents = {\n  Disconnected: Symbol('ConnectionEvents.Disconnected')\n};\n\n// CRPlaywright uses this special id to issue Browser.close command which we\n// should ignore.\nexports.ConnectionEvents = ConnectionEvents;\nconst kBrowserCloseMessageId = -9999;\nexports.kBrowserCloseMessageId = kBrowserCloseMessageId;\nclass CRConnection extends _events.EventEmitter {\n  constructor(transport, protocolLogger, browserLogsCollector) {\n    super();\n    this._lastId = 0;\n    this._transport = void 0;\n    this._sessions = new Map();\n    this._protocolLogger = void 0;\n    this._browserLogsCollector = void 0;\n    this.rootSession = void 0;\n    this._closed = false;\n    this.setMaxListeners(0);\n    this._transport = transport;\n    this._protocolLogger = protocolLogger;\n    this._browserLogsCollector = browserLogsCollector;\n    this.rootSession = new CRSession(this, '', 'browser', '');\n    this._sessions.set('', this.rootSession);\n    this._transport.onmessage = this._onMessage.bind(this);\n    // onclose should be set last, since it can be immediately called.\n    this._transport.onclose = this._onClose.bind(this);\n  }\n  static fromSession(session) {\n    return session._connection;\n  }\n  session(sessionId) {\n    return this._sessions.get(sessionId) || null;\n  }\n  _rawSend(sessionId, method, params) {\n    const id = ++this._lastId;\n    const message = {\n      id,\n      method,\n      params\n    };\n    if (sessionId) message.sessionId = sessionId;\n    this._protocolLogger('send', message);\n    this._transport.send(message);\n    return id;\n  }\n  async _onMessage(message) {\n    this._protocolLogger('receive', message);\n    if (message.id === kBrowserCloseMessageId) return;\n    if (message.method === 'Target.attachedToTarget') {\n      const sessionId = message.params.sessionId;\n      const rootSessionId = message.sessionId || '';\n      const session = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);\n      this._sessions.set(sessionId, session);\n    } else if (message.method === 'Target.detachedFromTarget') {\n      const session = this._sessions.get(message.params.sessionId);\n      if (session) {\n        session._onClosed(undefined);\n        this._sessions.delete(message.params.sessionId);\n      }\n    }\n    const session = this._sessions.get(message.sessionId || '');\n    if (session) session._onMessage(message);\n  }\n  _onClose() {\n    this._closed = true;\n    this._transport.onmessage = undefined;\n    this._transport.onclose = undefined;\n    const browserDisconnectedLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());\n    for (const session of this._sessions.values()) session._onClosed(browserDisconnectedLogs);\n    this._sessions.clear();\n    Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));\n  }\n  close() {\n    if (!this._closed) this._transport.close();\n  }\n  async createSession(targetInfo) {\n    const {\n      sessionId\n    } = await this.rootSession.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true\n    });\n    return this._sessions.get(sessionId);\n  }\n  async createBrowserSession() {\n    const {\n      sessionId\n    } = await this.rootSession.send('Target.attachToBrowserTarget');\n    return this._sessions.get(sessionId);\n  }\n}\nexports.CRConnection = CRConnection;\nconst CRSessionEvents = {\n  Disconnected: Symbol('Events.CDPSession.Disconnected')\n};\nexports.CRSessionEvents = CRSessionEvents;\nclass CRSession extends _events.EventEmitter {\n  constructor(connection, rootSessionId, targetType, sessionId) {\n    super();\n    this._connection = void 0;\n    this._eventListener = void 0;\n    this._callbacks = new Map();\n    this._targetType = void 0;\n    this._sessionId = void 0;\n    this._rootSessionId = void 0;\n    this._crashed = false;\n    this._browserDisconnectedLogs = void 0;\n    this.on = void 0;\n    this.addListener = void 0;\n    this.off = void 0;\n    this.removeListener = void 0;\n    this.once = void 0;\n    this.guid = void 0;\n    this.guid = `cdp-session@${sessionId}`;\n    this.setMaxListeners(0);\n    this._connection = connection;\n    this._rootSessionId = rootSessionId;\n    this._targetType = targetType;\n    this._sessionId = sessionId;\n    this.on = super.on;\n    this.addListener = super.addListener;\n    this.off = super.removeListener;\n    this.removeListener = super.removeListener;\n    this.once = super.once;\n  }\n  _markAsCrashed() {\n    this._crashed = true;\n  }\n  async send(method, params) {\n    if (this._crashed) throw new _protocolError.ProtocolError(true, 'Target crashed');\n    if (this._browserDisconnectedLogs !== undefined) throw new _protocolError.ProtocolError(true, `Browser closed.` + this._browserDisconnectedLogs);\n    if (!this._connection) throw new _protocolError.ProtocolError(true, `Target closed`);\n    const id = this._connection._rawSend(this._sessionId, method, params);\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {\n        resolve,\n        reject,\n        error: new _protocolError.ProtocolError(false),\n        method\n      });\n    });\n  }\n  _sendMayFail(method, params) {\n    return this.send(method, params).catch(error => _debugLogger.debugLogger.log('error', error));\n  }\n  _onMessage(object) {\n    var _object$error;\n    if (object.id && this._callbacks.has(object.id)) {\n      const callback = this._callbacks.get(object.id);\n      this._callbacks.delete(object.id);\n      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object.error));else callback.resolve(object.result);\n    } else if (object.id && ((_object$error = object.error) === null || _object$error === void 0 ? void 0 : _object$error.code) === -32001) {\n      // Message to a closed session, just ignore it.\n    } else {\n      var _object$error2;\n      (0, _utils.assert)(!object.id, (object === null || object === void 0 ? void 0 : (_object$error2 = object.error) === null || _object$error2 === void 0 ? void 0 : _object$error2.message) || undefined);\n      Promise.resolve().then(() => {\n        if (this._eventListener) this._eventListener(object.method, object.params);\n        this.emit(object.method, object.params);\n      });\n    }\n  }\n  async detach() {\n    if (!this._connection) throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);\n    const rootSession = this._connection.session(this._rootSessionId);\n    if (!rootSession) throw new Error('Root session has been closed');\n    await rootSession.send('Target.detachFromTarget', {\n      sessionId: this._sessionId\n    });\n  }\n  _onClosed(browserDisconnectedLogs) {\n    this._browserDisconnectedLogs = browserDisconnectedLogs;\n    const errorMessage = browserDisconnectedLogs !== undefined ? 'Browser closed.' + browserDisconnectedLogs : 'Target closed';\n    for (const callback of this._callbacks.values()) {\n      callback.error.sessionClosed = true;\n      callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, errorMessage));\n    }\n    this._callbacks.clear();\n    this._connection = null;\n    Promise.resolve().then(() => this.emit(CRSessionEvents.Disconnected));\n  }\n}\nexports.CRSession = CRSession;\nfunction createProtocolError(error, method, protocolError) {\n  let message = `Protocol error (${method}): ${protocolError.message}`;\n  if ('data' in protocolError) message += ` ${protocolError.data}`;\n  return (0, _stackTrace.rewriteErrorMessage)(error, message);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRCoverage = void 0;\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _utils = require(\"../../utils\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CRCoverage {\n  constructor(client) {\n    this._jsCoverage = void 0;\n    this._cssCoverage = void 0;\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n  async startJSCoverage(options) {\n    return await this._jsCoverage.start(options);\n  }\n  async stopJSCoverage() {\n    return await this._jsCoverage.stop();\n  }\n  async startCSSCoverage(options) {\n    return await this._cssCoverage.start(options);\n  }\n  async stopCSSCoverage() {\n    return await this._cssCoverage.stop();\n  }\n}\nexports.CRCoverage = CRCoverage;\nclass JSCoverage {\n  constructor(client) {\n    this._client = void 0;\n    this._enabled = void 0;\n    this._scriptIds = void 0;\n    this._scriptSources = void 0;\n    this._eventListeners = void 0;\n    this._resetOnNavigation = void 0;\n    this._reportAnonymousScripts = false;\n    this._client = client;\n    this._enabled = false;\n    this._scriptIds = new Set();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n  async start(options) {\n    (0, _utils.assert)(!this._enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._reportAnonymousScripts = reportAnonymousScripts;\n    this._enabled = true;\n    this._scriptIds.clear();\n    this._scriptSources.clear();\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Debugger.paused', this._onDebuggerPaused.bind(this))];\n    await Promise.all([this._client.send('Profiler.enable'), this._client.send('Profiler.startPreciseCoverage', {\n      callCount: true,\n      detailed: true\n    }), this._client.send('Debugger.enable'), this._client.send('Debugger.setSkipAllPauses', {\n      skip: true\n    })]);\n  }\n  _onDebuggerPaused() {\n    this._client.send('Debugger.resume');\n  }\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n    this._scriptIds.clear();\n    this._scriptSources.clear();\n  }\n  async _onScriptParsed(event) {\n    this._scriptIds.add(event.scriptId);\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !this._reportAnonymousScripts) return;\n    // This might fail if the page has already navigated away.\n    const response = await this._client._sendMayFail('Debugger.getScriptSource', {\n      scriptId: event.scriptId\n    });\n    if (response) this._scriptSources.set(event.scriptId, response.scriptSource);\n  }\n  async stop() {\n    (0, _utils.assert)(this._enabled, 'JSCoverage is not enabled');\n    this._enabled = false;\n    const [profileResponse] = await Promise.all([this._client.send('Profiler.takePreciseCoverage'), this._client.send('Profiler.stopPreciseCoverage'), this._client.send('Profiler.disable'), this._client.send('Debugger.disable')]);\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n    const coverage = {\n      entries: []\n    };\n    for (const entry of profileResponse.result) {\n      if (!this._scriptIds.has(entry.scriptId)) continue;\n      if (!entry.url && !this._reportAnonymousScripts) continue;\n      const source = this._scriptSources.get(entry.scriptId);\n      if (source) coverage.entries.push({\n        ...entry,\n        source\n      });else coverage.entries.push(entry);\n    }\n    return coverage;\n  }\n}\nclass CSSCoverage {\n  constructor(client) {\n    this._client = void 0;\n    this._enabled = void 0;\n    this._stylesheetURLs = void 0;\n    this._stylesheetSources = void 0;\n    this._eventListeners = void 0;\n    this._resetOnNavigation = void 0;\n    this._client = client;\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n  async start(options) {\n    (0, _utils.assert)(!this._enabled, 'CSSCoverage is already enabled');\n    const {\n      resetOnNavigation = true\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._enabled = true;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this))];\n    await Promise.all([this._client.send('DOM.enable'), this._client.send('CSS.enable'), this._client.send('CSS.startRuleUsageTracking')]);\n  }\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n  }\n  async _onStyleSheet(event) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL) return;\n    // This might fail if the page has already navigated away.\n    const response = await this._client._sendMayFail('CSS.getStyleSheetText', {\n      styleSheetId: header.styleSheetId\n    });\n    if (response) {\n      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n      this._stylesheetSources.set(header.styleSheetId, response.text);\n    }\n  }\n  async stop() {\n    (0, _utils.assert)(this._enabled, 'CSSCoverage is not enabled');\n    this._enabled = false;\n    const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n    await Promise.all([this._client.send('CSS.disable'), this._client.send('DOM.disable')]);\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n\n    // aggregate by styleSheetId\n    const styleSheetIdToCoverage = new Map();\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0\n      });\n    }\n    const coverage = {\n      entries: []\n    };\n    for (const styleSheetId of this._stylesheetURLs.keys()) {\n      const url = this._stylesheetURLs.get(styleSheetId);\n      const text = this._stylesheetSources.get(styleSheetId);\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.entries.push({\n        url,\n        ranges,\n        text\n      });\n    }\n    return coverage;\n  }\n}\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({\n      offset: range.startOffset,\n      type: 0,\n      range\n    });\n    points.push({\n      offset: range.endOffset,\n      type: 1,\n      range\n    });\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) return a.offset - b.offset;\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type) return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0) return bLength - aLength;\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset) lastResult.end = point.offset;else results.push({\n        start: lastOffset,\n        end: point.offset\n      });\n    }\n    lastOffset = point.offset;\n    if (point.type === 0) hitCountStack.push(point.range.count);else hitCountStack.pop();\n  }\n  // Filter out empty ranges.\n  return results.filter(range => range.end - range.start > 1);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRDevTools = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst kBindingName = '__pw_devtools__';\n\n// This class intercepts preferences-related DevTools embedder methods\n// and stores preferences as a json file in the browser installation directory.\nclass CRDevTools {\n  constructor(preferencesPath) {\n    this._preferencesPath = void 0;\n    this._prefs = void 0;\n    this._savePromise = void 0;\n    this.__testHookOnBinding = void 0;\n    this._preferencesPath = preferencesPath;\n    this._savePromise = Promise.resolve();\n  }\n  install(session) {\n    session.on('Runtime.bindingCalled', async event => {\n      if (event.name !== kBindingName) return;\n      const parsed = JSON.parse(event.payload);\n      let result = undefined;\n      if (this.__testHookOnBinding) this.__testHookOnBinding(parsed);\n      if (parsed.method === 'getPreferences') {\n        if (this._prefs === undefined) {\n          try {\n            const json = await _fs.default.promises.readFile(this._preferencesPath, 'utf8');\n            this._prefs = JSON.parse(json);\n          } catch (e) {\n            this._prefs = {};\n          }\n        }\n        result = this._prefs;\n      } else if (parsed.method === 'setPreference') {\n        this._prefs[parsed.params[0]] = parsed.params[1];\n        this._save();\n      } else if (parsed.method === 'removePreference') {\n        delete this._prefs[parsed.params[0]];\n        this._save();\n      } else if (parsed.method === 'clearPreferences') {\n        this._prefs = {};\n        this._save();\n      }\n      session.send('Runtime.evaluate', {\n        expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,\n        contextId: event.executionContextId\n      }).catch(e => null);\n    });\n    Promise.all([session.send('Runtime.enable'), session.send('Runtime.addBinding', {\n      name: kBindingName\n    }), session.send('Page.enable'), session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `\n        (() => {\n          const init = () => {\n            // Lazy init happens when InspectorFrontendHost is initialized.\n            // At this point DevToolsHost is ready to be used.\n            const host = window.DevToolsHost;\n            const old = host.sendMessageToEmbedder.bind(host);\n            host.sendMessageToEmbedder = message => {\n              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))\n                window.${kBindingName}(message);\n              else\n                old(message);\n            };\n          };\n          let value;\n          Object.defineProperty(window, 'InspectorFrontendHost', {\n            configurable: true,\n            enumerable: true,\n            get() { return value; },\n            set(v) { value = v; init(); },\n          });\n        })()\n      `\n    }), session.send('Runtime.runIfWaitingForDebugger')]).catch(e => null);\n  }\n  _save() {\n    // Serialize saves to avoid corruption.\n    this._savePromise = this._savePromise.then(async () => {\n      await _fs.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch(e => null);\n    });\n  }\n}\nexports.CRDevTools = CRDevTools;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DragManager = void 0;\nvar _utils = require(\"../../utils\");\nvar _crProtocolHelper = require(\"./crProtocolHelper\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\nclass DragManager {\n  constructor(page) {\n    this._crPage = void 0;\n    this._dragState = null;\n    this._lastPosition = {\n      x: 0,\n      y: 0\n    };\n    this._crPage = page;\n  }\n  async cancelDrag() {\n    if (!this._dragState) return false;\n    await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n      type: 'dragCancel',\n      x: this._lastPosition.x,\n      y: this._lastPosition.y,\n      data: {\n        items: [],\n        dragOperationsMask: 0xFFFF\n      }\n    });\n    this._dragState = null;\n    return true;\n  }\n  async interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {\n    this._lastPosition = {\n      x,\n      y\n    };\n    if (this._dragState) {\n      await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n        type: 'dragOver',\n        x,\n        y,\n        data: this._dragState,\n        modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)\n      });\n      return;\n    }\n    if (button !== 'left') return moveCallback();\n    const client = this._crPage._mainFrameSession._client;\n    let onDragIntercepted;\n    const dragInterceptedPromise = new Promise(x => onDragIntercepted = x);\n    await Promise.all(this._crPage._page.frames().map(async frame => {\n      await frame.nonStallingEvaluateInExistingContext(function () {\n        let didStartDrag = Promise.resolve(false);\n        let dragEvent = null;\n        const dragListener = event => dragEvent = event;\n        const mouseListener = () => {\n          didStartDrag = new Promise(callback => {\n            window.addEventListener('dragstart', dragListener, {\n              once: true,\n              capture: true\n            });\n            setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);\n          });\n        };\n        window.addEventListener('mousemove', mouseListener, {\n          once: true,\n          capture: true\n        });\n        window.__cleanupDrag = async () => {\n          const val = await didStartDrag;\n          window.removeEventListener('mousemove', mouseListener, {\n            capture: true\n          });\n          window.removeEventListener('dragstart', dragListener, {\n            capture: true\n          });\n          delete window.__cleanupDrag;\n          return val;\n        };\n      }.toString(), true, 'utility').catch(() => {});\n    }));\n    client.on('Input.dragIntercepted', onDragIntercepted);\n    try {\n      await client.send('Input.setInterceptDrags', {\n        enabled: true\n      });\n    } catch {\n      // If Input.setInterceptDrags is not supported, just do a regular move.\n      // This can be removed once we stop supporting old Electron.\n      client.off('Input.dragIntercepted', onDragIntercepted);\n      return moveCallback();\n    }\n    await moveCallback();\n    const expectingDrag = (await Promise.all(this._crPage._page.frames().map(async frame => {\n      return frame.nonStallingEvaluateInExistingContext('window.__cleanupDrag && window.__cleanupDrag()', false, 'utility').catch(() => false);\n    }))).some(x => x);\n    this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;\n    client.off('Input.dragIntercepted', onDragIntercepted);\n    await client.send('Input.setInterceptDrags', {\n      enabled: false\n    });\n    if (this._dragState) {\n      await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n        type: 'dragEnter',\n        x,\n        y,\n        data: this._dragState,\n        modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)\n      });\n    }\n  }\n  isDragging() {\n    return !!this._dragState;\n  }\n  async drop(x, y, modifiers) {\n    (0, _utils.assert)(this._dragState, 'missing drag state');\n    await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n      type: 'drop',\n      x,\n      y,\n      data: this._dragState,\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)\n    });\n    this._dragState = null;\n  }\n}\nexports.DragManager = DragManager;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRExecutionContext = void 0;\nvar _crProtocolHelper = require(\"./crProtocolHelper\");\nvar js = _interopRequireWildcard(require(\"../javascript\"));\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _utilityScriptSerializers = require(\"../isomorphic/utilityScriptSerializers\");\nvar _protocolError = require(\"../protocolError\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CRExecutionContext {\n  constructor(client, contextPayload) {\n    this._client = void 0;\n    this._contextId = void 0;\n    this._client = client;\n    this._contextId = contextPayload.id;\n  }\n  async rawEvaluateJSON(expression) {\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await this._client.send('Runtime.evaluate', {\n      expression,\n      contextId: this._contextId,\n      returnByValue: true\n    }).catch(rewriteError);\n    if (exceptionDetails) throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));\n    return remoteObject.value;\n  }\n  async rawEvaluateHandle(expression) {\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await this._client.send('Runtime.evaluate', {\n      expression,\n      contextId: this._contextId\n    }).catch(rewriteError);\n    if (exceptionDetails) throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));\n    return remoteObject.objectId;\n  }\n  rawCallFunctionNoReply(func, ...args) {\n    this._client.send('Runtime.callFunctionOn', {\n      functionDeclaration: func.toString(),\n      arguments: args.map(a => a instanceof js.JSHandle ? {\n        objectId: a._objectId\n      } : {\n        value: a\n      }),\n      returnByValue: true,\n      executionContextId: this._contextId,\n      userGesture: true\n    }).catch(() => {});\n  }\n  async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await this._client.send('Runtime.callFunctionOn', {\n      functionDeclaration: expression,\n      objectId: utilityScript._objectId,\n      arguments: [{\n        objectId: utilityScript._objectId\n      }, ...values.map(value => ({\n        value\n      })), ...objectIds.map(objectId => ({\n        objectId\n      }))],\n      returnByValue,\n      awaitPromise: true,\n      userGesture: true\n    }).catch(rewriteError);\n    if (exceptionDetails) throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));\n    return returnByValue ? (0, _utilityScriptSerializers.parseEvaluationResultValue)(remoteObject.value) : utilityScript._context.createHandle(remoteObject);\n  }\n  async getProperties(context, objectId) {\n    const response = await this._client.send('Runtime.getProperties', {\n      objectId,\n      ownProperties: true\n    });\n    const result = new Map();\n    for (const property of response.result) {\n      if (!property.enumerable || !property.value) continue;\n      result.set(property.name, context.createHandle(property.value));\n    }\n    return result;\n  }\n  createHandle(context, remoteObject) {\n    return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));\n  }\n  async releaseHandle(objectId) {\n    await (0, _crProtocolHelper.releaseObject)(this._client, objectId);\n  }\n}\nexports.CRExecutionContext = CRExecutionContext;\nfunction rewriteError(error) {\n  if (error.message.includes('Object reference chain is too long')) return {\n    result: {\n      type: 'undefined'\n    }\n  };\n  if (error.message.includes('Object couldn\\'t be returned by value')) return {\n    result: {\n      type: 'undefined'\n    }\n  };\n  if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) (0, _stackTrace.rewriteErrorMessage)(error, error.message + ' Are you passing a nested JSHandle?');\n  if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error)) throw new Error('Execution context was destroyed, most likely because of a navigation.');\n  throw error;\n}\nfunction potentiallyUnserializableValue(remoteObject) {\n  const value = remoteObject.value;\n  const unserializableValue = remoteObject.unserializableValue;\n  return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;\n}\nfunction renderPreview(object) {\n  if (object.type === 'undefined') return 'undefined';\n  if ('value' in object) return String(object.value);\n  if (object.unserializableValue) return String(object.unserializableValue);\n  if (object.description === 'Object' && object.preview) {\n    const tokens = [];\n    for (const {\n      name,\n      value\n    } of object.preview.properties) tokens.push(`${name}: ${value}`);\n    return `{${tokens.join(', ')}}`;\n  }\n  if (object.subtype === 'array' && object.preview) return js.sparseArrayToString(object.preview.properties);\n  return object.description;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;\nvar input = _interopRequireWildcard(require(\"../input\"));\nvar _macEditingCommands = require(\"../macEditingCommands\");\nvar _utils = require(\"../../utils\");\nvar _crProtocolHelper = require(\"./crProtocolHelper\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass RawKeyboardImpl {\n  constructor(_client, _isMac, _dragManger) {\n    this._client = _client;\n    this._isMac = _isMac;\n    this._dragManger = _dragManger;\n  }\n  _commandsForCode(code, modifiers) {\n    if (!this._isMac) return [];\n    const parts = [];\n    for (const modifier of ['Shift', 'Control', 'Alt', 'Meta']) {\n      if (modifiers.has(modifier)) parts.push(modifier);\n    }\n    parts.push(code);\n    const shortcut = parts.join('+');\n    let commands = _macEditingCommands.macEditingCommands[shortcut] || [];\n    if ((0, _utils.isString)(commands)) commands = [commands];\n    // Commands that insert text are not supported\n    commands = commands.filter(x => !x.startsWith('insert'));\n    // remove the trailing : to match the Chromium command names.\n    return commands.map(c => c.substring(0, c.length - 1));\n  }\n  async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {\n    if (code === 'Escape' && (await this._dragManger.cancelDrag())) return;\n    const commands = this._commandsForCode(code, modifiers);\n    await this._client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      windowsVirtualKeyCode: keyCodeWithoutLocation,\n      code,\n      commands,\n      key,\n      text,\n      unmodifiedText: text,\n      autoRepeat,\n      location,\n      isKeypad: location === input.keypadLocation\n    });\n  }\n  async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {\n    await this._client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      key,\n      windowsVirtualKeyCode: keyCodeWithoutLocation,\n      code,\n      location\n    });\n  }\n  async sendText(text) {\n    await this._client.send('Input.insertText', {\n      text\n    });\n  }\n}\nexports.RawKeyboardImpl = RawKeyboardImpl;\nclass RawMouseImpl {\n  constructor(page, client, dragManager) {\n    this._client = void 0;\n    this._page = void 0;\n    this._dragManager = void 0;\n    this._page = page;\n    this._client = client;\n    this._dragManager = dragManager;\n  }\n  async move(x, y, button, buttons, modifiers, forClick) {\n    const actualMove = async () => {\n      await this._client.send('Input.dispatchMouseEvent', {\n        type: 'mouseMoved',\n        button,\n        buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),\n        x,\n        y,\n        modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)\n      });\n    };\n    if (forClick) {\n      // Avoid extra protocol calls related to drag and drop, because click relies on\n      // move-down-up protocol commands being sent synchronously.\n      return actualMove();\n    }\n    await this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, actualMove);\n  }\n  async down(x, y, button, buttons, modifiers, clickCount) {\n    if (this._dragManager.isDragging()) return;\n    await this._client.send('Input.dispatchMouseEvent', {\n      type: 'mousePressed',\n      button,\n      buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),\n      x,\n      y,\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      clickCount\n    });\n  }\n  async up(x, y, button, buttons, modifiers, clickCount) {\n    if (this._dragManager.isDragging()) {\n      await this._dragManager.drop(x, y, modifiers);\n      return;\n    }\n    await this._client.send('Input.dispatchMouseEvent', {\n      type: 'mouseReleased',\n      button,\n      buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),\n      x,\n      y,\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      clickCount\n    });\n  }\n  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {\n    await this._client.send('Input.dispatchMouseEvent', {\n      type: 'mouseWheel',\n      x,\n      y,\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      deltaX,\n      deltaY\n    });\n  }\n}\nexports.RawMouseImpl = RawMouseImpl;\nclass RawTouchscreenImpl {\n  constructor(client) {\n    this._client = void 0;\n    this._client = client;\n  }\n  async tap(x, y, modifiers) {\n    await Promise.all([this._client.send('Input.dispatchTouchEvent', {\n      type: 'touchStart',\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      touchPoints: [{\n        x,\n        y\n      }]\n    }), this._client.send('Input.dispatchTouchEvent', {\n      type: 'touchEnd',\n      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),\n      touchPoints: []\n    })]);\n  }\n}\nexports.RawTouchscreenImpl = RawTouchscreenImpl;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRNetworkManager = void 0;\nvar _helper = require(\"../helper\");\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _utils = require(\"../../utils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CRNetworkManager {\n  constructor(client, page, serviceWorker, parentManager) {\n    this._client = void 0;\n    this._page = void 0;\n    this._serviceWorker = void 0;\n    this._parentManager = void 0;\n    this._requestIdToRequest = new Map();\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    this._credentials = null;\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._requestIdToRequestPausedEvent = new Map();\n    this._eventListeners = void 0;\n    this._responseExtraInfoTracker = new ResponseExtraInfoTracker();\n    this._client = client;\n    this._page = page;\n    this._serviceWorker = serviceWorker;\n    this._parentManager = parentManager;\n    this._eventListeners = this.instrumentNetworkEvents(client);\n  }\n  instrumentNetworkEvents(session, workerFrame) {\n    const listeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Fetch.requestPaused', this._onRequestPaused.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, 'Fetch.authRequired', this._onAuthRequired.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSentExtraInfo', this._onRequestWillBeSentExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestServedFromCache', this._onRequestServedFromCache.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceivedExtraInfo', this._onResponseReceivedExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFinished', this._onLoadingFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFailed', this._onLoadingFailed.bind(this, workerFrame))];\n    if (this._page) {\n      listeners.push(...[_eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketCreated', e => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketWillSendHandshakeRequest', e => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketHandshakeResponseReceived', e => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketClosed', e => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketFrameError', e => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))]);\n    }\n    return listeners;\n  }\n  async initialize() {\n    await this._client.send('Network.enable');\n  }\n  dispose() {\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n  }\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n  async setOffline(offline) {\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled) return;\n    this._protocolRequestInterceptionEnabled = enabled;\n    if (enabled) {\n      await Promise.all([this._client.send('Network.setCacheDisabled', {\n        cacheDisabled: true\n      }), this._client.send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*',\n          requestStage: 'Request'\n        }]\n      })]);\n    } else {\n      await Promise.all([this._client.send('Network.setCacheDisabled', {\n        cacheDisabled: false\n      }), this._client.send('Fetch.disable')]);\n    }\n  }\n  _onRequestWillBeSent(workerFrame, event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n      if (requestPausedEvent) {\n        this._onRequest(workerFrame, event, requestPausedEvent);\n        this._requestIdToRequestPausedEvent.delete(requestId);\n      } else {\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n    } else {\n      this._onRequest(workerFrame, event, null);\n    }\n  }\n  _onRequestServedFromCache(event) {\n    this._responseExtraInfoTracker.requestServedFromCache(event);\n  }\n  _onRequestWillBeSentExtraInfo(event) {\n    this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);\n  }\n  _onAuthRequired(event) {\n    let response = 'Default';\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n      this._attemptedAuthentications.add(event.requestId);\n    }\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n    this._client._sendMayFail('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    });\n  }\n  _onRequestPaused(workerFrame, event) {\n    if (!event.networkId) {\n      // Fetch without networkId means that request was not recongnized by inspector, and\n      // it will never receive Network.requestWillBeSent. Most likely, this is an internal request\n      // that we can safely fail.\n      this._client._sendMayFail('Fetch.failRequest', {\n        requestId: event.requestId,\n        errorReason: 'Aborted'\n      });\n      return;\n    }\n    if (event.request.url.startsWith('data:')) return;\n    const requestId = event.networkId;\n    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n    if (requestWillBeSentEvent) {\n      this._onRequest(workerFrame, requestWillBeSentEvent, event);\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToRequestPausedEvent.set(requestId, event);\n    }\n  }\n  _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {\n    var _this$_page, _this$_page2, _this$_page3;\n    if (requestWillBeSentEvent.request.url.startsWith('data:')) return;\n    let redirectedFrom = null;\n    if (requestWillBeSentEvent.redirectResponse) {\n      const request = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);\n      // If we connect late to the target, we could have missed the requestWillBeSent event.\n      if (request) {\n        this._handleRequestRedirect(request, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp, requestWillBeSentEvent.redirectHasExtraInfo);\n        redirectedFrom = request;\n      }\n    }\n    let frame = requestWillBeSentEvent.frameId ? (_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame;\n    // Requests from workers lack frameId, because we receive Network.requestWillBeSent\n    // on the worker target. However, we receive Fetch.requestPaused on the page target,\n    // and lack workerFrame there. Luckily, Fetch.requestPaused provides a frameId.\n    if (!frame && this._page && requestPausedEvent && requestPausedEvent.frameId) frame = this._page._frameManager.frame(requestPausedEvent.frameId);\n\n    // Check if it's main resource request interception (targetId === main frame id).\n    if (!frame && this._page && requestWillBeSentEvent.frameId === ((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2._delegate)._targetId) {\n      // Main resource request for the page is being intercepted so the Frame is not created\n      // yet. Precreate it here for the purposes of request interception. It will be updated\n      // later as soon as the request continues and we receive frame tree from the page.\n      frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);\n    }\n\n    // CORS options preflight request is generated by the network stack. If interception is enabled,\n    // we accept all CORS options, assuming that this was intended when setting route.\n    //\n    // Note: it would be better to match the URL against interception patterns.\n    const isInterceptedOptionsPreflight = !!requestPausedEvent && requestPausedEvent.request.method === 'OPTIONS' && requestWillBeSentEvent.initiator.type === 'preflight';\n    if (isInterceptedOptionsPreflight && (this._page || this._serviceWorker).needsRequestInterception()) {\n      const requestHeaders = requestPausedEvent.request.headers;\n      const responseHeaders = [{\n        name: 'Access-Control-Allow-Origin',\n        value: requestHeaders['Origin'] || '*'\n      }, {\n        name: 'Access-Control-Allow-Methods',\n        value: requestHeaders['Access-Control-Request-Method'] || 'GET, POST, OPTIONS, DELETE'\n      }, {\n        name: 'Access-Control-Allow-Credentials',\n        value: 'true'\n      }];\n      if (requestHeaders['Access-Control-Request-Headers']) responseHeaders.push({\n        name: 'Access-Control-Allow-Headers',\n        value: requestHeaders['Access-Control-Request-Headers']\n      });\n      this._client._sendMayFail('Fetch.fulfillRequest', {\n        requestId: requestPausedEvent.requestId,\n        responseCode: 204,\n        responsePhrase: network.STATUS_TEXTS['204'],\n        responseHeaders,\n        body: ''\n      });\n      return;\n    }\n\n    // Non-service-worker requests MUST have a frame—if they don't, we pretend there was no request\n    if (!frame && !this._serviceWorker) {\n      if (requestPausedEvent) this._client._sendMayFail('Fetch.continueRequest', {\n        requestId: requestPausedEvent.requestId\n      });\n      return;\n    }\n    let route = null;\n    if (requestPausedEvent) {\n      // We do not support intercepting redirects.\n      if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) this._client._sendMayFail('Fetch.continueRequest', {\n        requestId: requestPausedEvent.requestId\n      });else route = new RouteImpl(this._client, requestPausedEvent.requestId);\n    }\n    const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';\n    const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : undefined;\n    const request = new InterceptableRequest({\n      context: (this._page || this._serviceWorker)._browserContext,\n      frame: frame || null,\n      serviceWorker: this._serviceWorker || null,\n      documentId,\n      route,\n      requestWillBeSentEvent,\n      requestPausedEvent,\n      redirectedFrom\n    });\n    this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);\n    if (requestPausedEvent && !requestPausedEvent.responseStatusCode && !requestPausedEvent.responseErrorReason) {\n      // We will not receive extra info when intercepting the request.\n      // Use the headers from the Fetch.requestPausedPayload and release the allHeaders()\n      // right away, so that client can call it from the route handler.\n      request.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(requestPausedEvent.request.headers, '\\n'));\n    }\n    (((_this$_page3 = this._page) === null || _this$_page3 === void 0 ? void 0 : _this$_page3._frameManager) || this._serviceWorker).requestStarted(request.request, route || undefined);\n  }\n  _createResponse(request, responsePayload, hasExtraInfo) {\n    var _responsePayload$secu, _responsePayload$secu2, _responsePayload$secu3, _responsePayload$secu4, _responsePayload$secu5;\n    const getResponseBody = async () => {\n      const contentLengthHeader = Object.entries(responsePayload.headers).find(header => header[0].toLowerCase() === 'content-length');\n      const expectedLength = contentLengthHeader ? +contentLengthHeader[1] : undefined;\n      const response = await this._client.send('Network.getResponseBody', {\n        requestId: request._requestId\n      });\n      if (response.body || !expectedLength) return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n\n      // For <link prefetch we are going to receive empty body with non-emtpy content-length expectation. Reach out for the actual content.\n      const resource = await this._client.send('Network.loadNetworkResource', {\n        url: request.request.url(),\n        frameId: this._serviceWorker ? undefined : request.request.frame()._id,\n        options: {\n          disableCache: false,\n          includeCredentials: true\n        }\n      });\n      const chunks = [];\n      while (resource.resource.stream) {\n        const chunk = await this._client.send('IO.read', {\n          handle: resource.resource.stream\n        });\n        chunks.push(Buffer.from(chunk.data, chunk.base64Encoded ? 'base64' : 'utf-8'));\n        if (chunk.eof) {\n          await this._client.send('IO.close', {\n            handle: resource.resource.stream\n          });\n          break;\n        }\n      }\n      return Buffer.concat(chunks);\n    };\n    const timingPayload = responsePayload.timing;\n    let timing;\n    if (timingPayload && !this._responseExtraInfoTracker.servedFromCache(request._requestId)) {\n      timing = {\n        startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1000,\n        domainLookupStart: timingPayload.dnsStart,\n        domainLookupEnd: timingPayload.dnsEnd,\n        connectStart: timingPayload.connectStart,\n        secureConnectionStart: timingPayload.sslStart,\n        connectEnd: timingPayload.connectEnd,\n        requestStart: timingPayload.sendStart,\n        responseStart: timingPayload.receiveHeadersEnd\n      };\n    } else {\n      timing = {\n        startTime: request._wallTime * 1000,\n        domainLookupStart: -1,\n        domainLookupEnd: -1,\n        connectStart: -1,\n        secureConnectionStart: -1,\n        connectEnd: -1,\n        requestStart: -1,\n        responseStart: -1\n      };\n    }\n    const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers), timing, getResponseBody, !!responsePayload.fromServiceWorker, responsePayload.protocol);\n    if (responsePayload !== null && responsePayload !== void 0 && responsePayload.remoteIPAddress && typeof (responsePayload === null || responsePayload === void 0 ? void 0 : responsePayload.remotePort) === 'number') {\n      response._serverAddrFinished({\n        ipAddress: responsePayload.remoteIPAddress,\n        port: responsePayload.remotePort\n      });\n    } else {\n      response._serverAddrFinished();\n    }\n    response._securityDetailsFinished({\n      protocol: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu = responsePayload.securityDetails) === null || _responsePayload$secu === void 0 ? void 0 : _responsePayload$secu.protocol,\n      subjectName: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu2 = responsePayload.securityDetails) === null || _responsePayload$secu2 === void 0 ? void 0 : _responsePayload$secu2.subjectName,\n      issuer: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu3 = responsePayload.securityDetails) === null || _responsePayload$secu3 === void 0 ? void 0 : _responsePayload$secu3.issuer,\n      validFrom: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu4 = responsePayload.securityDetails) === null || _responsePayload$secu4 === void 0 ? void 0 : _responsePayload$secu4.validFrom,\n      validTo: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu5 = responsePayload.securityDetails) === null || _responsePayload$secu5 === void 0 ? void 0 : _responsePayload$secu5.validTo\n    });\n    this._responseExtraInfoTracker.processResponse(request._requestId, response, hasExtraInfo);\n    return response;\n  }\n  _handleRequestRedirect(request, responsePayload, timestamp, hasExtraInfo) {\n    var _this$_page4, _this$_page5;\n    const response = this._createResponse(request, responsePayload, hasExtraInfo);\n    response.setTransferSize(null);\n    response.setEncodedBodySize(null);\n    response._requestFinished((timestamp - request._timestamp) * 1000);\n    this._requestIdToRequest.delete(request._requestId);\n    if (request._interceptionId) this._attemptedAuthentications.delete(request._interceptionId);\n    (((_this$_page4 = this._page) === null || _this$_page4 === void 0 ? void 0 : _this$_page4._frameManager) || this._serviceWorker).requestReceivedResponse(response);\n    (((_this$_page5 = this._page) === null || _this$_page5 === void 0 ? void 0 : _this$_page5._frameManager) || this._serviceWorker).reportRequestFinished(request.request, response);\n  }\n  _onResponseReceivedExtraInfo(event) {\n    this._responseExtraInfoTracker.responseReceivedExtraInfo(event);\n  }\n  _onResponseReceived(event) {\n    var _this$_page7;\n    let request = this._requestIdToRequest.get(event.requestId);\n    // For frame-level Requests that are handled by a Service Worker's fetch handler, we'll never get a requestPaused event, so we need to\n    // manually create the request. In an ideal world, crNetworkManager would be able to know this on Network.requestWillBeSent, but there\n    // is not enough metadata there.\n    //\n    // PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS we guard with, since this would fix an old bug where, when using routing,\n    // request would not be emitted to the user for requests made by a page with a SW (and fetch handler) registered\n    if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS && !request && event.response.fromServiceWorker) {\n      var _this$_page6;\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);\n      const frame = requestWillBeSentEvent !== null && requestWillBeSentEvent !== void 0 && requestWillBeSentEvent.frameId ? (_this$_page6 = this._page) === null || _this$_page6 === void 0 ? void 0 : _this$_page6._frameManager.frame(requestWillBeSentEvent.frameId) : null;\n      if (requestWillBeSentEvent && frame) {\n        this._onRequest(frame, requestWillBeSentEvent, null /* requestPausedPayload */);\n        request = this._requestIdToRequest.get(event.requestId);\n        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);\n      }\n    }\n    // FileUpload sends a response without a matching request.\n    if (!request) return;\n    const response = this._createResponse(request, event.response, event.hasExtraInfo);\n    (((_this$_page7 = this._page) === null || _this$_page7 === void 0 ? void 0 : _this$_page7._frameManager) || this._serviceWorker).requestReceivedResponse(response);\n  }\n  _onLoadingFinished(event) {\n    var _this$_page8;\n    this._responseExtraInfoTracker.loadingFinished(event);\n    let request = this._requestIdToRequest.get(event.requestId);\n    if (!request) request = this._maybeAdoptMainRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) return;\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    const response = request.request._existingResponse();\n    if (response) {\n      response.setTransferSize(event.encodedDataLength);\n      response.responseHeadersSize().then(size => response.setEncodedBodySize(event.encodedDataLength - size));\n      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));\n    }\n    this._requestIdToRequest.delete(request._requestId);\n    if (request._interceptionId) this._attemptedAuthentications.delete(request._interceptionId);\n    (((_this$_page8 = this._page) === null || _this$_page8 === void 0 ? void 0 : _this$_page8._frameManager) || this._serviceWorker).reportRequestFinished(request.request, response);\n  }\n  _onLoadingFailed(workerFrame, event) {\n    var _this$_page9;\n    this._responseExtraInfoTracker.loadingFailed(event);\n    let request = this._requestIdToRequest.get(event.requestId);\n    if (!request) request = this._maybeAdoptMainRequest(event.requestId);\n    if (!request) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);\n      if (requestWillBeSentEvent) {\n        // This is a case where request has failed before we had a chance to intercept it.\n        // We stop waiting for Fetch.requestPaused (it might never come), and dispatch request event\n        // right away, followed by requestfailed event.\n        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);\n        this._onRequest(workerFrame, requestWillBeSentEvent, null);\n        request = this._requestIdToRequest.get(event.requestId);\n      }\n    }\n\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) return;\n    const response = request.request._existingResponse();\n    if (response) {\n      response.setTransferSize(null);\n      response.setEncodedBodySize(null);\n      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));\n    }\n    this._requestIdToRequest.delete(request._requestId);\n    if (request._interceptionId) this._attemptedAuthentications.delete(request._interceptionId);\n    request.request._setFailureText(event.errorText);\n    (((_this$_page9 = this._page) === null || _this$_page9 === void 0 ? void 0 : _this$_page9._frameManager) || this._serviceWorker).requestFailed(request.request, !!event.canceled);\n  }\n  _maybeAdoptMainRequest(requestId) {\n    // OOPIF has a main request that starts in the parent session but finishes in the child session.\n    if (!this._parentManager) return;\n    const request = this._parentManager._requestIdToRequest.get(requestId);\n    // Main requests have matching loaderId and requestId.\n    if (!request || request._documentId !== requestId) return;\n    this._requestIdToRequest.set(requestId, request);\n    this._parentManager._requestIdToRequest.delete(requestId);\n    if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {\n      this._parentManager._attemptedAuthentications.delete(request._interceptionId);\n      this._attemptedAuthentications.add(request._interceptionId);\n    }\n    return request;\n  }\n}\nexports.CRNetworkManager = CRNetworkManager;\nclass InterceptableRequest {\n  constructor(options) {\n    this.request = void 0;\n    this._requestId = void 0;\n    this._interceptionId = void 0;\n    this._documentId = void 0;\n    this._timestamp = void 0;\n    this._wallTime = void 0;\n    this._route = void 0;\n    this._redirectedFrom = void 0;\n    const {\n      context,\n      frame,\n      documentId,\n      route,\n      requestWillBeSentEvent,\n      requestPausedEvent,\n      redirectedFrom,\n      serviceWorker\n    } = options;\n    this._timestamp = requestWillBeSentEvent.timestamp;\n    this._wallTime = requestWillBeSentEvent.wallTime;\n    this._requestId = requestWillBeSentEvent.requestId;\n    this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;\n    this._documentId = documentId;\n    this._route = route;\n    this._redirectedFrom = redirectedFrom;\n    const {\n      headers,\n      method,\n      url,\n      postDataEntries = null\n    } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;\n    const type = (requestWillBeSentEvent.type || '').toLowerCase();\n    let postDataBuffer = null;\n    if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes) postDataBuffer = Buffer.from(postDataEntries[0].bytes, 'base64');\n    this.request = new network.Request(context, frame, serviceWorker, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, url, type, method, postDataBuffer, (0, _utils.headersObjectToArray)(headers));\n  }\n  _routeForRedirectChain() {\n    let request = this;\n    while (request._redirectedFrom) request = request._redirectedFrom;\n    return request._route;\n  }\n}\nclass RouteImpl {\n  constructor(client, interceptionId) {\n    this._client = void 0;\n    this._interceptionId = void 0;\n    this._client = client;\n    this._interceptionId = interceptionId;\n  }\n  async continue(request, overrides) {\n    // In certain cases, protocol will return error if the request was already canceled\n    // or the page was closed. We should tolerate these errors.\n    await this._client._sendMayFail('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url: overrides.url,\n      headers: overrides.headers,\n      method: overrides.method,\n      postData: overrides.postData ? overrides.postData.toString('base64') : undefined\n    });\n  }\n  async fulfill(response) {\n    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');\n    const responseHeaders = splitSetCookieHeader(response.headers);\n    // In certain cases, protocol will return error if the request was already canceled\n    // or the page was closed. We should tolerate these errors.\n    await this._client._sendMayFail('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: response.status,\n      responsePhrase: network.STATUS_TEXTS[String(response.status)],\n      responseHeaders,\n      body\n    });\n  }\n  async abort(errorCode = 'failed') {\n    const errorReason = errorReasons[errorCode];\n    (0, _utils.assert)(errorReason, 'Unknown error code: ' + errorCode);\n    // In certain cases, protocol will return error if the request was already canceled\n    // or the page was closed. We should tolerate these errors.\n    await this._client._sendMayFail('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason\n    });\n  }\n}\nfunction splitSetCookieHeader(headers) {\n  const index = headers.findIndex(({\n    name\n  }) => name.toLowerCase() === 'set-cookie');\n  if (index === -1) return headers;\n  const header = headers[index];\n  const values = header.value.split('\\n');\n  if (values.length === 1) return headers;\n  const result = headers.slice();\n  result.splice(index, 1, ...values.map(value => ({\n    name: header.name,\n    value\n  })));\n  return result;\n}\nconst errorReasons = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed'\n};\n// This class aligns responses with response headers from extra info:\n//   - Network.requestWillBeSent, Network.responseReceived, Network.loadingFinished/loadingFailed are\n//     dispatched using one channel.\n//   - Network.requestWillBeSentExtraInfo and Network.responseReceivedExtraInfo are dispatched on\n//     another channel. Those channels are not associated, so events come in random order.\n//\n// This class will associate responses with the new headers. These extra info headers will become\n// available to client reliably upon requestfinished event only. It consumes CDP\n// signals on one end and processResponse(network.Response) signals on the other hands. It then makes\n// sure that responses have all the extra headers in place by the time request finishes.\n//\n// The shape of the instrumentation API is deliberately following the CDP, so that it\n// is clear what is called when and what this means to the tracker without extra\n// documentation.\nclass ResponseExtraInfoTracker {\n  constructor() {\n    this._requests = new Map();\n  }\n  requestWillBeSentExtraInfo(event) {\n    const info = this._getOrCreateEntry(event.requestId);\n    info.requestWillBeSentExtraInfo.push(event);\n    this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);\n    this._checkFinished(info);\n  }\n  requestServedFromCache(event) {\n    const info = this._getOrCreateEntry(event.requestId);\n    info.servedFromCache = true;\n  }\n  servedFromCache(requestId) {\n    const info = this._requests.get(requestId);\n    return !!(info !== null && info !== void 0 && info.servedFromCache);\n  }\n  responseReceivedExtraInfo(event) {\n    const info = this._getOrCreateEntry(event.requestId);\n    info.responseReceivedExtraInfo.push(event);\n    this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);\n    this._checkFinished(info);\n  }\n  processResponse(requestId, response, hasExtraInfo) {\n    var _info;\n    let info = this._requests.get(requestId);\n    // Cached responses have erroneous \"hasExtraInfo\" flag.\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1340398\n    if (!hasExtraInfo || (_info = info) !== null && _info !== void 0 && _info.servedFromCache) {\n      // Use \"provisional\" headers as \"raw\" ones.\n      response.request().setRawRequestHeaders(null);\n      response.setResponseHeadersSize(null);\n      response.setRawResponseHeaders(null);\n      return;\n    }\n    info = this._getOrCreateEntry(requestId);\n    info.responses.push(response);\n    this._patchHeaders(info, info.responses.length - 1);\n  }\n  loadingFinished(event) {\n    const info = this._requests.get(event.requestId);\n    if (!info) return;\n    info.loadingFinished = event;\n    this._checkFinished(info);\n  }\n  loadingFailed(event) {\n    const info = this._requests.get(event.requestId);\n    if (!info) return;\n    info.loadingFailed = event;\n    this._checkFinished(info);\n  }\n  _getOrCreateEntry(requestId) {\n    let info = this._requests.get(requestId);\n    if (!info) {\n      info = {\n        requestId: requestId,\n        requestWillBeSentExtraInfo: [],\n        responseReceivedExtraInfo: [],\n        responses: []\n      };\n      this._requests.set(requestId, info);\n    }\n    return info;\n  }\n  _patchHeaders(info, index) {\n    const response = info.responses[index];\n    const requestExtraInfo = info.requestWillBeSentExtraInfo[index];\n    if (response && requestExtraInfo) {\n      response.request().setRawRequestHeaders((0, _utils.headersObjectToArray)(requestExtraInfo.headers, '\\n'));\n      info.requestWillBeSentExtraInfo[index] = undefined;\n    }\n    const responseExtraInfo = info.responseReceivedExtraInfo[index];\n    if (response && responseExtraInfo) {\n      var _responseExtraInfo$he;\n      response.setResponseHeadersSize(((_responseExtraInfo$he = responseExtraInfo.headersText) === null || _responseExtraInfo$he === void 0 ? void 0 : _responseExtraInfo$he.length) || 0);\n      response.setRawResponseHeaders((0, _utils.headersObjectToArray)(responseExtraInfo.headers, '\\n'));\n      info.responseReceivedExtraInfo[index] = undefined;\n    }\n  }\n  _checkFinished(info) {\n    if (!info.loadingFinished && !info.loadingFailed) return;\n    if (info.responses.length <= info.responseReceivedExtraInfo.length) {\n      // We have extra info for each response.\n      this._stopTracking(info.requestId);\n      return;\n    }\n\n    // We are not done yet.\n  }\n\n  _stopTracking(requestId) {\n    this._requests.delete(requestId);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRPage = void 0;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _registry = require(\"../registry\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _utils = require(\"../../utils\");\nvar dialog = _interopRequireWildcard(require(\"../dialog\"));\nvar dom = _interopRequireWildcard(require(\"../dom\"));\nvar frames = _interopRequireWildcard(require(\"../frames\"));\nvar _helper = require(\"../helper\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _page = require(\"../page\");\nvar _crAccessibility = require(\"./crAccessibility\");\nvar _crBrowser = require(\"./crBrowser\");\nvar _crConnection = require(\"./crConnection\");\nvar _crCoverage = require(\"./crCoverage\");\nvar _crDragDrop = require(\"./crDragDrop\");\nvar _crExecutionContext = require(\"./crExecutionContext\");\nvar _crInput = require(\"./crInput\");\nvar _crNetworkManager = require(\"./crNetworkManager\");\nvar _crPdf = require(\"./crPdf\");\nvar _crProtocolHelper = require(\"./crProtocolHelper\");\nvar _defaultFontFamilies = require(\"./defaultFontFamilies\");\nvar _videoRecorder = require(\"./videoRecorder\");\nvar _browserContext = require(\"../browserContext\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst UTILITY_WORLD_NAME = '__playwright_utility_world__';\nclass CRPage {\n  // Holds window features for the next popup being opened via window.open,\n  // until the popup target arrives. This could be racy if two oopifs\n  // simultaneously call window.open with window features: the order\n  // of their Page.windowOpen events is not guaranteed to match the order\n  // of new popup targets.\n\n  static mainFrameSession(page) {\n    const crPage = page._delegate;\n    return crPage._mainFrameSession;\n  }\n  constructor(client, targetId, browserContext, opener, bits) {\n    this._mainFrameSession = void 0;\n    this._sessions = new Map();\n    this._page = void 0;\n    this.rawMouse = void 0;\n    this.rawKeyboard = void 0;\n    this.rawTouchscreen = void 0;\n    this._targetId = void 0;\n    this._opener = void 0;\n    this._pdf = void 0;\n    this._coverage = void 0;\n    this._browserContext = void 0;\n    this._pagePromise = void 0;\n    this._initializedPage = null;\n    this._isBackgroundPage = void 0;\n    this._nextWindowOpenPopupFeatures = [];\n    this._targetId = targetId;\n    this._opener = opener;\n    this._isBackgroundPage = bits.isBackgroundPage;\n    const dragManager = new _crDragDrop.DragManager(this);\n    this.rawKeyboard = new _crInput.RawKeyboardImpl(client, browserContext._browser._platform() === 'mac', dragManager);\n    this.rawMouse = new _crInput.RawMouseImpl(this, client, dragManager);\n    this.rawTouchscreen = new _crInput.RawTouchscreenImpl(client);\n    this._pdf = new _crPdf.CRPDF(client);\n    this._coverage = new _crCoverage.CRCoverage(client);\n    this._browserContext = browserContext;\n    this._page = new _page.Page(this, browserContext);\n    this._mainFrameSession = new FrameSession(this, client, targetId, null);\n    this._sessions.set(targetId, this._mainFrameSession);\n    client.once(_crConnection.CRSessionEvents.Disconnected, () => this._page._didDisconnect());\n    if (opener && !browserContext._options.noDefaultViewport) {\n      const features = opener._nextWindowOpenPopupFeatures.shift() || [];\n      const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(features);\n      if (viewportSize) this._page._emulatedSize = {\n        viewport: viewportSize,\n        screen: viewportSize\n      };\n    }\n    // Note: it is important to call |reportAsNew| before resolving pageOrError promise,\n    // so that anyone who awaits pageOrError got a ready and reported page.\n    this._pagePromise = this._mainFrameSession._initialize(bits.hasUIWindow).then(async r => {\n      await this._page.initOpener(this._opener);\n      return r;\n    }).catch(async e => {\n      await this._page.initOpener(this._opener);\n      throw e;\n    }).then(() => {\n      this._initializedPage = this._page;\n      this._reportAsNew();\n      return this._page;\n    }).catch(e => {\n      this._reportAsNew(e);\n      return e;\n    });\n  }\n  potentiallyUninitializedPage() {\n    return this._page;\n  }\n  _reportAsNew(error) {\n    this._page.reportAsNew(error, this._isBackgroundPage ? _crBrowser.CRBrowserContext.CREvents.BackgroundPage : _browserContext.BrowserContext.Events.Page);\n  }\n  async _forAllFrameSessions(cb) {\n    const frameSessions = Array.from(this._sessions.values());\n    await Promise.all(frameSessions.map(frameSession => {\n      if (frameSession._isMainFrame()) return cb(frameSession);\n      return cb(frameSession).catch(e => {\n        // Broadcasting a message to the closed iframe shoule be a noop.\n        if (e.message && e.message.includes('Target closed')) return;\n        throw e;\n      });\n    }));\n  }\n  _sessionForFrame(frame) {\n    // Frame id equals target id.\n    while (!this._sessions.has(frame._id)) {\n      const parent = frame.parentFrame();\n      if (!parent) throw new Error(`Frame has been detached.`);\n      frame = parent;\n    }\n    return this._sessions.get(frame._id);\n  }\n  _sessionForHandle(handle) {\n    const frame = handle._context.frame;\n    return this._sessionForFrame(frame);\n  }\n  willBeginDownload() {\n    this._mainFrameSession._willBeginDownload();\n  }\n  async pageOrError() {\n    return this._pagePromise;\n  }\n  didClose() {\n    for (const session of this._sessions.values()) session.dispose();\n    this._page._didClose();\n  }\n  async navigateFrame(frame, url, referrer) {\n    return this._sessionForFrame(frame)._navigate(frame, url, referrer);\n  }\n  async exposeBinding(binding) {\n    await this._forAllFrameSessions(frame => frame._initBinding(binding));\n    await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source, false, {}).catch(e => {})));\n  }\n  async removeExposedBindings() {\n    await this._forAllFrameSessions(frame => frame._removeExposedBindings());\n  }\n  async updateExtraHTTPHeaders() {\n    await this._forAllFrameSessions(frame => frame._updateExtraHTTPHeaders(false));\n  }\n  async updateGeolocation() {\n    await this._forAllFrameSessions(frame => frame._updateGeolocation(false));\n  }\n  async updateOffline() {\n    await this._forAllFrameSessions(frame => frame._updateOffline(false));\n  }\n  async updateHttpCredentials() {\n    await this._forAllFrameSessions(frame => frame._updateHttpCredentials(false));\n  }\n  async updateEmulatedViewportSize(preserveWindowBoundaries) {\n    await this._mainFrameSession._updateViewport(preserveWindowBoundaries);\n  }\n  async bringToFront() {\n    await this._mainFrameSession._client.send('Page.bringToFront');\n  }\n  async updateEmulateMedia() {\n    await this._forAllFrameSessions(frame => frame._updateEmulateMedia());\n  }\n  async updateUserAgent() {\n    await this._forAllFrameSessions(frame => frame._updateUserAgent());\n  }\n  async updateRequestInterception() {\n    await this._forAllFrameSessions(frame => frame._updateRequestInterception());\n  }\n  async updateFileChooserInterception() {\n    await this._forAllFrameSessions(frame => frame._updateFileChooserInterception(false));\n  }\n  async reload() {\n    await this._mainFrameSession._client.send('Page.reload');\n  }\n  async _go(delta) {\n    const history = await this._mainFrameSession._client.send('Page.getNavigationHistory');\n    const entry = history.entries[history.currentIndex + delta];\n    if (!entry) return false;\n    await this._mainFrameSession._client.send('Page.navigateToHistoryEntry', {\n      entryId: entry.id\n    });\n    return true;\n  }\n  goBack() {\n    return this._go(-1);\n  }\n  goForward() {\n    return this._go(+1);\n  }\n  async addInitScript(source, world = 'main') {\n    await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(source, world));\n  }\n  async removeInitScripts() {\n    await this._forAllFrameSessions(frame => frame._removeEvaluatesOnNewDocument());\n  }\n  async closePage(runBeforeUnload) {\n    if (runBeforeUnload) await this._mainFrameSession._client.send('Page.close');else await this._browserContext._browser._closePage(this);\n  }\n  async setBackgroundColor(color) {\n    await this._mainFrameSession._client.send('Emulation.setDefaultBackgroundColorOverride', {\n      color\n    });\n  }\n  async takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {\n    const {\n      visualViewport\n    } = await this._mainFrameSession._client.send('Page.getLayoutMetrics');\n    if (!documentRect) {\n      documentRect = {\n        x: visualViewport.pageX + viewportRect.x,\n        y: visualViewport.pageY + viewportRect.y,\n        ..._helper.helper.enclosingIntSize({\n          width: viewportRect.width / visualViewport.scale,\n          height: viewportRect.height / visualViewport.scale\n        })\n      };\n    }\n    // When taking screenshots with documentRect (based on the page content, not viewport),\n    // ignore current page scale.\n    const clip = {\n      ...documentRect,\n      scale: viewportRect ? visualViewport.scale : 1\n    };\n    if (scale === 'css') {\n      const deviceScaleFactor = this._browserContext._options.deviceScaleFactor || 1;\n      clip.scale /= deviceScaleFactor;\n    }\n    progress.throwIfAborted();\n    const result = await this._mainFrameSession._client.send('Page.captureScreenshot', {\n      format,\n      quality,\n      clip,\n      captureBeyondViewport: !fitsViewport\n    });\n    return Buffer.from(result.data, 'base64');\n  }\n  async getContentFrame(handle) {\n    return this._sessionForHandle(handle)._getContentFrame(handle);\n  }\n  async getOwnerFrame(handle) {\n    return this._sessionForHandle(handle)._getOwnerFrame(handle);\n  }\n  isElementHandle(remoteObject) {\n    return remoteObject.subtype === 'node';\n  }\n  async getBoundingBox(handle) {\n    return this._sessionForHandle(handle)._getBoundingBox(handle);\n  }\n  async scrollRectIntoViewIfNeeded(handle, rect) {\n    return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);\n  }\n  async setScreencastOptions(options) {\n    if (options) {\n      await this._mainFrameSession._startScreencast(this, {\n        format: 'jpeg',\n        quality: options.quality,\n        maxWidth: options.width,\n        maxHeight: options.height\n      });\n    } else {\n      await this._mainFrameSession._stopScreencast(this);\n    }\n  }\n  rafCountForStablePosition() {\n    return 1;\n  }\n  async getContentQuads(handle) {\n    return this._sessionForHandle(handle)._getContentQuads(handle);\n  }\n  async setInputFiles(handle, files) {\n    await handle.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), files);\n  }\n  async setInputFilePaths(handle, files) {\n    const frame = await handle.ownerFrame();\n    if (!frame) throw new Error('Cannot set input files to detached input element');\n    const parentSession = this._sessionForFrame(frame);\n    await parentSession._client.send('DOM.setFileInputFiles', {\n      objectId: handle._objectId,\n      files\n    });\n  }\n  async adoptElementHandle(handle, to) {\n    return this._sessionForHandle(handle)._adoptElementHandle(handle, to);\n  }\n  async getAccessibilityTree(needle) {\n    return (0, _crAccessibility.getAccessibilityTree)(this._mainFrameSession._client, needle);\n  }\n  async inputActionEpilogue() {\n    await this._mainFrameSession._client.send('Page.enable').catch(e => {});\n  }\n  async pdf(options) {\n    return this._pdf.generate(options);\n  }\n  coverage() {\n    return this._coverage;\n  }\n  async getFrameElement(frame) {\n    let parent = frame.parentFrame();\n    if (!parent) throw new Error('Frame has been detached.');\n    const parentSession = this._sessionForFrame(parent);\n    const {\n      backendNodeId\n    } = await parentSession._client.send('DOM.getFrameOwner', {\n      frameId: frame._id\n    }).catch(e => {\n      if (e instanceof Error && e.message.includes('Frame with the given id was not found.')) (0, _stackTrace.rewriteErrorMessage)(e, 'Frame has been detached.');\n      throw e;\n    });\n    parent = frame.parentFrame();\n    if (!parent) throw new Error('Frame has been detached.');\n    return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());\n  }\n}\nexports.CRPage = CRPage;\nclass FrameSession {\n  // Marks the oopif session that remote -> local transition has happened in the parent.\n  // See Target.detachedFromTarget handler for details.\n\n  constructor(crPage, client, targetId, parentSession) {\n    this._client = void 0;\n    this._crPage = void 0;\n    this._page = void 0;\n    this._networkManager = void 0;\n    this._parentSession = void 0;\n    this._childSessions = new Set();\n    this._contextIdToContext = new Map();\n    this._eventListeners = [];\n    this._targetId = void 0;\n    this._firstNonInitialNavigationCommittedPromise = void 0;\n    this._firstNonInitialNavigationCommittedFulfill = () => {};\n    this._firstNonInitialNavigationCommittedReject = e => {};\n    this._windowId = void 0;\n    this._swappedIn = false;\n    this._videoRecorder = null;\n    this._screencastId = null;\n    this._screencastClients = new Set();\n    this._evaluateOnNewDocumentIdentifiers = [];\n    this._exposedBindingNames = [];\n    this._metricsOverride = void 0;\n    this._client = client;\n    this._crPage = crPage;\n    this._page = crPage._page;\n    this._targetId = targetId;\n    this._networkManager = new _crNetworkManager.CRNetworkManager(client, this._page, null, parentSession ? parentSession._networkManager : null);\n    this._parentSession = parentSession;\n    if (parentSession) parentSession._childSessions.add(this);\n    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {\n      this._firstNonInitialNavigationCommittedFulfill = f;\n      this._firstNonInitialNavigationCommittedReject = r;\n    });\n    client.once(_crConnection.CRSessionEvents.Disconnected, () => {\n      this._firstNonInitialNavigationCommittedReject(new Error('Page closed'));\n    });\n  }\n  _isMainFrame() {\n    return this._targetId === this._crPage._targetId;\n  }\n  _addRendererListeners() {\n    this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, 'Log.entryAdded', event => this._onLogEntryAdded(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameDetached', event => this._onFrameDetached(event.frameId, event.reason)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameRequestedNavigation', event => this._onFrameRequestedNavigation(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.javascriptDialogOpening', event => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.bindingCalled', event => this._onBindingCalled(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.consoleAPICalled', event => this._onConsoleAPI(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', event => this._onExecutionContextsCleared()), _eventsHelper.eventsHelper.addEventListener(this._client, 'Target.attachedToTarget', event => this._onAttachedToTarget(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Target.detachedFromTarget', event => this._onDetachedFromTarget(event))]);\n  }\n  _addBrowserListeners() {\n    this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, 'Inspector.targetCrashed', event => this._onTargetCrashed()), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.screencastFrame', event => this._onScreencastFrame(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.windowOpen', event => this._onWindowOpen(event))]);\n  }\n  async _initialize(hasUIWindow) {\n    const isSettingStorageState = this._page._browserContext.isSettingStorageState();\n    if (!isSettingStorageState && hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {\n      const {\n        windowId\n      } = await this._client.send('Browser.getWindowForTarget');\n      this._windowId = windowId;\n    }\n    let screencastOptions;\n    if (!isSettingStorageState && this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {\n      const screencastId = (0, _utils.createGuid)();\n      const outputFile = _path.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + '.webm');\n      screencastOptions = {\n        // validateBrowserContextOptions ensures correct video size.\n        ...this._crPage._browserContext._options.recordVideo.size,\n        outputFile\n      };\n      await this._crPage._browserContext._ensureVideosPath();\n      // Note: it is important to start video recorder before sending Page.startScreencast,\n      // and it is equally important to send Page.startScreencast before sending Runtime.runIfWaitingForDebugger.\n      await this._createVideoRecorder(screencastId, screencastOptions);\n      this._crPage.pageOrError().then(p => {\n        if (p instanceof Error) this._stopVideoRecording().catch(() => {});\n      });\n    }\n    let lifecycleEventsEnabled;\n    if (!this._isMainFrame()) this._addRendererListeners();\n    this._addBrowserListeners();\n    const promises = [this._client.send('Page.enable'), this._client.send('Page.getFrameTree').then(({\n      frameTree\n    }) => {\n      if (this._isMainFrame()) {\n        this._handleFrameTree(frameTree);\n        this._addRendererListeners();\n      }\n      const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];\n      for (const frame of localFrames) {\n        // Note: frames might be removed before we send these.\n        this._client._sendMayFail('Page.createIsolatedWorld', {\n          frameId: frame._id,\n          grantUniveralAccess: true,\n          worldName: UTILITY_WORLD_NAME\n        });\n        for (const binding of this._crPage._browserContext._pageBindings.values()) frame.evaluateExpression(binding.source, false, undefined).catch(e => {});\n        for (const source of this._crPage._browserContext.initScripts) frame.evaluateExpression(source, false, undefined, 'main').catch(e => {});\n      }\n      const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';\n      if (isInitialEmptyPage) {\n        // Ignore lifecycle events for the initial empty page. It is never the final page\n        // hence we are going to get more lifecycle updates after the actual navigation has\n        // started (even if the target url is about:blank).\n        lifecycleEventsEnabled.catch(e => {}).then(() => {\n          this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));\n        });\n      } else {\n        this._firstNonInitialNavigationCommittedFulfill();\n        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));\n      }\n    }), this._client.send('Log.enable', {}), lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', {\n      enabled: true\n    }), this._client.send('Runtime.enable', {}), this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: '',\n      worldName: UTILITY_WORLD_NAME\n    }), this._networkManager.initialize(), this._client.send('Target.setAutoAttach', {\n      autoAttach: true,\n      waitForDebuggerOnStart: true,\n      flatten: true\n    })];\n    if (!isSettingStorageState) {\n      if (this._isMainFrame()) promises.push(this._client.send('Emulation.setFocusEmulationEnabled', {\n        enabled: true\n      }));\n      const options = this._crPage._browserContext._options;\n      if (options.bypassCSP) promises.push(this._client.send('Page.setBypassCSP', {\n        enabled: true\n      }));\n      if (options.ignoreHTTPSErrors) promises.push(this._client.send('Security.setIgnoreCertificateErrors', {\n        ignore: true\n      }));\n      if (this._isMainFrame()) promises.push(this._updateViewport());\n      if (options.hasTouch) promises.push(this._client.send('Emulation.setTouchEmulationEnabled', {\n        enabled: true\n      }));\n      if (options.javaScriptEnabled === false) promises.push(this._client.send('Emulation.setScriptExecutionDisabled', {\n        value: true\n      }));\n      if (options.userAgent || options.locale) promises.push(this._updateUserAgent());\n      if (options.locale) promises.push(emulateLocale(this._client, options.locale));\n      if (options.timezoneId) promises.push(emulateTimezone(this._client, options.timezoneId));\n      if (!this._crPage._browserContext._browser.options.headful) promises.push(this._setDefaultFontFamilies(this._client));\n      promises.push(this._updateGeolocation(true));\n      promises.push(this._updateExtraHTTPHeaders(true));\n      promises.push(this._updateRequestInterception());\n      promises.push(this._updateOffline(true));\n      promises.push(this._updateHttpCredentials(true));\n      promises.push(this._updateEmulateMedia());\n      promises.push(this._updateFileChooserInterception(true));\n      for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));\n      for (const source of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(source, 'main'));\n      for (const source of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(source, 'main'));\n      if (screencastOptions) promises.push(this._startVideoRecording(screencastOptions));\n    }\n    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));\n    promises.push(this._firstNonInitialNavigationCommittedPromise);\n    await Promise.all(promises);\n  }\n  dispose() {\n    for (const childSession of this._childSessions) childSession.dispose();\n    if (this._parentSession) this._parentSession._childSessions.delete(this);\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n    this._networkManager.dispose();\n    this._crPage._sessions.delete(this._targetId);\n  }\n  async _navigate(frame, url, referrer) {\n    const response = await this._client.send('Page.navigate', {\n      url,\n      referrer,\n      frameId: frame._id\n    });\n    if (response.errorText) throw new frames.NavigationAbortedError(response.loaderId, `${response.errorText} at ${url}`);\n    return {\n      newDocumentId: response.loaderId\n    };\n  }\n  _onLifecycleEvent(event) {\n    if (this._eventBelongsToStaleFrame(event.frameId)) return;\n    if (event.name === 'load') this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');else if (event.name === 'DOMContentLoaded') this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');\n  }\n  _handleFrameTree(frameTree) {\n    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);\n    this._onFrameNavigated(frameTree.frame, true);\n    if (!frameTree.childFrames) return;\n    for (const child of frameTree.childFrames) this._handleFrameTree(child);\n  }\n  _eventBelongsToStaleFrame(frameId) {\n    const frame = this._page._frameManager.frame(frameId);\n    // Subtree may be already gone because some ancestor navigation destroyed the oopif.\n    if (!frame) return true;\n    // When frame goes remote, parent process may still send some events\n    // related to the local frame before it sends frameDetached.\n    // In this case, we already have a new session for this frame, so events\n    // in the old session should be ignored.\n    const session = this._crPage._sessionForFrame(frame);\n    return session && session !== this && !session._swappedIn;\n  }\n  _onFrameAttached(frameId, parentFrameId) {\n    const frameSession = this._crPage._sessions.get(frameId);\n    if (frameSession && frameId !== this._targetId) {\n      // This is a remote -> local frame transition.\n      frameSession._swappedIn = true;\n      const frame = this._page._frameManager.frame(frameId);\n      // Frame or even a whole subtree may be already gone, because some ancestor did navigate.\n      if (frame) this._page._frameManager.removeChildFramesRecursively(frame);\n      return;\n    }\n    if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {\n      // Parent frame may be gone already because some ancestor frame navigated and\n      // destroyed the whole subtree of some oopif, while oopif's process is still sending us events.\n      // Be careful to not confuse this with \"main frame navigated cross-process\" scenario\n      // where parentFrameId is null.\n      return;\n    }\n    this._page._frameManager.frameAttached(frameId, parentFrameId);\n  }\n  _onFrameNavigated(framePayload, initial) {\n    if (this._eventBelongsToStaleFrame(framePayload.id)) return;\n    this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);\n    if (!initial) this._firstNonInitialNavigationCommittedFulfill();\n  }\n  _onFrameRequestedNavigation(payload) {\n    if (this._eventBelongsToStaleFrame(payload.frameId)) return;\n    if (payload.disposition === 'currentTab') this._page._frameManager.frameRequestedNavigation(payload.frameId);\n  }\n  _onFrameNavigatedWithinDocument(frameId, url) {\n    if (this._eventBelongsToStaleFrame(frameId)) return;\n    this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);\n  }\n  _onFrameDetached(frameId, reason) {\n    if (this._crPage._sessions.has(frameId)) {\n      // This is a local -> remote frame transtion, where\n      // Page.frameDetached arrives after Target.attachedToTarget.\n      // We've already handled the new target and frame reattach - nothing to do here.\n      return;\n    }\n    if (reason === 'swap') {\n      // This is a local -> remote frame transtion, where\n      // Page.frameDetached arrives before Target.attachedToTarget.\n      // We should keep the frame in the tree, and it will be used for the new target.\n      const frame = this._page._frameManager.frame(frameId);\n      if (frame) this._page._frameManager.removeChildFramesRecursively(frame);\n      return;\n    }\n    // Just a regular frame detach.\n    this._page._frameManager.frameDetached(frameId);\n  }\n  _onExecutionContextCreated(contextPayload) {\n    const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;\n    if (!frame || this._eventBelongsToStaleFrame(frame._id)) return;\n    const delegate = new _crExecutionContext.CRExecutionContext(this._client, contextPayload);\n    let worldName = null;\n    if (contextPayload.auxData && !!contextPayload.auxData.isDefault) worldName = 'main';else if (contextPayload.name === UTILITY_WORLD_NAME) worldName = 'utility';\n    const context = new dom.FrameExecutionContext(delegate, frame, worldName);\n    context[contextDelegateSymbol] = delegate;\n    if (worldName) frame._contextCreated(worldName, context);\n    this._contextIdToContext.set(contextPayload.id, context);\n  }\n  _onExecutionContextDestroyed(executionContextId) {\n    const context = this._contextIdToContext.get(executionContextId);\n    if (!context) return;\n    this._contextIdToContext.delete(executionContextId);\n    context.frame._contextDestroyed(context);\n  }\n  _onExecutionContextsCleared() {\n    for (const contextId of Array.from(this._contextIdToContext.keys())) this._onExecutionContextDestroyed(contextId);\n  }\n  _onAttachedToTarget(event) {\n    const session = _crConnection.CRConnection.fromSession(this._client).session(event.sessionId);\n    if (event.targetInfo.type === 'iframe') {\n      // Frame id equals target id.\n      const targetId = event.targetInfo.targetId;\n      const frame = this._page._frameManager.frame(targetId);\n      if (!frame) return; // Subtree may be already gone due to renderer/browser race.\n      this._page._frameManager.removeChildFramesRecursively(frame);\n      const frameSession = new FrameSession(this._crPage, session, targetId, this);\n      this._crPage._sessions.set(targetId, frameSession);\n      frameSession._initialize(false).catch(e => e);\n      return;\n    }\n    if (event.targetInfo.type !== 'worker') {\n      // Ideally, detaching should resume any target, but there is a bug in the backend.\n      session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {\n        this._client._sendMayFail('Target.detachFromTarget', {\n          sessionId: event.sessionId\n        });\n      });\n      return;\n    }\n    const url = event.targetInfo.url;\n    const worker = new _page.Worker(this._page, url);\n    this._page._addWorker(event.sessionId, worker);\n    session.once('Runtime.executionContextCreated', async event => {\n      worker._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));\n    });\n    // This might fail if the target is closed before we initialize.\n    session._sendMayFail('Runtime.enable');\n    session._sendMayFail('Network.enable');\n    session._sendMayFail('Runtime.runIfWaitingForDebugger');\n    session.on('Runtime.consoleAPICalled', event => {\n      const args = event.args.map(o => worker._existingExecutionContext.createHandle(o));\n      this._page._addConsoleMessage(event.type, args, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));\n    });\n    session.on('Runtime.exceptionThrown', exception => this._page.emit(_page.Page.Events.PageError, (0, _crProtocolHelper.exceptionToError)(exception.exceptionDetails)));\n    // TODO: attribute workers to the right frame.\n    this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));\n  }\n  _onDetachedFromTarget(event) {\n    // This might be a worker...\n    this._page._removeWorker(event.sessionId);\n\n    // ... or an oopif.\n    const childFrameSession = this._crPage._sessions.get(event.targetId);\n    if (!childFrameSession) return;\n\n    // Usually, we get frameAttached in this session first and mark child as swappedIn.\n    if (childFrameSession._swappedIn) {\n      childFrameSession.dispose();\n      return;\n    }\n\n    // However, sometimes we get detachedFromTarget before frameAttached.\n    // In this case we don't know wheter this is a remote frame detach,\n    // or just a remote -> local transition. In the latter case, frameAttached\n    // is already inflight, so let's make a safe roundtrip to ensure it arrives.\n    this._client.send('Page.enable').catch(e => null).then(() => {\n      // Child was not swapped in - that means frameAttached did not happen and\n      // this is remote detach rather than remote -> local swap.\n      if (!childFrameSession._swappedIn) this._page._frameManager.frameDetached(event.targetId);\n      childFrameSession.dispose();\n    });\n  }\n  _onWindowOpen(event) {\n    this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);\n  }\n  async _onConsoleAPI(event) {\n    if (event.executionContextId === 0) {\n      // DevTools protocol stores the last 1000 console messages. These\n      // messages are always reported even for removed execution contexts. In\n      // this case, they are marked with executionContextId = 0 and are\n      // reported upon enabling Runtime agent.\n      //\n      // Ignore these messages since:\n      // - there's no execution context we can use to operate with message\n      //   arguments\n      // - these messages are reported before Playwright clients can subscribe\n      //   to the 'console'\n      //   page event.\n      //\n      // @see https://github.com/GoogleChrome/puppeteer/issues/3865\n      return;\n    }\n    const context = this._contextIdToContext.get(event.executionContextId);\n    if (!context) return;\n    const values = event.args.map(arg => context.createHandle(arg));\n    this._page._addConsoleMessage(event.type, values, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));\n  }\n  async _initBinding(binding) {\n    const [, response] = await Promise.all([this._client.send('Runtime.addBinding', {\n      name: binding.name\n    }), this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: binding.source\n    })]);\n    this._exposedBindingNames.push(binding.name);\n    if (!binding.name.startsWith('__pw')) this._evaluateOnNewDocumentIdentifiers.push(response.identifier);\n  }\n  async _removeExposedBindings() {\n    const toRetain = [];\n    const toRemove = [];\n    for (const name of this._exposedBindingNames) (name.startsWith('__pw_') ? toRetain : toRemove).push(name);\n    this._exposedBindingNames = toRetain;\n    await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', {\n      name\n    })));\n  }\n  async _onBindingCalled(event) {\n    const pageOrError = await this._crPage.pageOrError();\n    if (!(pageOrError instanceof Error)) {\n      const context = this._contextIdToContext.get(event.executionContextId);\n      if (context) await this._page._onBindingCalled(event.payload, context);\n    }\n  }\n  _onDialog(event) {\n    if (!this._page._frameManager.frame(this._targetId)) return; // Our frame/subtree may be gone already.\n    this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {\n      await this._client.send('Page.handleJavaScriptDialog', {\n        accept,\n        promptText\n      });\n    }, event.defaultPrompt));\n  }\n  _handleException(exceptionDetails) {\n    this._page.firePageError((0, _crProtocolHelper.exceptionToError)(exceptionDetails));\n  }\n  async _onTargetCrashed() {\n    this._client._markAsCrashed();\n    this._page._didCrash();\n  }\n  _onLogEntryAdded(event) {\n    const {\n      level,\n      text,\n      args,\n      source,\n      url,\n      lineNumber\n    } = event.entry;\n    if (args) args.map(arg => (0, _crProtocolHelper.releaseObject)(this._client, arg.objectId));\n    if (source !== 'worker') {\n      const location = {\n        url: url || '',\n        lineNumber: lineNumber || 0,\n        columnNumber: 0\n      };\n      this._page._addConsoleMessage(level, [], location, text);\n    }\n  }\n  async _onFileChooserOpened(event) {\n    if (!event.backendNodeId) return;\n    const frame = this._page._frameManager.frame(event.frameId);\n    if (!frame) return;\n    let handle;\n    try {\n      const utilityContext = await frame._utilityContext();\n      handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);\n    } catch (e) {\n      // During async processing, frame/context may go away. We should not throw.\n      return;\n    }\n    await this._page._onFileChooserOpened(handle);\n  }\n  _willBeginDownload() {\n    const originPage = this._crPage._initializedPage;\n    if (!originPage) {\n      // Resume the page creation with an error. The page will automatically close right\n      // after the download begins.\n      this._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));\n    }\n  }\n  _onScreencastFrame(payload) {\n    this._page.throttleScreencastFrameAck(() => {\n      this._client.send('Page.screencastFrameAck', {\n        sessionId: payload.sessionId\n      }).catch(() => {});\n    });\n    const buffer = Buffer.from(payload.data, 'base64');\n    this._page.emit(_page.Page.Events.ScreencastFrame, {\n      buffer,\n      timestamp: payload.metadata.timestamp,\n      width: payload.metadata.deviceWidth,\n      height: payload.metadata.deviceHeight\n    });\n  }\n  async _createVideoRecorder(screencastId, options) {\n    (0, _utils.assert)(!this._screencastId);\n    const ffmpegPath = _registry.registry.findExecutable('ffmpeg').executablePathOrDie(this._page._browserContext._browser.options.sdkLanguage);\n    this._videoRecorder = await _videoRecorder.VideoRecorder.launch(this._crPage._page, ffmpegPath, options);\n    this._screencastId = screencastId;\n  }\n  async _startVideoRecording(options) {\n    const screencastId = this._screencastId;\n    (0, _utils.assert)(screencastId);\n    this._page.once(_page.Page.Events.Close, () => this._stopVideoRecording().catch(() => {}));\n    const gotFirstFrame = new Promise(f => this._client.once('Page.screencastFrame', f));\n    await this._startScreencast(this._videoRecorder, {\n      format: 'jpeg',\n      quality: 90,\n      maxWidth: options.width,\n      maxHeight: options.height\n    });\n    // Wait for the first frame before reporting video to the client.\n    gotFirstFrame.then(() => {\n      this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options.outputFile, this._crPage.pageOrError());\n    });\n  }\n  async _stopVideoRecording() {\n    if (!this._screencastId) return;\n    const screencastId = this._screencastId;\n    this._screencastId = null;\n    const recorder = this._videoRecorder;\n    this._videoRecorder = null;\n    await this._stopScreencast(recorder);\n    await recorder.stop().catch(() => {});\n    // Keep the video artifact in the map utntil encoding is fully finished, if the context\n    // starts closing before the video is fully written to disk it will wait for it.\n    const video = this._crPage._browserContext._browser._takeVideo(screencastId);\n    video === null || video === void 0 ? void 0 : video.reportFinished();\n  }\n  async _startScreencast(client, options = {}) {\n    this._screencastClients.add(client);\n    if (this._screencastClients.size === 1) await this._client.send('Page.startScreencast', options);\n  }\n  async _stopScreencast(client) {\n    this._screencastClients.delete(client);\n    if (!this._screencastClients.size) await this._client._sendMayFail('Page.stopScreencast');\n  }\n  async _updateExtraHTTPHeaders(initial) {\n    const headers = network.mergeHeaders([this._crPage._browserContext._options.extraHTTPHeaders, this._page.extraHTTPHeaders()]);\n    if (!initial || headers.length) await this._client.send('Network.setExtraHTTPHeaders', {\n      headers: (0, _utils.headersArrayToObject)(headers, false /* lowerCase */)\n    });\n  }\n\n  async _updateGeolocation(initial) {\n    const geolocation = this._crPage._browserContext._options.geolocation;\n    if (!initial || geolocation) await this._client.send('Emulation.setGeolocationOverride', geolocation || {});\n  }\n  async _updateOffline(initial) {\n    const offline = !!this._crPage._browserContext._options.offline;\n    if (!initial || offline) await this._networkManager.setOffline(offline);\n  }\n  async _updateHttpCredentials(initial) {\n    const credentials = this._crPage._browserContext._options.httpCredentials || null;\n    if (!initial || credentials) await this._networkManager.authenticate(credentials);\n  }\n  async _updateViewport(preserveWindowBoundaries) {\n    if (this._crPage._browserContext._browser.isClank()) return;\n    (0, _utils.assert)(this._isMainFrame());\n    const options = this._crPage._browserContext._options;\n    const emulatedSize = this._page.emulatedSize();\n    if (emulatedSize === null) return;\n    const viewportSize = emulatedSize.viewport;\n    const screenSize = emulatedSize.screen;\n    const isLandscape = viewportSize.width > viewportSize.height;\n    const metricsOverride = {\n      mobile: !!options.isMobile,\n      width: viewportSize.width,\n      height: viewportSize.height,\n      screenWidth: screenSize.width,\n      screenHeight: screenSize.height,\n      deviceScaleFactor: options.deviceScaleFactor || 1,\n      screenOrientation: isLandscape ? {\n        angle: 90,\n        type: 'landscapePrimary'\n      } : {\n        angle: 0,\n        type: 'portraitPrimary'\n      },\n      dontSetVisibleSize: preserveWindowBoundaries\n    };\n    if (JSON.stringify(this._metricsOverride) === JSON.stringify(metricsOverride)) return;\n    const promises = [this._client.send('Emulation.setDeviceMetricsOverride', metricsOverride)];\n    if (!preserveWindowBoundaries && this._windowId) {\n      let insets = {\n        width: 0,\n        height: 0\n      };\n      if (this._crPage._browserContext._browser.options.headful) {\n        // TODO: popup windows have their own insets.\n        insets = {\n          width: 24,\n          height: 88\n        };\n        if (process.platform === 'win32') insets = {\n          width: 16,\n          height: 88\n        };else if (process.platform === 'linux') insets = {\n          width: 8,\n          height: 85\n        };else if (process.platform === 'darwin') insets = {\n          width: 2,\n          height: 80\n        };\n        if (this._crPage._browserContext.isPersistentContext()) {\n          // FIXME: Chrome bug: OOPIF router is confused when hit target is\n          // outside browser window.\n          // Account for the infobar here to work around the bug.\n          insets.height += 46;\n        }\n      }\n      promises.push(this.setWindowBounds({\n        width: viewportSize.width + insets.width,\n        height: viewportSize.height + insets.height\n      }));\n    }\n    await Promise.all(promises);\n    this._metricsOverride = metricsOverride;\n  }\n  async windowBounds() {\n    const {\n      bounds\n    } = await this._client.send('Browser.getWindowBounds', {\n      windowId: this._windowId\n    });\n    return bounds;\n  }\n  async setWindowBounds(bounds) {\n    return await this._client.send('Browser.setWindowBounds', {\n      windowId: this._windowId,\n      bounds\n    });\n  }\n  async _updateEmulateMedia() {\n    const emulatedMedia = this._page.emulatedMedia();\n    // Empty string disables the override.\n    const media = emulatedMedia.media === 'no-override' ? '' : emulatedMedia.media;\n    const colorScheme = emulatedMedia.colorScheme === 'no-override' ? '' : emulatedMedia.colorScheme;\n    const reducedMotion = emulatedMedia.reducedMotion === 'no-override' ? '' : emulatedMedia.reducedMotion;\n    const forcedColors = emulatedMedia.forcedColors === 'no-override' ? '' : emulatedMedia.forcedColors;\n    const features = [{\n      name: 'prefers-color-scheme',\n      value: colorScheme\n    }, {\n      name: 'prefers-reduced-motion',\n      value: reducedMotion\n    }, {\n      name: 'forced-colors',\n      value: forcedColors\n    }];\n    await this._client.send('Emulation.setEmulatedMedia', {\n      media,\n      features\n    });\n  }\n  async _updateUserAgent() {\n    const options = this._crPage._browserContext._options;\n    await this._client.send('Emulation.setUserAgentOverride', {\n      userAgent: options.userAgent || '',\n      acceptLanguage: options.locale\n    });\n  }\n  async _setDefaultFontFamilies(session) {\n    const fontFamilies = _defaultFontFamilies.platformToFontFamilies[this._crPage._browserContext._browser._platform()];\n    await session.send('Page.setFontFamilies', fontFamilies);\n  }\n  async _updateRequestInterception() {\n    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());\n  }\n  async _updateFileChooserInterception(initial) {\n    const enabled = this._page.fileChooserIntercepted();\n    if (initial && !enabled) return;\n    await this._client.send('Page.setInterceptFileChooserDialog', {\n      enabled\n    }).catch(() => {}); // target can be closed.\n  }\n\n  async _evaluateOnNewDocument(source, world) {\n    const worldName = world === 'utility' ? UTILITY_WORLD_NAME : undefined;\n    const {\n      identifier\n    } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n      source,\n      worldName\n    });\n    this._evaluateOnNewDocumentIdentifiers.push(identifier);\n  }\n  async _removeEvaluatesOnNewDocument() {\n    const identifiers = this._evaluateOnNewDocumentIdentifiers;\n    this._evaluateOnNewDocumentIdentifiers = [];\n    await Promise.all(identifiers.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', {\n      identifier\n    })));\n  }\n  async _getContentFrame(handle) {\n    const nodeInfo = await this._client.send('DOM.describeNode', {\n      objectId: handle._objectId\n    });\n    if (!nodeInfo || typeof nodeInfo.node.frameId !== 'string') return null;\n    return this._page._frameManager.frame(nodeInfo.node.frameId);\n  }\n  async _getOwnerFrame(handle) {\n    // document.documentElement has frameId of the owner frame.\n    const documentElement = await handle.evaluateHandle(node => {\n      const doc = node;\n      if (doc.documentElement && doc.documentElement.ownerDocument === doc) return doc.documentElement;\n      return node.ownerDocument ? node.ownerDocument.documentElement : null;\n    });\n    if (!documentElement) return null;\n    if (!documentElement._objectId) return null;\n    const nodeInfo = await this._client.send('DOM.describeNode', {\n      objectId: documentElement._objectId\n    });\n    const frameId = nodeInfo && typeof nodeInfo.node.frameId === 'string' ? nodeInfo.node.frameId : null;\n    documentElement.dispose();\n    return frameId;\n  }\n  async _getBoundingBox(handle) {\n    const result = await this._client._sendMayFail('DOM.getBoxModel', {\n      objectId: handle._objectId\n    });\n    if (!result) return null;\n    const quad = result.model.border;\n    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);\n    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);\n    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;\n    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;\n    const position = await this._framePosition();\n    if (!position) return null;\n    return {\n      x: x + position.x,\n      y: y + position.y,\n      width,\n      height\n    };\n  }\n  async _framePosition() {\n    const frame = this._page._frameManager.frame(this._targetId);\n    if (!frame) return null;\n    if (frame === this._page.mainFrame()) return {\n      x: 0,\n      y: 0\n    };\n    const element = await frame.frameElement();\n    const box = await element.boundingBox();\n    return box;\n  }\n  async _scrollRectIntoViewIfNeeded(handle, rect) {\n    return await this._client.send('DOM.scrollIntoViewIfNeeded', {\n      objectId: handle._objectId,\n      rect\n    }).then(() => 'done').catch(e => {\n      if (e instanceof Error && e.message.includes('Node does not have a layout object')) return 'error:notvisible';\n      if (e instanceof Error && e.message.includes('Node is detached from document')) return 'error:notconnected';\n      throw e;\n    });\n  }\n  async _getContentQuads(handle) {\n    const result = await this._client._sendMayFail('DOM.getContentQuads', {\n      objectId: handle._objectId\n    });\n    if (!result) return null;\n    const position = await this._framePosition();\n    if (!position) return null;\n    return result.quads.map(quad => [{\n      x: quad[0] + position.x,\n      y: quad[1] + position.y\n    }, {\n      x: quad[2] + position.x,\n      y: quad[3] + position.y\n    }, {\n      x: quad[4] + position.x,\n      y: quad[5] + position.y\n    }, {\n      x: quad[6] + position.x,\n      y: quad[7] + position.y\n    }]);\n  }\n  async _adoptElementHandle(handle, to) {\n    const nodeInfo = await this._client.send('DOM.describeNode', {\n      objectId: handle._objectId\n    });\n    return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);\n  }\n  async _adoptBackendNodeId(backendNodeId, to) {\n    const result = await this._client._sendMayFail('DOM.resolveNode', {\n      backendNodeId,\n      executionContextId: to[contextDelegateSymbol]._contextId\n    });\n    if (!result || result.object.subtype === 'null') throw new Error(dom.kUnableToAdoptErrorMessage);\n    return to.createHandle(result.object).asElement();\n  }\n}\nasync function emulateLocale(session, locale) {\n  try {\n    await session.send('Emulation.setLocaleOverride', {\n      locale\n    });\n  } catch (exception) {\n    // All pages in the same renderer share locale. All such pages belong to the same\n    // context and if locale is overridden for one of them its value is the same as\n    // we are trying to set so it's not a problem.\n    if (exception.message.includes('Another locale override is already in effect')) return;\n    throw exception;\n  }\n}\nasync function emulateTimezone(session, timezoneId) {\n  try {\n    await session.send('Emulation.setTimezoneOverride', {\n      timezoneId: timezoneId\n    });\n  } catch (exception) {\n    if (exception.message.includes('Timezone override is already in effect')) return;\n    if (exception.message.includes('Invalid timezone')) throw new Error(`Invalid timezone ID: ${timezoneId}`);\n    throw exception;\n  }\n}\nconst contextDelegateSymbol = Symbol('delegate');","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRPDF = void 0;\nvar _utils = require(\"../../utils\");\nvar _crProtocolHelper = require(\"./crProtocolHelper\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst PagePaperFormats = {\n  letter: {\n    width: 8.5,\n    height: 11\n  },\n  legal: {\n    width: 8.5,\n    height: 14\n  },\n  tabloid: {\n    width: 11,\n    height: 17\n  },\n  ledger: {\n    width: 17,\n    height: 11\n  },\n  a0: {\n    width: 33.1,\n    height: 46.8\n  },\n  a1: {\n    width: 23.4,\n    height: 33.1\n  },\n  a2: {\n    width: 16.54,\n    height: 23.4\n  },\n  a3: {\n    width: 11.7,\n    height: 16.54\n  },\n  a4: {\n    width: 8.27,\n    height: 11.7\n  },\n  a5: {\n    width: 5.83,\n    height: 8.27\n  },\n  a6: {\n    width: 4.13,\n    height: 5.83\n  }\n};\nconst unitToPixels = {\n  'px': 1,\n  'in': 96,\n  'cm': 37.8,\n  'mm': 3.78\n};\nfunction convertPrintParameterToInches(text) {\n  if (text === undefined) return undefined;\n  let unit = text.substring(text.length - 2).toLowerCase();\n  let valueText = '';\n  if (unitToPixels.hasOwnProperty(unit)) {\n    valueText = text.substring(0, text.length - 2);\n  } else {\n    // In case of unknown unit try to parse the whole parameter as number of pixels.\n    // This is consistent with phantom's paperSize behavior.\n    unit = 'px';\n    valueText = text;\n  }\n  const value = Number(valueText);\n  (0, _utils.assert)(!isNaN(value), 'Failed to parse parameter value: ' + text);\n  const pixels = value * unitToPixels[unit];\n  return pixels / 96;\n}\nclass CRPDF {\n  constructor(client) {\n    this._client = void 0;\n    this._client = client;\n  }\n  async generate(options) {\n    const {\n      scale = 1,\n      displayHeaderFooter = false,\n      headerTemplate = '',\n      footerTemplate = '',\n      printBackground = false,\n      landscape = false,\n      pageRanges = '',\n      preferCSSPageSize = false,\n      margin = {}\n    } = options;\n    let paperWidth = 8.5;\n    let paperHeight = 11;\n    if (options.format) {\n      const format = PagePaperFormats[options.format.toLowerCase()];\n      (0, _utils.assert)(format, 'Unknown paper format: ' + options.format);\n      paperWidth = format.width;\n      paperHeight = format.height;\n    } else {\n      paperWidth = convertPrintParameterToInches(options.width) || paperWidth;\n      paperHeight = convertPrintParameterToInches(options.height) || paperHeight;\n    }\n    const marginTop = convertPrintParameterToInches(margin.top) || 0;\n    const marginLeft = convertPrintParameterToInches(margin.left) || 0;\n    const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;\n    const marginRight = convertPrintParameterToInches(margin.right) || 0;\n    const result = await this._client.send('Page.printToPDF', {\n      transferMode: 'ReturnAsStream',\n      landscape,\n      displayHeaderFooter,\n      headerTemplate,\n      footerTemplate,\n      printBackground,\n      scale,\n      paperWidth,\n      paperHeight,\n      marginTop,\n      marginBottom,\n      marginLeft,\n      marginRight,\n      pageRanges,\n      preferCSSPageSize\n    });\n    return await (0, _crProtocolHelper.readProtocolStream)(this._client, result.stream, null);\n  }\n}\nexports.CRPDF = CRPDF;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exceptionToError = exceptionToError;\nexports.getExceptionMessage = getExceptionMessage;\nexports.readProtocolStream = readProtocolStream;\nexports.releaseObject = releaseObject;\nexports.toButtonsMask = toButtonsMask;\nexports.toConsoleMessageLocation = toConsoleMessageLocation;\nexports.toModifiersMask = toModifiersMask;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _fileUtils = require(\"../../utils/fileUtils\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction getExceptionMessage(exceptionDetails) {\n  if (exceptionDetails.exception) return exceptionDetails.exception.description || String(exceptionDetails.exception.value);\n  let message = exceptionDetails.text;\n  if (exceptionDetails.stackTrace) {\n    for (const callframe of exceptionDetails.stackTrace.callFrames) {\n      const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n      const functionName = callframe.functionName || '<anonymous>';\n      message += `\\n    at ${functionName} (${location})`;\n    }\n  }\n  return message;\n}\nasync function releaseObject(client, objectId) {\n  await client.send('Runtime.releaseObject', {\n    objectId\n  }).catch(error => {});\n}\nasync function readProtocolStream(client, handle, path) {\n  let eof = false;\n  let fd;\n  if (path) {\n    await (0, _fileUtils.mkdirIfNeeded)(path);\n    fd = await _fs.default.promises.open(path, 'w');\n  }\n  const bufs = [];\n  while (!eof) {\n    const response = await client.send('IO.read', {\n      handle\n    });\n    eof = response.eof;\n    const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);\n    bufs.push(buf);\n    if (fd) await fd.write(buf);\n  }\n  if (fd) await fd.close();\n  await client.send('IO.close', {\n    handle\n  });\n  return Buffer.concat(bufs);\n}\nfunction toConsoleMessageLocation(stackTrace) {\n  return stackTrace && stackTrace.callFrames.length ? {\n    url: stackTrace.callFrames[0].url,\n    lineNumber: stackTrace.callFrames[0].lineNumber,\n    columnNumber: stackTrace.callFrames[0].columnNumber\n  } : {\n    url: '',\n    lineNumber: 0,\n    columnNumber: 0\n  };\n}\nfunction exceptionToError(exceptionDetails) {\n  const messageWithStack = getExceptionMessage(exceptionDetails);\n  const lines = messageWithStack.split('\\n');\n  const firstStackTraceLine = lines.findIndex(line => line.startsWith('    at'));\n  let messageWithName = '';\n  let stack = '';\n  if (firstStackTraceLine === -1) {\n    messageWithName = messageWithStack;\n  } else {\n    messageWithName = lines.slice(0, firstStackTraceLine).join('\\n');\n    stack = messageWithStack;\n  }\n  const {\n    name,\n    message\n  } = (0, _stackTrace.splitErrorMessage)(messageWithName);\n  const err = new Error(message);\n  err.stack = stack;\n  err.name = name;\n  return err;\n}\nfunction toModifiersMask(modifiers) {\n  let mask = 0;\n  if (modifiers.has('Alt')) mask |= 1;\n  if (modifiers.has('Control')) mask |= 2;\n  if (modifiers.has('Meta')) mask |= 4;\n  if (modifiers.has('Shift')) mask |= 8;\n  return mask;\n}\nfunction toButtonsMask(buttons) {\n  let mask = 0;\n  if (buttons.has('left')) mask |= 1;\n  if (buttons.has('right')) mask |= 2;\n  if (buttons.has('middle')) mask |= 4;\n  return mask;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CRServiceWorker = void 0;\nvar _page = require(\"../page\");\nvar _crExecutionContext = require(\"./crExecutionContext\");\nvar _crNetworkManager = require(\"./crNetworkManager\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _browserContext = require(\"../browserContext\");\nvar _utils = require(\"../../utils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CRServiceWorker extends _page.Worker {\n  constructor(browserContext, session, url) {\n    super(browserContext, url);\n    this._browserContext = void 0;\n    this._networkManager = void 0;\n    this._session = void 0;\n    this._extraHTTPHeaders = null;\n    this._session = session;\n    this._browserContext = browserContext;\n    if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS) this._networkManager = new _crNetworkManager.CRNetworkManager(session, null, this, null);\n    session.once('Runtime.executionContextCreated', event => {\n      this._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));\n    });\n    if (this._networkManager && this._isNetworkInspectionEnabled()) {\n      this._networkManager.initialize().catch(() => {});\n      this.updateRequestInterception();\n      this.updateExtraHTTPHeaders(true);\n      this.updateHttpCredentials(true);\n      this.updateOffline(true);\n    }\n    session.send('Runtime.enable', {}).catch(e => {});\n    session.send('Runtime.runIfWaitingForDebugger').catch(e => {});\n    session.on('Inspector.targetReloadedAfterCrash', () => {\n      // Resume service worker after restart.\n      session._sendMayFail('Runtime.runIfWaitingForDebugger', {});\n    });\n  }\n  async updateOffline(initial) {\n    var _this$_networkManager;\n    if (!this._isNetworkInspectionEnabled()) return;\n    const offline = !!this._browserContext._options.offline;\n    if (!initial || offline) await ((_this$_networkManager = this._networkManager) === null || _this$_networkManager === void 0 ? void 0 : _this$_networkManager.setOffline(offline));\n  }\n  async updateHttpCredentials(initial) {\n    var _this$_networkManager2;\n    if (!this._isNetworkInspectionEnabled()) return;\n    const credentials = this._browserContext._options.httpCredentials || null;\n    if (!initial || credentials) await ((_this$_networkManager2 = this._networkManager) === null || _this$_networkManager2 === void 0 ? void 0 : _this$_networkManager2.authenticate(credentials));\n  }\n  async updateExtraHTTPHeaders(initial) {\n    if (!this._isNetworkInspectionEnabled()) return;\n    const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._extraHTTPHeaders]);\n    if (!initial || headers.length) await this._session.send('Network.setExtraHTTPHeaders', {\n      headers: (0, _utils.headersArrayToObject)(headers, false /* lowerCase */)\n    });\n  }\n\n  updateRequestInterception() {\n    if (!this._networkManager || !this._isNetworkInspectionEnabled()) return Promise.resolve();\n    return this._networkManager.setRequestInterception(this.needsRequestInterception()).catch(e => {});\n  }\n  needsRequestInterception() {\n    return this._isNetworkInspectionEnabled() && !!this._browserContext._requestInterceptor;\n  }\n  reportRequestFinished(request, response) {\n    this._browserContext.emit(_browserContext.BrowserContext.Events.RequestFinished, {\n      request,\n      response\n    });\n  }\n  requestFailed(request, _canceled) {\n    this._browserContext.emit(_browserContext.BrowserContext.Events.RequestFailed, request);\n  }\n  requestReceivedResponse(response) {\n    this._browserContext.emit(_browserContext.BrowserContext.Events.Response, response);\n  }\n  requestStarted(request, route) {\n    this._browserContext.emit(_browserContext.BrowserContext.Events.Request, request);\n    if (route) {\n      var _this$_browserContext, _this$_browserContext2;\n      const r = new network.Route(request, route);\n      if ((_this$_browserContext = (_this$_browserContext2 = this._browserContext)._requestInterceptor) !== null && _this$_browserContext !== void 0 && _this$_browserContext.call(_this$_browserContext2, r, request)) return;\n      r.continue();\n    }\n  }\n  _isNetworkInspectionEnabled() {\n    return this._browserContext._options.serviceWorkers !== 'block';\n  }\n}\nexports.CRServiceWorker = CRServiceWorker;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.platformToFontFamilies = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// DO NOT EDIT: this map is generated from Chromium source code by utils/generate_chromium_default_font_families.js\nconst platformToFontFamilies = {\n  'linux': {\n    'fontFamilies': {\n      'standard': 'Times New Roman',\n      'fixed': 'Monospace',\n      'serif': 'Times New Roman',\n      'sansSerif': 'Arial',\n      'cursive': 'Comic Sans MS',\n      'fantasy': 'Impact'\n    }\n  },\n  'mac': {\n    'fontFamilies': {\n      'standard': 'Times',\n      'fixed': 'Courier',\n      'serif': 'Times',\n      'sansSerif': 'Helvetica',\n      'cursive': 'Apple Chancery',\n      'fantasy': 'Papyrus'\n    },\n    'forScripts': [{\n      'script': 'jpan',\n      'fontFamilies': {\n        'standard': 'Hiragino Kaku Gothic ProN',\n        'fixed': 'Osaka-Mono',\n        'serif': 'Hiragino Mincho ProN',\n        'sansSerif': 'Hiragino Kaku Gothic ProN'\n      }\n    }, {\n      'script': 'hang',\n      'fontFamilies': {\n        'standard': 'Apple SD Gothic Neo',\n        'serif': 'AppleMyungjo',\n        'sansSerif': 'Apple SD Gothic Neo'\n      }\n    }, {\n      'script': 'hans',\n      'fontFamilies': {\n        'standard': ',PingFang SC,STHeiti',\n        'serif': 'Songti SC',\n        'sansSerif': ',PingFang SC,STHeiti',\n        'cursive': 'Kaiti SC'\n      }\n    }, {\n      'script': 'hant',\n      'fontFamilies': {\n        'standard': ',PingFang TC,Heiti TC',\n        'serif': 'Songti TC',\n        'sansSerif': ',PingFang TC,Heiti TC',\n        'cursive': 'Kaiti TC'\n      }\n    }]\n  },\n  'win': {\n    'fontFamilies': {\n      'standard': 'Times New Roman',\n      'fixed': 'Consolas',\n      'serif': 'Times New Roman',\n      'sansSerif': 'Arial',\n      'cursive': 'Comic Sans MS',\n      'fantasy': 'Impact'\n    },\n    'forScripts': [{\n      'script': 'cyrl',\n      'fontFamilies': {\n        'standard': 'Times New Roman',\n        'fixed': 'Courier New',\n        'serif': 'Times New Roman',\n        'sansSerif': 'Arial'\n      }\n    }, {\n      'script': 'arab',\n      'fontFamilies': {\n        'fixed': 'Courier New',\n        'sansSerif': 'Segoe UI'\n      }\n    }, {\n      'script': 'grek',\n      'fontFamilies': {\n        'standard': 'Times New Roman',\n        'fixed': 'Courier New',\n        'serif': 'Times New Roman',\n        'sansSerif': 'Arial'\n      }\n    }, {\n      'script': 'jpan',\n      'fontFamilies': {\n        'standard': ',Meiryo,Yu Gothic',\n        'fixed': 'MS Gothic',\n        'serif': ',Yu Mincho,MS PMincho',\n        'sansSerif': ',Meiryo,Yu Gothic'\n      }\n    }, {\n      'script': 'hang',\n      'fontFamilies': {\n        'standard': 'Malgun Gothic',\n        'fixed': 'Gulimche',\n        'serif': 'Batang',\n        'sansSerif': 'Malgun Gothic',\n        'cursive': 'Gungsuh'\n      }\n    }, {\n      'script': 'hans',\n      'fontFamilies': {\n        'standard': 'Microsoft YaHei',\n        'fixed': 'NSimsun',\n        'serif': 'Simsun',\n        'sansSerif': 'Microsoft YaHei',\n        'cursive': 'KaiTi'\n      }\n    }, {\n      'script': 'hant',\n      'fontFamilies': {\n        'standard': 'Microsoft JhengHei',\n        'fixed': 'MingLiU',\n        'serif': 'PMingLiU',\n        'sansSerif': 'Microsoft JhengHei',\n        'cursive': 'DFKai-SB'\n      }\n    }]\n  }\n};\nexports.platformToFontFamilies = platformToFontFamilies;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VideoRecorder = void 0;\nvar _utils = require(\"../../utils\");\nvar _page = require(\"../page\");\nvar _processLauncher = require(\"../../utils/processLauncher\");\nvar _progress = require(\"../progress\");\nvar _instrumentation = require(\"../instrumentation\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst fps = 25;\nclass VideoRecorder {\n  static async launch(page, ffmpegPath, options) {\n    if (!options.outputFile.endsWith('.webm')) throw new Error('File must have .webm extension');\n    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), page);\n    controller.setLogName('browser');\n    return await controller.run(async progress => {\n      const recorder = new VideoRecorder(page, ffmpegPath, progress);\n      await recorder._launch(options);\n      return recorder;\n    });\n  }\n  constructor(page, ffmpegPath, progress) {\n    this._process = null;\n    this._gracefullyClose = null;\n    this._lastWritePromise = Promise.resolve();\n    this._lastFrameTimestamp = 0;\n    this._lastFrameBuffer = null;\n    this._lastWriteTimestamp = 0;\n    this._progress = void 0;\n    this._frameQueue = [];\n    this._isStopped = false;\n    this._ffmpegPath = void 0;\n    this._progress = progress;\n    this._ffmpegPath = ffmpegPath;\n    page.on(_page.Page.Events.ScreencastFrame, frame => this.writeFrame(frame.buffer, frame.timestamp));\n  }\n  async _launch(options) {\n    // How to tune the codec:\n    // 1. Read vp8 documentation to figure out the options.\n    //   https://www.webmproject.org/docs/encoder-parameters/\n    // 2. Use the following command to map the options to ffmpeg arguments.\n    //   $ ./third_party/ffmpeg/ffmpeg-mac -h encoder=vp8\n    // 3. A bit more about passing vp8 options to ffmpeg.\n    //   https://trac.ffmpeg.org/wiki/Encode/VP8\n    // 4. Tuning for VP9:\n    //   https://developers.google.com/media/vp9/live-encoding\n    //\n    // How to stress-test video recording (runs 10 recorders in parallel to book all cpus available):\n    //   $ node ./utils/video_stress.js\n    //\n    // We use the following vp8 options:\n    //   \"-qmin 0 -qmax 50\" - quality variation from 0 to 50.\n    //     Suggested here: https://trac.ffmpeg.org/wiki/Encode/VP8\n    //   \"-crf 8\" - constant quality mode, 4-63, lower means better quality.\n    //   \"-deadline realtime -speed 8\" - do not use too much cpu to keep up with incoming frames.\n    //   \"-b:v 1M\" - video bitrate. Default value is too low for vp8\n    //     Suggested here: https://trac.ffmpeg.org/wiki/Encode/VP8\n    //   Note that we can switch to \"-qmin 20 -qmax 50 -crf 30\" for smaller video size but worse quality.\n    //\n    // We use \"pad\" and \"crop\" video filters (-vf option) to resize incoming frames\n    // that might be of the different size to the desired video size.\n    //   https://ffmpeg.org/ffmpeg-filters.html#pad-1\n    //   https://ffmpeg.org/ffmpeg-filters.html#crop\n    //\n    // We use \"image2pipe\" mode to pipe frames and get a single video - https://trac.ffmpeg.org/wiki/Slideshow\n    //   \"-f image2pipe -c:v mjpeg -i -\" forces input to be read from standard input, and forces\n    //     mjpeg input image format.\n    //   \"-avioflags direct\" reduces general buffering.\n    //   \"-fpsprobesize 0 -probesize 32 -analyzeduration 0\" reduces initial buffering\n    //     while analyzing input fps and other stats.\n    //\n    // \"-y\" means overwrite output.\n    // \"-an\" means no audio.\n    // \"-threads 1\" means using one thread. This drastically reduces stalling when\n    //   cpu is overbooked. By default vp8 tries to use all available threads?\n\n    const w = options.width;\n    const h = options.height;\n    const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(' ');\n    args.push(options.outputFile);\n    const progress = this._progress;\n    const {\n      launchedProcess,\n      gracefullyClose\n    } = await (0, _processLauncher.launchProcess)({\n      command: this._ffmpegPath,\n      args,\n      stdio: 'stdin',\n      log: message => progress.log(message),\n      tempDirectories: [],\n      attemptToGracefullyClose: async () => {\n        progress.log('Closing stdin...');\n        launchedProcess.stdin.end();\n      },\n      onExit: (exitCode, signal) => {\n        progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);\n      }\n    });\n    launchedProcess.stdin.on('finish', () => {\n      progress.log('ffmpeg finished input.');\n    });\n    launchedProcess.stdin.on('error', () => {\n      progress.log('ffmpeg error.');\n    });\n    this._process = launchedProcess;\n    this._gracefullyClose = gracefullyClose;\n  }\n  writeFrame(frame, timestamp) {\n    (0, _utils.assert)(this._process);\n    if (this._isStopped) return;\n    if (this._lastFrameBuffer) {\n      const durationSec = timestamp - this._lastFrameTimestamp;\n      const repeatCount = Math.max(1, Math.round(fps * durationSec));\n      for (let i = 0; i < repeatCount; ++i) this._frameQueue.push(this._lastFrameBuffer);\n      this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());\n    }\n    this._lastFrameBuffer = frame;\n    this._lastFrameTimestamp = timestamp;\n    this._lastWriteTimestamp = (0, _utils.monotonicTime)();\n  }\n  async _sendFrames() {\n    while (this._frameQueue.length) await this._sendFrame(this._frameQueue.shift());\n  }\n  async _sendFrame(frame) {\n    return new Promise(f => this._process.stdin.write(frame, f)).then(error => {\n      if (error) this._progress.log(`ffmpeg failed to write: ${error}`);\n    });\n  }\n  async stop() {\n    if (this._isStopped) return;\n    this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + ((0, _utils.monotonicTime)() - this._lastWriteTimestamp) / 1000);\n    this._isStopped = true;\n    await this._lastWritePromise;\n    await this._gracefullyClose();\n  }\n}\nexports.VideoRecorder = VideoRecorder;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConsoleMessage = void 0;\nvar _instrumentation = require(\"./instrumentation\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ConsoleMessage extends _instrumentation.SdkObject {\n  constructor(parent, type, text, args, location) {\n    super(parent, 'console-message');\n    this._type = void 0;\n    this._text = void 0;\n    this._args = void 0;\n    this._location = void 0;\n    this._type = type;\n    this._text = text;\n    this._args = args;\n    this._location = location || {\n      url: '',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  type() {\n    return this._type;\n  }\n  text() {\n    if (this._text === undefined) this._text = this._args.map(arg => arg.preview()).join(' ');\n    return this._text;\n  }\n  args() {\n    return this._args;\n  }\n  location() {\n    return this._location;\n  }\n}\nexports.ConsoleMessage = ConsoleMessage;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CookieStore = void 0;\nexports.domainMatches = domainMatches;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Cookie {\n  constructor(data) {\n    this._raw = void 0;\n    this._raw = data;\n  }\n  name() {\n    return this._raw.name;\n  }\n\n  // https://datatracker.ietf.org/doc/html/rfc6265#section-5.4\n  matches(url) {\n    if (this._raw.secure && url.protocol !== 'https:' && url.hostname !== 'localhost') return false;\n    if (!domainMatches(url.hostname, this._raw.domain)) return false;\n    if (!pathMatches(url.pathname, this._raw.path)) return false;\n    return true;\n  }\n  equals(other) {\n    return this._raw.name === other._raw.name && this._raw.domain === other._raw.domain && this._raw.path === other._raw.path;\n  }\n  networkCookie() {\n    return this._raw;\n  }\n  updateExpiresFrom(other) {\n    this._raw.expires = other._raw.expires;\n  }\n  expired() {\n    if (this._raw.expires === -1) return false;\n    return this._raw.expires * 1000 < Date.now();\n  }\n}\nclass CookieStore {\n  constructor() {\n    this._nameToCookies = new Map();\n  }\n  addCookies(cookies) {\n    for (const cookie of cookies) this._addCookie(new Cookie(cookie));\n  }\n  cookies(url) {\n    const result = [];\n    for (const cookie of this._cookiesIterator()) {\n      if (cookie.matches(url)) result.push(cookie.networkCookie());\n    }\n    return result;\n  }\n  allCookies() {\n    const result = [];\n    for (const cookie of this._cookiesIterator()) result.push(cookie.networkCookie());\n    return result;\n  }\n  _addCookie(cookie) {\n    let set = this._nameToCookies.get(cookie.name());\n    if (!set) {\n      set = new Set();\n      this._nameToCookies.set(cookie.name(), set);\n    }\n    // https://datatracker.ietf.org/doc/html/rfc6265#section-5.3\n    for (const other of set) {\n      if (other.equals(cookie)) set.delete(other);\n    }\n    set.add(cookie);\n    CookieStore.pruneExpired(set);\n  }\n  *_cookiesIterator() {\n    for (const [name, cookies] of this._nameToCookies) {\n      CookieStore.pruneExpired(cookies);\n      for (const cookie of cookies) yield cookie;\n      if (cookies.size === 0) this._nameToCookies.delete(name);\n    }\n  }\n  static pruneExpired(cookies) {\n    for (const cookie of cookies) {\n      if (cookie.expired()) cookies.delete(cookie);\n    }\n  }\n}\nexports.CookieStore = CookieStore;\nfunction domainMatches(value, domain) {\n  if (value === domain) return true;\n  // Only strict match is allowed if domain doesn't start with '.' (host-only-flag is true in the spec)\n  if (!domain.startsWith('.')) return false;\n  value = '.' + value;\n  return value.endsWith(domain);\n}\nfunction pathMatches(value, path) {\n  if (value === path) return true;\n  if (!value.endsWith('/')) value = value + '/';\n  if (!path.endsWith('/')) path = path + '/';\n  return value.startsWith(path);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DebugController = void 0;\nvar _processLauncher = require(\"../utils/processLauncher\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _recorder = require(\"./recorder\");\nvar _recorderApp = require(\"./recorder/recorderApp\");\nvar _locatorGenerators = require(\"./isomorphic/locatorGenerators\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst internalMetadata = (0, _instrumentation.serverSideCallMetadata)();\nclass DebugController extends _instrumentation.SdkObject {\n  // TODO: remove in 1.27\n\n  constructor(playwright) {\n    super({\n      attribution: {\n        isInternalPlaywright: true\n      },\n      instrumentation: (0, _instrumentation.createInstrumentation)()\n    }, undefined, 'DebugController');\n    this._autoCloseTimer = void 0;\n    this._autoCloseAllowed = false;\n    this._trackHierarchyListener = void 0;\n    this._playwright = void 0;\n    this._sdkLanguage = 'javascript';\n    this._codegenId = 'playwright-test';\n    this._playwright = playwright;\n  }\n  initialize(codegenId, sdkLanguage) {\n    this._codegenId = codegenId;\n    this._sdkLanguage = sdkLanguage;\n    _recorder.Recorder.setAppFactory(async () => new InspectingRecorderApp(this));\n  }\n  setAutoCloseAllowed(allowed) {\n    this._autoCloseAllowed = allowed;\n  }\n  dispose() {\n    this.setReportStateChanged(false);\n    this.setAutoCloseAllowed(false);\n    _recorder.Recorder.setAppFactory(undefined);\n  }\n  setReportStateChanged(enabled) {\n    if (enabled && !this._trackHierarchyListener) {\n      this._trackHierarchyListener = {\n        onPageOpen: () => this._emitSnapshot(),\n        onPageClose: () => this._emitSnapshot()\n      };\n      this._playwright.instrumentation.addListener(this._trackHierarchyListener, null);\n    } else if (!enabled && this._trackHierarchyListener) {\n      this._playwright.instrumentation.removeListener(this._trackHierarchyListener);\n      this._trackHierarchyListener = undefined;\n    }\n  }\n  async resetForReuse() {\n    const contexts = new Set();\n    for (const page of this._playwright.allPages()) contexts.add(page.context());\n    for (const context of contexts) await context.resetForReuse(internalMetadata, null);\n  }\n  async navigate(url) {\n    for (const p of this._playwright.allPages()) await p.mainFrame().goto(internalMetadata, url);\n  }\n  async setRecorderMode(params) {\n    // TODO: |file| is only used in the legacy mode.\n    await this._closeBrowsersWithoutPages();\n    if (params.mode === 'none') {\n      for (const recorder of await this._allRecorders()) {\n        recorder.hideHighlightedSelecor();\n        recorder.setMode('none');\n      }\n      this.setAutoCloseEnabled(true);\n      return;\n    }\n    if (!this._playwright.allBrowsers().length) await this._playwright.chromium.launch(internalMetadata, {\n      headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS\n    });\n    // Create page if none.\n    const pages = this._playwright.allPages();\n    if (!pages.length) {\n      const [browser] = this._playwright.allBrowsers();\n      const {\n        context\n      } = await browser.newContextForReuse({}, internalMetadata);\n      await context.newPage(internalMetadata);\n    }\n    // Update test id attribute.\n    if (params.testIdAttributeName) {\n      for (const page of this._playwright.allPages()) page.context().selectors().setTestIdAttributeName(params.testIdAttributeName);\n    }\n    // Toggle the mode.\n    for (const recorder of await this._allRecorders()) {\n      recorder.hideHighlightedSelecor();\n      if (params.mode === 'recording') recorder.setOutput(this._codegenId, params.file);\n      recorder.setMode(params.mode);\n    }\n    this.setAutoCloseEnabled(true);\n  }\n  async setAutoCloseEnabled(enabled) {\n    if (!this._autoCloseAllowed) return;\n    if (this._autoCloseTimer) clearTimeout(this._autoCloseTimer);\n    if (!enabled) return;\n    const heartBeat = () => {\n      if (!this._playwright.allPages().length) selfDestruct();else this._autoCloseTimer = setTimeout(heartBeat, 5000);\n    };\n    this._autoCloseTimer = setTimeout(heartBeat, 30000);\n  }\n  async highlight(selector) {\n    for (const recorder of await this._allRecorders()) recorder.setHighlightedSelector(this._sdkLanguage, selector);\n  }\n  async hideHighlight() {\n    // Hide all active recorder highlights.\n    for (const recorder of await this._allRecorders()) recorder.hideHighlightedSelecor();\n    // Hide all locator.highlight highlights.\n    await this._playwright.hideHighlight();\n  }\n  allBrowsers() {\n    return [...this._playwright.allBrowsers()];\n  }\n  async resume() {\n    for (const recorder of await this._allRecorders()) recorder.resume();\n  }\n  async kill() {\n    selfDestruct();\n  }\n  async closeAllBrowsers() {\n    await Promise.all(this.allBrowsers().map(browser => browser.close()));\n  }\n  _emitSnapshot() {\n    const browsers = [];\n    let pageCount = 0;\n    for (const browser of this._playwright.allBrowsers()) {\n      const b = {\n        contexts: []\n      };\n      browsers.push(b);\n      for (const context of browser.contexts()) {\n        const c = {\n          pages: []\n        };\n        b.contexts.push(c);\n        for (const page of context.pages()) c.pages.push(page.mainFrame().url());\n        pageCount += context.pages().length;\n      }\n    }\n    // TODO: browsers is deprecated, remove it.\n    this.emit(DebugController.Events.BrowsersChanged, browsers);\n    this.emit(DebugController.Events.StateChanged, {\n      pageCount\n    });\n  }\n  async _allRecorders() {\n    const contexts = new Set();\n    for (const page of this._playwright.allPages()) contexts.add(page.context());\n    const result = await Promise.all([...contexts].map(c => _recorder.Recorder.show(c, {\n      omitCallTracking: true\n    })));\n    return result.filter(Boolean);\n  }\n  async _closeBrowsersWithoutPages() {\n    for (const browser of this._playwright.allBrowsers()) {\n      for (const context of browser.contexts()) {\n        if (!context.pages().length) await context.close((0, _instrumentation.serverSideCallMetadata)());\n      }\n      if (!browser.contexts()) await browser.close();\n    }\n  }\n}\nexports.DebugController = DebugController;\nDebugController.Events = {\n  BrowsersChanged: 'browsersChanged',\n  StateChanged: 'stateChanged',\n  InspectRequested: 'inspectRequested',\n  SourceChanged: 'sourceChanged',\n  Paused: 'paused'\n};\nfunction selfDestruct() {\n  // Force exit after 30 seconds.\n  setTimeout(() => process.exit(0), 30000);\n  // Meanwhile, try to gracefully close all browsers.\n  (0, _processLauncher.gracefullyCloseAll)().then(() => {\n    process.exit(0);\n  });\n}\nclass InspectingRecorderApp extends _recorderApp.EmptyRecorderApp {\n  constructor(debugController) {\n    super();\n    this._debugController = void 0;\n    this._debugController = debugController;\n  }\n  async setSelector(selector) {\n    const locator = (0, _locatorGenerators.asLocator)(this._debugController._sdkLanguage, selector);\n    this._debugController.emit(DebugController.Events.InspectRequested, {\n      selector,\n      locator\n    });\n  }\n  async setSources(sources) {\n    const source = sources.find(s => s.id === this._debugController._codegenId);\n    const {\n      text,\n      header,\n      footer,\n      actions\n    } = source || {\n      text: ''\n    };\n    this._debugController.emit(DebugController.Events.SourceChanged, {\n      text,\n      header,\n      footer,\n      actions\n    });\n  }\n  async setPaused(paused) {\n    this._debugController.emit(DebugController.Events.Paused, {\n      paused\n    });\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Debugger = void 0;\nexports.shouldSlowMo = shouldSlowMo;\nvar _events = require(\"events\");\nvar _utils = require(\"../utils\");\nvar _browserContext = require(\"./browserContext\");\nvar _debug = require(\"../protocol/debug\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst symbol = Symbol('Debugger');\nclass Debugger extends _events.EventEmitter {\n  constructor(context) {\n    super();\n    this._pauseOnNextStatement = false;\n    this._pausedCallsMetadata = new Map();\n    this._enabled = void 0;\n    this._context = void 0;\n    this._muted = false;\n    this._slowMo = void 0;\n    this._context = context;\n    this._context[symbol] = this;\n    this._enabled = (0, _utils.debugMode)() === 'inspector';\n    if (this._enabled) this.pauseOnNextStatement();\n    context.instrumentation.addListener(this, context);\n    this._context.once(_browserContext.BrowserContext.Events.Close, () => {\n      this._context.instrumentation.removeListener(this);\n    });\n    this._slowMo = this._context._browser.options.slowMo;\n  }\n  async setMuted(muted) {\n    this._muted = muted;\n  }\n  async onBeforeCall(sdkObject, metadata) {\n    if (this._muted) return;\n    if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata)) await this.pause(sdkObject, metadata);\n  }\n  async _doSlowMo() {\n    await new Promise(f => setTimeout(f, this._slowMo));\n  }\n  async onAfterCall(sdkObject, metadata) {\n    if (this._slowMo && shouldSlowMo(metadata)) await this._doSlowMo();\n  }\n  async onBeforeInputAction(sdkObject, metadata) {\n    if (this._muted) return;\n    if (this._enabled && this._pauseOnNextStatement) await this.pause(sdkObject, metadata);\n  }\n  async pause(sdkObject, metadata) {\n    if (this._muted) return;\n    this._enabled = true;\n    metadata.pauseStartTime = (0, _utils.monotonicTime)();\n    const result = new Promise(resolve => {\n      this._pausedCallsMetadata.set(metadata, {\n        resolve,\n        sdkObject\n      });\n    });\n    this.emit(Debugger.Events.PausedStateChanged);\n    return result;\n  }\n  resume(step) {\n    if (!this.isPaused()) return;\n    this._pauseOnNextStatement = step;\n    const endTime = (0, _utils.monotonicTime)();\n    for (const [metadata, {\n      resolve\n    }] of this._pausedCallsMetadata) {\n      metadata.pauseEndTime = endTime;\n      resolve();\n    }\n    this._pausedCallsMetadata.clear();\n    this.emit(Debugger.Events.PausedStateChanged);\n  }\n  pauseOnNextStatement() {\n    this._pauseOnNextStatement = true;\n  }\n  isPaused(metadata) {\n    if (metadata) return this._pausedCallsMetadata.has(metadata);\n    return !!this._pausedCallsMetadata.size;\n  }\n  pausedDetails() {\n    const result = [];\n    for (const [metadata, {\n      sdkObject\n    }] of this._pausedCallsMetadata) result.push({\n      metadata,\n      sdkObject\n    });\n    return result;\n  }\n}\nexports.Debugger = Debugger;\nDebugger.Events = {\n  PausedStateChanged: 'pausedstatechanged'\n};\nfunction shouldPauseOnCall(sdkObject, metadata) {\n  var _sdkObject$attributio;\n  if (!((_sdkObject$attributio = sdkObject.attribution.browser) !== null && _sdkObject$attributio !== void 0 && _sdkObject$attributio.options.headful) && !(0, _utils.isUnderTest)()) return false;\n  return metadata.method === 'pause';\n}\nfunction shouldPauseBeforeStep(metadata) {\n  // Don't stop on internal.\n  if (!metadata.apiName) return false;\n  // Always stop on 'close'\n  if (metadata.method === 'close') return true;\n  if (metadata.method === 'waitForSelector' || metadata.method === 'waitForEventInfo') return false; // Never stop on those, primarily for the test harness.\n  const step = metadata.type + '.' + metadata.method;\n  // Stop before everything that generates snapshot. But don't stop before those marked as pausesBeforeInputActions\n  // since we stop in them on a separate instrumentation signal.\n  return _debug.commandsWithTracingSnapshots.has(step) && !_debug.pausesBeforeInputActions.has(metadata.type + '.' + metadata.method);\n}\nfunction shouldSlowMo(metadata) {\n  return _debug.commandsWithTracingSnapshots.has(metadata.type + '.' + metadata.method);\n}","/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @type {import('./types').Devices}\n */\nmodule.exports = require(\"./deviceDescriptorsSource.json\")\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dialog = void 0;\nvar _utils = require(\"../utils\");\nvar _instrumentation = require(\"./instrumentation\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Dialog extends _instrumentation.SdkObject {\n  constructor(page, type, message, onHandle, defaultValue) {\n    super(page, 'dialog');\n    this._page = void 0;\n    this._type = void 0;\n    this._message = void 0;\n    this._onHandle = void 0;\n    this._handled = false;\n    this._defaultValue = void 0;\n    this._page = page;\n    this._type = type;\n    this._message = message;\n    this._onHandle = onHandle;\n    this._defaultValue = defaultValue || '';\n    this._page._frameManager.dialogDidOpen(this);\n  }\n  type() {\n    return this._type;\n  }\n  message() {\n    return this._message;\n  }\n  defaultValue() {\n    return this._defaultValue;\n  }\n  async accept(promptText) {\n    (0, _utils.assert)(!this._handled, 'Cannot accept dialog which is already handled!');\n    this._handled = true;\n    this._page._frameManager.dialogWillClose(this);\n    await this._onHandle(true, promptText);\n  }\n  async dismiss() {\n    (0, _utils.assert)(!this._handled, 'Cannot dismiss dialog which is already handled!');\n    this._handled = true;\n    this._page._frameManager.dialogWillClose(this);\n    await this._onHandle(false);\n  }\n  async close() {\n    if (this._type === 'beforeunload') await this.accept();else await this.dismiss();\n  }\n}\nexports.Dialog = Dialog;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AndroidSocketDispatcher = exports.AndroidDispatcher = exports.AndroidDeviceDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _android = require(\"../android/android\");\nvar _browserContextDispatcher = require(\"./browserContextDispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass AndroidDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, android) {\n    super(scope, android, 'Android', {});\n    this._type_Android = true;\n  }\n  async devices(params) {\n    const devices = await this._object.devices(params);\n    return {\n      devices: devices.map(d => AndroidDeviceDispatcher.from(this, d))\n    };\n  }\n  async setDefaultTimeoutNoReply(params) {\n    this._object.setDefaultTimeout(params.timeout);\n  }\n}\nexports.AndroidDispatcher = AndroidDispatcher;\nclass AndroidDeviceDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, device) {\n    const result = (0, _dispatcher.existingDispatcher)(device);\n    return result || new AndroidDeviceDispatcher(scope, device);\n  }\n  constructor(scope, device) {\n    super(scope, device, 'AndroidDevice', {\n      model: device.model,\n      serial: device.serial\n    });\n    this._type_EventTarget = true;\n    this._type_AndroidDevice = true;\n    for (const webView of device.webViews()) this._dispatchEvent('webViewAdded', {\n      webView\n    });\n    this.addObjectListener(_android.AndroidDevice.Events.WebViewAdded, webView => this._dispatchEvent('webViewAdded', {\n      webView\n    }));\n    this.addObjectListener(_android.AndroidDevice.Events.WebViewRemoved, socketName => this._dispatchEvent('webViewRemoved', {\n      socketName\n    }));\n    this.addObjectListener(_android.AndroidDevice.Events.Close, socketName => this._dispatchEvent('close'));\n  }\n  async wait(params) {\n    await this._object.send('wait', params);\n  }\n  async fill(params) {\n    await this._object.send('click', {\n      selector: params.selector\n    });\n    await this._object.send('fill', params);\n  }\n  async tap(params) {\n    await this._object.send('click', params);\n  }\n  async drag(params) {\n    await this._object.send('drag', params);\n  }\n  async fling(params) {\n    await this._object.send('fling', params);\n  }\n  async longTap(params) {\n    await this._object.send('longClick', params);\n  }\n  async pinchClose(params) {\n    await this._object.send('pinchClose', params);\n  }\n  async pinchOpen(params) {\n    await this._object.send('pinchOpen', params);\n  }\n  async scroll(params) {\n    await this._object.send('scroll', params);\n  }\n  async swipe(params) {\n    await this._object.send('swipe', params);\n  }\n  async info(params) {\n    return {\n      info: await this._object.send('info', params)\n    };\n  }\n  async inputType(params) {\n    const text = params.text;\n    const keyCodes = [];\n    for (let i = 0; i < text.length; ++i) {\n      const code = keyMap.get(text[i].toUpperCase());\n      if (code === undefined) throw new Error('No mapping for ' + text[i] + ' found');\n      keyCodes.push(code);\n    }\n    await Promise.all(keyCodes.map(keyCode => this._object.send('inputPress', {\n      keyCode\n    })));\n  }\n  async inputPress(params) {\n    if (!keyMap.has(params.key)) throw new Error('Unknown key: ' + params.key);\n    await this._object.send('inputPress', {\n      keyCode: keyMap.get(params.key)\n    });\n  }\n  async inputTap(params) {\n    await this._object.send('inputClick', params);\n  }\n  async inputSwipe(params) {\n    await this._object.send('inputSwipe', params);\n  }\n  async inputDrag(params) {\n    await this._object.send('inputDrag', params);\n  }\n  async screenshot(params) {\n    return {\n      binary: await this._object.screenshot()\n    };\n  }\n  async shell(params) {\n    return {\n      result: await this._object.shell(params.command)\n    };\n  }\n  async open(params, metadata) {\n    const socket = await this._object.open(params.command);\n    return {\n      socket: new AndroidSocketDispatcher(this, socket)\n    };\n  }\n  async installApk(params) {\n    await this._object.installApk(params.file, {\n      args: params.args\n    });\n  }\n  async push(params) {\n    await this._object.push(params.file, params.path, params.mode);\n  }\n  async launchBrowser(params) {\n    const context = await this._object.launchBrowser(params.pkg, params);\n    return {\n      context: new _browserContextDispatcher.BrowserContextDispatcher(this, context)\n    };\n  }\n  async close(params) {\n    await this._object.close();\n  }\n  async setDefaultTimeoutNoReply(params) {\n    this._object.setDefaultTimeout(params.timeout);\n  }\n  async connectToWebView(params) {\n    return {\n      context: new _browserContextDispatcher.BrowserContextDispatcher(this, await this._object.connectToWebView(params.socketName))\n    };\n  }\n}\nexports.AndroidDeviceDispatcher = AndroidDeviceDispatcher;\nclass AndroidSocketDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, socket) {\n    super(scope, socket, 'AndroidSocket', {});\n    this._type_AndroidSocket = true;\n    this.addObjectListener('data', data => this._dispatchEvent('data', {\n      data\n    }));\n    this.addObjectListener('close', () => {\n      this._dispatchEvent('close');\n      this._dispose();\n    });\n  }\n  async write(params, metadata) {\n    await this._object.write(params.data);\n  }\n  async close(params, metadata) {\n    this._object.close();\n  }\n}\nexports.AndroidSocketDispatcher = AndroidSocketDispatcher;\nconst keyMap = new Map([['Unknown', 0], ['SoftLeft', 1], ['SoftRight', 2], ['Home', 3], ['Back', 4], ['Call', 5], ['EndCall', 6], ['0', 7], ['1', 8], ['2', 9], ['3', 10], ['4', 11], ['5', 12], ['6', 13], ['7', 14], ['8', 15], ['9', 16], ['Star', 17], ['*', 17], ['Pound', 18], ['#', 18], ['DialUp', 19], ['DialDown', 20], ['DialLeft', 21], ['DialRight', 22], ['DialCenter', 23], ['VolumeUp', 24], ['VolumeDown', 25], ['Power', 26], ['Camera', 27], ['Clear', 28], ['A', 29], ['B', 30], ['C', 31], ['D', 32], ['E', 33], ['F', 34], ['G', 35], ['H', 36], ['I', 37], ['J', 38], ['K', 39], ['L', 40], ['M', 41], ['N', 42], ['O', 43], ['P', 44], ['Q', 45], ['R', 46], ['S', 47], ['T', 48], ['U', 49], ['V', 50], ['W', 51], ['X', 52], ['Y', 53], ['Z', 54], ['Comma', 55], [',', 55], ['Period', 56], ['.', 56], ['AltLeft', 57], ['AltRight', 58], ['ShiftLeft', 59], ['ShiftRight', 60], ['Tab', 61], ['\\t', 61], ['Space', 62], [' ', 62], ['Sym', 63], ['Explorer', 64], ['Envelop', 65], ['Enter', 66], ['Del', 67], ['Grave', 68], ['Minus', 69], ['-', 69], ['Equals', 70], ['=', 70], ['LeftBracket', 71], ['(', 71], ['RightBracket', 72], [')', 72], ['Backslash', 73], ['\\\\', 73], ['Semicolon', 74], [';', 74], ['Apostrophe', 75], ['`', 75], ['Slash', 76], ['/', 76], ['At', 77], ['@', 77], ['Num', 78], ['HeadsetHook', 79], ['Focus', 80], ['Plus', 81], ['Menu', 82], ['Notification', 83], ['Search', 84], ['AppSwitch', 187], ['Assist', 219], ['Cut', 277], ['Copy', 278], ['Paste', 279]]);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArtifactDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _streamDispatcher = require(\"./streamDispatcher\");\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _fileUtils = require(\"../../utils/fileUtils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ArtifactDispatcher extends _dispatcher.Dispatcher {\n  static from(parentScope, artifact) {\n    return ArtifactDispatcher.fromNullable(parentScope, artifact);\n  }\n  static fromNullable(parentScope, artifact) {\n    if (!artifact) return undefined;\n    const result = (0, _dispatcher.existingDispatcher)(artifact);\n    return result || new ArtifactDispatcher(parentScope, artifact);\n  }\n  constructor(scope, artifact) {\n    super(scope, artifact, 'Artifact', {\n      absolutePath: artifact.localPath()\n    });\n    this._type_Artifact = true;\n  }\n  async pathAfterFinished() {\n    const path = await this._object.localPathAfterFinished();\n    return {\n      value: path || undefined\n    };\n  }\n  async saveAs(params) {\n    return await new Promise((resolve, reject) => {\n      this._object.saveAs(async (localPath, error) => {\n        if (error !== undefined) {\n          reject(new Error(error));\n          return;\n        }\n        try {\n          await (0, _fileUtils.mkdirIfNeeded)(params.path);\n          await _fs.default.promises.copyFile(localPath, params.path);\n          resolve();\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  async saveAsStream() {\n    return await new Promise((resolve, reject) => {\n      this._object.saveAs(async (localPath, error) => {\n        if (error !== undefined) {\n          reject(new Error(error));\n          return;\n        }\n        try {\n          const readable = _fs.default.createReadStream(localPath);\n          const stream = new _streamDispatcher.StreamDispatcher(this, readable);\n          // Resolve with a stream, so that client starts saving the data.\n          resolve({\n            stream\n          });\n          // Block the Artifact until the stream is consumed.\n          await new Promise(resolve => {\n            readable.on('close', resolve);\n            readable.on('end', resolve);\n            readable.on('error', resolve);\n          });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  async stream() {\n    const fileName = await this._object.localPathAfterFinished();\n    if (!fileName) return {};\n    const readable = _fs.default.createReadStream(fileName);\n    return {\n      stream: new _streamDispatcher.StreamDispatcher(this, readable)\n    };\n  }\n  async failure() {\n    const error = await this._object.failureError();\n    return {\n      error: error || undefined\n    };\n  }\n  async cancel() {\n    await this._object.cancel();\n  }\n  async delete() {\n    await this._object.delete();\n    this._dispose();\n  }\n}\nexports.ArtifactDispatcher = ArtifactDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserContextDispatcher = void 0;\nvar _browserContext = require(\"../browserContext\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _pageDispatcher = require(\"./pageDispatcher\");\nvar _networkDispatchers = require(\"./networkDispatchers\");\nvar _crBrowser = require(\"../chromium/crBrowser\");\nvar _cdpSessionDispatcher = require(\"./cdpSessionDispatcher\");\nvar _recorder = require(\"../recorder\");\nvar _artifactDispatcher = require(\"./artifactDispatcher\");\nvar _tracingDispatcher = require(\"./tracingDispatcher\");\nvar fs = _interopRequireWildcard(require(\"fs\"));\nvar path = _interopRequireWildcard(require(\"path\"));\nvar _utils = require(\"../../utils\");\nvar _writableStreamDispatcher = require(\"./writableStreamDispatcher\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserContextDispatcher extends _dispatcher.Dispatcher {\n  constructor(parentScope, context) {\n    // We will reparent these to the context below.\n    const requestContext = _networkDispatchers.APIRequestContextDispatcher.from(parentScope, context.fetchRequest);\n    const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, context.tracing);\n    super(parentScope, context, 'BrowserContext', {\n      isChromium: context._browser.options.isChromium,\n      requestContext,\n      tracing\n    });\n    this._type_EventTarget = true;\n    this._type_BrowserContext = true;\n    this._context = void 0;\n    this._subscriptions = new Set();\n    this.adopt(requestContext);\n    this.adopt(tracing);\n    this._context = context;\n    // Note: when launching persistent context, dispatcher is created very late,\n    // so we can already have pages, videos and everything else.\n\n    const onVideo = artifact => {\n      // Note: Video must outlive Page and BrowserContext, so that client can saveAs it\n      // after closing the context. We use |scope| for it.\n      const artifactDispatcher = _artifactDispatcher.ArtifactDispatcher.from(parentScope, artifact);\n      this._dispatchEvent('video', {\n        artifact: artifactDispatcher\n      });\n    };\n    this.addObjectListener(_browserContext.BrowserContext.Events.VideoStarted, onVideo);\n    for (const video of context._browser._idToVideo.values()) {\n      if (video.context === context) onVideo(video.artifact);\n    }\n    for (const page of context.pages()) this._dispatchEvent('page', {\n      page: _pageDispatcher.PageDispatcher.from(this, page)\n    });\n    this.addObjectListener(_browserContext.BrowserContext.Events.Page, page => {\n      this._dispatchEvent('page', {\n        page: _pageDispatcher.PageDispatcher.from(this, page)\n      });\n    });\n    this.addObjectListener(_browserContext.BrowserContext.Events.Close, () => {\n      this._dispatchEvent('close');\n      this._dispose();\n    });\n    if (context._browser.options.name === 'chromium') {\n      for (const page of context.backgroundPages()) this._dispatchEvent('backgroundPage', {\n        page: _pageDispatcher.PageDispatcher.from(this, page)\n      });\n      this.addObjectListener(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, page => this._dispatchEvent('backgroundPage', {\n        page: _pageDispatcher.PageDispatcher.from(this, page)\n      }));\n      for (const serviceWorker of context.serviceWorkers()) this._dispatchEvent('serviceWorker', {\n        worker: new _pageDispatcher.WorkerDispatcher(this, serviceWorker)\n      });\n      this.addObjectListener(_crBrowser.CRBrowserContext.CREvents.ServiceWorker, serviceWorker => this._dispatchEvent('serviceWorker', {\n        worker: new _pageDispatcher.WorkerDispatcher(this, serviceWorker)\n      }));\n    }\n    this.addObjectListener(_browserContext.BrowserContext.Events.Request, request => {\n      var _request$frame;\n      // Create dispatcher, if:\n      // - There are listeners to the requests.\n      // - We are redirected from a reported request so that redirectedTo was updated on client.\n      // - We are a navigation request and dispatcher will be reported as a part of the goto return value and newDocument param anyways.\n      //   By the time requestFinished is triggered to update the request, we should have a request on the client already.\n      const redirectFromDispatcher = request.redirectedFrom() && (0, _dispatcher.existingDispatcher)(request.redirectedFrom());\n      if (!redirectFromDispatcher && !this._shouldDispatchNetworkEvent(request, 'request') && !request.isNavigationRequest()) return;\n      const requestDispatcher = _networkDispatchers.RequestDispatcher.from(this, request);\n      this._dispatchEvent('request', {\n        request: requestDispatcher,\n        page: _pageDispatcher.PageDispatcher.fromNullable(this, (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page.initializedOrUndefined())\n      });\n    });\n    this.addObjectListener(_browserContext.BrowserContext.Events.Response, response => {\n      var _response$frame;\n      const requestDispatcher = (0, _dispatcher.existingDispatcher)(response.request());\n      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(response.request(), 'response')) return;\n      this._dispatchEvent('response', {\n        response: _networkDispatchers.ResponseDispatcher.from(this, response),\n        page: _pageDispatcher.PageDispatcher.fromNullable(this, (_response$frame = response.frame()) === null || _response$frame === void 0 ? void 0 : _response$frame._page.initializedOrUndefined())\n      });\n    });\n    this.addObjectListener(_browserContext.BrowserContext.Events.RequestFailed, request => {\n      var _request$frame2;\n      const requestDispatcher = (0, _dispatcher.existingDispatcher)(request);\n      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request, 'requestFailed')) return;\n      this._dispatchEvent('requestFailed', {\n        request: _networkDispatchers.RequestDispatcher.from(this, request),\n        failureText: request._failureText || undefined,\n        responseEndTiming: request._responseEndTiming,\n        page: _pageDispatcher.PageDispatcher.fromNullable(this, (_request$frame2 = request.frame()) === null || _request$frame2 === void 0 ? void 0 : _request$frame2._page.initializedOrUndefined())\n      });\n    });\n    this.addObjectListener(_browserContext.BrowserContext.Events.RequestFinished, ({\n      request,\n      response\n    }) => {\n      var _request$frame3;\n      const requestDispatcher = (0, _dispatcher.existingDispatcher)(request);\n      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request, 'requestFinished')) return;\n      this._dispatchEvent('requestFinished', {\n        request: _networkDispatchers.RequestDispatcher.from(this, request),\n        response: _networkDispatchers.ResponseDispatcher.fromNullable(this, response),\n        responseEndTiming: request._responseEndTiming,\n        page: _pageDispatcher.PageDispatcher.fromNullable(this, (_request$frame3 = request.frame()) === null || _request$frame3 === void 0 ? void 0 : _request$frame3._page.initializedOrUndefined())\n      });\n    });\n  }\n  _shouldDispatchNetworkEvent(request, event) {\n    var _request$frame4, _request$frame4$_page;\n    if (this._subscriptions.has(event)) return true;\n    const page = (_request$frame4 = request.frame()) === null || _request$frame4 === void 0 ? void 0 : (_request$frame4$_page = _request$frame4._page) === null || _request$frame4$_page === void 0 ? void 0 : _request$frame4$_page.initializedOrUndefined();\n    const pageDispatcher = page ? (0, _dispatcher.existingDispatcher)(page) : undefined;\n    if (pageDispatcher !== null && pageDispatcher !== void 0 && pageDispatcher._subscriptions.has(event)) return true;\n    return false;\n  }\n  async createTempFile(params, metadata) {\n    const dir = this._context._browser.options.artifactsDir;\n    const tmpDir = path.join(dir, 'upload-' + (0, _utils.createGuid)());\n    await fs.promises.mkdir(tmpDir);\n    this._context._tempDirs.push(tmpDir);\n    const file = fs.createWriteStream(path.join(tmpDir, params.name));\n    return {\n      writableStream: new _writableStreamDispatcher.WritableStreamDispatcher(this, file)\n    };\n  }\n  async setDefaultNavigationTimeoutNoReply(params) {\n    this._context.setDefaultNavigationTimeout(params.timeout);\n  }\n  async setDefaultTimeoutNoReply(params) {\n    this._context.setDefaultTimeout(params.timeout);\n  }\n  async exposeBinding(params) {\n    await this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {\n      const pageDispatcher = _pageDispatcher.PageDispatcher.from(this, source.page);\n      const binding = new _pageDispatcher.BindingCallDispatcher(pageDispatcher, params.name, !!params.needsHandle, source, args);\n      this._dispatchEvent('bindingCall', {\n        binding\n      });\n      return binding.promise();\n    });\n  }\n  async newPage(params, metadata) {\n    return {\n      page: _pageDispatcher.PageDispatcher.from(this, await this._context.newPage(metadata))\n    };\n  }\n  async cookies(params) {\n    return {\n      cookies: await this._context.cookies(params.urls)\n    };\n  }\n  async addCookies(params) {\n    await this._context.addCookies(params.cookies);\n  }\n  async clearCookies() {\n    await this._context.clearCookies();\n  }\n  async grantPermissions(params) {\n    await this._context.grantPermissions(params.permissions, params.origin);\n  }\n  async clearPermissions() {\n    await this._context.clearPermissions();\n  }\n  async setGeolocation(params) {\n    await this._context.setGeolocation(params.geolocation);\n  }\n  async setExtraHTTPHeaders(params) {\n    await this._context.setExtraHTTPHeaders(params.headers);\n  }\n  async setOffline(params) {\n    await this._context.setOffline(params.offline);\n  }\n  async setHTTPCredentials(params) {\n    await this._context.setHTTPCredentials(params.httpCredentials);\n  }\n  async addInitScript(params) {\n    await this._context.addInitScript(params.source);\n  }\n  async setNetworkInterceptionPatterns(params) {\n    if (!params.patterns.length) {\n      await this._context.setRequestInterceptor(undefined);\n      return;\n    }\n    const urlMatchers = params.patterns.map(pattern => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);\n    await this._context.setRequestInterceptor((route, request) => {\n      const matchesSome = urlMatchers.some(urlMatch => (0, _utils.urlMatches)(this._context._options.baseURL, request.url(), urlMatch));\n      if (!matchesSome) return false;\n      this._dispatchEvent('route', {\n        route: _networkDispatchers.RouteDispatcher.from(_networkDispatchers.RequestDispatcher.from(this, request), route)\n      });\n      return true;\n    });\n  }\n  async storageState(params, metadata) {\n    return await this._context.storageState();\n  }\n  async close(params, metadata) {\n    await this._context.close(metadata);\n  }\n  async recorderSupplementEnable(params) {\n    await _recorder.Recorder.show(this._context, params);\n  }\n  async pause(params, metadata) {\n    // Debugger will take care of this.\n  }\n  async newCDPSession(params) {\n    if (!this._object._browser.options.isChromium) throw new Error(`CDP session is only available in Chromium`);\n    if (!params.page && !params.frame || params.page && params.frame) throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);\n    const crBrowserContext = this._object;\n    return {\n      session: new _cdpSessionDispatcher.CDPSessionDispatcher(this, await crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))\n    };\n  }\n  async harStart(params) {\n    const harId = await this._context._harStart(params.page ? params.page._object : null, params.options);\n    return {\n      harId\n    };\n  }\n  async harExport(params) {\n    const artifact = await this._context._harExport(params.harId);\n    if (!artifact) throw new Error('No HAR artifact. Ensure record.harPath is set.');\n    return {\n      artifact: _artifactDispatcher.ArtifactDispatcher.from(this, artifact)\n    };\n  }\n  async updateSubscription(params, metadata) {\n    if (params.enabled) this._subscriptions.add(params.event);else this._subscriptions.delete(params.event);\n  }\n  _onDispose() {\n    // Avoid protocol calls for the closed context.\n    if (!this._context.isClosingOrClosed()) this._context.setRequestInterceptor(undefined).catch(() => {});\n  }\n}\nexports.BrowserContextDispatcher = BrowserContextDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedBrowserDispatcher = exports.BrowserDispatcher = void 0;\nvar _browser = require(\"../browser\");\nvar _browserContextDispatcher = require(\"./browserContextDispatcher\");\nvar _cdpSessionDispatcher = require(\"./cdpSessionDispatcher\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _instrumentation = require(\"../instrumentation\");\nvar _browserContext = require(\"../browserContext\");\nvar _selectors = require(\"../selectors\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, browser) {\n    super(scope, browser, 'Browser', {\n      version: browser.version(),\n      name: browser.options.name\n    });\n    this._type_Browser = true;\n    this.addObjectListener(_browser.Browser.Events.Disconnected, () => this._didClose());\n  }\n  _didClose() {\n    this._dispatchEvent('close');\n    this._dispose();\n  }\n  async newContext(params, metadata) {\n    const context = await this._object.newContext(metadata, params);\n    return {\n      context: new _browserContextDispatcher.BrowserContextDispatcher(this, context)\n    };\n  }\n  async newContextForReuse(params, metadata) {\n    return await newContextForReuse(this._object, this, params, null, metadata);\n  }\n  async close() {\n    await this._object.close();\n  }\n  async killForTests() {\n    await this._object.killForTests();\n  }\n  async newBrowserCDPSession() {\n    if (!this._object.options.isChromium) throw new Error(`CDP session is only available in Chromium`);\n    const crBrowser = this._object;\n    return {\n      session: new _cdpSessionDispatcher.CDPSessionDispatcher(this, await crBrowser.newBrowserCDPSession())\n    };\n  }\n  async startTracing(params) {\n    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);\n    const crBrowser = this._object;\n    await crBrowser.startTracing(params.page ? params.page._object : undefined, params);\n  }\n  async stopTracing() {\n    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);\n    const crBrowser = this._object;\n    return {\n      binary: await crBrowser.stopTracing()\n    };\n  }\n}\n\n// This class implements multiplexing browser dispatchers over a single Browser instance.\nexports.BrowserDispatcher = BrowserDispatcher;\nclass ConnectedBrowserDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, browser) {\n    super(scope, browser, 'Browser', {\n      version: browser.version(),\n      name: browser.options.name\n    });\n    // When we have a remotely-connected browser, each client gets a fresh Selector instance,\n    // so that two clients do not interfere between each other.\n    this._type_Browser = true;\n    this._contexts = new Set();\n    this.selectors = void 0;\n    this.selectors = new _selectors.Selectors();\n  }\n  async newContext(params, metadata) {\n    if (params.recordVideo) params.recordVideo.dir = this._object.options.artifactsDir;\n    const context = await this._object.newContext(metadata, params);\n    this._contexts.add(context);\n    context.setSelectors(this.selectors);\n    context.on(_browserContext.BrowserContext.Events.Close, () => this._contexts.delete(context));\n    return {\n      context: new _browserContextDispatcher.BrowserContextDispatcher(this, context)\n    };\n  }\n  async newContextForReuse(params, metadata) {\n    return await newContextForReuse(this._object, this, params, this.selectors, metadata);\n  }\n  async close() {\n    // Client should not send us Browser.close.\n  }\n  async killForTests() {\n    // Client should not send us Browser.killForTests.\n  }\n  async newBrowserCDPSession() {\n    if (!this._object.options.isChromium) throw new Error(`CDP session is only available in Chromium`);\n    const crBrowser = this._object;\n    return {\n      session: new _cdpSessionDispatcher.CDPSessionDispatcher(this, await crBrowser.newBrowserCDPSession())\n    };\n  }\n  async startTracing(params) {\n    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);\n    const crBrowser = this._object;\n    await crBrowser.startTracing(params.page ? params.page._object : undefined, params);\n  }\n  async stopTracing() {\n    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);\n    const crBrowser = this._object;\n    return {\n      binary: await crBrowser.stopTracing()\n    };\n  }\n  async cleanupContexts() {\n    await Promise.all(Array.from(this._contexts).map(context => context.close((0, _instrumentation.serverSideCallMetadata)())));\n  }\n}\nexports.ConnectedBrowserDispatcher = ConnectedBrowserDispatcher;\nasync function newContextForReuse(browser, scope, params, selectors, metadata) {\n  const {\n    context,\n    needsReset\n  } = await browser.newContextForReuse(params, metadata);\n  if (needsReset) {\n    const oldContextDispatcher = (0, _dispatcher.existingDispatcher)(context);\n    if (oldContextDispatcher) oldContextDispatcher._dispose();\n    await context.resetForReuse(metadata, params);\n  }\n  if (selectors) context.setSelectors(selectors);\n  const contextDispatcher = new _browserContextDispatcher.BrowserContextDispatcher(scope, context);\n  return {\n    context: contextDispatcher\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserTypeDispatcher = void 0;\nvar _browserDispatcher = require(\"./browserDispatcher\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _browserContextDispatcher = require(\"./browserContextDispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass BrowserTypeDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, browserType) {\n    super(scope, browserType, 'BrowserType', {\n      executablePath: browserType.executablePath(),\n      name: browserType.name()\n    });\n    this._type_BrowserType = true;\n  }\n  async launch(params, metadata) {\n    const browser = await this._object.launch(metadata, params);\n    return {\n      browser: new _browserDispatcher.BrowserDispatcher(this, browser)\n    };\n  }\n  async launchPersistentContext(params, metadata) {\n    const browserContext = await this._object.launchPersistentContext(metadata, params.userDataDir, params);\n    return {\n      context: new _browserContextDispatcher.BrowserContextDispatcher(this, browserContext)\n    };\n  }\n  async connectOverCDP(params, metadata) {\n    const browser = await this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);\n    const browserDispatcher = new _browserDispatcher.BrowserDispatcher(this, browser);\n    return {\n      browser: browserDispatcher,\n      defaultContext: browser._defaultContext ? new _browserContextDispatcher.BrowserContextDispatcher(browserDispatcher, browser._defaultContext) : undefined\n    };\n  }\n}\nexports.BrowserTypeDispatcher = BrowserTypeDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CDPSessionDispatcher = void 0;\nvar _crConnection = require(\"../chromium/crConnection\");\nvar _dispatcher = require(\"./dispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CDPSessionDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, crSession) {\n    super(scope, crSession, 'CDPSession', {});\n    this._type_CDPSession = true;\n    crSession._eventListener = (method, params) => {\n      this._dispatchEvent('event', {\n        method,\n        params\n      });\n    };\n    this.addObjectListener(_crConnection.CRSessionEvents.Disconnected, () => this._dispose());\n  }\n  async send(params) {\n    return {\n      result: await this._object.send(params.method, params.params)\n    };\n  }\n  async detach() {\n    return this._object.detach();\n  }\n}\nexports.CDPSessionDispatcher = CDPSessionDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConsoleMessageDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _elementHandlerDispatcher = require(\"./elementHandlerDispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ConsoleMessageDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, message) {\n    super(scope, message, 'ConsoleMessage', {\n      type: message.type(),\n      text: message.text(),\n      args: message.args().map(a => _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, a)),\n      location: message.location()\n    });\n    this._type_ConsoleMessage = true;\n  }\n}\nexports.ConsoleMessageDispatcher = ConsoleMessageDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DebugControllerDispatcher = void 0;\nvar _utils = require(\"playwright-core/lib/utils\");\nvar _debugController = require(\"../debugController\");\nvar _dispatcher = require(\"./dispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass DebugControllerDispatcher extends _dispatcher.Dispatcher {\n  constructor(connection, debugController) {\n    super(connection, debugController, 'DebugController', {});\n    this._type_DebugController = void 0;\n    this._listeners = void 0;\n    this._type_DebugController = true;\n    this._listeners = [_utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.StateChanged, params => {\n      this._dispatchEvent('stateChanged', params);\n    }), _utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.InspectRequested, ({\n      selector,\n      locator\n    }) => {\n      this._dispatchEvent('inspectRequested', {\n        selector,\n        locator\n      });\n    }), _utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.SourceChanged, ({\n      text,\n      header,\n      footer,\n      actions\n    }) => {\n      this._dispatchEvent('sourceChanged', {\n        text,\n        header,\n        footer,\n        actions\n      });\n    }), _utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.Paused, ({\n      paused\n    }) => {\n      this._dispatchEvent('paused', {\n        paused\n      });\n    })];\n  }\n  async initialize(params) {\n    this._object.initialize(params.codegenId, params.sdkLanguage);\n  }\n  async setReportStateChanged(params) {\n    this._object.setReportStateChanged(params.enabled);\n  }\n  async resetForReuse() {\n    await this._object.resetForReuse();\n  }\n  async navigate(params) {\n    await this._object.navigate(params.url);\n  }\n  async setRecorderMode(params) {\n    await this._object.setRecorderMode(params);\n  }\n  async highlight(params) {\n    await this._object.highlight(params.selector);\n  }\n  async hideHighlight() {\n    await this._object.hideHighlight();\n  }\n  async resume() {\n    await this._object.resume();\n  }\n  async kill() {\n    await this._object.kill();\n  }\n  async closeAllBrowsers() {\n    await this._object.closeAllBrowsers();\n  }\n  _onDispose() {\n    _utils.eventsHelper.removeEventListeners(this._listeners);\n    this._object.dispose();\n  }\n}\nexports.DebugControllerDispatcher = DebugControllerDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DialogDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass DialogDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, dialog) {\n    super(scope, dialog, 'Dialog', {\n      type: dialog.type(),\n      message: dialog.message(),\n      defaultValue: dialog.defaultValue()\n    });\n    this._type_Dialog = true;\n  }\n  async accept(params) {\n    await this._object.accept(params.promptText);\n  }\n  async dismiss() {\n    await this._object.dismiss();\n  }\n}\nexports.DialogDispatcher = DialogDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dispatcherSymbol = exports.RootDispatcher = exports.DispatcherConnection = exports.Dispatcher = void 0;\nexports.existingDispatcher = existingDispatcher;\nvar _events = require(\"events\");\nvar _serializers = require(\"../../protocol/serializers\");\nvar _validator = require(\"../../protocol/validator\");\nvar _utils = require(\"../../utils\");\nvar _errors = require(\"../../common/errors\");\nvar _instrumentation = require(\"../instrumentation\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _eventsHelper = require(\"../..//utils/eventsHelper\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst dispatcherSymbol = Symbol('dispatcher');\nexports.dispatcherSymbol = dispatcherSymbol;\nconst metadataValidator = (0, _validator.createMetadataValidator)();\nfunction existingDispatcher(object) {\n  return object[dispatcherSymbol];\n}\nclass Dispatcher extends _events.EventEmitter {\n  // Parent is always \"isScope\".\n\n  // Only \"isScope\" channel owners have registered dispatchers inside.\n\n  constructor(parent, object, type, initializer) {\n    super();\n    this._connection = void 0;\n    this._parent = void 0;\n    this._dispatchers = new Map();\n    this._disposed = false;\n    this._eventListeners = [];\n    this._guid = void 0;\n    this._type = void 0;\n    this._object = void 0;\n    this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;\n    this._parent = parent instanceof DispatcherConnection ? undefined : parent;\n    const guid = object.guid;\n    (0, _utils.assert)(!this._connection._dispatchers.has(guid));\n    this._connection._dispatchers.set(guid, this);\n    if (this._parent) {\n      (0, _utils.assert)(!this._parent._dispatchers.has(guid));\n      this._parent._dispatchers.set(guid, this);\n    }\n    this._type = type;\n    this._guid = guid;\n    this._object = object;\n    object[dispatcherSymbol] = this;\n    if (this._parent) this._connection.sendCreate(this._parent, type, guid, initializer, this._parent._object);\n  }\n  parentScope() {\n    return this._parent;\n  }\n  addObjectListener(eventName, handler) {\n    this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._object, eventName, handler));\n  }\n  adopt(child) {\n    const oldParent = child._parent;\n    oldParent._dispatchers.delete(child._guid);\n    this._dispatchers.set(child._guid, child);\n    child._parent = this;\n    this._connection.sendAdopt(this, child);\n  }\n  _dispatchEvent(method, params) {\n    if (this._disposed) {\n      if ((0, _utils.isUnderTest)()) throw new Error(`${this._guid} is sending \"${String(method)}\" event after being disposed`);\n      // Just ignore this event outside of tests.\n      return;\n    }\n    const sdkObject = this._object instanceof _instrumentation.SdkObject ? this._object : undefined;\n    this._connection.sendEvent(this, method, params, sdkObject);\n  }\n  _dispose() {\n    this._disposeRecursively();\n    this._connection.sendDispose(this);\n  }\n  _onDispose() {}\n  _disposeRecursively() {\n    (0, _utils.assert)(!this._disposed, `${this._guid} is disposed more than once`);\n    this._onDispose();\n    this._disposed = true;\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n\n    // Clean up from parent and connection.\n    if (this._parent) this._parent._dispatchers.delete(this._guid);\n    this._connection._dispatchers.delete(this._guid);\n\n    // Dispose all children.\n    for (const dispatcher of [...this._dispatchers.values()]) dispatcher._disposeRecursively();\n    this._dispatchers.clear();\n    delete this._object[dispatcherSymbol];\n  }\n  _debugScopeState() {\n    return {\n      _guid: this._guid,\n      objects: Array.from(this._dispatchers.values()).map(o => o._debugScopeState())\n    };\n  }\n  async waitForEventInfo() {\n    // Instrumentation takes care of this.\n  }\n}\nexports.Dispatcher = Dispatcher;\nclass RootDispatcher extends Dispatcher {\n  constructor(connection, createPlaywright) {\n    super(connection, {\n      guid: ''\n    }, 'Root', {});\n    this._initialized = false;\n    this.createPlaywright = createPlaywright;\n  }\n  async initialize(params) {\n    (0, _utils.assert)(this.createPlaywright);\n    (0, _utils.assert)(!this._initialized);\n    this._initialized = true;\n    return {\n      playwright: await this.createPlaywright(this, params)\n    };\n  }\n}\nexports.RootDispatcher = RootDispatcher;\nclass DispatcherConnection {\n  constructor(isLocal) {\n    this._dispatchers = new Map();\n    this.onmessage = message => {};\n    this._waitOperations = new Map();\n    this._isLocal = void 0;\n    this._isLocal = !!isLocal;\n  }\n  sendEvent(dispatcher, event, params, sdkObject) {\n    const validator = (0, _validator.findValidator)(dispatcher._type, event, 'Event');\n    params = validator(params, '', {\n      tChannelImpl: this._tChannelImplToWire.bind(this),\n      binary: this._isLocal ? 'buffer' : 'toBase64'\n    });\n    this._sendMessageToClient(dispatcher._guid, dispatcher._type, event, params, sdkObject);\n  }\n  sendCreate(parent, type, guid, initializer, sdkObject) {\n    const validator = (0, _validator.findValidator)(type, '', 'Initializer');\n    initializer = validator(initializer, '', {\n      tChannelImpl: this._tChannelImplToWire.bind(this),\n      binary: this._isLocal ? 'buffer' : 'toBase64'\n    });\n    this._sendMessageToClient(parent._guid, type, '__create__', {\n      type,\n      initializer,\n      guid\n    }, sdkObject);\n  }\n  sendAdopt(parent, dispatcher) {\n    this._sendMessageToClient(parent._guid, dispatcher._type, '__adopt__', {\n      guid: dispatcher._guid\n    });\n  }\n  sendDispose(dispatcher) {\n    this._sendMessageToClient(dispatcher._guid, dispatcher._type, '__dispose__', {});\n  }\n  _sendMessageToClient(guid, type, method, params, sdkObject) {\n    if (sdkObject) {\n      var _sdkObject$attributio, _sdkObject$attributio2, _sdkObject$attributio3, _sdkObject$attributio4, _sdkObject$instrument;\n      const eventMetadata = {\n        id: `event@${++lastEventId}`,\n        objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,\n        pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio = sdkObject.attribution) === null || _sdkObject$attributio === void 0 ? void 0 : (_sdkObject$attributio2 = _sdkObject$attributio.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.guid,\n        frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio3 = sdkObject.attribution) === null || _sdkObject$attributio3 === void 0 ? void 0 : (_sdkObject$attributio4 = _sdkObject$attributio3.frame) === null || _sdkObject$attributio4 === void 0 ? void 0 : _sdkObject$attributio4.guid,\n        wallTime: Date.now(),\n        startTime: (0, _utils.monotonicTime)(),\n        endTime: 0,\n        type,\n        method,\n        params: params || {},\n        log: [],\n        snapshots: []\n      };\n      (_sdkObject$instrument = sdkObject.instrumentation) === null || _sdkObject$instrument === void 0 ? void 0 : _sdkObject$instrument.onEvent(sdkObject, eventMetadata);\n    }\n    this.onmessage({\n      guid,\n      method,\n      params\n    });\n  }\n  _tChannelImplFromWire(names, arg, path, context) {\n    if (arg && typeof arg === 'object' && typeof arg.guid === 'string') {\n      const guid = arg.guid;\n      const dispatcher = this._dispatchers.get(guid);\n      if (!dispatcher) throw new _validator.ValidationError(`${path}: no object with guid ${guid}`);\n      if (names !== '*' && !names.includes(dispatcher._type)) throw new _validator.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${names.toString()}`);\n      return dispatcher;\n    }\n    throw new _validator.ValidationError(`${path}: expected guid for ${names.toString()}`);\n  }\n  _tChannelImplToWire(names, arg, path, context) {\n    if (arg instanceof Dispatcher) {\n      if (names !== '*' && !names.includes(arg._type)) throw new _validator.ValidationError(`${path}: dispatcher with guid ${arg._guid} has type ${arg._type}, expected ${names.toString()}`);\n      return {\n        guid: arg._guid\n      };\n    }\n    throw new _validator.ValidationError(`${path}: expected dispatcher ${names.toString()}`);\n  }\n  async dispatch(message) {\n    var _sdkObject$attributio5, _sdkObject$attributio6, _sdkObject$attributio7, _sdkObject$attributio8, _params$info;\n    const {\n      id,\n      guid,\n      method,\n      params,\n      metadata\n    } = message;\n    const dispatcher = this._dispatchers.get(guid);\n    if (!dispatcher) {\n      this.onmessage({\n        id,\n        error: (0, _serializers.serializeError)(new Error(_errors.kBrowserOrContextClosedError))\n      });\n      return;\n    }\n    let validParams;\n    let validMetadata;\n    try {\n      const validator = (0, _validator.findValidator)(dispatcher._type, method, 'Params');\n      validParams = validator(params, '', {\n        tChannelImpl: this._tChannelImplFromWire.bind(this),\n        binary: this._isLocal ? 'buffer' : 'fromBase64'\n      });\n      validMetadata = metadataValidator(metadata, '', {\n        tChannelImpl: this._tChannelImplFromWire.bind(this),\n        binary: this._isLocal ? 'buffer' : 'fromBase64'\n      });\n      if (typeof dispatcher[method] !== 'function') throw new Error(`Mismatching dispatcher: \"${dispatcher._type}\" does not implement \"${method}\"`);\n    } catch (e) {\n      this.onmessage({\n        id,\n        error: (0, _serializers.serializeError)(e)\n      });\n      return;\n    }\n    const sdkObject = dispatcher._object instanceof _instrumentation.SdkObject ? dispatcher._object : undefined;\n    const callMetadata = {\n      id: `call@${id}`,\n      stack: validMetadata.stack,\n      apiName: validMetadata.apiName,\n      internal: validMetadata.internal,\n      objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,\n      pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio5 = sdkObject.attribution) === null || _sdkObject$attributio5 === void 0 ? void 0 : (_sdkObject$attributio6 = _sdkObject$attributio5.page) === null || _sdkObject$attributio6 === void 0 ? void 0 : _sdkObject$attributio6.guid,\n      frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio7 = sdkObject.attribution) === null || _sdkObject$attributio7 === void 0 ? void 0 : (_sdkObject$attributio8 = _sdkObject$attributio7.frame) === null || _sdkObject$attributio8 === void 0 ? void 0 : _sdkObject$attributio8.guid,\n      wallTime: Date.now(),\n      startTime: (0, _utils.monotonicTime)(),\n      endTime: 0,\n      type: dispatcher._type,\n      method,\n      params: params || {},\n      log: [],\n      snapshots: []\n    };\n    if (sdkObject && params !== null && params !== void 0 && (_params$info = params.info) !== null && _params$info !== void 0 && _params$info.waitId) {\n      // Process logs for waitForNavigation/waitForLoadState/etc.\n      const info = params.info;\n      switch (info.phase) {\n        case 'before':\n          {\n            this._waitOperations.set(info.waitId, callMetadata);\n            await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);\n            this.onmessage({\n              id\n            });\n            return;\n          }\n        case 'log':\n          {\n            const originalMetadata = this._waitOperations.get(info.waitId);\n            originalMetadata.log.push(info.message);\n            sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, 'api', info.message);\n            this.onmessage({\n              id\n            });\n            return;\n          }\n        case 'after':\n          {\n            const originalMetadata = this._waitOperations.get(info.waitId);\n            originalMetadata.endTime = (0, _utils.monotonicTime)();\n            originalMetadata.error = info.error ? {\n              error: {\n                name: 'Error',\n                message: info.error\n              }\n            } : undefined;\n            this._waitOperations.delete(info.waitId);\n            await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);\n            this.onmessage({\n              id\n            });\n            return;\n          }\n      }\n    }\n    let error;\n    await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata));\n    try {\n      const result = await dispatcher[method](validParams, callMetadata);\n      const validator = (0, _validator.findValidator)(dispatcher._type, method, 'Result');\n      callMetadata.result = validator(result, '', {\n        tChannelImpl: this._tChannelImplToWire.bind(this),\n        binary: this._isLocal ? 'buffer' : 'toBase64'\n      });\n    } catch (e) {\n      // Dispatching error\n      // We want original, unmodified error in metadata.\n      callMetadata.error = (0, _serializers.serializeError)(e);\n      if (callMetadata.log.length) (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(callMetadata.log));\n      error = (0, _serializers.serializeError)(e);\n    } finally {\n      callMetadata.endTime = (0, _utils.monotonicTime)();\n      await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata));\n    }\n    const response = {\n      id\n    };\n    if (callMetadata.result) response.result = callMetadata.result;\n    if (error) response.error = error;\n    this.onmessage(response);\n  }\n}\nexports.DispatcherConnection = DispatcherConnection;\nfunction formatLogRecording(log) {\n  if (!log.length) return '';\n  const header = ` logs `;\n  const headerLength = 60;\n  const leftLength = (headerLength - header.length) / 2;\n  const rightLength = headerLength - header.length - leftLength;\n  return `\\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\\n${log.join('\\n')}\\n${'='.repeat(headerLength)}`;\n}\nlet lastEventId = 0;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElectronDispatcher = exports.ElectronApplicationDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _electron = require(\"../electron/electron\");\nvar _browserContextDispatcher = require(\"./browserContextDispatcher\");\nvar _jsHandleDispatcher = require(\"./jsHandleDispatcher\");\nvar _elementHandlerDispatcher = require(\"./elementHandlerDispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ElectronDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, electron) {\n    super(scope, electron, 'Electron', {});\n    this._type_Electron = true;\n  }\n  async launch(params) {\n    const electronApplication = await this._object.launch(params);\n    return {\n      electronApplication: new ElectronApplicationDispatcher(this, electronApplication)\n    };\n  }\n}\nexports.ElectronDispatcher = ElectronDispatcher;\nclass ElectronApplicationDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, electronApplication) {\n    super(scope, electronApplication, 'ElectronApplication', {\n      context: new _browserContextDispatcher.BrowserContextDispatcher(scope, electronApplication.context())\n    });\n    this._type_EventTarget = true;\n    this._type_ElectronApplication = true;\n    this.addObjectListener(_electron.ElectronApplication.Events.Close, () => {\n      this._dispatchEvent('close');\n      this._dispose();\n    });\n  }\n  async browserWindow(params) {\n    const handle = await this._object.browserWindow(params.page.page());\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this, handle)\n    };\n  }\n  async evaluateExpression(params) {\n    const handle = await this._object._nodeElectronHandlePromise;\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true /* returnByValue */, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n  async evaluateExpressionHandle(params) {\n    const handle = await this._object._nodeElectronHandlePromise;\n    const result = await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false /* returnByValue */, (0, _jsHandleDispatcher.parseArgument)(params.arg));\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this, result)\n    };\n  }\n  async close() {\n    await this._object.close();\n  }\n}\nexports.ElectronApplicationDispatcher = ElectronApplicationDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElementHandleDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _jsHandleDispatcher = require(\"./jsHandleDispatcher\");\nvar _frameDispatcher = require(\"./frameDispatcher\");\nvar _utils = require(\"../../utils\");\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ElementHandleDispatcher extends _jsHandleDispatcher.JSHandleDispatcher {\n  static from(scope, handle) {\n    return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);\n  }\n  static fromNullable(scope, handle) {\n    if (!handle) return undefined;\n    return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);\n  }\n  static fromJSHandle(scope, handle) {\n    const result = (0, _dispatcher.existingDispatcher)(handle);\n    if (result) return result;\n    return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new _jsHandleDispatcher.JSHandleDispatcher(scope, handle);\n  }\n  constructor(scope, elementHandle) {\n    super(scope, elementHandle);\n    this._type_ElementHandle = true;\n    this._elementHandle = void 0;\n    this._elementHandle = elementHandle;\n  }\n  async ownerFrame(params, metadata) {\n    const frame = await this._elementHandle.ownerFrame();\n    return {\n      frame: frame ? _frameDispatcher.FrameDispatcher.from(this.parentScope(), frame) : undefined\n    };\n  }\n  async contentFrame(params, metadata) {\n    const frame = await this._elementHandle.contentFrame();\n    return {\n      frame: frame ? _frameDispatcher.FrameDispatcher.from(this.parentScope(), frame) : undefined\n    };\n  }\n  async getAttribute(params, metadata) {\n    const value = await this._elementHandle.getAttribute(params.name);\n    return {\n      value: value === null ? undefined : value\n    };\n  }\n  async inputValue(params, metadata) {\n    const value = await this._elementHandle.inputValue();\n    return {\n      value\n    };\n  }\n  async textContent(params, metadata) {\n    const value = await this._elementHandle.textContent();\n    return {\n      value: value === null ? undefined : value\n    };\n  }\n  async innerText(params, metadata) {\n    return {\n      value: await this._elementHandle.innerText()\n    };\n  }\n  async innerHTML(params, metadata) {\n    return {\n      value: await this._elementHandle.innerHTML()\n    };\n  }\n  async isChecked(params, metadata) {\n    return {\n      value: await this._elementHandle.isChecked()\n    };\n  }\n  async isDisabled(params, metadata) {\n    return {\n      value: await this._elementHandle.isDisabled()\n    };\n  }\n  async isEditable(params, metadata) {\n    return {\n      value: await this._elementHandle.isEditable()\n    };\n  }\n  async isEnabled(params, metadata) {\n    return {\n      value: await this._elementHandle.isEnabled()\n    };\n  }\n  async isHidden(params, metadata) {\n    return {\n      value: await this._elementHandle.isHidden()\n    };\n  }\n  async isVisible(params, metadata) {\n    return {\n      value: await this._elementHandle.isVisible()\n    };\n  }\n  async dispatchEvent(params, metadata) {\n    await this._elementHandle.dispatchEvent(params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit));\n  }\n  async scrollIntoViewIfNeeded(params, metadata) {\n    await this._elementHandle.scrollIntoViewIfNeeded(metadata, params);\n  }\n  async hover(params, metadata) {\n    return await this._elementHandle.hover(metadata, params);\n  }\n  async click(params, metadata) {\n    return await this._elementHandle.click(metadata, params);\n  }\n  async dblclick(params, metadata) {\n    return await this._elementHandle.dblclick(metadata, params);\n  }\n  async tap(params, metadata) {\n    return await this._elementHandle.tap(metadata, params);\n  }\n  async selectOption(params, metadata) {\n    const elements = (params.elements || []).map(e => e._elementHandle);\n    return {\n      values: await this._elementHandle.selectOption(metadata, elements, params.options || [], params)\n    };\n  }\n  async fill(params, metadata) {\n    return await this._elementHandle.fill(metadata, params.value, params);\n  }\n  async selectText(params, metadata) {\n    await this._elementHandle.selectText(metadata, params);\n  }\n  async setInputFiles(params, metadata) {\n    return await this._elementHandle.setInputFiles(metadata, {\n      files: params.files\n    }, params);\n  }\n  async setInputFilePaths(params, metadata) {\n    let {\n      localPaths\n    } = params;\n    if (!localPaths) {\n      if (!params.streams) throw new Error('Neither localPaths nor streams is specified');\n      localPaths = params.streams.map(c => c.path());\n    }\n    for (const p of localPaths) (0, _utils.assert)(_path.default.isAbsolute(p) && _path.default.resolve(p) === p, 'Paths provided to localPaths must be absolute and fully resolved.');\n    return await this._elementHandle.setInputFiles(metadata, {\n      localPaths\n    }, params);\n  }\n  async focus(params, metadata) {\n    await this._elementHandle.focus(metadata);\n  }\n  async type(params, metadata) {\n    return await this._elementHandle.type(metadata, params.text, params);\n  }\n  async press(params, metadata) {\n    return await this._elementHandle.press(metadata, params.key, params);\n  }\n  async check(params, metadata) {\n    return await this._elementHandle.check(metadata, params);\n  }\n  async uncheck(params, metadata) {\n    return await this._elementHandle.uncheck(metadata, params);\n  }\n  async boundingBox(params, metadata) {\n    const value = await this._elementHandle.boundingBox();\n    return {\n      value: value || undefined\n    };\n  }\n  async screenshot(params, metadata) {\n    const mask = (params.mask || []).map(({\n      frame,\n      selector\n    }) => ({\n      frame: frame._object,\n      selector\n    }));\n    return {\n      binary: await this._elementHandle.screenshot(metadata, {\n        ...params,\n        mask\n      })\n    };\n  }\n  async querySelector(params, metadata) {\n    const handle = await this._elementHandle.querySelector(params.selector, params);\n    return {\n      element: ElementHandleDispatcher.fromNullable(this.parentScope(), handle)\n    };\n  }\n  async querySelectorAll(params, metadata) {\n    const elements = await this._elementHandle.querySelectorAll(params.selector);\n    return {\n      elements: elements.map(e => ElementHandleDispatcher.from(this.parentScope(), e))\n    };\n  }\n  async evalOnSelector(params, metadata) {\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n  async evalOnSelectorAll(params, metadata) {\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n  async waitForElementState(params, metadata) {\n    await this._elementHandle.waitForElementState(metadata, params.state, params);\n  }\n  async waitForSelector(params, metadata) {\n    return {\n      element: ElementHandleDispatcher.fromNullable(this.parentScope(), await this._elementHandle.waitForSelector(metadata, params.selector, params))\n    };\n  }\n}\nexports.ElementHandleDispatcher = ElementHandleDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrameDispatcher = void 0;\nvar _frames = require(\"../frames\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _elementHandlerDispatcher = require(\"./elementHandlerDispatcher\");\nvar _jsHandleDispatcher = require(\"./jsHandleDispatcher\");\nvar _networkDispatchers = require(\"./networkDispatchers\");\nvar _utils = require(\"../../utils\");\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass FrameDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, frame) {\n    const result = (0, _dispatcher.existingDispatcher)(frame);\n    return result || new FrameDispatcher(scope, frame);\n  }\n  static fromNullable(scope, frame) {\n    if (!frame) return;\n    return FrameDispatcher.from(scope, frame);\n  }\n  constructor(scope, frame) {\n    super(scope, frame, 'Frame', {\n      url: frame.url(),\n      name: frame.name(),\n      parentFrame: FrameDispatcher.fromNullable(scope, frame.parentFrame()),\n      loadStates: Array.from(frame._firedLifecycleEvents)\n    });\n    this._type_Frame = true;\n    this._frame = void 0;\n    this._frame = frame;\n    this.addObjectListener(_frames.Frame.Events.AddLifecycle, lifecycleEvent => {\n      this._dispatchEvent('loadstate', {\n        add: lifecycleEvent\n      });\n    });\n    this.addObjectListener(_frames.Frame.Events.RemoveLifecycle, lifecycleEvent => {\n      this._dispatchEvent('loadstate', {\n        remove: lifecycleEvent\n      });\n    });\n    this.addObjectListener(_frames.Frame.Events.InternalNavigation, event => {\n      if (!event.isPublic) return;\n      const params = {\n        url: event.url,\n        name: event.name,\n        error: event.error ? event.error.message : undefined\n      };\n      if (event.newDocument) params.newDocument = {\n        request: _networkDispatchers.RequestDispatcher.fromNullable(this.parentScope().parentScope(), event.newDocument.request || null)\n      };\n      this._dispatchEvent('navigated', params);\n    });\n  }\n  async goto(params, metadata) {\n    return {\n      response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope().parentScope(), await this._frame.goto(metadata, params.url, params))\n    };\n  }\n  async frameElement() {\n    return {\n      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), await this._frame.frameElement())\n    };\n  }\n  async evaluateExpression(params, metadata) {\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evaluateExpressionAndWaitForSignals(params.expression, {\n        isFunction: params.isFunction,\n        exposeUtilityScript: params.exposeUtilityScript\n      }, (0, _jsHandleDispatcher.parseArgument)(params.arg), 'main'))\n    };\n  }\n  async evaluateExpressionHandle(params, metadata) {\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), await this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), 'main'))\n    };\n  }\n  async waitForSelector(params, metadata) {\n    return {\n      element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this.parentScope(), await this._frame.waitForSelector(metadata, params.selector, params))\n    };\n  }\n  async dispatchEvent(params, metadata) {\n    return this._frame.dispatchEvent(metadata, params.selector, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit), params);\n  }\n  async evalOnSelector(params, metadata) {\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n  async evalOnSelectorAll(params, metadata) {\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n  async querySelector(params, metadata) {\n    return {\n      element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this.parentScope(), await this._frame.querySelector(params.selector, params))\n    };\n  }\n  async querySelectorAll(params, metadata) {\n    const elements = await this._frame.querySelectorAll(params.selector);\n    return {\n      elements: elements.map(e => _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), e))\n    };\n  }\n  async queryCount(params) {\n    return {\n      value: await this._frame.queryCount(params.selector)\n    };\n  }\n  async content() {\n    return {\n      value: await this._frame.content()\n    };\n  }\n  async setContent(params, metadata) {\n    return await this._frame.setContent(metadata, params.html, params);\n  }\n  async addScriptTag(params, metadata) {\n    return {\n      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), await this._frame.addScriptTag(params))\n    };\n  }\n  async addStyleTag(params, metadata) {\n    return {\n      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), await this._frame.addStyleTag(params))\n    };\n  }\n  async click(params, metadata) {\n    return await this._frame.click(metadata, params.selector, params);\n  }\n  async dblclick(params, metadata) {\n    return await this._frame.dblclick(metadata, params.selector, params);\n  }\n  async dragAndDrop(params, metadata) {\n    return await this._frame.dragAndDrop(metadata, params.source, params.target, params);\n  }\n  async tap(params, metadata) {\n    return await this._frame.tap(metadata, params.selector, params);\n  }\n  async fill(params, metadata) {\n    return await this._frame.fill(metadata, params.selector, params.value, params);\n  }\n  async focus(params, metadata) {\n    await this._frame.focus(metadata, params.selector, params);\n  }\n  async blur(params, metadata) {\n    await this._frame.blur(metadata, params.selector, params);\n  }\n  async textContent(params, metadata) {\n    const value = await this._frame.textContent(metadata, params.selector, params);\n    return {\n      value: value === null ? undefined : value\n    };\n  }\n  async innerText(params, metadata) {\n    return {\n      value: await this._frame.innerText(metadata, params.selector, params)\n    };\n  }\n  async innerHTML(params, metadata) {\n    return {\n      value: await this._frame.innerHTML(metadata, params.selector, params)\n    };\n  }\n  async getAttribute(params, metadata) {\n    const value = await this._frame.getAttribute(metadata, params.selector, params.name, params);\n    return {\n      value: value === null ? undefined : value\n    };\n  }\n  async inputValue(params, metadata) {\n    const value = await this._frame.inputValue(metadata, params.selector, params);\n    return {\n      value\n    };\n  }\n  async isChecked(params, metadata) {\n    return {\n      value: await this._frame.isChecked(metadata, params.selector, params)\n    };\n  }\n  async isDisabled(params, metadata) {\n    return {\n      value: await this._frame.isDisabled(metadata, params.selector, params)\n    };\n  }\n  async isEditable(params, metadata) {\n    return {\n      value: await this._frame.isEditable(metadata, params.selector, params)\n    };\n  }\n  async isEnabled(params, metadata) {\n    return {\n      value: await this._frame.isEnabled(metadata, params.selector, params)\n    };\n  }\n  async isHidden(params, metadata) {\n    return {\n      value: await this._frame.isHidden(metadata, params.selector, params)\n    };\n  }\n  async isVisible(params, metadata) {\n    return {\n      value: await this._frame.isVisible(metadata, params.selector, params)\n    };\n  }\n  async hover(params, metadata) {\n    return await this._frame.hover(metadata, params.selector, params);\n  }\n  async selectOption(params, metadata) {\n    const elements = (params.elements || []).map(e => e._elementHandle);\n    return {\n      values: await this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)\n    };\n  }\n  async setInputFiles(params, metadata) {\n    return await this._frame.setInputFiles(metadata, params.selector, {\n      files: params.files\n    }, params);\n  }\n  async setInputFilePaths(params, metadata) {\n    let {\n      localPaths\n    } = params;\n    if (!localPaths) {\n      if (!params.streams) throw new Error('Neither localPaths nor streams is specified');\n      localPaths = params.streams.map(c => c.path());\n    }\n    for (const p of localPaths) (0, _utils.assert)(_path.default.isAbsolute(p) && _path.default.resolve(p) === p, 'Paths provided to localPaths must be absolute and fully resolved.');\n    return await this._frame.setInputFiles(metadata, params.selector, {\n      localPaths\n    }, params);\n  }\n  async type(params, metadata) {\n    return await this._frame.type(metadata, params.selector, params.text, params);\n  }\n  async press(params, metadata) {\n    return await this._frame.press(metadata, params.selector, params.key, params);\n  }\n  async check(params, metadata) {\n    return await this._frame.check(metadata, params.selector, params);\n  }\n  async uncheck(params, metadata) {\n    return await this._frame.uncheck(metadata, params.selector, params);\n  }\n  async waitForTimeout(params, metadata) {\n    return await this._frame.waitForTimeout(metadata, params.timeout);\n  }\n  async waitForFunction(params, metadata) {\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), await this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), params))\n    };\n  }\n  async title(params, metadata) {\n    return {\n      value: await this._frame.title()\n    };\n  }\n  async highlight(params, metadata) {\n    return await this._frame.highlight(params.selector);\n  }\n  async expect(params, metadata) {\n    const expectedValue = params.expectedValue ? (0, _jsHandleDispatcher.parseArgument)(params.expectedValue) : undefined;\n    const result = await this._frame.expect(metadata, params.selector, {\n      ...params,\n      expectedValue\n    });\n    if (result.received !== undefined) result.received = (0, _jsHandleDispatcher.serializeResult)(result.received);\n    if (result.matches === params.isNot) metadata.error = {\n      error: {\n        name: 'Expect',\n        message: 'Expect failed'\n      }\n    };\n    return result;\n  }\n}\nexports.FrameDispatcher = FrameDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSHandleDispatcher = void 0;\nexports.parseArgument = parseArgument;\nexports.parseValue = parseValue;\nexports.serializeResult = serializeResult;\nvar _dispatcher = require(\"./dispatcher\");\nvar _elementHandlerDispatcher = require(\"./elementHandlerDispatcher\");\nvar _serializers = require(\"../../protocol/serializers\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass JSHandleDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, jsHandle) {\n    // Do not call this directly, use createHandle() instead.\n    super(scope, jsHandle, jsHandle.asElement() ? 'ElementHandle' : 'JSHandle', {\n      preview: jsHandle.toString()\n    });\n    this._type_JSHandle = true;\n    jsHandle._setPreviewCallback(preview => this._dispatchEvent('previewUpdated', {\n      preview\n    }));\n  }\n  async evaluateExpression(params) {\n    return {\n      value: serializeResult(await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true /* returnByValue */, parseArgument(params.arg)))\n    };\n  }\n  async evaluateExpressionHandle(params) {\n    const jsHandle = await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false /* returnByValue */, parseArgument(params.arg));\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle)\n    };\n  }\n  async getProperty(params) {\n    const jsHandle = await this._object.getProperty(params.name);\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle)\n    };\n  }\n  async getPropertyList() {\n    const map = await this._object.getProperties();\n    const properties = [];\n    for (const [name, value] of map) properties.push({\n      name,\n      value: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), value)\n    });\n    return {\n      properties\n    };\n  }\n  async jsonValue() {\n    return {\n      value: serializeResult(await this._object.jsonValue())\n    };\n  }\n  async dispose() {\n    await this._object.dispose();\n  }\n}\n\n// Generic channel parser converts guids to JSHandleDispatchers,\n// and this function takes care of coverting them into underlying JSHandles.\nexports.JSHandleDispatcher = JSHandleDispatcher;\nfunction parseArgument(arg) {\n  return (0, _serializers.parseSerializedValue)(arg.value, arg.handles.map(a => a._object));\n}\nfunction parseValue(v) {\n  return (0, _serializers.parseSerializedValue)(v, []);\n}\nfunction serializeResult(arg) {\n  return (0, _serializers.serializeValue)(arg, value => ({\n    fallThrough: value\n  }));\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonPipeDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _utils = require(\"../../utils\");\nvar _serializers = require(\"../../protocol/serializers\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass JsonPipeDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope) {\n    super(scope, {\n      guid: 'jsonPipe@' + (0, _utils.createGuid)()\n    }, 'JsonPipe', {});\n    this._type_JsonPipe = true;\n  }\n  async send(params) {\n    this.emit('message', params.message);\n  }\n  async close() {\n    this.emit('close');\n    if (!this._disposed) {\n      this._dispatchEvent('closed', {});\n      this._dispose();\n    }\n  }\n  dispatch(message) {\n    if (!this._disposed) this._dispatchEvent('message', {\n      message\n    });\n  }\n  wasClosed(error) {\n    if (!this._disposed) {\n      const params = error ? {\n        error: (0, _serializers.serializeError)(error)\n      } : {};\n      this._dispatchEvent('closed', params);\n      this._dispose();\n    }\n  }\n  dispose() {\n    this._dispose();\n  }\n}\nexports.JsonPipeDispatcher = JsonPipeDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalUtilsDispatcher = void 0;\nexports.urlToWSEndpoint = urlToWSEndpoint;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _manualPromise = require(\"../../utils/manualPromise\");\nvar _utils = require(\"../../utils\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _zipBundle = require(\"../../zipBundle\");\nvar _zipFile = require(\"../../utils/zipFile\");\nvar _jsonPipeDispatcher = require(\"../dispatchers/jsonPipeDispatcher\");\nvar _transport = require(\"../transport\");\nvar _socksInterceptor = require(\"../socksInterceptor\");\nvar _userAgent = require(\"../../utils/userAgent\");\nvar _progress = require(\"../progress\");\nvar _network = require(\"../../utils/network\");\nvar _instrumentation = require(\"../../server/instrumentation\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass LocalUtilsDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, playwright) {\n    const localUtils = new _instrumentation.SdkObject(playwright, 'localUtils', 'localUtils');\n    super(scope, localUtils, 'LocalUtils', {});\n    this._type_LocalUtils = void 0;\n    this._harBakends = new Map();\n    this._type_LocalUtils = true;\n  }\n  async zip(params, metadata) {\n    const promise = new _manualPromise.ManualPromise();\n    const zipFile = new _zipBundle.yazl.ZipFile();\n    zipFile.on('error', error => promise.reject(error));\n    for (const entry of params.entries) {\n      try {\n        if (_fs.default.statSync(entry.value).isFile()) zipFile.addFile(entry.value, entry.name);\n      } catch (e) {}\n    }\n    if (!_fs.default.existsSync(params.zipFile)) {\n      // New file, just compress the entries.\n      await _fs.default.promises.mkdir(_path.default.dirname(params.zipFile), {\n        recursive: true\n      });\n      zipFile.end(undefined, () => {\n        zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on('close', () => promise.resolve());\n      });\n      return promise;\n    }\n\n    // File already exists. Repack and add new entries.\n    const tempFile = params.zipFile + '.tmp';\n    await _fs.default.promises.rename(params.zipFile, tempFile);\n    _zipBundle.yauzl.open(tempFile, (err, inZipFile) => {\n      if (err) {\n        promise.reject(err);\n        return;\n      }\n      (0, _utils.assert)(inZipFile);\n      let pendingEntries = inZipFile.entryCount;\n      inZipFile.on('entry', entry => {\n        inZipFile.openReadStream(entry, (err, readStream) => {\n          if (err) {\n            promise.reject(err);\n            return;\n          }\n          zipFile.addReadStream(readStream, entry.fileName);\n          if (--pendingEntries === 0) {\n            zipFile.end(undefined, () => {\n              zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on('close', () => {\n                _fs.default.promises.unlink(tempFile).then(() => {\n                  promise.resolve();\n                });\n              });\n            });\n          }\n        });\n      });\n    });\n    return promise;\n  }\n  async harOpen(params, metadata) {\n    let harBackend;\n    if (params.file.endsWith('.zip')) {\n      const zipFile = new _zipFile.ZipFile(params.file);\n      const entryNames = await zipFile.entries();\n      const harEntryName = entryNames.find(e => e.endsWith('.har'));\n      if (!harEntryName) return {\n        error: 'Specified archive does not have a .har file'\n      };\n      const har = await zipFile.read(harEntryName);\n      const harFile = JSON.parse(har.toString());\n      harBackend = new HarBackend(harFile, null, zipFile);\n    } else {\n      const harFile = JSON.parse(await _fs.default.promises.readFile(params.file, 'utf-8'));\n      harBackend = new HarBackend(harFile, _path.default.dirname(params.file), null);\n    }\n    this._harBakends.set(harBackend.id, harBackend);\n    return {\n      harId: harBackend.id\n    };\n  }\n  async harLookup(params, metadata) {\n    const harBackend = this._harBakends.get(params.harId);\n    if (!harBackend) return {\n      action: 'error',\n      message: `Internal error: har was not opened`\n    };\n    return await harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest);\n  }\n  async harClose(params, metadata) {\n    const harBackend = this._harBakends.get(params.harId);\n    if (harBackend) {\n      this._harBakends.delete(harBackend.id);\n      harBackend.dispose();\n    }\n  }\n  async harUnzip(params, metadata) {\n    const dir = _path.default.dirname(params.zipFile);\n    const zipFile = new _zipFile.ZipFile(params.zipFile);\n    for (const entry of await zipFile.entries()) {\n      const buffer = await zipFile.read(entry);\n      if (entry === 'har.har') await _fs.default.promises.writeFile(params.harFile, buffer);else await _fs.default.promises.writeFile(_path.default.join(dir, entry), buffer);\n    }\n    zipFile.close();\n    await _fs.default.promises.unlink(params.zipFile);\n  }\n  async connect(params, metadata) {\n    const controller = new _progress.ProgressController(metadata, this._object);\n    controller.setLogName('browser');\n    return await controller.run(async progress => {\n      var _params$exposeNetwork;\n      const wsHeaders = {\n        'User-Agent': (0, _userAgent.getUserAgent)(),\n        'x-playwright-proxy': (_params$exposeNetwork = params.exposeNetwork) !== null && _params$exposeNetwork !== void 0 ? _params$exposeNetwork : '',\n        ...params.headers\n      };\n      const wsEndpoint = await urlToWSEndpoint(progress, params.wsEndpoint);\n      const transport = await _transport.WebSocketTransport.connect(progress, wsEndpoint, wsHeaders, true);\n      const socksInterceptor = new _socksInterceptor.SocksInterceptor(transport, params.exposeNetwork, params.socksProxyRedirectPortForTest);\n      const pipe = new _jsonPipeDispatcher.JsonPipeDispatcher(this);\n      transport.onmessage = json => {\n        if (socksInterceptor.interceptMessage(json)) return;\n        const cb = () => {\n          try {\n            pipe.dispatch(json);\n          } catch (e) {\n            transport.close();\n          }\n        };\n        if (params.slowMo) setTimeout(cb, params.slowMo);else cb();\n      };\n      pipe.on('message', message => {\n        transport.send(message);\n      });\n      transport.onclose = () => {\n        socksInterceptor === null || socksInterceptor === void 0 ? void 0 : socksInterceptor.cleanup();\n        pipe.wasClosed();\n      };\n      pipe.on('close', () => transport.close());\n      return {\n        pipe\n      };\n    }, params.timeout || 0);\n  }\n}\nexports.LocalUtilsDispatcher = LocalUtilsDispatcher;\nconst redirectStatus = [301, 302, 303, 307, 308];\nclass HarBackend {\n  constructor(harFile, baseDir, zipFile) {\n    this.id = (0, _utils.createGuid)();\n    this._harFile = void 0;\n    this._zipFile = void 0;\n    this._baseDir = void 0;\n    this._harFile = harFile;\n    this._baseDir = baseDir;\n    this._zipFile = zipFile;\n  }\n  async lookup(url, method, headers, postData, isNavigationRequest) {\n    let entry;\n    try {\n      entry = await this._harFindResponse(url, method, headers, postData);\n    } catch (e) {\n      return {\n        action: 'error',\n        message: 'HAR error: ' + e.message\n      };\n    }\n    if (!entry) return {\n      action: 'noentry'\n    };\n\n    // If navigation is being redirected, restart it with the final url to ensure the document's url changes.\n    if (entry.request.url !== url && isNavigationRequest) return {\n      action: 'redirect',\n      redirectURL: entry.request.url\n    };\n    const response = entry.response;\n    try {\n      const buffer = await this._loadContent(response.content);\n      return {\n        action: 'fulfill',\n        status: response.status,\n        headers: response.headers,\n        body: buffer\n      };\n    } catch (e) {\n      return {\n        action: 'error',\n        message: e.message\n      };\n    }\n  }\n  async _loadContent(content) {\n    const file = content._file;\n    let buffer;\n    if (file) {\n      if (this._zipFile) buffer = await this._zipFile.read(file);else buffer = await _fs.default.promises.readFile(_path.default.resolve(this._baseDir, file));\n    } else {\n      buffer = Buffer.from(content.text || '', content.encoding === 'base64' ? 'base64' : 'utf-8');\n    }\n    return buffer;\n  }\n  async _harFindResponse(url, method, headers, postData) {\n    const harLog = this._harFile.log;\n    const visited = new Set();\n    while (true) {\n      const entries = [];\n      for (const candidate of harLog.entries) {\n        if (candidate.request.url !== url || candidate.request.method !== method) continue;\n        if (method === 'POST' && postData && candidate.request.postData) {\n          const buffer = await this._loadContent(candidate.request.postData);\n          if (!buffer.equals(postData)) continue;\n        }\n        entries.push(candidate);\n      }\n      if (!entries.length) return;\n      let entry = entries[0];\n\n      // Disambiguate using headers - then one with most matching headers wins.\n      if (entries.length > 1) {\n        const list = [];\n        for (const candidate of entries) {\n          const matchingHeaders = countMatchingHeaders(candidate.request.headers, headers);\n          list.push({\n            candidate,\n            matchingHeaders\n          });\n        }\n        list.sort((a, b) => b.matchingHeaders - a.matchingHeaders);\n        entry = list[0].candidate;\n      }\n      if (visited.has(entry)) throw new Error(`Found redirect cycle for ${url}`);\n      visited.add(entry);\n\n      // Follow redirects.\n      const locationHeader = entry.response.headers.find(h => h.name.toLowerCase() === 'location');\n      if (redirectStatus.includes(entry.response.status) && locationHeader) {\n        const locationURL = new URL(locationHeader.value, url);\n        url = locationURL.toString();\n        if ((entry.response.status === 301 || entry.response.status === 302) && method === 'POST' || entry.response.status === 303 && !['GET', 'HEAD'].includes(method)) {\n          // HTTP-redirect fetch step 13 (https://fetch.spec.whatwg.org/#http-redirect-fetch)\n          method = 'GET';\n        }\n        continue;\n      }\n      return entry;\n    }\n  }\n  dispose() {\n    var _this$_zipFile;\n    (_this$_zipFile = this._zipFile) === null || _this$_zipFile === void 0 ? void 0 : _this$_zipFile.close();\n  }\n}\nfunction countMatchingHeaders(harHeaders, headers) {\n  const set = new Set(headers.map(h => h.name.toLowerCase() + ':' + h.value));\n  let matches = 0;\n  for (const h of harHeaders) {\n    if (set.has(h.name.toLowerCase() + ':' + h.value)) ++matches;\n  }\n  return matches;\n}\nasync function urlToWSEndpoint(progress, endpointURL) {\n  var _progress$timeUntilDe;\n  if (endpointURL.startsWith('ws')) return endpointURL;\n  progress === null || progress === void 0 ? void 0 : progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);\n  const fetchUrl = new URL(endpointURL);\n  if (!fetchUrl.pathname.endsWith('/')) fetchUrl.pathname += '/';\n  fetchUrl.pathname += 'json';\n  const json = await (0, _network.fetchData)({\n    url: fetchUrl.toString(),\n    method: 'GET',\n    timeout: (_progress$timeUntilDe = progress === null || progress === void 0 ? void 0 : progress.timeUntilDeadline()) !== null && _progress$timeUntilDe !== void 0 ? _progress$timeUntilDe : 30_000,\n    headers: {\n      'User-Agent': (0, _userAgent.getUserAgent)()\n    }\n  }, async (params, response) => {\n    return new Error(`Unexpected status ${response.statusCode} when connecting to ${fetchUrl.toString()}.\\n` + `This does not look like a Playwright server, try connecting via ws://.`);\n  });\n  progress === null || progress === void 0 ? void 0 : progress.throwIfAborted();\n  const wsUrl = new URL(endpointURL);\n  let wsEndpointPath = JSON.parse(json).wsEndpointPath;\n  if (wsEndpointPath.startsWith('/')) wsEndpointPath = wsEndpointPath.substring(1);\n  if (!wsUrl.pathname.endsWith('/')) wsUrl.pathname += '/';\n  wsUrl.pathname += wsEndpointPath;\n  wsUrl.protocol = wsUrl.protocol === 'https:' ? 'wss:' : 'ws:';\n  return wsUrl.toString();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketDispatcher = exports.RouteDispatcher = exports.ResponseDispatcher = exports.RequestDispatcher = exports.APIRequestContextDispatcher = void 0;\nvar _network = require(\"../network\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _tracingDispatcher = require(\"./tracingDispatcher\");\nvar _frameDispatcher = require(\"./frameDispatcher\");\nvar _pageDispatcher = require(\"./pageDispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass RequestDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, request) {\n    const result = (0, _dispatcher.existingDispatcher)(request);\n    return result || new RequestDispatcher(scope, request);\n  }\n  static fromNullable(scope, request) {\n    return request ? RequestDispatcher.from(scope, request) : undefined;\n  }\n  constructor(scope, request) {\n    const postData = request.postDataBuffer();\n    super(scope, request, 'Request', {\n      frame: _frameDispatcher.FrameDispatcher.fromNullable(scope, request.frame()),\n      serviceWorker: _pageDispatcher.WorkerDispatcher.fromNullable(scope, request.serviceWorker()),\n      url: request.url(),\n      resourceType: request.resourceType(),\n      method: request.method(),\n      postData: postData === null ? undefined : postData,\n      headers: request.headers(),\n      isNavigationRequest: request.isNavigationRequest(),\n      redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())\n    });\n    this._type_Request = void 0;\n    this._type_Request = true;\n  }\n  async rawRequestHeaders(params) {\n    return {\n      headers: await this._object.rawRequestHeaders()\n    };\n  }\n  async response() {\n    return {\n      response: ResponseDispatcher.fromNullable(this.parentScope(), await this._object.response())\n    };\n  }\n}\nexports.RequestDispatcher = RequestDispatcher;\nclass ResponseDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, response) {\n    const result = (0, _dispatcher.existingDispatcher)(response);\n    return result || new ResponseDispatcher(scope, response);\n  }\n  static fromNullable(scope, response) {\n    return response ? ResponseDispatcher.from(scope, response) : undefined;\n  }\n  constructor(scope, response) {\n    super(scope, response, 'Response', {\n      // TODO: responses in popups can point to non-reported requests.\n      request: RequestDispatcher.from(scope, response.request()),\n      url: response.url(),\n      status: response.status(),\n      statusText: response.statusText(),\n      headers: response.headers(),\n      timing: response.timing(),\n      fromServiceWorker: response.fromServiceWorker()\n    });\n    this._type_Response = true;\n  }\n  async body() {\n    return {\n      binary: await this._object.body()\n    };\n  }\n  async securityDetails() {\n    return {\n      value: (await this._object.securityDetails()) || undefined\n    };\n  }\n  async serverAddr() {\n    return {\n      value: (await this._object.serverAddr()) || undefined\n    };\n  }\n  async rawResponseHeaders(params) {\n    return {\n      headers: await this._object.rawResponseHeaders()\n    };\n  }\n  async sizes(params) {\n    return {\n      sizes: await this._object.sizes()\n    };\n  }\n}\nexports.ResponseDispatcher = ResponseDispatcher;\nclass RouteDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, route) {\n    const result = (0, _dispatcher.existingDispatcher)(route);\n    return result || new RouteDispatcher(scope, route);\n  }\n  constructor(scope, route) {\n    super(scope, route, 'Route', {\n      // Context route can point to a non-reported request.\n      request: scope\n    });\n    this._type_Route = true;\n  }\n  async continue(params, metadata) {\n    // Used to discriminate between continue in tracing.\n    metadata.params.requestUrl = this._object.request().url();\n    await this._object.continue({\n      url: params.url,\n      method: params.method,\n      headers: params.headers,\n      postData: params.postData\n    });\n  }\n  async fulfill(params, metadata) {\n    // Used to discriminate between fulfills in tracing.\n    metadata.params.requestUrl = this._object.request().url();\n    await this._object.fulfill(params);\n  }\n  async abort(params, metadata) {\n    // Used to discriminate between abort in tracing.\n    metadata.params.requestUrl = this._object.request().url();\n    await this._object.abort(params.errorCode || 'failed');\n  }\n  async redirectNavigationRequest(params) {\n    await this._object.redirectNavigationRequest(params.url);\n  }\n}\nexports.RouteDispatcher = RouteDispatcher;\nclass WebSocketDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, webSocket) {\n    super(scope, webSocket, 'WebSocket', {\n      url: webSocket.url()\n    });\n    this._type_EventTarget = true;\n    this._type_WebSocket = true;\n    this.addObjectListener(_network.WebSocket.Events.FrameSent, event => this._dispatchEvent('frameSent', event));\n    this.addObjectListener(_network.WebSocket.Events.FrameReceived, event => this._dispatchEvent('frameReceived', event));\n    this.addObjectListener(_network.WebSocket.Events.SocketError, error => this._dispatchEvent('socketError', {\n      error\n    }));\n    this.addObjectListener(_network.WebSocket.Events.Close, () => this._dispatchEvent('close', {}));\n  }\n}\nexports.WebSocketDispatcher = WebSocketDispatcher;\nclass APIRequestContextDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, request) {\n    const result = (0, _dispatcher.existingDispatcher)(request);\n    return result || new APIRequestContextDispatcher(scope, request);\n  }\n  static fromNullable(scope, request) {\n    return request ? APIRequestContextDispatcher.from(scope, request) : undefined;\n  }\n  constructor(parentScope, request) {\n    // We will reparent these to the context below.\n    const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, request.tracing());\n    super(parentScope, request, 'APIRequestContext', {\n      tracing\n    });\n    this._type_APIRequestContext = true;\n    this.adopt(tracing);\n  }\n  async storageState(params) {\n    return this._object.storageState();\n  }\n  async dispose(params) {\n    await this._object.dispose();\n  }\n  async fetch(params, metadata) {\n    const fetchResponse = await this._object.fetch(params, metadata);\n    return {\n      response: {\n        url: fetchResponse.url,\n        status: fetchResponse.status,\n        statusText: fetchResponse.statusText,\n        headers: fetchResponse.headers,\n        fetchUid: fetchResponse.fetchUid\n      }\n    };\n  }\n  async fetchResponseBody(params, metadata) {\n    return {\n      binary: this._object.fetchResponses.get(params.fetchUid)\n    };\n  }\n  async fetchLog(params, metadata) {\n    const log = this._object.fetchLog.get(params.fetchUid) || [];\n    return {\n      log\n    };\n  }\n  async disposeAPIResponse(params, metadata) {\n    this._object.disposeResponse(params.fetchUid);\n  }\n}\nexports.APIRequestContextDispatcher = APIRequestContextDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WorkerDispatcher = exports.PageDispatcher = exports.BindingCallDispatcher = void 0;\nvar _page = require(\"../page\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _serializers = require(\"../../protocol/serializers\");\nvar _consoleMessageDispatcher = require(\"./consoleMessageDispatcher\");\nvar _dialogDispatcher = require(\"./dialogDispatcher\");\nvar _frameDispatcher = require(\"./frameDispatcher\");\nvar _networkDispatchers = require(\"./networkDispatchers\");\nvar _jsHandleDispatcher = require(\"./jsHandleDispatcher\");\nvar _elementHandlerDispatcher = require(\"./elementHandlerDispatcher\");\nvar _artifactDispatcher = require(\"./artifactDispatcher\");\nvar _utils = require(\"../../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass PageDispatcher extends _dispatcher.Dispatcher {\n  static from(parentScope, page) {\n    return PageDispatcher.fromNullable(parentScope, page);\n  }\n  static fromNullable(parentScope, page) {\n    if (!page) return undefined;\n    const result = (0, _dispatcher.existingDispatcher)(page);\n    return result || new PageDispatcher(parentScope, page);\n  }\n  constructor(parentScope, page) {\n    // TODO: theoretically, there could be more than one frame already.\n    // If we split pageCreated and pageReady, there should be no main frame during pageCreated.\n\n    // We will reparent it to the page below using adopt.\n    const mainFrame = _frameDispatcher.FrameDispatcher.from(parentScope, page.mainFrame());\n    super(parentScope, page, 'Page', {\n      mainFrame,\n      viewportSize: page.viewportSize() || undefined,\n      isClosed: page.isClosed(),\n      opener: PageDispatcher.fromNullable(parentScope, page.opener())\n    });\n    this._type_EventTarget = true;\n    this._type_Page = true;\n    this._page = void 0;\n    this._subscriptions = new Set();\n    this.adopt(mainFrame);\n    this._page = page;\n    this.addObjectListener(_page.Page.Events.Close, () => {\n      this._dispatchEvent('close');\n      this._dispose();\n    });\n    this.addObjectListener(_page.Page.Events.Console, message => this._dispatchEvent('console', {\n      message: new _consoleMessageDispatcher.ConsoleMessageDispatcher(this, message)\n    }));\n    this.addObjectListener(_page.Page.Events.Crash, () => this._dispatchEvent('crash'));\n    this.addObjectListener(_page.Page.Events.Dialog, dialog => this._dispatchEvent('dialog', {\n      dialog: new _dialogDispatcher.DialogDispatcher(this, dialog)\n    }));\n    this.addObjectListener(_page.Page.Events.Download, download => {\n      // Artifact can outlive the page, so bind to the context scope.\n      this._dispatchEvent('download', {\n        url: download.url,\n        suggestedFilename: download.suggestedFilename(),\n        artifact: _artifactDispatcher.ArtifactDispatcher.from(parentScope, download.artifact)\n      });\n    });\n    this.addObjectListener(_page.Page.Events.FileChooser, fileChooser => this._dispatchEvent('fileChooser', {\n      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this, fileChooser.element()),\n      isMultiple: fileChooser.isMultiple()\n    }));\n    this.addObjectListener(_page.Page.Events.FrameAttached, frame => this._onFrameAttached(frame));\n    this.addObjectListener(_page.Page.Events.FrameDetached, frame => this._onFrameDetached(frame));\n    this.addObjectListener(_page.Page.Events.PageError, error => this._dispatchEvent('pageError', {\n      error: (0, _serializers.serializeError)(error)\n    }));\n    this.addObjectListener(_page.Page.Events.WebSocket, webSocket => this._dispatchEvent('webSocket', {\n      webSocket: new _networkDispatchers.WebSocketDispatcher(this, webSocket)\n    }));\n    this.addObjectListener(_page.Page.Events.Worker, worker => this._dispatchEvent('worker', {\n      worker: new WorkerDispatcher(this, worker)\n    }));\n    this.addObjectListener(_page.Page.Events.Video, artifact => this._dispatchEvent('video', {\n      artifact: _artifactDispatcher.ArtifactDispatcher.from(parentScope, artifact)\n    }));\n    if (page._video) this._dispatchEvent('video', {\n      artifact: _artifactDispatcher.ArtifactDispatcher.from(this.parentScope(), page._video)\n    });\n    // Ensure client knows about all frames.\n    const frames = page._frameManager.frames();\n    for (let i = 1; i < frames.length; i++) this._onFrameAttached(frames[i]);\n  }\n  page() {\n    return this._page;\n  }\n  async setDefaultNavigationTimeoutNoReply(params, metadata) {\n    this._page.setDefaultNavigationTimeout(params.timeout);\n  }\n  async setDefaultTimeoutNoReply(params, metadata) {\n    this._page.setDefaultTimeout(params.timeout);\n  }\n  async exposeBinding(params, metadata) {\n    await this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {\n      const binding = new BindingCallDispatcher(this, params.name, !!params.needsHandle, source, args);\n      this._dispatchEvent('bindingCall', {\n        binding\n      });\n      return binding.promise();\n    });\n  }\n  async setExtraHTTPHeaders(params, metadata) {\n    await this._page.setExtraHTTPHeaders(params.headers);\n  }\n  async reload(params, metadata) {\n    return {\n      response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope(), await this._page.reload(metadata, params))\n    };\n  }\n  async goBack(params, metadata) {\n    return {\n      response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope(), await this._page.goBack(metadata, params))\n    };\n  }\n  async goForward(params, metadata) {\n    return {\n      response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope(), await this._page.goForward(metadata, params))\n    };\n  }\n  async emulateMedia(params, metadata) {\n    await this._page.emulateMedia({\n      media: params.media,\n      colorScheme: params.colorScheme,\n      reducedMotion: params.reducedMotion,\n      forcedColors: params.forcedColors\n    });\n  }\n  async setViewportSize(params, metadata) {\n    await this._page.setViewportSize(params.viewportSize);\n  }\n  async addInitScript(params, metadata) {\n    await this._page.addInitScript(params.source);\n  }\n  async setNetworkInterceptionPatterns(params, metadata) {\n    if (!params.patterns.length) {\n      await this._page.setClientRequestInterceptor(undefined);\n      return;\n    }\n    const urlMatchers = params.patterns.map(pattern => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);\n    await this._page.setClientRequestInterceptor((route, request) => {\n      const matchesSome = urlMatchers.some(urlMatch => (0, _utils.urlMatches)(this._page._browserContext._options.baseURL, request.url(), urlMatch));\n      if (!matchesSome) return false;\n      this._dispatchEvent('route', {\n        route: _networkDispatchers.RouteDispatcher.from(_networkDispatchers.RequestDispatcher.from(this.parentScope(), request), route)\n      });\n      return true;\n    });\n  }\n  async expectScreenshot(params, metadata) {\n    var _params$screenshotOpt, _params$comparatorOpt;\n    const mask = (((_params$screenshotOpt = params.screenshotOptions) === null || _params$screenshotOpt === void 0 ? void 0 : _params$screenshotOpt.mask) || []).map(({\n      frame,\n      selector\n    }) => ({\n      frame: frame._object,\n      selector\n    }));\n    const locator = params.locator ? {\n      frame: params.locator.frame._object,\n      selector: params.locator.selector\n    } : undefined;\n    return await this._page.expectScreenshot(metadata, {\n      ...params,\n      locator,\n      comparatorOptions: {\n        ...params.comparatorOptions,\n        _comparator: (_params$comparatorOpt = params.comparatorOptions) === null || _params$comparatorOpt === void 0 ? void 0 : _params$comparatorOpt.comparator\n      },\n      screenshotOptions: {\n        ...params.screenshotOptions,\n        mask\n      }\n    });\n  }\n  async screenshot(params, metadata) {\n    const mask = (params.mask || []).map(({\n      frame,\n      selector\n    }) => ({\n      frame: frame._object,\n      selector\n    }));\n    return {\n      binary: await this._page.screenshot(metadata, {\n        ...params,\n        mask\n      })\n    };\n  }\n  async close(params, metadata) {\n    await this._page.close(metadata, params);\n  }\n  async updateSubscription(params, metadata) {\n    if (params.event === 'fileChooser') await this._page.setFileChooserIntercepted(params.enabled);\n    if (params.enabled) this._subscriptions.add(params.event);else this._subscriptions.delete(params.event);\n  }\n  async keyboardDown(params, metadata) {\n    await this._page.keyboard.down(params.key);\n  }\n  async keyboardUp(params, metadata) {\n    await this._page.keyboard.up(params.key);\n  }\n  async keyboardInsertText(params, metadata) {\n    await this._page.keyboard.insertText(params.text);\n  }\n  async keyboardType(params, metadata) {\n    await this._page.keyboard.type(params.text, params);\n  }\n  async keyboardPress(params, metadata) {\n    await this._page.keyboard.press(params.key, params);\n  }\n  async mouseMove(params, metadata) {\n    await this._page.mouse.move(params.x, params.y, params);\n  }\n  async mouseDown(params, metadata) {\n    await this._page.mouse.down(params);\n  }\n  async mouseUp(params, metadata) {\n    await this._page.mouse.up(params);\n  }\n  async mouseClick(params, metadata) {\n    await this._page.mouse.click(params.x, params.y, params);\n  }\n  async mouseWheel(params, metadata) {\n    await this._page.mouse.wheel(params.deltaX, params.deltaY);\n  }\n  async touchscreenTap(params, metadata) {\n    await this._page.touchscreen.tap(params.x, params.y);\n  }\n  async accessibilitySnapshot(params, metadata) {\n    const rootAXNode = await this._page.accessibility.snapshot({\n      interestingOnly: params.interestingOnly,\n      root: params.root ? params.root._elementHandle : undefined\n    });\n    return {\n      rootAXNode: rootAXNode || undefined\n    };\n  }\n  async pdf(params, metadata) {\n    if (!this._page.pdf) throw new Error('PDF generation is only supported for Headless Chromium');\n    const buffer = await this._page.pdf(params);\n    return {\n      pdf: buffer\n    };\n  }\n  async bringToFront(params, metadata) {\n    await this._page.bringToFront();\n  }\n  async startJSCoverage(params, metadata) {\n    const coverage = this._page.coverage;\n    await coverage.startJSCoverage(params);\n  }\n  async stopJSCoverage(params, metadata) {\n    const coverage = this._page.coverage;\n    return await coverage.stopJSCoverage();\n  }\n  async startCSSCoverage(params, metadata) {\n    const coverage = this._page.coverage;\n    await coverage.startCSSCoverage(params);\n  }\n  async stopCSSCoverage(params, metadata) {\n    const coverage = this._page.coverage;\n    return await coverage.stopCSSCoverage();\n  }\n  _onFrameAttached(frame) {\n    this._dispatchEvent('frameAttached', {\n      frame: _frameDispatcher.FrameDispatcher.from(this, frame)\n    });\n  }\n  _onFrameDetached(frame) {\n    this._dispatchEvent('frameDetached', {\n      frame: _frameDispatcher.FrameDispatcher.from(this, frame)\n    });\n  }\n  _onDispose() {\n    // Avoid protocol calls for the closed page.\n    if (!this._page.isClosedOrClosingOrCrashed()) this._page.setClientRequestInterceptor(undefined).catch(() => {});\n  }\n}\nexports.PageDispatcher = PageDispatcher;\nclass WorkerDispatcher extends _dispatcher.Dispatcher {\n  static fromNullable(scope, worker) {\n    if (!worker) return undefined;\n    const result = (0, _dispatcher.existingDispatcher)(worker);\n    return result || new WorkerDispatcher(scope, worker);\n  }\n  constructor(scope, worker) {\n    super(scope, worker, 'Worker', {\n      url: worker.url()\n    });\n    this._type_Worker = true;\n    this.addObjectListener(_page.Worker.Events.Close, () => this._dispatchEvent('close'));\n  }\n  async evaluateExpression(params, metadata) {\n    return {\n      value: (0, _jsHandleDispatcher.serializeResult)(await this._object.evaluateExpression(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n  async evaluateExpressionHandle(params, metadata) {\n    return {\n      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))\n    };\n  }\n}\nexports.WorkerDispatcher = WorkerDispatcher;\nclass BindingCallDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, name, needsHandle, source, args) {\n    super(scope, {\n      guid: 'bindingCall@' + (0, _utils.createGuid)()\n    }, 'BindingCall', {\n      frame: _frameDispatcher.FrameDispatcher.from(scope, source.frame),\n      name,\n      args: needsHandle ? undefined : args.map(_jsHandleDispatcher.serializeResult),\n      handle: needsHandle ? _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : undefined\n    });\n    this._type_BindingCall = true;\n    this._resolve = void 0;\n    this._reject = void 0;\n    this._promise = void 0;\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n  promise() {\n    return this._promise;\n  }\n  async resolve(params, metadata) {\n    this._resolve((0, _jsHandleDispatcher.parseArgument)(params.result));\n  }\n  async reject(params, metadata) {\n    this._reject((0, _serializers.parseError)(params.error));\n  }\n}\nexports.BindingCallDispatcher = BindingCallDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PlaywrightDispatcher = void 0;\nvar _fetch = require(\"../fetch\");\nvar _socksProxy = require(\"../../common/socksProxy\");\nvar _androidDispatcher = require(\"./androidDispatcher\");\nvar _browserTypeDispatcher = require(\"./browserTypeDispatcher\");\nvar _dispatcher = require(\"./dispatcher\");\nvar _electronDispatcher = require(\"./electronDispatcher\");\nvar _localUtilsDispatcher = require(\"./localUtilsDispatcher\");\nvar _networkDispatchers = require(\"./networkDispatchers\");\nvar _selectorsDispatcher = require(\"./selectorsDispatcher\");\nvar _browserDispatcher = require(\"./browserDispatcher\");\nvar _utils = require(\"../../utils\");\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass PlaywrightDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, playwright, socksProxy, preLaunchedBrowser, prelaunchedAndroidDevice) {\n    const descriptors = require('../deviceDescriptors');\n    const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({\n      name,\n      descriptor\n    }));\n    const browserDispatcher = preLaunchedBrowser ? new _browserDispatcher.ConnectedBrowserDispatcher(scope, preLaunchedBrowser) : undefined;\n    const android = new _androidDispatcher.AndroidDispatcher(scope, playwright.android);\n    const prelaunchedAndroidDeviceDispatcher = prelaunchedAndroidDevice ? new _androidDispatcher.AndroidDeviceDispatcher(android, prelaunchedAndroidDevice) : undefined;\n    super(scope, playwright, 'Playwright', {\n      chromium: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.chromium),\n      firefox: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.firefox),\n      webkit: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.webkit),\n      android,\n      electron: new _electronDispatcher.ElectronDispatcher(scope, playwright.electron),\n      utils: new _localUtilsDispatcher.LocalUtilsDispatcher(scope, playwright),\n      deviceDescriptors,\n      selectors: new _selectorsDispatcher.SelectorsDispatcher(scope, (browserDispatcher === null || browserDispatcher === void 0 ? void 0 : browserDispatcher.selectors) || playwright.selectors),\n      preLaunchedBrowser: browserDispatcher,\n      preConnectedAndroidDevice: prelaunchedAndroidDeviceDispatcher,\n      socksSupport: socksProxy ? new SocksSupportDispatcher(scope, socksProxy) : undefined\n    });\n    this._type_Playwright = void 0;\n    this._browserDispatcher = void 0;\n    this._type_Playwright = true;\n    this._browserDispatcher = browserDispatcher;\n  }\n  async newRequest(params, metadata) {\n    const request = new _fetch.GlobalAPIRequestContext(this._object, params);\n    return {\n      request: _networkDispatchers.APIRequestContextDispatcher.from(this.parentScope(), request)\n    };\n  }\n  async cleanup() {\n    var _this$_browserDispatc;\n    // Cleanup contexts upon disconnect.\n    await ((_this$_browserDispatc = this._browserDispatcher) === null || _this$_browserDispatc === void 0 ? void 0 : _this$_browserDispatc.cleanupContexts());\n  }\n}\nexports.PlaywrightDispatcher = PlaywrightDispatcher;\nclass SocksSupportDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, socksProxy) {\n    super(scope, {\n      guid: 'socksSupport@' + (0, _utils.createGuid)()\n    }, 'SocksSupport', {});\n    this._type_SocksSupport = void 0;\n    this._socksProxy = void 0;\n    this._socksListeners = void 0;\n    this._type_SocksSupport = true;\n    this._socksProxy = socksProxy;\n    this._socksListeners = [_eventsHelper.eventsHelper.addEventListener(socksProxy, _socksProxy.SocksProxy.Events.SocksRequested, payload => this._dispatchEvent('socksRequested', payload)), _eventsHelper.eventsHelper.addEventListener(socksProxy, _socksProxy.SocksProxy.Events.SocksData, payload => this._dispatchEvent('socksData', payload)), _eventsHelper.eventsHelper.addEventListener(socksProxy, _socksProxy.SocksProxy.Events.SocksClosed, payload => this._dispatchEvent('socksClosed', payload))];\n  }\n  async socksConnected(params) {\n    var _this$_socksProxy;\n    (_this$_socksProxy = this._socksProxy) === null || _this$_socksProxy === void 0 ? void 0 : _this$_socksProxy.socketConnected(params);\n  }\n  async socksFailed(params) {\n    var _this$_socksProxy2;\n    (_this$_socksProxy2 = this._socksProxy) === null || _this$_socksProxy2 === void 0 ? void 0 : _this$_socksProxy2.socketFailed(params);\n  }\n  async socksData(params) {\n    var _this$_socksProxy3;\n    (_this$_socksProxy3 = this._socksProxy) === null || _this$_socksProxy3 === void 0 ? void 0 : _this$_socksProxy3.sendSocketData(params);\n  }\n  async socksError(params) {\n    var _this$_socksProxy4;\n    (_this$_socksProxy4 = this._socksProxy) === null || _this$_socksProxy4 === void 0 ? void 0 : _this$_socksProxy4.sendSocketError(params);\n  }\n  async socksEnd(params) {\n    var _this$_socksProxy5;\n    (_this$_socksProxy5 = this._socksProxy) === null || _this$_socksProxy5 === void 0 ? void 0 : _this$_socksProxy5.sendSocketEnd(params);\n  }\n  _onDispose() {\n    _eventsHelper.eventsHelper.removeEventListeners(this._socksListeners);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SelectorsDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass SelectorsDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, selectors) {\n    super(scope, selectors, 'Selectors', {});\n    this._type_Selectors = true;\n  }\n  async register(params) {\n    await this._object.register(params.name, params.source, params.contentScript);\n  }\n  async setTestIdAttributeName(params, metadata) {\n    this._object.setTestIdAttributeName(params.testIdAttributeName);\n  }\n}\nexports.SelectorsDispatcher = SelectorsDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _utils = require(\"../../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass StreamDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, stream) {\n    super(scope, {\n      guid: 'stream@' + (0, _utils.createGuid)(),\n      stream\n    }, 'Stream', {});\n    // In Node v12.9.0+ we can use readableEnded.\n    this._type_Stream = true;\n    this._ended = false;\n    stream.once('end', () => this._ended = true);\n    stream.once('error', () => this._ended = true);\n  }\n  async read(params) {\n    const stream = this._object.stream;\n    if (this._ended) return {\n      binary: Buffer.from('')\n    };\n    if (!stream.readableLength) {\n      await new Promise((fulfill, reject) => {\n        stream.once('readable', fulfill);\n        stream.once('end', fulfill);\n        stream.once('error', reject);\n      });\n    }\n    const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));\n    return {\n      binary: buffer || Buffer.from('')\n    };\n  }\n  async close() {\n    this._object.stream.destroy();\n  }\n}\nexports.StreamDispatcher = StreamDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TracingDispatcher = void 0;\nvar _artifactDispatcher = require(\"./artifactDispatcher\");\nvar _dispatcher = require(\"./dispatcher\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass TracingDispatcher extends _dispatcher.Dispatcher {\n  static from(scope, tracing) {\n    const result = (0, _dispatcher.existingDispatcher)(tracing);\n    return result || new TracingDispatcher(scope, tracing);\n  }\n  constructor(scope, tracing) {\n    super(scope, tracing, 'Tracing', {});\n    this._type_Tracing = true;\n  }\n  async tracingStart(params) {\n    await this._object.start(params);\n  }\n  async tracingStartChunk(params) {\n    await this._object.startChunk(params);\n  }\n  async tracingStopChunk(params) {\n    const {\n      artifact,\n      sourceEntries\n    } = await this._object.stopChunk(params);\n    return {\n      artifact: artifact ? _artifactDispatcher.ArtifactDispatcher.from(this, artifact) : undefined,\n      sourceEntries\n    };\n  }\n  async tracingStop(params) {\n    await this._object.stop();\n  }\n}\nexports.TracingDispatcher = TracingDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WritableStreamDispatcher = void 0;\nvar _dispatcher = require(\"./dispatcher\");\nvar _utils = require(\"../../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WritableStreamDispatcher extends _dispatcher.Dispatcher {\n  constructor(scope, stream) {\n    super(scope, {\n      guid: 'writableStream@' + (0, _utils.createGuid)(),\n      stream\n    }, 'WritableStream', {});\n    this._type_WritableStream = true;\n  }\n  async write(params) {\n    const stream = this._object.stream;\n    await new Promise((fulfill, reject) => {\n      stream.write(params.binary, error => {\n        if (error) reject(error);else fulfill();\n      });\n    });\n  }\n  async close() {\n    const stream = this._object.stream;\n    await new Promise(fulfill => stream.end(fulfill));\n  }\n  path() {\n    return this._object.stream.path;\n  }\n}\nexports.WritableStreamDispatcher = WritableStreamDispatcher;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NonRecoverableDOMError = exports.InjectedScriptPollHandler = exports.FrameExecutionContext = exports.ElementHandle = void 0;\nexports.assertDone = assertDone;\nexports.isNonRecoverableDOMError = isNonRecoverableDOMError;\nexports.kUnableToAdoptErrorMessage = void 0;\nexports.throwRetargetableDOMError = throwRetargetableDOMError;\nvar _utilsBundle = require(\"../utilsBundle\");\nvar injectedScriptSource = _interopRequireWildcard(require(\"../generated/injectedScriptSource\"));\nvar _protocolError = require(\"./protocolError\");\nvar js = _interopRequireWildcard(require(\"./javascript\"));\nvar _progress = require(\"./progress\");\nvar _utils = require(\"../utils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass NonRecoverableDOMError extends Error {}\nexports.NonRecoverableDOMError = NonRecoverableDOMError;\nfunction isNonRecoverableDOMError(error) {\n  return error instanceof NonRecoverableDOMError;\n}\nclass FrameExecutionContext extends js.ExecutionContext {\n  constructor(delegate, frame, world) {\n    super(frame, delegate);\n    this.frame = void 0;\n    this._injectedScriptPromise = void 0;\n    this.world = void 0;\n    this.frame = frame;\n    this.world = world;\n  }\n  async waitForSignalsCreatedBy(action) {\n    return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);\n  }\n  adoptIfNeeded(handle) {\n    if (handle instanceof ElementHandle && handle._context !== this) return this.frame._page._delegate.adoptElementHandle(handle, this);\n    return null;\n  }\n  async evaluate(pageFunction, arg) {\n    return js.evaluate(this, true /* returnByValue */, pageFunction, arg);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    return js.evaluate(this, false /* returnByValue */, pageFunction, arg);\n  }\n  async evaluateExpression(expression, options, arg) {\n    return js.evaluateExpression(this, expression, {\n      ...options,\n      returnByValue: true\n    }, arg);\n  }\n  async evaluateExpressionAndWaitForSignals(expression, options, arg) {\n    return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {\n      return this.evaluateExpression(expression, options, arg);\n    });\n  }\n  async evaluateExpressionHandleAndWaitForSignals(expression, options, arg) {\n    return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {\n      return js.evaluateExpression(this, expression, {\n        ...options,\n        returnByValue: false\n      }, arg);\n    });\n  }\n  createHandle(remoteObject) {\n    if (this.frame._page._delegate.isElementHandle(remoteObject)) return new ElementHandle(this, remoteObject.objectId);\n    return super.createHandle(remoteObject);\n  }\n  injectedScript() {\n    if (!this._injectedScriptPromise) {\n      const custom = [];\n      for (const [name, {\n        source\n      }] of this.frame._page.selectors._engines) custom.push(`{ name: '${name}', engine: (${source}) }`);\n      const sdkLanguage = this.frame._page.context()._browser.options.sdkLanguage;\n      const source = `\n        (() => {\n        const module = {};\n        ${injectedScriptSource.source}\n        return new module.exports(\n          ${(0, _utils.isUnderTest)()},\n          \"${sdkLanguage}\",\n          ${JSON.stringify(this.frame._page.selectors.testIdAttributeName())},\n          ${this.frame._page._delegate.rafCountForStablePosition()},\n          \"${this.frame._page._browserContext._browser.options.name}\",\n          [${custom.join(',\\n')}]\n        );\n        })();\n      `;\n      this._injectedScriptPromise = this.rawEvaluateHandle(source).then(objectId => new js.JSHandle(this, 'object', undefined, objectId));\n    }\n    return this._injectedScriptPromise;\n  }\n}\nexports.FrameExecutionContext = FrameExecutionContext;\nclass ElementHandle extends js.JSHandle {\n  constructor(context, objectId) {\n    super(context, 'node', undefined, objectId);\n    this.__elementhandle = true;\n    this._page = void 0;\n    this._frame = void 0;\n    this._page = context.frame._page;\n    this._frame = context.frame;\n    this._initializePreview().catch(e => {});\n  }\n  async _initializePreview() {\n    const utility = await this._context.injectedScript();\n    this._setPreview(await utility.evaluate((injected, e) => 'JSHandle@' + injected.previewNode(e), this));\n  }\n  asElement() {\n    return this;\n  }\n  async evaluateInUtility(pageFunction, arg) {\n    try {\n      const utility = await this._frame._utilityContext();\n      return await utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);\n    } catch (e) {\n      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;\n      return 'error:notconnected';\n    }\n  }\n  async evaluateHandleInUtility(pageFunction, arg) {\n    try {\n      const utility = await this._frame._utilityContext();\n      return await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);\n    } catch (e) {\n      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;\n      return 'error:notconnected';\n    }\n  }\n  async evaluatePoll(progress, pageFunction, arg) {\n    try {\n      const utility = await this._frame._utilityContext();\n      const poll = await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);\n      const pollHandler = new InjectedScriptPollHandler(progress, poll);\n      return await pollHandler.finish();\n    } catch (e) {\n      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;\n      return 'error:notconnected';\n    }\n  }\n  async ownerFrame() {\n    const frameId = await this._page._delegate.getOwnerFrame(this);\n    if (!frameId) return null;\n    const frame = this._page._frameManager.frame(frameId);\n    if (frame) return frame;\n    for (const page of this._page._browserContext.pages()) {\n      const frame = page._frameManager.frame(frameId);\n      if (frame) return frame;\n    }\n    return null;\n  }\n  async isIframeElement() {\n    return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'), {});\n  }\n  async contentFrame() {\n    const isFrameElement = throwRetargetableDOMError(await this.isIframeElement());\n    if (!isFrameElement) return null;\n    return this._page._delegate.getContentFrame(this);\n  }\n  async getAttribute(name) {\n    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node, name]) => {\n      if (node.nodeType !== Node.ELEMENT_NODE) throw injected.createStacklessError('Node is not an element');\n      const element = node;\n      return {\n        value: element.getAttribute(name)\n      };\n    }, name)).value;\n  }\n  async inputValue() {\n    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {\n      const element = injected.retarget(node, 'follow-label');\n      if (!element || element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA' && element.nodeName !== 'SELECT') throw injected.createStacklessError('Node is not an <input>, <textarea> or <select> element');\n      return {\n        value: element.value\n      };\n    }, undefined)).value;\n  }\n  async textContent() {\n    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {\n      return {\n        value: node.textContent\n      };\n    }, undefined)).value;\n  }\n  async innerText() {\n    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {\n      if (node.nodeType !== Node.ELEMENT_NODE) throw injected.createStacklessError('Node is not an element');\n      if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml') throw injected.createStacklessError('Node is not an HTMLElement');\n      const element = node;\n      return {\n        value: element.innerText\n      };\n    }, undefined)).value;\n  }\n  async innerHTML() {\n    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {\n      if (node.nodeType !== Node.ELEMENT_NODE) throw injected.createStacklessError('Node is not an element');\n      const element = node;\n      return {\n        value: element.innerHTML\n      };\n    }, undefined)).value;\n  }\n  async dispatchEvent(type, eventInit = {}) {\n    const main = await this._frame._mainContext();\n    await this._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {\n      return main.evaluate(([injected, node, {\n        type,\n        eventInit\n      }]) => injected.dispatchEvent(node, type, eventInit), [await main.injectedScript(), this, {\n        type,\n        eventInit\n      }]);\n    });\n  }\n  async _scrollRectIntoViewIfNeeded(rect) {\n    return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);\n  }\n  async _waitAndScrollIntoViewIfNeeded(progress, waitForVisible) {\n    const timeouts = [0, 50, 100, 250];\n    while (progress.isRunning()) {\n      assertDone(throwRetargetableDOMError(await this._waitForElementStates(progress, waitForVisible ? ['visible', 'stable'] : ['stable'], false /* force */)));\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      const result = throwRetargetableDOMError(await this._scrollRectIntoViewIfNeeded());\n      if (result === 'error:notvisible') {\n        if (!waitForVisible) {\n          var _timeouts$shift;\n          // Wait for a timeout to avoid retrying too often when not waiting for visible.\n          // If we wait for visible, this should be covered by _waitForElementStates instead.\n          const timeout = (_timeouts$shift = timeouts.shift()) !== null && _timeouts$shift !== void 0 ? _timeouts$shift : 500;\n          progress.log(`  element is not displayed, retrying in ${timeout}ms`);\n          await new Promise(f => setTimeout(f, timeout));\n        }\n        continue;\n      }\n      assertDone(result);\n      return;\n    }\n  }\n  async scrollIntoViewIfNeeded(metadata, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this._waitAndScrollIntoViewIfNeeded(progress, false /* waitForVisible */), this._page._timeoutSettings.timeout(options));\n  }\n  async _clickablePoint() {\n    const intersectQuadWithViewport = quad => {\n      return quad.map(point => ({\n        x: Math.min(Math.max(point.x, 0), metrics.width),\n        y: Math.min(Math.max(point.y, 0), metrics.height)\n      }));\n    };\n    const computeQuadArea = quad => {\n      // Compute sum of all directed areas of adjacent triangles\n      // https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n      let area = 0;\n      for (let i = 0; i < quad.length; ++i) {\n        const p1 = quad[i];\n        const p2 = quad[(i + 1) % quad.length];\n        area += (p1.x * p2.y - p2.x * p1.y) / 2;\n      }\n      return Math.abs(area);\n    };\n    const [quads, metrics] = await Promise.all([this._page._delegate.getContentQuads(this), this._page.mainFrame()._utilityContext().then(utility => utility.evaluate(() => ({\n      width: innerWidth,\n      height: innerHeight\n    })))]);\n    if (!quads || !quads.length) return 'error:notvisible';\n\n    // Allow 1x1 elements. Compensate for rounding errors by comparing with 0.99 instead.\n    const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 0.99);\n    if (!filtered.length) return 'error:notinviewport';\n    // Return the middle point of the first quad.\n    const result = {\n      x: 0,\n      y: 0\n    };\n    for (const point of filtered[0]) {\n      result.x += point.x / 4;\n      result.y += point.y / 4;\n    }\n    compensateHalfIntegerRoundingError(result);\n    return result;\n  }\n  async _offsetPoint(offset) {\n    const [box, border] = await Promise.all([this.boundingBox(), this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch(e => {})]);\n    if (!box || !border) return 'error:notvisible';\n    if (border === 'error:notconnected') return border;\n    // Make point relative to the padding box to align with offsetX/offsetY.\n    return {\n      x: box.x + border.left + offset.x,\n      y: box.y + border.top + offset.y\n    };\n  }\n  async _retryPointerAction(progress, actionName, waitForEnabled, action, options) {\n    let retry = 0;\n    // We progressively wait longer between retries, up to 500ms.\n    const waitTime = [0, 20, 100, 100, 500];\n\n    // By default, we scroll with protocol method to reveal the action point.\n    // However, that might not work to scroll from under position:sticky elements\n    // that overlay the target element. To fight this, we cycle through different\n    // scroll alignments. This works in most scenarios.\n    const scrollOptions = [undefined, {\n      block: 'end',\n      inline: 'end'\n    }, {\n      block: 'center',\n      inline: 'center'\n    }, {\n      block: 'start',\n      inline: 'start'\n    }];\n    while (progress.isRunning()) {\n      if (retry) {\n        progress.log(`retrying ${actionName} action${options.trial ? ' (trial run)' : ''}, attempt #${retry}`);\n        const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];\n        if (timeout) {\n          progress.log(`  waiting ${timeout}ms`);\n          const result = await this.evaluateInUtility(([injected, node, timeout]) => new Promise(f => setTimeout(f, timeout)), timeout);\n          if (result === 'error:notconnected') return result;\n        }\n      } else {\n        progress.log(`attempting ${actionName} action${options.trial ? ' (trial run)' : ''}`);\n      }\n      const forceScrollOptions = scrollOptions[retry % scrollOptions.length];\n      const result = await this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options);\n      ++retry;\n      if (result === 'error:notvisible') {\n        if (options.force) throw new NonRecoverableDOMError('Element is not visible');\n        progress.log('  element is not visible');\n        continue;\n      }\n      if (result === 'error:notinviewport') {\n        if (options.force) throw new NonRecoverableDOMError('Element is outside of the viewport');\n        progress.log('  element is outside of the viewport');\n        continue;\n      }\n      if (typeof result === 'object' && 'hitTargetDescription' in result) {\n        progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);\n        continue;\n      }\n      return result;\n    }\n    return 'done';\n  }\n  async _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options) {\n    const {\n      force = false,\n      position\n    } = options;\n    if (options.__testHookBeforeStable) await options.__testHookBeforeStable();\n    const result = await this._waitForElementStates(progress, waitForEnabled ? ['visible', 'enabled', 'stable'] : ['visible', 'stable'], force);\n    if (result !== 'done') return result;\n    if (options.__testHookAfterStable) await options.__testHookAfterStable();\n    progress.log('  scrolling into view if needed');\n    progress.throwIfAborted(); // Avoid action that has side-effects.\n    if (forceScrollOptions) {\n      const scrolled = await this.evaluateInUtility(([injected, node, options]) => {\n        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) node.scrollIntoView(options);\n      }, forceScrollOptions);\n      if (scrolled === 'error:notconnected') return scrolled;\n    } else {\n      const scrolled = await this._scrollRectIntoViewIfNeeded(position ? {\n        x: position.x,\n        y: position.y,\n        width: 0,\n        height: 0\n      } : undefined);\n      if (scrolled !== 'done') return scrolled;\n    }\n    progress.log('  done scrolling');\n    const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();\n    if (typeof maybePoint === 'string') return maybePoint;\n    const point = roundPoint(maybePoint);\n    progress.metadata.point = point;\n    await progress.beforeInputAction(this);\n    let hitTargetInterceptionHandle;\n    if (!options.force) {\n      if (options.__testHookBeforeHitTarget) await options.__testHookBeforeHitTarget();\n      const frameCheckResult = await this._checkFrameIsHitTarget(point);\n      if (frameCheckResult === 'error:notconnected' || 'hitTargetDescription' in frameCheckResult) return frameCheckResult;\n      const hitPoint = frameCheckResult.framePoint;\n      const actionType = actionName === 'move and up' ? 'drag' : actionName === 'hover' || actionName === 'tap' ? actionName : 'mouse';\n      const handle = await this.evaluateHandleInUtility(([injected, node, {\n        actionType,\n        hitPoint,\n        trial\n      }]) => injected.setupHitTargetInterceptor(node, actionType, hitPoint, trial), {\n        actionType,\n        hitPoint,\n        trial: !!options.trial\n      });\n      if (handle === 'error:notconnected') return handle;\n      if (!handle._objectId) {\n        const error = handle.rawValue();\n        if (error === 'error:notconnected') return error;\n        return {\n          hitTargetDescription: error\n        };\n      }\n      hitTargetInterceptionHandle = handle;\n      progress.cleanupWhenAborted(() => {\n        // Do not await here, just in case the renderer is stuck (e.g. on alert)\n        // and we won't be able to cleanup.\n        hitTargetInterceptionHandle.evaluate(h => h.stop()).catch(e => {});\n      });\n    }\n    const actionResult = await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {\n      if (options.__testHookBeforePointerAction) await options.__testHookBeforePointerAction();\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      let restoreModifiers;\n      if (options && options.modifiers) restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);\n      progress.log(`  performing ${actionName} action`);\n      await action(point);\n      if (restoreModifiers) await this._page.keyboard._ensureModifiers(restoreModifiers);\n      if (hitTargetInterceptionHandle) {\n        const stopHitTargetInterception = hitTargetInterceptionHandle.evaluate(h => h.stop()).catch(e => 'done');\n        if (!options.noWaitAfter) {\n          // When noWaitAfter is passed, we do not want to accidentally stall on\n          // non-committed navigation blocking the evaluate.\n          const hitTargetResult = await stopHitTargetInterception;\n          if (hitTargetResult !== 'done') return hitTargetResult;\n        }\n      }\n      progress.log(`  ${options.trial ? 'trial ' : ''}${actionName} action done`);\n      progress.log('  waiting for scheduled navigations to finish');\n      if (options.__testHookAfterPointerAction) await options.__testHookAfterPointerAction();\n      return 'done';\n    }, 'input');\n    if (actionResult !== 'done') return actionResult;\n    progress.log('  navigations have finished');\n    return 'done';\n  }\n  async hover(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._hover(progress, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  _hover(progress, options) {\n    return this._retryPointerAction(progress, 'hover', false /* waitForEnabled */, point => this._page.mouse.move(point.x, point.y), options);\n  }\n  async click(metadata, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._click(progress, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  _click(progress, options) {\n    return this._retryPointerAction(progress, 'click', true /* waitForEnabled */, point => this._page.mouse.click(point.x, point.y, options), options);\n  }\n  async dblclick(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._dblclick(progress, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  _dblclick(progress, options) {\n    return this._retryPointerAction(progress, 'dblclick', true /* waitForEnabled */, point => this._page.mouse.dblclick(point.x, point.y, options), options);\n  }\n  async tap(metadata, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._tap(progress, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  _tap(progress, options) {\n    return this._retryPointerAction(progress, 'tap', true /* waitForEnabled */, point => this._page.touchscreen.tap(point.x, point.y), options);\n  }\n  async selectOption(metadata, elements, values, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._selectOption(progress, elements, values, options);\n      return throwRetargetableDOMError(result);\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async _selectOption(progress, elements, values, options) {\n    const optionsToSelect = [...elements, ...values];\n    await progress.beforeInputAction(this);\n    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      progress.log('  selecting specified option(s)');\n      const result = await this.evaluatePoll(progress, ([injected, node, {\n        optionsToSelect,\n        force\n      }]) => {\n        return injected.waitForElementStatesAndPerformAction(node, ['visible', 'enabled'], force, injected.selectOptions.bind(injected, optionsToSelect));\n      }, {\n        optionsToSelect,\n        force: options.force\n      });\n      return result;\n    });\n  }\n  async fill(metadata, value, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._fill(progress, value, options);\n      assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async _fill(progress, value, options) {\n    progress.log(`elementHandle.fill(\"${value}\")`);\n    await progress.beforeInputAction(this);\n    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {\n      progress.log('  waiting for element to be visible, enabled and editable');\n      const filled = await this.evaluatePoll(progress, ([injected, node, {\n        value,\n        force\n      }]) => {\n        return injected.waitForElementStatesAndPerformAction(node, ['visible', 'enabled', 'editable'], force, injected.fill.bind(injected, value));\n      }, {\n        value,\n        force: options.force\n      });\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      if (filled === 'error:notconnected') return filled;\n      progress.log('  element is visible, enabled and editable');\n      if (filled === 'needsinput') {\n        progress.throwIfAborted(); // Avoid action that has side-effects.\n        if (value) await this._page.keyboard.insertText(value);else await this._page.keyboard.press('Delete');\n      } else {\n        assertDone(filled);\n      }\n      return 'done';\n    }, 'input');\n  }\n  async selectText(metadata, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      const result = await this.evaluatePoll(progress, ([injected, node, force]) => {\n        return injected.waitForElementStatesAndPerformAction(node, ['visible'], force, injected.selectText.bind(injected));\n      }, options.force);\n      assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async setInputFiles(metadata, items, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._setInputFiles(progress, items, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async _setInputFiles(progress, items, options) {\n    const {\n      files,\n      localPaths\n    } = items;\n    let filePayloads;\n    if (files) {\n      filePayloads = [];\n      for (const payload of files) {\n        filePayloads.push({\n          name: payload.name,\n          mimeType: payload.mimeType || _utilsBundle.mime.getType(payload.name) || 'application/octet-stream',\n          buffer: payload.buffer.toString('base64')\n        });\n      }\n    }\n    const multiple = files && files.length > 1 || localPaths && localPaths.length > 1;\n    const result = await this.evaluateHandleInUtility(([injected, node, multiple]) => {\n      const element = injected.retarget(node, 'follow-label');\n      if (!element) return;\n      if (element.tagName !== 'INPUT') throw injected.createStacklessError('Node is not an HTMLInputElement');\n      if (multiple && !element.multiple) throw injected.createStacklessError('Non-multiple file input can only accept single file');\n      return element;\n    }, multiple);\n    if (result === 'error:notconnected' || !result.asElement()) return 'error:notconnected';\n    const retargeted = result.asElement();\n    await progress.beforeInputAction(this);\n    await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      if (localPaths) await this._page._delegate.setInputFilePaths(retargeted, localPaths);else await this._page._delegate.setInputFiles(retargeted, filePayloads);\n    });\n    return 'done';\n  }\n  async focus(metadata) {\n    const controller = new _progress.ProgressController(metadata, this);\n    await controller.run(async progress => {\n      const result = await this._focus(progress);\n      return assertDone(throwRetargetableDOMError(result));\n    }, 0);\n  }\n  async _focus(progress, resetSelectionIfNotFocused) {\n    progress.throwIfAborted(); // Avoid action that has side-effects.\n    return await this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused]) => injected.focusNode(node, resetSelectionIfNotFocused), resetSelectionIfNotFocused);\n  }\n  async _blur(progress) {\n    progress.throwIfAborted(); // Avoid action that has side-effects.\n    return await this.evaluateInUtility(([injected, node]) => injected.blurNode(node), {});\n  }\n  async type(metadata, text, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._type(progress, text, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async _type(progress, text, options) {\n    progress.log(`elementHandle.type(\"${text}\")`);\n    await progress.beforeInputAction(this);\n    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {\n      const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);\n      if (result !== 'done') return result;\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      await this._page.keyboard.type(text, options);\n      return 'done';\n    }, 'input');\n  }\n  async press(metadata, key, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._press(progress, key, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async _press(progress, key, options) {\n    progress.log(`elementHandle.press(\"${key}\")`);\n    await progress.beforeInputAction(this);\n    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {\n      const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);\n      if (result !== 'done') return result;\n      progress.throwIfAborted(); // Avoid action that has side-effects.\n      await this._page.keyboard.press(key, options);\n      return 'done';\n    }, 'input');\n  }\n  async check(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._setChecked(progress, true, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async uncheck(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      const result = await this._setChecked(progress, false, options);\n      return assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async _setChecked(progress, state, options) {\n    const isChecked = async () => {\n      const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'checked'), {});\n      return throwRetargetableDOMError(result);\n    };\n    if ((await isChecked()) === state) return 'done';\n    const result = await this._click(progress, options);\n    if (result !== 'done') return result;\n    if (options.trial) return 'done';\n    if ((await isChecked()) !== state) throw new NonRecoverableDOMError('Clicking the checkbox did not change its state');\n    return 'done';\n  }\n  async boundingBox() {\n    return this._page._delegate.getBoundingBox(this);\n  }\n  async screenshot(metadata, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this._page._screenshotter.screenshotElement(progress, this, options), this._page._timeoutSettings.timeout(options));\n  }\n  async querySelector(selector, options) {\n    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, options, this);\n    if (!pair) return null;\n    const {\n      frame,\n      info\n    } = pair;\n    // If we end up in the same frame => use the scope again, line above was noop.\n    return this._page.selectors.query(frame, info, this._frame === frame ? this : undefined);\n  }\n  async querySelectorAll(selector) {\n    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {}, this);\n    if (!pair) return [];\n    const {\n      frame,\n      info\n    } = pair;\n    // If we end up in the same frame => use the scope again, line above was noop.\n    return this._page.selectors._queryAll(frame, info, this._frame === frame ? this : undefined, true /* adoptToMain */);\n  }\n\n  async evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {\n    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {\n      strict\n    }, this);\n    // If we end up in the same frame => use the scope again, line above was noop.\n    const handle = pair ? await this._page.selectors.query(pair.frame, pair.info, this._frame === pair.frame ? this : undefined) : null;\n    if (!handle) throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n    const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);\n    handle.dispose();\n    return result;\n  }\n  async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {\n    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {}, this);\n    if (!pair) throw new Error(`Error: failed to find frame for selector \"${selector}\"`);\n    const {\n      frame,\n      info\n    } = pair;\n    // If we end up in the same frame => use the scope again, line above was noop.\n    const arrayHandle = await this._page.selectors._queryArrayInMainWorld(frame, info, this._frame === frame ? this : undefined);\n    const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);\n    arrayHandle.dispose();\n    return result;\n  }\n  async isVisible() {\n    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'visible'), {});\n    if (result === 'error:notconnected') return false;\n    return result;\n  }\n  async isHidden() {\n    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'hidden'), {});\n    return throwRetargetableDOMError(result);\n  }\n  async isEnabled() {\n    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'enabled'), {});\n    return throwRetargetableDOMError(result);\n  }\n  async isDisabled() {\n    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'disabled'), {});\n    return throwRetargetableDOMError(result);\n  }\n  async isEditable() {\n    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'editable'), {});\n    return throwRetargetableDOMError(result);\n  }\n  async isChecked() {\n    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'checked'), {});\n    return throwRetargetableDOMError(result);\n  }\n  async waitForElementState(metadata, state, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      progress.log(`  waiting for element to be ${state}`);\n      const result = await this.evaluatePoll(progress, ([injected, node, state]) => {\n        return injected.waitForElementStatesAndPerformAction(node, [state], false, () => 'done');\n      }, state);\n      assertDone(throwRetargetableDOMError(result));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async waitForSelector(metadata, selector, options = {}) {\n    return this._frame.waitForSelector(metadata, selector, options, this);\n  }\n  async _adoptTo(context) {\n    if (this._context !== context) {\n      const adopted = await this._page._delegate.adoptElementHandle(this, context);\n      this.dispose();\n      return adopted;\n    }\n    return this;\n  }\n  async _waitForElementStates(progress, states, force) {\n    const title = joinWithAnd(states);\n    progress.log(`  waiting for element to be ${title}`);\n    const result = await this.evaluatePoll(progress, ([injected, node, {\n      states,\n      force\n    }]) => {\n      return injected.waitForElementStatesAndPerformAction(node, states, force, () => 'done');\n    }, {\n      states,\n      force\n    });\n    if (result === 'error:notconnected') return result;\n    progress.log(`  element is ${title}`);\n    return result;\n  }\n  async _checkFrameIsHitTarget(point) {\n    let frame = this._frame;\n    const data = [];\n    while (frame.parentFrame()) {\n      const frameElement = await frame.frameElement();\n      const box = await frameElement.boundingBox();\n      const style = await frameElement.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch(e => 'error:notconnected');\n      if (!box || style === 'error:notconnected') return 'error:notconnected';\n      if (style === 'transformed') {\n        // We cannot translate coordinates when iframe has any transform applied.\n        // The best we can do right now is to skip the hitPoint check,\n        // and solely rely on the event interceptor.\n        return {\n          framePoint: undefined\n        };\n      }\n      // Translate from viewport coordinates to frame coordinates.\n      const pointInFrame = {\n        x: point.x - box.x - style.left,\n        y: point.y - box.y - style.top\n      };\n      data.push({\n        frame,\n        frameElement,\n        pointInFrame\n      });\n      frame = frame.parentFrame();\n    }\n    // Add main frame.\n    data.push({\n      frame,\n      frameElement: null,\n      pointInFrame: point\n    });\n    for (let i = data.length - 1; i > 0; i--) {\n      const element = data[i - 1].frameElement;\n      const point = data[i].pointInFrame;\n      // Hit target in the parent frame should hit the child frame element.\n      const hitTargetResult = await element.evaluateInUtility(([injected, element, hitPoint]) => {\n        return injected.expectHitTarget(hitPoint, element);\n      }, point);\n      if (hitTargetResult !== 'done') return hitTargetResult;\n    }\n    return {\n      framePoint: data[0].pointInFrame\n    };\n  }\n}\n\n// Handles an InjectedScriptPoll running in injected script:\n// - streams logs into progress;\n// - cancels the poll when progress cancels.\nexports.ElementHandle = ElementHandle;\nclass InjectedScriptPollHandler {\n  constructor(progress, poll) {\n    this._progress = void 0;\n    this._poll = void 0;\n    this._progress = progress;\n    this._poll = poll;\n    // Ensure we cancel the poll before progress aborts and returns:\n    //   - no unnecessary work in the page;\n    //   - no possible side effects after progress promsie rejects.\n    this._progress.cleanupWhenAborted(() => this.cancel());\n    this._streamLogs();\n  }\n  async _streamLogs() {\n    while (this._poll && this._progress.isRunning()) {\n      const log = await this._poll.evaluate(poll => poll.takeNextLogs()).catch(e => []);\n      if (!this._poll || !this._progress.isRunning()) return;\n      for (const entry of log) this._progress.logEntry(entry);\n    }\n  }\n  async finishHandle() {\n    try {\n      const result = await this._poll.evaluateHandle(poll => poll.run());\n      await this._finishInternal();\n      return result;\n    } finally {\n      await this.cancel();\n    }\n  }\n  async finish() {\n    try {\n      const result = await this._poll.evaluate(poll => poll.run());\n      await this._finishInternal();\n      return result;\n    } finally {\n      await this.cancel();\n    }\n  }\n  async _finishInternal() {\n    if (!this._poll) return;\n    // Retrieve all the logs before continuing.\n    const log = await this._poll.evaluate(poll => poll.takeLastLogs()).catch(e => []);\n    for (const entry of log) this._progress.logEntry(entry);\n  }\n  async cancel() {\n    if (!this._poll) return;\n    const copy = this._poll;\n    this._poll = null;\n    await copy.evaluate(p => p.cancel()).catch(e => {});\n    copy.dispose();\n  }\n}\nexports.InjectedScriptPollHandler = InjectedScriptPollHandler;\nfunction throwRetargetableDOMError(result) {\n  if (result === 'error:notconnected') throw new Error('Element is not attached to the DOM');\n  return result;\n}\nfunction assertDone(result) {\n  // This function converts 'done' to void and ensures typescript catches unhandled errors.\n}\nfunction roundPoint(point) {\n  return {\n    x: (point.x * 100 | 0) / 100,\n    y: (point.y * 100 | 0) / 100\n  };\n}\nfunction compensateHalfIntegerRoundingError(point) {\n  // Firefox internally uses integer coordinates, so 8.5 is converted to 9 when clicking.\n  //\n  // This does not work nicely for small elements. For example, 1x1 square with corners\n  // (8;8) and (9;9) is targeted when clicking at (8;8) but not when clicking at (9;9).\n  // So, clicking at (8.5;8.5) will effectively click at (9;9) and miss the target.\n  //\n  // Therefore, we skew half-integer values from the interval (8.49, 8.51) towards\n  // (8.47, 8.49) that is rounded towards 8. This means clicking at (8.5;8.5) will\n  // be replaced with (8.48;8.48) and will effectively click at (8;8).\n  //\n  // Other browsers use float coordinates, so this change should not matter.\n  const remainderX = point.x - Math.floor(point.x);\n  if (remainderX > 0.49 && remainderX < 0.51) point.x -= 0.02;\n  const remainderY = point.y - Math.floor(point.y);\n  if (remainderY > 0.49 && remainderY < 0.51) point.y -= 0.02;\n}\nfunction joinWithAnd(strings) {\n  if (strings.length < 1) return strings.join(', ');\n  return strings.slice(0, strings.length - 1).join(', ') + ' and ' + strings[strings.length - 1];\n}\nconst kUnableToAdoptErrorMessage = 'Unable to adopt element handle from a different document';\nexports.kUnableToAdoptErrorMessage = kUnableToAdoptErrorMessage;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Download = void 0;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _page = require(\"./page\");\nvar _utils = require(\"../utils\");\nvar _artifact = require(\"./artifact\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Download {\n  constructor(page, downloadsPath, uuid, url, suggestedFilename) {\n    this.artifact = void 0;\n    this.url = void 0;\n    this._page = void 0;\n    this._suggestedFilename = void 0;\n    const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? 'Pass { acceptDownloads: true } when you are creating your browser context.' : undefined;\n    this.artifact = new _artifact.Artifact(page, _path.default.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {\n      return this._page._browserContext.cancelDownload(uuid);\n    });\n    this._page = page;\n    this.url = url;\n    this._suggestedFilename = suggestedFilename;\n    page._browserContext._downloads.add(this);\n    if (suggestedFilename !== undefined) this._page.emit(_page.Page.Events.Download, this);\n  }\n  _filenameSuggested(suggestedFilename) {\n    (0, _utils.assert)(this._suggestedFilename === undefined);\n    this._suggestedFilename = suggestedFilename;\n    this._page.emit(_page.Page.Events.Download, this);\n  }\n  suggestedFilename() {\n    return this._suggestedFilename;\n  }\n}\nexports.Download = Download;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElectronApplication = exports.Electron = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _crBrowser = require(\"../chromium/crBrowser\");\nvar _crConnection = require(\"../chromium/crConnection\");\nvar _crExecutionContext = require(\"../chromium/crExecutionContext\");\nvar js = _interopRequireWildcard(require(\"../javascript\"));\nvar _timeoutSettings = require(\"../../common/timeoutSettings\");\nvar _utils = require(\"../../utils\");\nvar _transport = require(\"../transport\");\nvar _processLauncher = require(\"../../utils/processLauncher\");\nvar _browserContext = require(\"../browserContext\");\nvar _progress = require(\"../progress\");\nvar _helper = require(\"../helper\");\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar readline = _interopRequireWildcard(require(\"readline\"));\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _instrumentation = require(\"../instrumentation\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), 'playwright-artifacts-');\nclass ElectronApplication extends _instrumentation.SdkObject {\n  constructor(parent, browser, nodeConnection, process) {\n    super(parent, 'electron-app');\n    this._browserContext = void 0;\n    this._nodeConnection = void 0;\n    this._nodeSession = void 0;\n    this._nodeExecutionContext = void 0;\n    this._nodeElectronHandlePromise = void 0;\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();\n    this._process = void 0;\n    this._process = process;\n    this._browserContext = browser._defaultContext;\n    this._browserContext.on(_browserContext.BrowserContext.Events.Close, () => {\n      // Emit application closed after context closed.\n      Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));\n    });\n    this._nodeConnection = nodeConnection;\n    this._nodeSession = nodeConnection.rootSession;\n    this._nodeElectronHandlePromise = new Promise(f => {\n      this._nodeSession.on('Runtime.executionContextCreated', async event => {\n        if (event.context.auxData && event.context.auxData.isDefault) {\n          this._nodeExecutionContext = new js.ExecutionContext(this, new _crExecutionContext.CRExecutionContext(this._nodeSession, event.context));\n          f(await js.evaluate(this._nodeExecutionContext, false /* returnByValue */, `process.mainModule.require('electron')`));\n        }\n      });\n    });\n    this._browserContext.setCustomCloseHandler(async () => {\n      const electronHandle = await this._nodeElectronHandlePromise;\n      await electronHandle.evaluate(({\n        app\n      }) => app.quit()).catch(() => {});\n    });\n  }\n  async initialize() {\n    await this._nodeSession.send('Runtime.enable', {});\n    // Delay loading the app until browser is started and the browser targets are configured to auto-attach.\n    await this._nodeSession.send('Runtime.evaluate', {\n      expression: '__playwright_run()'\n    });\n  }\n  process() {\n    return this._process;\n  }\n  context() {\n    return this._browserContext;\n  }\n  async close() {\n    const progressController = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);\n    const closed = progressController.run(progress => _helper.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise);\n    await this._browserContext.close((0, _instrumentation.serverSideCallMetadata)());\n    this._nodeConnection.close();\n    await closed;\n  }\n  async browserWindow(page) {\n    // Assume CRPage as Electron is always Chromium.\n    const targetId = page._delegate._targetId;\n    const electronHandle = await this._nodeElectronHandlePromise;\n    return await electronHandle.evaluateHandle(({\n      BrowserWindow,\n      webContents\n    }, targetId) => {\n      const wc = webContents.fromDevToolsTargetId(targetId);\n      return BrowserWindow.fromWebContents(wc);\n    }, targetId);\n  }\n}\nexports.ElectronApplication = ElectronApplication;\nElectronApplication.Events = {\n  Close: 'close'\n};\nclass Electron extends _instrumentation.SdkObject {\n  constructor(playwrightOptions) {\n    super(playwrightOptions.rootSdkObject, 'electron');\n    this._playwrightOptions = void 0;\n    this._playwrightOptions = playwrightOptions;\n  }\n  async launch(options) {\n    const {\n      args = []\n    } = options;\n    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);\n    controller.setLogName('browser');\n    return controller.run(async progress => {\n      let app = undefined;\n      const electronArguments = ['-r', require.resolve('./loader'), '--inspect=0', '--remote-debugging-port=0', ...args];\n      if (_os.default.platform() === 'linux') {\n        const runningAsRoot = process.geteuid && process.geteuid() === 0;\n        if (runningAsRoot && electronArguments.indexOf('--no-sandbox') === -1) electronArguments.push('--no-sandbox');\n      }\n      const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);\n      const browserLogsCollector = new _debugLogger.RecentLogsCollector();\n      const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;\n      let command;\n      if (options.executablePath) {\n        command = options.executablePath;\n      } else {\n        try {\n          // By default we fallback to the Electron App executable path.\n          // 'electron/index.js' resolves to the actual Electron App.\n          command = require('electron/index.js');\n        } catch (error) {\n          if ((error === null || error === void 0 ? void 0 : error.code) === 'MODULE_NOT_FOUND') {\n            throw new Error('\\n' + (0, _utils.wrapInASCIIBox)(['Electron executablePath not found!', 'Please install it using `npm install -D electron` or set the executablePath to your Electron executable.'].join('\\n'), 1));\n          }\n          throw error;\n        }\n      }\n\n      // When debugging Playwright test that runs Electron, NODE_OPTIONS\n      // will make the debugger attach to Electron's Node. But Playwright\n      // also needs to attach to drive the automation. Disable external debugging.\n      delete env.NODE_OPTIONS;\n      const {\n        launchedProcess,\n        gracefullyClose,\n        kill\n      } = await (0, _processLauncher.launchProcess)({\n        command,\n        args: electronArguments,\n        env,\n        log: message => {\n          progress.log(message);\n          browserLogsCollector.log(message);\n        },\n        stdio: 'pipe',\n        cwd: options.cwd,\n        tempDirectories: [artifactsDir],\n        attemptToGracefullyClose: () => app.close(),\n        handleSIGINT: true,\n        handleSIGTERM: true,\n        handleSIGHUP: true,\n        onExit: () => {}\n      });\n      const waitForXserverError = new Promise(async (resolve, reject) => {\n        waitForLine(progress, launchedProcess, /Unable to open X display/).then(() => reject(new Error(['Unable to open X display!', `================================`, 'Most likely this is because there is no X server available.', \"Use 'xvfb-run' on Linux to launch your tests with an emulated display server.\", \"For example: 'xvfb-run npm run test:e2e'\", `================================`, progress.metadata.log].join('\\n')))).catch(() => {});\n      });\n      const nodeMatch = await waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\\/\\/.*)$/);\n      const nodeTransport = await _transport.WebSocketTransport.connect(progress, nodeMatch[1]);\n      const nodeConnection = new _crConnection.CRConnection(nodeTransport, _helper.helper.debugProtocolLogger(), browserLogsCollector);\n\n      // Immediately release exiting process under debug.\n      waitForLine(progress, launchedProcess, /Waiting for the debugger to disconnect\\.\\.\\./).then(() => {\n        nodeTransport.close();\n      }).catch(() => {});\n      const chromeMatch = await Promise.race([waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\\/\\/.*)$/), waitForXserverError]);\n      const chromeTransport = await _transport.WebSocketTransport.connect(progress, chromeMatch[1]);\n      const browserProcess = {\n        onclose: undefined,\n        process: launchedProcess,\n        close: gracefullyClose,\n        kill\n      };\n      const contextOptions = {\n        ...options,\n        noDefaultViewport: true\n      };\n      const browserOptions = {\n        ...this._playwrightOptions,\n        name: 'electron',\n        isChromium: true,\n        headful: true,\n        persistent: contextOptions,\n        browserProcess,\n        protocolLogger: _helper.helper.debugProtocolLogger(),\n        browserLogsCollector,\n        artifactsDir,\n        downloadsPath: artifactsDir,\n        tracesDir: artifactsDir,\n        originalLaunchOptions: {}\n      };\n      (0, _browserContext.validateBrowserContextOptions)(contextOptions, browserOptions);\n      const browser = await _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);\n      app = new ElectronApplication(this, browser, nodeConnection, launchedProcess);\n      await app.initialize();\n      return app;\n    }, _timeoutSettings.TimeoutSettings.timeout(options));\n  }\n}\nexports.Electron = Electron;\nfunction waitForLine(progress, process, regex) {\n  return new Promise((resolve, reject) => {\n    const rl = readline.createInterface({\n      input: process.stderr\n    });\n    const failError = new Error('Process failed to launch!');\n    const listeners = [_eventsHelper.eventsHelper.addEventListener(rl, 'line', onLine), _eventsHelper.eventsHelper.addEventListener(rl, 'close', reject.bind(null, failError)), _eventsHelper.eventsHelper.addEventListener(process, 'exit', reject.bind(null, failError)),\n    // It is Ok to remove error handler because we did not create process and there is another listener.\n    _eventsHelper.eventsHelper.addEventListener(process, 'error', reject.bind(null, failError))];\n    progress.cleanupWhenAborted(cleanup);\n    function onLine(line) {\n      const match = line.match(regex);\n      if (!match) return;\n      cleanup();\n      resolve(match);\n    }\n    function cleanup() {\n      _eventsHelper.eventsHelper.removeEventListeners(listeners);\n    }\n  });\n}","\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {\n  app\n} = require('electron');\nconst {\n  chromiumSwitches\n} = require('../chromium/chromiumSwitches');\n\n// [Electron, -r, loader.js, --inspect=0, --remote-debugging-port=0, ...args]\nprocess.argv.splice(1, 4);\nfor (const arg of chromiumSwitches) {\n  const match = arg.match(/--([^=]*)=?(.*)/);\n  app.commandLine.appendSwitch(match[1], match[2]);\n}\n\n// Defer ready event.\nconst originalWhenReady = app.whenReady();\nconst originalEmit = app.emit.bind(app);\nlet readyEventArgs;\napp.emit = (event, ...args) => {\n  if (event === 'ready') {\n    readyEventArgs = args;\n    return app.listenerCount('ready') > 0;\n  }\n  return originalEmit(event, ...args);\n};\nlet isReady = false;\nlet whenReadyCallback;\nconst whenReadyPromise = new Promise(f => whenReadyCallback = f);\napp.isReady = () => isReady;\napp.whenReady = () => whenReadyPromise;\nglobalThis.__playwright_run = async () => {\n  // Wait for app to be ready to avoid browser initialization races.\n  const event = await originalWhenReady;\n  isReady = true;\n  whenReadyCallback(event);\n  originalEmit('ready', ...readyEventArgs);\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlobalAPIRequestContext = exports.BrowserContextAPIRequestContext = exports.APIRequestContext = void 0;\nvar http = _interopRequireWildcard(require(\"http\"));\nvar https = _interopRequireWildcard(require(\"https\"));\nvar _stream = require(\"stream\");\nvar _url = _interopRequireDefault(require(\"url\"));\nvar _zlib = _interopRequireDefault(require(\"zlib\"));\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _userAgent = require(\"../utils/userAgent\");\nvar _utils = require(\"../utils\");\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _browserContext = require(\"./browserContext\");\nvar _cookieStore = require(\"./cookieStore\");\nvar _formData = require(\"./formData\");\nvar _happyEyeballs = require(\"./happy-eyeballs\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _progress = require(\"./progress\");\nvar _tracing = require(\"./trace/recorder/tracing\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass APIRequestContext extends _instrumentation.SdkObject {\n  static findResponseBody(guid) {\n    for (const request of APIRequestContext.allInstances) {\n      const body = request.fetchResponses.get(guid);\n      if (body) return body;\n    }\n    return undefined;\n  }\n  constructor(parent) {\n    super(parent, 'request-context');\n    this.fetchResponses = new Map();\n    this.fetchLog = new Map();\n    this._activeProgressControllers = new Set();\n    APIRequestContext.allInstances.add(this);\n  }\n  _disposeImpl() {\n    APIRequestContext.allInstances.delete(this);\n    this.fetchResponses.clear();\n    this.fetchLog.clear();\n    this.emit(APIRequestContext.Events.Dispose);\n  }\n  disposeResponse(fetchUid) {\n    this.fetchResponses.delete(fetchUid);\n    this.fetchLog.delete(fetchUid);\n  }\n  _storeResponseBody(body) {\n    const uid = (0, _utils.createGuid)();\n    this.fetchResponses.set(uid, body);\n    return uid;\n  }\n  async fetch(params, metadata) {\n    var _params$method;\n    const headers = {};\n    const defaults = this._defaultOptions();\n    headers['user-agent'] = defaults.userAgent;\n    headers['accept'] = '*/*';\n    headers['accept-encoding'] = 'gzip,deflate,br';\n    if (defaults.extraHTTPHeaders) {\n      for (const {\n        name,\n        value\n      } of defaults.extraHTTPHeaders) headers[name.toLowerCase()] = value;\n    }\n    if (params.headers) {\n      for (const {\n        name,\n        value\n      } of params.headers) headers[name.toLowerCase()] = value;\n    }\n    const method = ((_params$method = params.method) === null || _params$method === void 0 ? void 0 : _params$method.toUpperCase()) || 'GET';\n    const proxy = defaults.proxy;\n    let agent;\n    if (proxy && proxy.server !== 'per-context') {\n      var _proxyOpts$protocol;\n      // TODO: support bypass proxy\n      const proxyOpts = _url.default.parse(proxy.server);\n      if ((_proxyOpts$protocol = proxyOpts.protocol) !== null && _proxyOpts$protocol !== void 0 && _proxyOpts$protocol.startsWith('socks')) {\n        agent = new _utilsBundle.SocksProxyAgent({\n          host: proxyOpts.hostname,\n          port: proxyOpts.port || undefined\n        });\n      } else {\n        if (proxy.username) proxyOpts.auth = `${proxy.username}:${proxy.password || ''}`;\n        agent = new _utilsBundle.HttpsProxyAgent(proxyOpts);\n      }\n    }\n    const timeout = defaults.timeoutSettings.timeout(params);\n    const deadline = timeout && (0, _utils.monotonicTime)() + timeout;\n    const options = {\n      method,\n      headers,\n      agent,\n      maxRedirects: params.maxRedirects === 0 ? -1 : params.maxRedirects === undefined ? 20 : params.maxRedirects,\n      timeout,\n      deadline,\n      __testHookLookup: params.__testHookLookup\n    };\n    // rejectUnauthorized = undefined is treated as true in node 12.\n    if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors) options.rejectUnauthorized = false;\n    const requestUrl = new URL(params.url, defaults.baseURL);\n    if (params.params) {\n      for (const {\n        name,\n        value\n      } of params.params) requestUrl.searchParams.set(name, value);\n    }\n    const postData = serializePostData(params, headers);\n    if (postData) headers['content-length'] = String(postData.byteLength);\n    const controller = new _progress.ProgressController(metadata, this);\n    const fetchResponse = await controller.run(progress => {\n      return this._sendRequest(progress, requestUrl, options, postData);\n    });\n    const fetchUid = this._storeResponseBody(fetchResponse.body);\n    this.fetchLog.set(fetchUid, controller.metadata.log);\n    if (params.failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400)) throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}`);\n    return {\n      ...fetchResponse,\n      fetchUid\n    };\n  }\n  _parseSetCookieHeader(responseUrl, setCookie) {\n    if (!setCookie) return [];\n    const url = new URL(responseUrl);\n    // https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4\n    const defaultPath = '/' + url.pathname.substr(1).split('/').slice(0, -1).join('/');\n    const cookies = [];\n    for (const header of setCookie) {\n      // Decode cookie value?\n      const cookie = parseCookie(header);\n      if (!cookie) continue;\n      // https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.3\n      if (!cookie.domain) cookie.domain = url.hostname;else (0, _utils.assert)(cookie.domain.startsWith('.') || !cookie.domain.includes('.'));\n      if (!(0, _cookieStore.domainMatches)(url.hostname, cookie.domain)) continue;\n      // https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.4\n      if (!cookie.path || !cookie.path.startsWith('/')) cookie.path = defaultPath;\n      cookies.push(cookie);\n    }\n    return cookies;\n  }\n  async _updateRequestCookieHeader(url, options) {\n    if (options.headers['cookie'] !== undefined) return;\n    const cookies = await this._cookies(url);\n    if (cookies.length) {\n      const valueArray = cookies.map(c => `${c.name}=${c.value}`);\n      options.headers['cookie'] = valueArray.join('; ');\n    }\n  }\n  async _sendRequest(progress, url, options, postData) {\n    var _cookie;\n    await this._updateRequestCookieHeader(url, options);\n    const requestCookies = ((_cookie = options.headers['cookie']) === null || _cookie === void 0 ? void 0 : _cookie.split(';').map(p => {\n      const [name, value] = p.split('=').map(v => v.trim());\n      return {\n        name,\n        value\n      };\n    })) || [];\n    const requestEvent = {\n      url,\n      method: options.method,\n      headers: options.headers,\n      cookies: requestCookies,\n      postData\n    };\n    this.emit(APIRequestContext.Events.Request, requestEvent);\n    return new Promise((fulfill, reject) => {\n      const requestConstructor = (url.protocol === 'https:' ? https : http).request;\n      // If we have a proxy agent already, do not override it.\n      const agent = options.agent || (url.protocol === 'https:' ? _happyEyeballs.httpsHappyEyeballsAgent : _happyEyeballs.httpHappyEyeballsAgent);\n      const requestOptions = {\n        ...options,\n        agent\n      };\n      const request = requestConstructor(url, requestOptions, async response => {\n        const notifyRequestFinished = body => {\n          const requestFinishedEvent = {\n            requestEvent,\n            httpVersion: response.httpVersion,\n            statusCode: response.statusCode || 0,\n            statusMessage: response.statusMessage || '',\n            headers: response.headers,\n            rawHeaders: response.rawHeaders,\n            cookies,\n            body\n          };\n          this.emit(APIRequestContext.Events.RequestFinished, requestFinishedEvent);\n        };\n        progress.log(`← ${response.statusCode} ${response.statusMessage}`);\n        for (const [name, value] of Object.entries(response.headers)) progress.log(`  ${name}: ${value}`);\n        const cookies = this._parseSetCookieHeader(response.url || url.toString(), response.headers['set-cookie']);\n        if (cookies.length) await this._addCookies(cookies);\n        if (redirectStatus.includes(response.statusCode) && options.maxRedirects >= 0) {\n          if (!options.maxRedirects) {\n            reject(new Error('Max redirect count exceeded'));\n            request.destroy();\n            return;\n          }\n          const headers = {\n            ...options.headers\n          };\n          delete headers[`cookie`];\n\n          // HTTP-redirect fetch step 13 (https://fetch.spec.whatwg.org/#http-redirect-fetch)\n          const status = response.statusCode;\n          let method = options.method;\n          if ((status === 301 || status === 302) && method === 'POST' || status === 303 && !['GET', 'HEAD'].includes(method)) {\n            method = 'GET';\n            postData = undefined;\n            delete headers[`content-encoding`];\n            delete headers[`content-language`];\n            delete headers[`content-length`];\n            delete headers[`content-location`];\n            delete headers[`content-type`];\n          }\n          const redirectOptions = {\n            method,\n            headers,\n            agent: options.agent,\n            maxRedirects: options.maxRedirects - 1,\n            timeout: options.timeout,\n            deadline: options.deadline,\n            __testHookLookup: options.__testHookLookup\n          };\n          // rejectUnauthorized = undefined is treated as true in node 12.\n          if (options.rejectUnauthorized === false) redirectOptions.rejectUnauthorized = false;\n\n          // HTTP-redirect fetch step 4: If locationURL is null, then return response.\n          if (response.headers.location) {\n            let locationURL;\n            try {\n              locationURL = new URL(response.headers.location, url);\n            } catch (error) {\n              reject(new Error(`uri requested responds with an invalid redirect URL: ${response.headers.location}`));\n              request.destroy();\n              return;\n            }\n            notifyRequestFinished();\n            fulfill(this._sendRequest(progress, locationURL, redirectOptions, postData));\n            request.destroy();\n            return;\n          }\n        }\n        if (response.statusCode === 401 && !options.headers['authorization']) {\n          const auth = response.headers['www-authenticate'];\n          const credentials = this._defaultOptions().httpCredentials;\n          if (auth !== null && auth !== void 0 && auth.trim().startsWith('Basic') && credentials) {\n            const {\n              username,\n              password\n            } = credentials;\n            const encoded = Buffer.from(`${username || ''}:${password || ''}`).toString('base64');\n            options.headers['authorization'] = `Basic ${encoded}`;\n            notifyRequestFinished();\n            fulfill(this._sendRequest(progress, url, options, postData));\n            request.destroy();\n            return;\n          }\n        }\n        response.on('aborted', () => reject(new Error('aborted')));\n        const chunks = [];\n        const notifyBodyFinished = () => {\n          const body = Buffer.concat(chunks);\n          notifyRequestFinished(body);\n          fulfill({\n            url: response.url || url.toString(),\n            status: response.statusCode || 0,\n            statusText: response.statusMessage || '',\n            headers: toHeadersArray(response.rawHeaders),\n            body\n          });\n        };\n        let body = response;\n        let transform;\n        const encoding = response.headers['content-encoding'];\n        if (encoding === 'gzip' || encoding === 'x-gzip') {\n          transform = _zlib.default.createGunzip({\n            flush: _zlib.default.constants.Z_SYNC_FLUSH,\n            finishFlush: _zlib.default.constants.Z_SYNC_FLUSH\n          });\n        } else if (encoding === 'br') {\n          transform = _zlib.default.createBrotliDecompress();\n        } else if (encoding === 'deflate') {\n          transform = _zlib.default.createInflate();\n        }\n        if (transform) {\n          // Brotli and deflate decompressors throw if the input stream is empty.\n          const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);\n          body = (0, _stream.pipeline)(response, emptyStreamTransform, transform, e => {\n            if (e) reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`));\n          });\n          body.on('error', e => reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`)));\n        } else {\n          body.on('error', reject);\n        }\n        body.on('data', chunk => chunks.push(chunk));\n        body.on('end', notifyBodyFinished);\n      });\n      request.on('error', reject);\n      const disposeListener = () => {\n        reject(new Error('Request context disposed.'));\n        request.destroy();\n      };\n      this.on(APIRequestContext.Events.Dispose, disposeListener);\n      request.on('close', () => this.off(APIRequestContext.Events.Dispose, disposeListener));\n      progress.log(`→ ${options.method} ${url.toString()}`);\n      if (options.headers) {\n        for (const [name, value] of Object.entries(options.headers)) progress.log(`  ${name}: ${value}`);\n      }\n      if (options.deadline) {\n        const rejectOnTimeout = () => {\n          reject(new Error(`Request timed out after ${options.timeout}ms`));\n          request.destroy();\n        };\n        const remaining = options.deadline - (0, _utils.monotonicTime)();\n        if (remaining <= 0) {\n          rejectOnTimeout();\n          return;\n        }\n        request.setTimeout(remaining, rejectOnTimeout);\n      }\n      if (postData) request.write(postData);\n      request.end();\n    });\n  }\n}\nexports.APIRequestContext = APIRequestContext;\nAPIRequestContext.Events = {\n  Dispose: 'dispose',\n  Request: 'request',\n  RequestFinished: 'requestfinished'\n};\nAPIRequestContext.allInstances = new Set();\nclass SafeEmptyStreamTransform extends _stream.Transform {\n  constructor(onEmptyStreamCallback) {\n    super();\n    this._receivedSomeData = false;\n    this._onEmptyStreamCallback = void 0;\n    this._onEmptyStreamCallback = onEmptyStreamCallback;\n  }\n  _transform(chunk, encoding, callback) {\n    this._receivedSomeData = true;\n    callback(null, chunk);\n  }\n  _flush(callback) {\n    if (this._receivedSomeData) callback(null);else this._onEmptyStreamCallback();\n  }\n}\nclass BrowserContextAPIRequestContext extends APIRequestContext {\n  constructor(context) {\n    super(context);\n    this._context = void 0;\n    this._context = context;\n    context.once(_browserContext.BrowserContext.Events.Close, () => this._disposeImpl());\n  }\n  tracing() {\n    return this._context.tracing;\n  }\n  async dispose() {\n    this.fetchResponses.clear();\n  }\n  _defaultOptions() {\n    return {\n      userAgent: this._context._options.userAgent || this._context._browser.userAgent(),\n      extraHTTPHeaders: this._context._options.extraHTTPHeaders,\n      httpCredentials: this._context._options.httpCredentials,\n      proxy: this._context._options.proxy || this._context._browser.options.proxy,\n      timeoutSettings: this._context._timeoutSettings,\n      ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,\n      baseURL: this._context._options.baseURL\n    };\n  }\n  async _addCookies(cookies) {\n    await this._context.addCookies(cookies);\n  }\n  async _cookies(url) {\n    return await this._context.cookies(url.toString());\n  }\n  async storageState() {\n    return this._context.storageState();\n  }\n}\nexports.BrowserContextAPIRequestContext = BrowserContextAPIRequestContext;\nclass GlobalAPIRequestContext extends APIRequestContext {\n  constructor(playwright, options) {\n    super(playwright);\n    this._cookieStore = new _cookieStore.CookieStore();\n    this._options = void 0;\n    this._origins = void 0;\n    this._tracing = void 0;\n    this.attribution.context = this;\n    const timeoutSettings = new _timeoutSettings.TimeoutSettings();\n    if (options.timeout !== undefined) timeoutSettings.setDefaultTimeout(options.timeout);\n    const proxy = options.proxy;\n    if (proxy !== null && proxy !== void 0 && proxy.server) {\n      let url = proxy === null || proxy === void 0 ? void 0 : proxy.server.trim();\n      if (!/^\\w+:\\/\\//.test(url)) url = 'http://' + url;\n      proxy.server = url;\n    }\n    if (options.storageState) {\n      this._origins = options.storageState.origins;\n      this._cookieStore.addCookies(options.storageState.cookies);\n    }\n    this._options = {\n      baseURL: options.baseURL,\n      userAgent: options.userAgent || (0, _userAgent.getUserAgent)(),\n      extraHTTPHeaders: options.extraHTTPHeaders,\n      ignoreHTTPSErrors: !!options.ignoreHTTPSErrors,\n      httpCredentials: options.httpCredentials,\n      proxy,\n      timeoutSettings\n    };\n    this._tracing = new _tracing.Tracing(this, options.tracesDir);\n  }\n  tracing() {\n    return this._tracing;\n  }\n  async dispose() {\n    await this._tracing.dispose();\n    await this._tracing.deleteTmpTracesDir();\n    this._disposeImpl();\n  }\n  _defaultOptions() {\n    return this._options;\n  }\n  async _addCookies(cookies) {\n    this._cookieStore.addCookies(cookies);\n  }\n  async _cookies(url) {\n    return this._cookieStore.cookies(url);\n  }\n  async storageState() {\n    return {\n      cookies: this._cookieStore.allCookies(),\n      origins: this._origins || []\n    };\n  }\n}\nexports.GlobalAPIRequestContext = GlobalAPIRequestContext;\nfunction toHeadersArray(rawHeaders) {\n  const result = [];\n  for (let i = 0; i < rawHeaders.length; i += 2) result.push({\n    name: rawHeaders[i],\n    value: rawHeaders[i + 1]\n  });\n  return result;\n}\nconst redirectStatus = [301, 302, 303, 307, 308];\nfunction parseCookie(header) {\n  const pairs = header.split(';').filter(s => s.trim().length > 0).map(p => {\n    let key = '';\n    let value = '';\n    const separatorPos = p.indexOf('=');\n    if (separatorPos === -1) {\n      // If only a key is specified, the value is left undefined.\n      key = p.trim();\n    } else {\n      // Otherwise we assume that the key is the element before the first `=`\n      key = p.slice(0, separatorPos).trim();\n      // And the value is the rest of the string.\n      value = p.slice(separatorPos + 1).trim();\n    }\n    return [key, value];\n  });\n  if (!pairs.length) return null;\n  const [name, value] = pairs[0];\n  const cookie = {\n    name,\n    value,\n    domain: '',\n    path: '',\n    expires: -1,\n    httpOnly: false,\n    secure: false,\n    // From https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite\n    // The cookie-sending behavior if SameSite is not specified is SameSite=Lax.\n    sameSite: 'Lax'\n  };\n  for (let i = 1; i < pairs.length; i++) {\n    const [name, value] = pairs[i];\n    switch (name.toLowerCase()) {\n      case 'expires':\n        const expiresMs = +new Date(value);\n        if (isFinite(expiresMs)) cookie.expires = expiresMs / 1000;\n        break;\n      case 'max-age':\n        const maxAgeSec = parseInt(value, 10);\n        if (isFinite(maxAgeSec)) cookie.expires = Date.now() / 1000 + maxAgeSec;\n        break;\n      case 'domain':\n        cookie.domain = value.toLocaleLowerCase() || '';\n        if (cookie.domain && !cookie.domain.startsWith('.') && cookie.domain.includes('.')) cookie.domain = '.' + cookie.domain;\n        break;\n      case 'path':\n        cookie.path = value || '';\n        break;\n      case 'secure':\n        cookie.secure = true;\n        break;\n      case 'httponly':\n        cookie.httpOnly = true;\n        break;\n      case 'samesite':\n        switch (value.toLowerCase()) {\n          case 'none':\n            cookie.sameSite = 'None';\n            break;\n          case 'lax':\n            cookie.sameSite = 'Lax';\n            break;\n          case 'strict':\n            cookie.sameSite = 'Strict';\n            break;\n        }\n        break;\n    }\n  }\n  return cookie;\n}\nfunction isJsonParsable(value) {\n  if (typeof value !== 'string') return false;\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (e) {\n    if (e instanceof SyntaxError) return false;else throw e;\n  }\n}\nfunction serializePostData(params, headers) {\n  (0, _utils.assert)((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);\n  if (params.jsonData !== undefined) {\n    var _contentType, _headers$_contentType;\n    const json = isJsonParsable(params.jsonData) ? params.jsonData : JSON.stringify(params.jsonData);\n    (_headers$_contentType = headers[_contentType = 'content-type']) !== null && _headers$_contentType !== void 0 ? _headers$_contentType : headers[_contentType] = 'application/json';\n    return Buffer.from(json, 'utf8');\n  } else if (params.formData) {\n    var _contentType2, _headers$_contentType2;\n    const searchParams = new URLSearchParams();\n    for (const {\n      name,\n      value\n    } of params.formData) searchParams.append(name, value);\n    (_headers$_contentType2 = headers[_contentType2 = 'content-type']) !== null && _headers$_contentType2 !== void 0 ? _headers$_contentType2 : headers[_contentType2] = 'application/x-www-form-urlencoded';\n    return Buffer.from(searchParams.toString(), 'utf8');\n  } else if (params.multipartData) {\n    var _contentType3, _headers$_contentType3;\n    const formData = new _formData.MultipartFormData();\n    for (const field of params.multipartData) {\n      if (field.file) formData.addFileField(field.name, field.file);else if (field.value) formData.addField(field.name, field.value);\n    }\n    (_headers$_contentType3 = headers[_contentType3 = 'content-type']) !== null && _headers$_contentType3 !== void 0 ? _headers$_contentType3 : headers[_contentType3] = formData.contentTypeHeader();\n    return formData.finish();\n  } else if (params.postData !== undefined) {\n    var _contentType4, _headers$_contentType4;\n    (_headers$_contentType4 = headers[_contentType4 = 'content-type']) !== null && _headers$_contentType4 !== void 0 ? _headers$_contentType4 : headers[_contentType4] = 'application/octet-stream';\n    return params.postData;\n  }\n  return undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileChooser = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass FileChooser {\n  constructor(page, elementHandle, isMultiple) {\n    this._page = void 0;\n    this._elementHandle = void 0;\n    this._isMultiple = void 0;\n    this._page = page;\n    this._elementHandle = elementHandle;\n    this._isMultiple = isMultiple;\n  }\n  element() {\n    return this._elementHandle;\n  }\n  isMultiple() {\n    return this._isMultiple;\n  }\n  page() {\n    return this._page;\n  }\n}\nexports.FileChooser = FileChooser;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAccessibilityTree = getAccessibilityTree;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nasync function getAccessibilityTree(session, needle) {\n  const objectId = needle ? needle._objectId : undefined;\n  const {\n    tree\n  } = await session.send('Accessibility.getFullAXTree', {\n    objectId\n  });\n  const axNode = new FFAXNode(tree);\n  return {\n    tree: axNode,\n    needle: needle ? axNode._findNeedle() : null\n  };\n}\nconst FFRoleToARIARole = new Map(Object.entries({\n  'pushbutton': 'button',\n  'checkbutton': 'checkbox',\n  'editcombobox': 'combobox',\n  'content deletion': 'deletion',\n  'footnote': 'doc-footnote',\n  'non-native document': 'document',\n  'grouping': 'group',\n  'graphic': 'img',\n  'content insertion': 'insertion',\n  'animation': 'marquee',\n  'flat equation': 'math',\n  'menupopup': 'menu',\n  'check menu item': 'menuitemcheckbox',\n  'radio menu item': 'menuitemradio',\n  'listbox option': 'option',\n  'radiobutton': 'radio',\n  'statusbar': 'status',\n  'pagetab': 'tab',\n  'pagetablist': 'tablist',\n  'propertypage': 'tabpanel',\n  'entry': 'textbox',\n  'outline': 'tree',\n  'tree table': 'treegrid',\n  'outlineitem': 'treeitem'\n}));\nclass FFAXNode {\n  constructor(payload) {\n    this._children = void 0;\n    this._payload = void 0;\n    this._editable = void 0;\n    this._richlyEditable = void 0;\n    this._focusable = void 0;\n    this._expanded = void 0;\n    this._name = void 0;\n    this._role = void 0;\n    this._cachedHasFocusableChild = void 0;\n    this._payload = payload;\n    this._children = (payload.children || []).map(x => new FFAXNode(x));\n    this._editable = !!payload.editable;\n    this._richlyEditable = this._editable && payload.tag !== 'textarea' && payload.tag !== 'input';\n    this._focusable = !!payload.focusable;\n    this._expanded = !!payload.expanded;\n    this._name = this._payload.name;\n    this._role = this._payload.role;\n  }\n  _isPlainTextField() {\n    if (this._richlyEditable) return false;\n    if (this._editable) return true;\n    return this._role === 'entry';\n  }\n  _isTextOnlyObject() {\n    const role = this._role;\n    return role === 'text leaf' || role === 'text' || role === 'statictext';\n  }\n  _hasFocusableChild() {\n    if (this._cachedHasFocusableChild === undefined) {\n      this._cachedHasFocusableChild = false;\n      for (const child of this._children) {\n        if (child._focusable || child._hasFocusableChild()) {\n          this._cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n    return this._cachedHasFocusableChild;\n  }\n  children() {\n    return this._children;\n  }\n  _findNeedle() {\n    if (this._payload.foundObject) return this;\n    for (const child of this._children) {\n      const found = child._findNeedle();\n      if (found) return found;\n    }\n    return null;\n  }\n  isLeafNode() {\n    if (!this._children.length) return true;\n    // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n    if (this._isPlainTextField() || this._isTextOnlyObject()) return true;\n    // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n    switch (this._role) {\n      case 'graphic':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n      default:\n        break;\n    }\n    // Here and below: Android heuristics\n    if (this._hasFocusableChild()) return false;\n    if (this._focusable && this._role !== 'document' && this._name) return true;\n    if (this._role === 'heading' && this._name) return true;\n    return false;\n  }\n  isControl() {\n    switch (this._role) {\n      case 'checkbutton':\n      case 'check menu item':\n      case 'check rich option':\n      case 'combobox':\n      case 'combobox option':\n      case 'color chooser':\n      case 'listbox':\n      case 'listbox option':\n      case 'listbox rich option':\n      case 'popup menu':\n      case 'menupopup':\n      case 'menuitem':\n      case 'menubar':\n      case 'button':\n      case 'pushbutton':\n      case 'radiobutton':\n      case 'radio menuitem':\n      case 'scrollbar':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'pagetab':\n      case 'entry':\n      case 'tree table':\n        return true;\n      default:\n        return false;\n    }\n  }\n  isInteresting(insideControl) {\n    if (this._focusable || this._richlyEditable) return true;\n    // If it's not focusable but has a control role, then it's interesting.\n    if (this.isControl()) return true;\n    // A non focusable child of a control is not interesting\n    if (insideControl) return false;\n    return this.isLeafNode() && !!this._name.trim();\n  }\n  serialize() {\n    const node = {\n      role: FFRoleToARIARole.get(this._role) || this._role,\n      name: this._name || ''\n    };\n    const userStringProperties = ['name', 'description', 'roledescription', 'valuetext', 'keyshortcuts'];\n    for (const userStringProperty of userStringProperties) {\n      if (!(userStringProperty in this._payload)) continue;\n      node[userStringProperty] = this._payload[userStringProperty];\n    }\n    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];\n    for (const booleanProperty of booleanProperties) {\n      if (this._role === 'document' && booleanProperty === 'focused') continue; // document focusing is strange\n      const value = this._payload[booleanProperty];\n      if (!value) continue;\n      node[booleanProperty] = value;\n    }\n    const numericalProperties = ['level'];\n    for (const numericalProperty of numericalProperties) {\n      if (!(numericalProperty in this._payload)) continue;\n      node[numericalProperty] = this._payload[numericalProperty];\n    }\n    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];\n    for (const tokenProperty of tokenProperties) {\n      const value = this._payload[tokenProperty];\n      if (!value || value === 'false') continue;\n      node[tokenProperty] = value;\n    }\n    const axNode = node;\n    axNode.valueString = this._payload.value;\n    if ('checked' in this._payload) axNode.checked = this._payload.checked === true ? 'checked' : this._payload.checked === 'mixed' ? 'mixed' : 'unchecked';\n    if ('pressed' in this._payload) axNode.pressed = this._payload.pressed === true ? 'pressed' : 'released';\n    return axNode;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FFBrowserContext = exports.FFBrowser = void 0;\nvar _errors = require(\"../../common/errors\");\nvar _utils = require(\"../../utils\");\nvar _browser = require(\"../browser\");\nvar _browserContext = require(\"../browserContext\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _ffConnection = require(\"./ffConnection\");\nvar _ffPage = require(\"./ffPage\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass FFBrowser extends _browser.Browser {\n  static async connect(transport, options) {\n    const connection = new _ffConnection.FFConnection(transport, options.protocolLogger, options.browserLogsCollector);\n    const browser = new FFBrowser(connection, options);\n    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();\n    const promises = [connection.send('Browser.enable', {\n      attachToDefaultContext: !!options.persistent\n    }), browser._initVersion()];\n    if (options.persistent) {\n      browser._defaultContext = new FFBrowserContext(browser, undefined, options.persistent);\n      promises.push(browser._defaultContext._initialize());\n    }\n    if (options.proxy) promises.push(browser._connection.send('Browser.setBrowserProxy', toJugglerProxyOptions(options.proxy)));\n    await Promise.all(promises);\n    return browser;\n  }\n  constructor(connection, options) {\n    super(options);\n    this._connection = void 0;\n    this._ffPages = void 0;\n    this._contexts = void 0;\n    this._version = '';\n    this._userAgent = '';\n    this._connection = connection;\n    this._ffPages = new Map();\n    this._contexts = new Map();\n    this._connection.on(_ffConnection.ConnectionEvents.Disconnected, () => this._onDisconnect());\n    this._connection.on('Browser.attachedToTarget', this._onAttachedToTarget.bind(this));\n    this._connection.on('Browser.detachedFromTarget', this._onDetachedFromTarget.bind(this));\n    this._connection.on('Browser.downloadCreated', this._onDownloadCreated.bind(this));\n    this._connection.on('Browser.downloadFinished', this._onDownloadFinished.bind(this));\n    this._connection.on('Browser.videoRecordingFinished', this._onVideoRecordingFinished.bind(this));\n  }\n  async _initVersion() {\n    const result = await this._connection.send('Browser.getInfo');\n    this._version = result.version.substring(result.version.indexOf('/') + 1);\n    this._userAgent = result.userAgent;\n  }\n  isConnected() {\n    return !this._connection._closed;\n  }\n  async doCreateNewContext(options) {\n    if (options.isMobile) throw new Error('options.isMobile is not supported in Firefox');\n    const {\n      browserContextId\n    } = await this._connection.send('Browser.createBrowserContext', {\n      removeOnDetach: true\n    });\n    const context = new FFBrowserContext(this, browserContextId, options);\n    await context._initialize();\n    this._contexts.set(browserContextId, context);\n    return context;\n  }\n  contexts() {\n    return Array.from(this._contexts.values());\n  }\n  version() {\n    return this._version;\n  }\n  userAgent() {\n    return this._userAgent;\n  }\n  _onDetachedFromTarget(payload) {\n    const ffPage = this._ffPages.get(payload.targetId);\n    this._ffPages.delete(payload.targetId);\n    ffPage.didClose();\n  }\n  _onAttachedToTarget(payload) {\n    const {\n      targetId,\n      browserContextId,\n      openerId,\n      type\n    } = payload.targetInfo;\n    (0, _utils.assert)(type === 'page');\n    const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;\n    (0, _utils.assert)(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);\n    const session = this._connection.createSession(payload.sessionId);\n    const opener = openerId ? this._ffPages.get(openerId) : null;\n    const ffPage = new _ffPage.FFPage(session, context, opener);\n    this._ffPages.set(targetId, ffPage);\n  }\n  _onDownloadCreated(payload) {\n    const ffPage = this._ffPages.get(payload.pageTargetId);\n    (0, _utils.assert)(ffPage);\n    if (!ffPage) return;\n\n    // Abort the navigation that turned into download.\n    ffPage._page._frameManager.frameAbortedNavigation(payload.frameId, 'Download is starting');\n    let originPage = ffPage._initializedPage;\n    // If it's a new window download, report it on the opener page.\n    if (!originPage) {\n      // Resume the page creation with an error. The page will automatically close right\n      // after the download begins.\n      ffPage._markAsError(new Error('Starting new page download'));\n      if (ffPage._opener) originPage = ffPage._opener._initializedPage;\n    }\n    if (!originPage) return;\n    this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);\n  }\n  _onDownloadFinished(payload) {\n    const error = payload.canceled ? 'canceled' : payload.error;\n    this._downloadFinished(payload.uuid, error);\n  }\n  _onVideoRecordingFinished(payload) {\n    var _this$_takeVideo;\n    (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();\n  }\n  _onDisconnect() {\n    for (const video of this._idToVideo.values()) video.artifact.reportFinished(_errors.kBrowserClosedError);\n    this._idToVideo.clear();\n    this._didClose();\n  }\n}\nexports.FFBrowser = FFBrowser;\nclass FFBrowserContext extends _browserContext.BrowserContext {\n  constructor(browser, browserContextId, options) {\n    super(browser, options, browserContextId);\n  }\n  async _initialize() {\n    (0, _utils.assert)(!this._ffPages().length);\n    const browserContextId = this._browserContextId;\n    const promises = [super._initialize()];\n    promises.push(this._browser._connection.send('Browser.setDownloadOptions', {\n      browserContextId,\n      downloadOptions: {\n        behavior: this._options.acceptDownloads ? 'saveToDisk' : 'cancel',\n        downloadsDir: this._browser.options.downloadsPath\n      }\n    }));\n    if (this._options.viewport) {\n      const viewport = {\n        viewportSize: {\n          width: this._options.viewport.width,\n          height: this._options.viewport.height\n        },\n        deviceScaleFactor: this._options.deviceScaleFactor || 1\n      };\n      promises.push(this._browser._connection.send('Browser.setDefaultViewport', {\n        browserContextId,\n        viewport\n      }));\n    }\n    if (this._options.hasTouch) promises.push(this._browser._connection.send('Browser.setTouchOverride', {\n      browserContextId,\n      hasTouch: true\n    }));\n    if (this._options.userAgent) promises.push(this._browser._connection.send('Browser.setUserAgentOverride', {\n      browserContextId,\n      userAgent: this._options.userAgent\n    }));\n    if (this._options.bypassCSP) promises.push(this._browser._connection.send('Browser.setBypassCSP', {\n      browserContextId,\n      bypassCSP: true\n    }));\n    if (this._options.ignoreHTTPSErrors) promises.push(this._browser._connection.send('Browser.setIgnoreHTTPSErrors', {\n      browserContextId,\n      ignoreHTTPSErrors: true\n    }));\n    if (this._options.javaScriptEnabled === false) promises.push(this._browser._connection.send('Browser.setJavaScriptDisabled', {\n      browserContextId,\n      javaScriptDisabled: true\n    }));\n    if (this._options.locale) promises.push(this._browser._connection.send('Browser.setLocaleOverride', {\n      browserContextId,\n      locale: this._options.locale\n    }));\n    if (this._options.timezoneId) promises.push(this._browser._connection.send('Browser.setTimezoneOverride', {\n      browserContextId,\n      timezoneId: this._options.timezoneId\n    }));\n    if (this._options.extraHTTPHeaders || this._options.locale) promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));\n    if (this._options.httpCredentials) promises.push(this.setHTTPCredentials(this._options.httpCredentials));\n    if (this._options.geolocation) promises.push(this.setGeolocation(this._options.geolocation));\n    if (this._options.offline) promises.push(this.setOffline(this._options.offline));\n    if (this._options.colorScheme !== 'no-override') {\n      promises.push(this._browser._connection.send('Browser.setColorScheme', {\n        browserContextId,\n        colorScheme: this._options.colorScheme !== undefined ? this._options.colorScheme : 'light'\n      }));\n    }\n    if (this._options.reducedMotion !== 'no-override') {\n      promises.push(this._browser._connection.send('Browser.setReducedMotion', {\n        browserContextId,\n        reducedMotion: this._options.reducedMotion !== undefined ? this._options.reducedMotion : 'no-preference'\n      }));\n    }\n    if (this._options.forcedColors !== 'no-override') {\n      promises.push(this._browser._connection.send('Browser.setForcedColors', {\n        browserContextId,\n        forcedColors: this._options.forcedColors !== undefined ? this._options.forcedColors : 'none'\n      }));\n    }\n    if (this._options.recordVideo) {\n      promises.push(this._ensureVideosPath().then(() => {\n        return this._browser._connection.send('Browser.setVideoRecordingOptions', {\n          // validateBrowserContextOptions ensures correct video size.\n          options: {\n            ...this._options.recordVideo.size,\n            dir: this._options.recordVideo.dir\n          },\n          browserContextId: this._browserContextId\n        });\n      }));\n    }\n    if (this._options.proxy) {\n      promises.push(this._browser._connection.send('Browser.setContextProxy', {\n        browserContextId: this._browserContextId,\n        ...toJugglerProxyOptions(this._options.proxy)\n      }));\n    }\n    await Promise.all(promises);\n  }\n  _ffPages() {\n    return Array.from(this._browser._ffPages.values()).filter(ffPage => ffPage._browserContext === this);\n  }\n  pages() {\n    return this._ffPages().map(ffPage => ffPage._initializedPage).filter(pageOrNull => !!pageOrNull);\n  }\n  async newPageDelegate() {\n    (0, _browserContext.assertBrowserContextIsNotOwned)(this);\n    const {\n      targetId\n    } = await this._browser._connection.send('Browser.newPage', {\n      browserContextId: this._browserContextId\n    }).catch(e => {\n      if (e.message.includes('Failed to override timezone')) throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);\n      throw e;\n    });\n    return this._browser._ffPages.get(targetId);\n  }\n  async doGetCookies(urls) {\n    const {\n      cookies\n    } = await this._browser._connection.send('Browser.getCookies', {\n      browserContextId: this._browserContextId\n    });\n    return network.filterCookies(cookies.map(c => {\n      const copy = {\n        ...c\n      };\n      delete copy.size;\n      delete copy.session;\n      return copy;\n    }), urls);\n  }\n  async addCookies(cookies) {\n    const cc = network.rewriteCookies(cookies).map(c => ({\n      ...c,\n      expires: c.expires && c.expires !== -1 ? c.expires : undefined\n    }));\n    await this._browser._connection.send('Browser.setCookies', {\n      browserContextId: this._browserContextId,\n      cookies: cc\n    });\n  }\n  async clearCookies() {\n    await this._browser._connection.send('Browser.clearCookies', {\n      browserContextId: this._browserContextId\n    });\n  }\n  async doGrantPermissions(origin, permissions) {\n    const webPermissionToProtocol = new Map([['geolocation', 'geo'], ['persistent-storage', 'persistent-storage'], ['push', 'push'], ['notifications', 'desktop-notification']]);\n    const filtered = permissions.map(permission => {\n      const protocolPermission = webPermissionToProtocol.get(permission);\n      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);\n      return protocolPermission;\n    });\n    await this._browser._connection.send('Browser.grantPermissions', {\n      origin: origin,\n      browserContextId: this._browserContextId,\n      permissions: filtered\n    });\n  }\n  async doClearPermissions() {\n    await this._browser._connection.send('Browser.resetPermissions', {\n      browserContextId: this._browserContextId\n    });\n  }\n  async setGeolocation(geolocation) {\n    (0, _browserContext.verifyGeolocation)(geolocation);\n    this._options.geolocation = geolocation;\n    await this._browser._connection.send('Browser.setGeolocationOverride', {\n      browserContextId: this._browserContextId,\n      geolocation: geolocation || null\n    });\n  }\n  async setExtraHTTPHeaders(headers) {\n    this._options.extraHTTPHeaders = headers;\n    let allHeaders = this._options.extraHTTPHeaders;\n    if (this._options.locale) allHeaders = network.mergeHeaders([allHeaders, network.singleHeader('Accept-Language', this._options.locale)]);\n    await this._browser._connection.send('Browser.setExtraHTTPHeaders', {\n      browserContextId: this._browserContextId,\n      headers: allHeaders\n    });\n  }\n  async setUserAgent(userAgent) {\n    await this._browser._connection.send('Browser.setUserAgentOverride', {\n      browserContextId: this._browserContextId,\n      userAgent: userAgent || null\n    });\n  }\n  async setOffline(offline) {\n    this._options.offline = offline;\n    await this._browser._connection.send('Browser.setOnlineOverride', {\n      browserContextId: this._browserContextId,\n      override: offline ? 'offline' : 'online'\n    });\n  }\n  async doSetHTTPCredentials(httpCredentials) {\n    this._options.httpCredentials = httpCredentials;\n    await this._browser._connection.send('Browser.setHTTPCredentials', {\n      browserContextId: this._browserContextId,\n      credentials: httpCredentials || null\n    });\n  }\n  async doAddInitScript(source) {\n    await this._browser._connection.send('Browser.setInitScripts', {\n      browserContextId: this._browserContextId,\n      scripts: this.initScripts.map(script => ({\n        script\n      }))\n    });\n  }\n  async doRemoveInitScripts() {\n    await this._browser._connection.send('Browser.setInitScripts', {\n      browserContextId: this._browserContextId,\n      scripts: []\n    });\n  }\n  async doExposeBinding(binding) {\n    await this._browser._connection.send('Browser.addBinding', {\n      browserContextId: this._browserContextId,\n      name: binding.name,\n      script: binding.source\n    });\n  }\n  async doRemoveExposedBindings() {\n    // TODO: implement me.\n    // This is not a critical problem, what ends up happening is\n    // an old binding will be restored upon page reload and will point nowhere.\n  }\n  async doUpdateRequestInterception() {\n    await this._browser._connection.send('Browser.setRequestInterception', {\n      browserContextId: this._browserContextId,\n      enabled: !!this._requestInterceptor\n    });\n  }\n  onClosePersistent() {}\n  async doClose() {\n    if (!this._browserContextId) {\n      if (this._options.recordVideo) {\n        await this._browser._connection.send('Browser.setVideoRecordingOptions', {\n          options: undefined,\n          browserContextId: this._browserContextId\n        });\n      }\n      // Closing persistent context should close the browser.\n      await this._browser.close();\n    } else {\n      await this._browser._connection.send('Browser.removeBrowserContext', {\n        browserContextId: this._browserContextId\n      });\n      this._browser._contexts.delete(this._browserContextId);\n    }\n  }\n  async cancelDownload(uuid) {\n    await this._browser._connection.send('Browser.cancelDownload', {\n      uuid\n    });\n  }\n}\nexports.FFBrowserContext = FFBrowserContext;\nfunction toJugglerProxyOptions(proxy) {\n  const proxyServer = new URL(proxy.server);\n  let port = parseInt(proxyServer.port, 10);\n  let type = 'http';\n  if (proxyServer.protocol === 'socks5:') type = 'socks';else if (proxyServer.protocol === 'socks4:') type = 'socks4';else if (proxyServer.protocol === 'https:') type = 'https';\n  if (proxyServer.port === '') {\n    if (proxyServer.protocol === 'http:') port = 80;else if (proxyServer.protocol === 'https:') port = 443;\n  }\n  return {\n    type,\n    bypass: proxy.bypass ? proxy.bypass.split(',').map(domain => domain.trim()) : [],\n    host: proxyServer.hostname,\n    port,\n    username: proxy.username,\n    password: proxy.password\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.kBrowserCloseMessageId = exports.FFSessionEvents = exports.FFSession = exports.FFConnection = exports.ConnectionEvents = void 0;\nvar _events = require(\"events\");\nvar _utils = require(\"../../utils\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _helper = require(\"../helper\");\nvar _protocolError = require(\"../protocolError\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst ConnectionEvents = {\n  Disconnected: Symbol('Disconnected')\n};\n\n// FFPlaywright uses this special id to issue Browser.close command which we\n// should ignore.\nexports.ConnectionEvents = ConnectionEvents;\nconst kBrowserCloseMessageId = -9999;\nexports.kBrowserCloseMessageId = kBrowserCloseMessageId;\nclass FFConnection extends _events.EventEmitter {\n  constructor(transport, protocolLogger, browserLogsCollector) {\n    super();\n    this._lastId = void 0;\n    this._callbacks = void 0;\n    this._transport = void 0;\n    this._protocolLogger = void 0;\n    this._browserLogsCollector = void 0;\n    this._sessions = void 0;\n    this._closed = void 0;\n    this.on = void 0;\n    this.addListener = void 0;\n    this.off = void 0;\n    this.removeListener = void 0;\n    this.once = void 0;\n    this.setMaxListeners(0);\n    this._transport = transport;\n    this._protocolLogger = protocolLogger;\n    this._browserLogsCollector = browserLogsCollector;\n    this._lastId = 0;\n    this._callbacks = new Map();\n    this._sessions = new Map();\n    this._closed = false;\n    this.on = super.on;\n    this.addListener = super.addListener;\n    this.off = super.removeListener;\n    this.removeListener = super.removeListener;\n    this.once = super.once;\n    this._transport.onmessage = this._onMessage.bind(this);\n    // onclose should be set last, since it can be immediately called.\n    this._transport.onclose = this._onClose.bind(this);\n  }\n  async send(method, params) {\n    this._checkClosed(method);\n    const id = this.nextMessageId();\n    this._rawSend({\n      id,\n      method,\n      params\n    });\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {\n        resolve,\n        reject,\n        error: new _protocolError.ProtocolError(false),\n        method\n      });\n    });\n  }\n  nextMessageId() {\n    return ++this._lastId;\n  }\n  _checkClosed(method) {\n    if (this._closed) throw new _protocolError.ProtocolError(true, `${method}): Browser closed.` + _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));\n  }\n  _rawSend(message) {\n    this._protocolLogger('send', message);\n    this._transport.send(message);\n  }\n  async _onMessage(message) {\n    this._protocolLogger('receive', message);\n    if (message.id === kBrowserCloseMessageId) return;\n    if (message.sessionId) {\n      const session = this._sessions.get(message.sessionId);\n      if (session) session.dispatchMessage(message);\n    } else if (message.id) {\n      const callback = this._callbacks.get(message.id);\n      // Callbacks could be all rejected if someone has called `.dispose()`.\n      if (callback) {\n        this._callbacks.delete(message.id);\n        if (message.error) callback.reject(createProtocolError(callback.error, callback.method, message.error));else callback.resolve(message.result);\n      }\n    } else {\n      Promise.resolve().then(() => this.emit(message.method, message.params));\n    }\n  }\n  _onClose() {\n    this._closed = true;\n    this._transport.onmessage = undefined;\n    this._transport.onclose = undefined;\n    const formattedBrowserLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());\n    for (const session of this._sessions.values()) session.dispose();\n    this._sessions.clear();\n    for (const callback of this._callbacks.values()) {\n      const error = (0, _stackTrace.rewriteErrorMessage)(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs);\n      error.sessionClosed = true;\n      callback.reject(error);\n    }\n    this._callbacks.clear();\n    Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));\n  }\n  close() {\n    if (!this._closed) this._transport.close();\n  }\n  createSession(sessionId) {\n    const session = new FFSession(this, sessionId, message => this._rawSend({\n      ...message,\n      sessionId\n    }));\n    this._sessions.set(sessionId, session);\n    return session;\n  }\n}\nexports.FFConnection = FFConnection;\nconst FFSessionEvents = {\n  Disconnected: Symbol('Disconnected')\n};\nexports.FFSessionEvents = FFSessionEvents;\nclass FFSession extends _events.EventEmitter {\n  constructor(connection, sessionId, rawSend) {\n    super();\n    this._connection = void 0;\n    this._disposed = false;\n    this._callbacks = void 0;\n    this._sessionId = void 0;\n    this._rawSend = void 0;\n    this._crashed = false;\n    this.on = void 0;\n    this.addListener = void 0;\n    this.off = void 0;\n    this.removeListener = void 0;\n    this.once = void 0;\n    this.setMaxListeners(0);\n    this._callbacks = new Map();\n    this._connection = connection;\n    this._sessionId = sessionId;\n    this._rawSend = rawSend;\n    this.on = super.on;\n    this.addListener = super.addListener;\n    this.off = super.removeListener;\n    this.removeListener = super.removeListener;\n    this.once = super.once;\n  }\n  markAsCrashed() {\n    this._crashed = true;\n  }\n  async send(method, params) {\n    if (this._crashed) throw new _protocolError.ProtocolError(true, 'Target crashed');\n    this._connection._checkClosed(method);\n    if (this._disposed) throw new _protocolError.ProtocolError(true, 'Target closed');\n    const id = this._connection.nextMessageId();\n    this._rawSend({\n      method,\n      params,\n      id\n    });\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {\n        resolve,\n        reject,\n        error: new _protocolError.ProtocolError(false),\n        method\n      });\n    });\n  }\n  sendMayFail(method, params) {\n    return this.send(method, params).catch(error => _debugLogger.debugLogger.log('error', error));\n  }\n  dispatchMessage(object) {\n    if (object.id && this._callbacks.has(object.id)) {\n      const callback = this._callbacks.get(object.id);\n      this._callbacks.delete(object.id);\n      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object.error));else callback.resolve(object.result);\n    } else {\n      (0, _utils.assert)(!object.id);\n      Promise.resolve().then(() => this.emit(object.method, object.params));\n    }\n  }\n  dispose() {\n    for (const callback of this._callbacks.values()) {\n      callback.error.sessionClosed = true;\n      callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, 'Target closed'));\n    }\n    this._callbacks.clear();\n    this._disposed = true;\n    this._connection._sessions.delete(this._sessionId);\n    Promise.resolve().then(() => this.emit(FFSessionEvents.Disconnected));\n  }\n}\nexports.FFSession = FFSession;\nfunction createProtocolError(error, method, protocolError) {\n  let message = `Protocol error (${method}): ${protocolError.message}`;\n  if ('data' in protocolError) message += ` ${protocolError.data}`;\n  return (0, _stackTrace.rewriteErrorMessage)(error, message);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FFExecutionContext = void 0;\nvar js = _interopRequireWildcard(require(\"../javascript\"));\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _utilityScriptSerializers = require(\"../isomorphic/utilityScriptSerializers\");\nvar _protocolError = require(\"../protocolError\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass FFExecutionContext {\n  constructor(session, executionContextId) {\n    this._session = void 0;\n    this._executionContextId = void 0;\n    this._session = session;\n    this._executionContextId = executionContextId;\n  }\n  async rawEvaluateJSON(expression) {\n    const payload = await this._session.send('Runtime.evaluate', {\n      expression,\n      returnByValue: true,\n      executionContextId: this._executionContextId\n    }).catch(rewriteError);\n    checkException(payload.exceptionDetails);\n    return payload.result.value;\n  }\n  async rawEvaluateHandle(expression) {\n    const payload = await this._session.send('Runtime.evaluate', {\n      expression,\n      returnByValue: false,\n      executionContextId: this._executionContextId\n    }).catch(rewriteError);\n    checkException(payload.exceptionDetails);\n    return payload.result.objectId;\n  }\n  rawCallFunctionNoReply(func, ...args) {\n    this._session.send('Runtime.callFunction', {\n      functionDeclaration: func.toString(),\n      args: args.map(a => a instanceof js.JSHandle ? {\n        objectId: a._objectId\n      } : {\n        value: a\n      }),\n      returnByValue: true,\n      executionContextId: this._executionContextId\n    }).catch(() => {});\n  }\n  async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {\n    const payload = await this._session.send('Runtime.callFunction', {\n      functionDeclaration: expression,\n      args: [{\n        objectId: utilityScript._objectId,\n        value: undefined\n      }, ...values.map(value => ({\n        value\n      })), ...objectIds.map(objectId => ({\n        objectId,\n        value: undefined\n      }))],\n      returnByValue,\n      executionContextId: this._executionContextId\n    }).catch(rewriteError);\n    checkException(payload.exceptionDetails);\n    if (returnByValue) return (0, _utilityScriptSerializers.parseEvaluationResultValue)(payload.result.value);\n    return utilityScript._context.createHandle(payload.result);\n  }\n  async getProperties(context, objectId) {\n    const response = await this._session.send('Runtime.getObjectProperties', {\n      executionContextId: this._executionContextId,\n      objectId\n    });\n    const result = new Map();\n    for (const property of response.properties) result.set(property.name, context.createHandle(property.value));\n    return result;\n  }\n  createHandle(context, remoteObject) {\n    return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || '', renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));\n  }\n  async releaseHandle(objectId) {\n    await this._session.send('Runtime.disposeObject', {\n      executionContextId: this._executionContextId,\n      objectId\n    });\n  }\n}\nexports.FFExecutionContext = FFExecutionContext;\nfunction checkException(exceptionDetails) {\n  if (!exceptionDetails) return;\n  if (exceptionDetails.value) throw new js.JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));else throw new js.JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? '\\n' + exceptionDetails.stack : ''));\n}\nfunction rewriteError(error) {\n  if (error.message.includes('cyclic object value') || error.message.includes('Object is not serializable')) return {\n    result: {\n      type: 'undefined',\n      value: undefined\n    }\n  };\n  if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) (0, _stackTrace.rewriteErrorMessage)(error, error.message + ' Are you passing a nested JSHandle?');\n  if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error)) throw new Error('Execution context was destroyed, most likely because of a navigation.');\n  throw error;\n}\nfunction potentiallyUnserializableValue(remoteObject) {\n  const value = remoteObject.value;\n  const unserializableValue = remoteObject.unserializableValue;\n  return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;\n}\nfunction renderPreview(object) {\n  if (object.type === 'undefined') return 'undefined';\n  if (object.unserializableValue) return String(object.unserializableValue);\n  if (object.type === 'symbol') return 'Symbol()';\n  if (object.subtype === 'regexp') return 'RegExp';\n  if (object.subtype === 'weakmap') return 'WeakMap';\n  if (object.subtype === 'weakset') return 'WeakSet';\n  if (object.subtype) return object.subtype[0].toUpperCase() + object.subtype.slice(1);\n  if ('value' in object) return String(object.value);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction toModifiersMask(modifiers) {\n  let mask = 0;\n  if (modifiers.has('Alt')) mask |= 1;\n  if (modifiers.has('Control')) mask |= 2;\n  if (modifiers.has('Shift')) mask |= 4;\n  if (modifiers.has('Meta')) mask |= 8;\n  return mask;\n}\nfunction toButtonNumber(button) {\n  if (button === 'left') return 0;\n  if (button === 'middle') return 1;\n  if (button === 'right') return 2;\n  return 0;\n}\nfunction toButtonsMask(buttons) {\n  let mask = 0;\n  if (buttons.has('left')) mask |= 1;\n  if (buttons.has('right')) mask |= 2;\n  if (buttons.has('middle')) mask |= 4;\n  return mask;\n}\nclass RawKeyboardImpl {\n  constructor(client) {\n    this._client = void 0;\n    this._client = client;\n  }\n  async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {\n    if (code === 'MetaLeft') code = 'OSLeft';\n    if (code === 'MetaRight') code = 'OSRight';\n    // Firefox will figure out Enter by itself\n    if (text === '\\r') text = '';\n    await this._client.send('Page.dispatchKeyEvent', {\n      type: 'keydown',\n      keyCode: keyCodeWithoutLocation,\n      code,\n      key,\n      repeat: autoRepeat,\n      location,\n      text\n    });\n  }\n  async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {\n    if (code === 'MetaLeft') code = 'OSLeft';\n    if (code === 'MetaRight') code = 'OSRight';\n    await this._client.send('Page.dispatchKeyEvent', {\n      type: 'keyup',\n      key,\n      keyCode: keyCodeWithoutLocation,\n      code,\n      location,\n      repeat: false\n    });\n  }\n  async sendText(text) {\n    await this._client.send('Page.insertText', {\n      text\n    });\n  }\n}\nexports.RawKeyboardImpl = RawKeyboardImpl;\nclass RawMouseImpl {\n  constructor(client) {\n    this._client = void 0;\n    this._page = void 0;\n    this._client = client;\n  }\n  async move(x, y, button, buttons, modifiers, forClick) {\n    await this._client.send('Page.dispatchMouseEvent', {\n      type: 'mousemove',\n      button: 0,\n      buttons: toButtonsMask(buttons),\n      x: Math.floor(x),\n      y: Math.floor(y),\n      modifiers: toModifiersMask(modifiers)\n    });\n  }\n  async down(x, y, button, buttons, modifiers, clickCount) {\n    await this._client.send('Page.dispatchMouseEvent', {\n      type: 'mousedown',\n      button: toButtonNumber(button),\n      buttons: toButtonsMask(buttons),\n      x: Math.floor(x),\n      y: Math.floor(y),\n      modifiers: toModifiersMask(modifiers),\n      clickCount\n    });\n  }\n  async up(x, y, button, buttons, modifiers, clickCount) {\n    await this._client.send('Page.dispatchMouseEvent', {\n      type: 'mouseup',\n      button: toButtonNumber(button),\n      buttons: toButtonsMask(buttons),\n      x: Math.floor(x),\n      y: Math.floor(y),\n      modifiers: toModifiersMask(modifiers),\n      clickCount\n    });\n  }\n  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {\n    // Wheel events hit the compositor first, so wait one frame for it to be synced.\n    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, 'utility');\n    await this._client.send('Page.dispatchWheelEvent', {\n      deltaX,\n      deltaY,\n      x: Math.floor(x),\n      y: Math.floor(y),\n      deltaZ: 0,\n      modifiers: toModifiersMask(modifiers)\n    });\n  }\n  setPage(page) {\n    this._page = page;\n  }\n}\nexports.RawMouseImpl = RawMouseImpl;\nclass RawTouchscreenImpl {\n  constructor(client) {\n    this._client = void 0;\n    this._client = client;\n  }\n  async tap(x, y, modifiers) {\n    await this._client.send('Page.dispatchTapEvent', {\n      x,\n      y,\n      modifiers: toModifiersMask(modifiers)\n    });\n  }\n}\nexports.RawTouchscreenImpl = RawTouchscreenImpl;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FFNetworkManager = void 0;\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass FFNetworkManager {\n  constructor(session, page) {\n    this._session = void 0;\n    this._requests = void 0;\n    this._page = void 0;\n    this._eventListeners = void 0;\n    this._session = session;\n    this._requests = new Map();\n    this._page = page;\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestFinished', this._onRequestFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestFailed', this._onRequestFailed.bind(this))];\n  }\n  dispose() {\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n  }\n  async setRequestInterception(enabled) {\n    await this._session.send('Network.setRequestInterception', {\n      enabled\n    });\n  }\n  _onRequestWillBeSent(event) {\n    const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;\n    const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;\n    if (!frame) return;\n    if (redirectedFrom) this._requests.delete(redirectedFrom._id);\n    const request = new InterceptableRequest(frame, redirectedFrom, event);\n    let route;\n    if (event.isIntercepted) route = new FFRouteImpl(this._session, request);\n    this._requests.set(request._id, request);\n    this._page._frameManager.requestStarted(request.request, route);\n  }\n  _onResponseReceived(event) {\n    var _event$securityDetail, _event$securityDetail2, _event$securityDetail3, _event$securityDetail4, _event$securityDetail5;\n    const request = this._requests.get(event.requestId);\n    if (!request) return;\n    const getResponseBody = async () => {\n      const response = await this._session.send('Network.getResponseBody', {\n        requestId: request._id\n      });\n      if (response.evicted) throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);\n      return Buffer.from(response.base64body, 'base64');\n    };\n    const startTime = event.timing.startTime;\n    function relativeToStart(time) {\n      if (!time) return -1;\n      return (time - startTime) / 1000;\n    }\n    const timing = {\n      startTime: startTime / 1000,\n      domainLookupStart: relativeToStart(event.timing.domainLookupStart),\n      domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),\n      connectStart: relativeToStart(event.timing.connectStart),\n      secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),\n      connectEnd: relativeToStart(event.timing.connectEnd),\n      requestStart: relativeToStart(event.timing.requestStart),\n      responseStart: relativeToStart(event.timing.responseStart)\n    };\n    const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody, event.fromServiceWorker);\n    if (event !== null && event !== void 0 && event.remoteIPAddress && typeof (event === null || event === void 0 ? void 0 : event.remotePort) === 'number') {\n      response._serverAddrFinished({\n        ipAddress: event.remoteIPAddress,\n        port: event.remotePort\n      });\n    } else {\n      response._serverAddrFinished();\n    }\n    response._securityDetailsFinished({\n      protocol: event === null || event === void 0 ? void 0 : (_event$securityDetail = event.securityDetails) === null || _event$securityDetail === void 0 ? void 0 : _event$securityDetail.protocol,\n      subjectName: event === null || event === void 0 ? void 0 : (_event$securityDetail2 = event.securityDetails) === null || _event$securityDetail2 === void 0 ? void 0 : _event$securityDetail2.subjectName,\n      issuer: event === null || event === void 0 ? void 0 : (_event$securityDetail3 = event.securityDetails) === null || _event$securityDetail3 === void 0 ? void 0 : _event$securityDetail3.issuer,\n      validFrom: event === null || event === void 0 ? void 0 : (_event$securityDetail4 = event.securityDetails) === null || _event$securityDetail4 === void 0 ? void 0 : _event$securityDetail4.validFrom,\n      validTo: event === null || event === void 0 ? void 0 : (_event$securityDetail5 = event.securityDetails) === null || _event$securityDetail5 === void 0 ? void 0 : _event$securityDetail5.validTo\n    });\n    // \"raw\" headers are the same as \"provisional\" headers in Firefox.\n    response.setRawResponseHeaders(null);\n    // Headers size are not available in Firefox.\n    response.setResponseHeadersSize(null);\n    this._page._frameManager.requestReceivedResponse(response);\n  }\n  _onRequestFinished(event) {\n    const request = this._requests.get(event.requestId);\n    if (!request) return;\n    const response = request.request._existingResponse();\n    response.setTransferSize(event.transferSize);\n    response.setEncodedBodySize(event.encodedBodySize);\n\n    // Keep redirected requests in the map for future reference as redirectedFrom.\n    const isRedirected = response.status() >= 300 && response.status() <= 399;\n    const responseEndTime = event.responseEndTime ? event.responseEndTime / 1000 - response.timing().startTime : -1;\n    if (isRedirected) {\n      response._requestFinished(responseEndTime);\n    } else {\n      this._requests.delete(request._id);\n      response._requestFinished(responseEndTime);\n    }\n    if (event.protocolVersion) response._setHttpVersion(event.protocolVersion);\n    this._page._frameManager.reportRequestFinished(request.request, response);\n  }\n  _onRequestFailed(event) {\n    const request = this._requests.get(event.requestId);\n    if (!request) return;\n    this._requests.delete(request._id);\n    const response = request.request._existingResponse();\n    if (response) {\n      response.setTransferSize(null);\n      response.setEncodedBodySize(null);\n      response._requestFinished(-1);\n    }\n    request.request._setFailureText(event.errorCode);\n    this._page._frameManager.requestFailed(request.request, event.errorCode === 'NS_BINDING_ABORTED');\n  }\n}\nexports.FFNetworkManager = FFNetworkManager;\nconst causeToResourceType = {\n  TYPE_INVALID: 'other',\n  TYPE_OTHER: 'other',\n  TYPE_SCRIPT: 'script',\n  TYPE_IMAGE: 'image',\n  TYPE_STYLESHEET: 'stylesheet',\n  TYPE_OBJECT: 'other',\n  TYPE_DOCUMENT: 'document',\n  TYPE_SUBDOCUMENT: 'document',\n  TYPE_REFRESH: 'document',\n  TYPE_XBL: 'other',\n  TYPE_PING: 'other',\n  TYPE_XMLHTTPREQUEST: 'xhr',\n  TYPE_OBJECT_SUBREQUEST: 'other',\n  TYPE_DTD: 'other',\n  TYPE_FONT: 'font',\n  TYPE_MEDIA: 'media',\n  TYPE_WEBSOCKET: 'websocket',\n  TYPE_CSP_REPORT: 'other',\n  TYPE_XSLT: 'other',\n  TYPE_BEACON: 'other',\n  TYPE_FETCH: 'fetch',\n  TYPE_IMAGESET: 'images',\n  TYPE_WEB_MANIFEST: 'manifest'\n};\nconst internalCauseToResourceType = {\n  TYPE_INTERNAL_EVENTSOURCE: 'eventsource'\n};\nclass InterceptableRequest {\n  constructor(frame, redirectedFrom, payload) {\n    this.request = void 0;\n    this._id = void 0;\n    this._redirectedTo = void 0;\n    this._id = payload.requestId;\n    if (redirectedFrom) redirectedFrom._redirectedTo = this;\n    let postDataBuffer = null;\n    if (payload.postData) postDataBuffer = Buffer.from(payload.postData, 'base64');\n    this.request = new network.Request(frame._page._browserContext, frame, null, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || 'other', payload.method, postDataBuffer, payload.headers);\n    // \"raw\" headers are the same as \"provisional\" headers in Firefox.\n    this.request.setRawRequestHeaders(null);\n  }\n  _finalRequest() {\n    let request = this;\n    while (request._redirectedTo) request = request._redirectedTo;\n    return request;\n  }\n}\nclass FFRouteImpl {\n  constructor(session, request) {\n    this._request = void 0;\n    this._session = void 0;\n    this._session = session;\n    this._request = request;\n  }\n  async continue(request, overrides) {\n    await this._session.sendMayFail('Network.resumeInterceptedRequest', {\n      requestId: this._request._id,\n      url: overrides.url,\n      method: overrides.method,\n      headers: overrides.headers,\n      postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined\n    });\n  }\n  async fulfill(response) {\n    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');\n    await this._session.sendMayFail('Network.fulfillInterceptedRequest', {\n      requestId: this._request._id,\n      status: response.status,\n      statusText: network.STATUS_TEXTS[String(response.status)] || '',\n      headers: response.headers,\n      base64body\n    });\n  }\n  async abort(errorCode) {\n    await this._session.sendMayFail('Network.abortInterceptedRequest', {\n      requestId: this._request._id,\n      errorCode\n    });\n  }\n}\nfunction parseMultivalueHeaders(headers) {\n  const result = [];\n  for (const header of headers) {\n    const separator = header.name.toLowerCase() === 'set-cookie' ? '\\n' : ',';\n    const tokens = header.value.split(separator).map(s => s.trim());\n    for (const token of tokens) result.push({\n      name: header.name,\n      value: token\n    });\n  }\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UTILITY_WORLD_NAME = exports.FFPage = void 0;\nvar dialog = _interopRequireWildcard(require(\"../dialog\"));\nvar dom = _interopRequireWildcard(require(\"../dom\"));\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _page = require(\"../page\");\nvar _ffAccessibility = require(\"./ffAccessibility\");\nvar _ffConnection = require(\"./ffConnection\");\nvar _ffExecutionContext = require(\"./ffExecutionContext\");\nvar _ffInput = require(\"./ffInput\");\nvar _ffNetworkManager = require(\"./ffNetworkManager\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst UTILITY_WORLD_NAME = '__playwright_utility_world__';\nexports.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;\nclass FFPage {\n  constructor(session, browserContext, opener) {\n    this.cspErrorsAsynchronousForInlineScipts = true;\n    this.rawMouse = void 0;\n    this.rawKeyboard = void 0;\n    this.rawTouchscreen = void 0;\n    this._session = void 0;\n    this._page = void 0;\n    this._networkManager = void 0;\n    this._browserContext = void 0;\n    this._pagePromise = new _manualPromise.ManualPromise();\n    this._initializedPage = null;\n    this._initializationFailed = false;\n    this._opener = void 0;\n    this._contextIdToContext = void 0;\n    this._eventListeners = void 0;\n    this._workers = new Map();\n    this._screencastId = void 0;\n    this._initScripts = [];\n    this._session = session;\n    this._opener = opener;\n    this.rawKeyboard = new _ffInput.RawKeyboardImpl(session);\n    this.rawMouse = new _ffInput.RawMouseImpl(session);\n    this.rawTouchscreen = new _ffInput.RawTouchscreenImpl(session);\n    this._contextIdToContext = new Map();\n    this._browserContext = browserContext;\n    this._page = new _page.Page(this, browserContext);\n    this.rawMouse.setPage(this._page);\n    this._networkManager = new _ffNetworkManager.FFNetworkManager(session, this._page);\n    this._page.on(_page.Page.Events.FrameDetached, frame => this._removeContextsForFrame(frame));\n    // TODO: remove Page.willOpenNewWindowAsynchronously from the protocol.\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, 'Page.eventFired', this._onEventFired.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameAttached', this._onFrameAttached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameDetached', this._onFrameDetached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigationAborted', this._onNavigationAborted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigationCommitted', this._onNavigationCommitted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigationStarted', this._onNavigationStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.sameDocumentNavigation', this._onSameDocumentNavigation.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextCreated', this._onExecutionContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextDestroyed', this._onExecutionContextDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.linkClicked', event => this._onLinkClicked(event.phase)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.uncaughtError', this._onUncaughtError.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.console', this._onConsole.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.dialogOpened', this._onDialogOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.bindingCalled', this._onBindingCalled.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.fileChooserOpened', this._onFileChooserOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.workerCreated', this._onWorkerCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.workerDestroyed', this._onWorkerDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.dispatchMessageFromWorker', this._onDispatchMessageFromWorker.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.crashed', this._onCrashed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.videoRecordingStarted', this._onVideoRecordingStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketCreated', this._onWebSocketCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketClosed', this._onWebSocketClosed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketFrameReceived', this._onWebSocketFrameReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketFrameSent', this._onWebSocketFrameSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.screencastFrame', this._onScreencastFrame.bind(this))];\n    session.once(_ffConnection.FFSessionEvents.Disconnected, () => {\n      this._markAsError(new Error('Page closed'));\n      this._page._didDisconnect();\n    });\n    this._session.once('Page.ready', async () => {\n      await this._page.initOpener(this._opener);\n      if (this._initializationFailed) return;\n      // Note: it is important to call |reportAsNew| before resolving pageOrError promise,\n      // so that anyone who awaits pageOrError got a ready and reported page.\n      this._initializedPage = this._page;\n      this._page.reportAsNew();\n      this._pagePromise.resolve(this._page);\n    });\n    // Ideally, we somehow ensure that utility world is created before Page.ready arrives, but currently it is racy.\n    // Therefore, we can end up with an initialized page without utility world, although very unlikely.\n    this.addInitScript('', UTILITY_WORLD_NAME).catch(e => this._markAsError(e));\n  }\n  potentiallyUninitializedPage() {\n    return this._page;\n  }\n  async _markAsError(error) {\n    // Same error may be report twice: channer disconnected and session.send fails.\n    if (this._initializationFailed) return;\n    this._initializationFailed = true;\n    if (!this._initializedPage) {\n      await this._page.initOpener(this._opener);\n      this._page.reportAsNew(error);\n      this._pagePromise.resolve(error);\n    }\n  }\n  async pageOrError() {\n    return this._pagePromise;\n  }\n  _onWebSocketCreated(event) {\n    this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);\n    this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));\n  }\n  _onWebSocketClosed(event) {\n    if (event.error) this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);\n    this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));\n  }\n  _onWebSocketFrameReceived(event) {\n    this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);\n  }\n  _onWebSocketFrameSent(event) {\n    this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);\n  }\n  _onExecutionContextCreated(payload) {\n    const {\n      executionContextId,\n      auxData\n    } = payload;\n    const frame = this._page._frameManager.frame(auxData.frameId);\n    if (!frame) return;\n    const delegate = new _ffExecutionContext.FFExecutionContext(this._session, executionContextId);\n    let worldName = null;\n    if (auxData.name === UTILITY_WORLD_NAME) worldName = 'utility';else if (!auxData.name) worldName = 'main';\n    const context = new dom.FrameExecutionContext(delegate, frame, worldName);\n    context[contextDelegateSymbol] = delegate;\n    if (worldName) frame._contextCreated(worldName, context);\n    this._contextIdToContext.set(executionContextId, context);\n  }\n  _onExecutionContextDestroyed(payload) {\n    const {\n      executionContextId\n    } = payload;\n    const context = this._contextIdToContext.get(executionContextId);\n    if (!context) return;\n    this._contextIdToContext.delete(executionContextId);\n    context.frame._contextDestroyed(context);\n  }\n  _onExecutionContextsCleared() {\n    for (const executionContextId of Array.from(this._contextIdToContext.keys())) this._onExecutionContextDestroyed({\n      executionContextId\n    });\n  }\n  _removeContextsForFrame(frame) {\n    for (const [contextId, context] of this._contextIdToContext) {\n      if (context.frame === frame) this._contextIdToContext.delete(contextId);\n    }\n  }\n  _onLinkClicked(phase) {\n    if (phase === 'before') this._page._frameManager.frameWillPotentiallyRequestNavigation();else this._page._frameManager.frameDidPotentiallyRequestNavigation();\n  }\n  _onNavigationStarted(params) {\n    this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);\n  }\n  _onNavigationAborted(params) {\n    this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);\n  }\n  _onNavigationCommitted(params) {\n    for (const [workerId, worker] of this._workers) {\n      if (worker.frameId === params.frameId) this._onWorkerDestroyed({\n        workerId\n      });\n    }\n    this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || '', params.navigationId || '', false);\n  }\n  _onSameDocumentNavigation(params) {\n    this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);\n  }\n  _onFrameAttached(params) {\n    this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);\n  }\n  _onFrameDetached(params) {\n    this._page._frameManager.frameDetached(params.frameId);\n  }\n  _onEventFired(payload) {\n    const {\n      frameId,\n      name\n    } = payload;\n    if (name === 'load') this._page._frameManager.frameLifecycleEvent(frameId, 'load');\n    if (name === 'DOMContentLoaded') this._page._frameManager.frameLifecycleEvent(frameId, 'domcontentloaded');\n  }\n  _onUncaughtError(params) {\n    const {\n      name,\n      message\n    } = (0, _stackTrace.splitErrorMessage)(params.message);\n    const error = new Error(message);\n    error.stack = params.message + '\\n' + params.stack.split('\\n').filter(Boolean).map(a => a.replace(/([^@]*)@(.*)/, '    at $1 ($2)')).join('\\n');\n    error.name = name;\n    this._page.firePageError(error);\n  }\n  _onConsole(payload) {\n    const {\n      type,\n      args,\n      executionContextId,\n      location\n    } = payload;\n    const context = this._contextIdToContext.get(executionContextId);\n    if (!context) return;\n    this._page._addConsoleMessage(type, args.map(arg => context.createHandle(arg)), location);\n  }\n  _onDialogOpened(params) {\n    this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, async (accept, promptText) => {\n      await this._session.sendMayFail('Page.handleDialog', {\n        dialogId: params.dialogId,\n        accept,\n        promptText\n      });\n    }, params.defaultValue));\n  }\n  async _onBindingCalled(event) {\n    const pageOrError = await this.pageOrError();\n    if (!(pageOrError instanceof Error)) {\n      const context = this._contextIdToContext.get(event.executionContextId);\n      if (context) await this._page._onBindingCalled(event.payload, context);\n    }\n  }\n  async _onFileChooserOpened(payload) {\n    const {\n      executionContextId,\n      element\n    } = payload;\n    const context = this._contextIdToContext.get(executionContextId);\n    if (!context) return;\n    const handle = context.createHandle(element).asElement();\n    await this._page._onFileChooserOpened(handle);\n  }\n  async _onWorkerCreated(event) {\n    const workerId = event.workerId;\n    const worker = new _page.Worker(this._page, event.url);\n    const workerSession = new _ffConnection.FFSession(this._session._connection, workerId, message => {\n      this._session.send('Page.sendMessageToWorker', {\n        frameId: event.frameId,\n        workerId: workerId,\n        message: JSON.stringify(message)\n      }).catch(e => {\n        workerSession.dispatchMessage({\n          id: message.id,\n          method: '',\n          params: {},\n          error: {\n            message: e.message,\n            data: undefined\n          }\n        });\n      });\n    });\n    this._workers.set(workerId, {\n      session: workerSession,\n      frameId: event.frameId\n    });\n    this._page._addWorker(workerId, worker);\n    workerSession.once('Runtime.executionContextCreated', event => {\n      worker._createExecutionContext(new _ffExecutionContext.FFExecutionContext(workerSession, event.executionContextId));\n    });\n    workerSession.on('Runtime.console', event => {\n      const {\n        type,\n        args,\n        location\n      } = event;\n      const context = worker._existingExecutionContext;\n      this._page._addConsoleMessage(type, args.map(arg => context.createHandle(arg)), location);\n    });\n    // Note: we receive worker exceptions directly from the page.\n  }\n\n  _onWorkerDestroyed(event) {\n    const workerId = event.workerId;\n    const worker = this._workers.get(workerId);\n    if (!worker) return;\n    worker.session.dispose();\n    this._workers.delete(workerId);\n    this._page._removeWorker(workerId);\n  }\n  async _onDispatchMessageFromWorker(event) {\n    const worker = this._workers.get(event.workerId);\n    if (!worker) return;\n    worker.session.dispatchMessage(JSON.parse(event.message));\n  }\n  async _onCrashed(event) {\n    this._session.markAsCrashed();\n    this._page._didCrash();\n  }\n  _onVideoRecordingStarted(event) {\n    this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());\n  }\n  async exposeBinding(binding) {\n    await this._session.send('Page.addBinding', {\n      name: binding.name,\n      script: binding.source\n    });\n  }\n  async removeExposedBindings() {\n    // TODO: implement me.\n  }\n  didClose() {\n    this._session.dispose();\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n    this._networkManager.dispose();\n    this._page._didClose();\n  }\n  async navigateFrame(frame, url, referer) {\n    const response = await this._session.send('Page.navigate', {\n      url,\n      referer,\n      frameId: frame._id\n    });\n    return {\n      newDocumentId: response.navigationId || undefined\n    };\n  }\n  async updateExtraHTTPHeaders() {\n    await this._session.send('Network.setExtraHTTPHeaders', {\n      headers: this._page.extraHTTPHeaders() || []\n    });\n  }\n  async updateEmulatedViewportSize() {\n    const viewportSize = this._page.viewportSize();\n    await this._session.send('Page.setViewportSize', {\n      viewportSize\n    });\n  }\n  async bringToFront() {\n    await this._session.send('Page.bringToFront', {});\n  }\n  async updateEmulateMedia() {\n    const emulatedMedia = this._page.emulatedMedia();\n    const colorScheme = emulatedMedia.colorScheme === 'no-override' ? undefined : emulatedMedia.colorScheme;\n    const reducedMotion = emulatedMedia.reducedMotion === 'no-override' ? undefined : emulatedMedia.reducedMotion;\n    const forcedColors = emulatedMedia.forcedColors === 'no-override' ? undefined : emulatedMedia.forcedColors;\n    await this._session.send('Page.setEmulatedMedia', {\n      // Empty string means reset.\n      type: emulatedMedia.media === 'no-override' ? '' : emulatedMedia.media,\n      colorScheme,\n      reducedMotion,\n      forcedColors\n    });\n  }\n  async updateRequestInterception() {\n    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());\n  }\n  async updateFileChooserInterception() {\n    const enabled = this._page.fileChooserIntercepted();\n    await this._session.send('Page.setInterceptFileChooserDialog', {\n      enabled\n    }).catch(() => {}); // target can be closed.\n  }\n\n  async reload() {\n    await this._session.send('Page.reload');\n  }\n  async goBack() {\n    const {\n      success\n    } = await this._session.send('Page.goBack', {\n      frameId: this._page.mainFrame()._id\n    });\n    return success;\n  }\n  async goForward() {\n    const {\n      success\n    } = await this._session.send('Page.goForward', {\n      frameId: this._page.mainFrame()._id\n    });\n    return success;\n  }\n  async addInitScript(script, worldName) {\n    this._initScripts.push({\n      script,\n      worldName\n    });\n    await this._session.send('Page.setInitScripts', {\n      scripts: this._initScripts\n    });\n  }\n  async removeInitScripts() {\n    this._initScripts = [];\n    await this._session.send('Page.setInitScripts', {\n      scripts: []\n    });\n  }\n  async closePage(runBeforeUnload) {\n    await this._session.send('Page.close', {\n      runBeforeUnload\n    });\n  }\n  async setBackgroundColor(color) {\n    if (color) throw new Error('Not implemented');\n  }\n  async takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {\n    if (!documentRect) {\n      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({\n        x: window.scrollX,\n        y: window.scrollY\n      }));\n      documentRect = {\n        x: viewportRect.x + scrollOffset.x,\n        y: viewportRect.y + scrollOffset.y,\n        width: viewportRect.width,\n        height: viewportRect.height\n      };\n    }\n    progress.throwIfAborted();\n    const {\n      data\n    } = await this._session.send('Page.screenshot', {\n      mimeType: 'image/' + format,\n      clip: documentRect,\n      omitDeviceScaleFactor: scale === 'css'\n    });\n    return Buffer.from(data, 'base64');\n  }\n  async getContentFrame(handle) {\n    const {\n      contentFrameId\n    } = await this._session.send('Page.describeNode', {\n      frameId: handle._context.frame._id,\n      objectId: handle._objectId\n    });\n    if (!contentFrameId) return null;\n    return this._page._frameManager.frame(contentFrameId);\n  }\n  async getOwnerFrame(handle) {\n    const {\n      ownerFrameId\n    } = await this._session.send('Page.describeNode', {\n      frameId: handle._context.frame._id,\n      objectId: handle._objectId\n    });\n    return ownerFrameId || null;\n  }\n  isElementHandle(remoteObject) {\n    return remoteObject.subtype === 'node';\n  }\n  async getBoundingBox(handle) {\n    const quads = await this.getContentQuads(handle);\n    if (!quads || !quads.length) return null;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (const quad of quads) {\n      for (const point of quad) {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    }\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n  async scrollRectIntoViewIfNeeded(handle, rect) {\n    return await this._session.send('Page.scrollIntoViewIfNeeded', {\n      frameId: handle._context.frame._id,\n      objectId: handle._objectId,\n      rect\n    }).then(() => 'done').catch(e => {\n      if (e instanceof Error && e.message.includes('Node is detached from document')) return 'error:notconnected';\n      if (e instanceof Error && e.message.includes('Node does not have a layout object')) return 'error:notvisible';\n      throw e;\n    });\n  }\n  async setScreencastOptions(options) {\n    if (options) {\n      const {\n        screencastId\n      } = await this._session.send('Page.startScreencast', options);\n      this._screencastId = screencastId;\n    } else {\n      await this._session.send('Page.stopScreencast');\n    }\n  }\n  _onScreencastFrame(event) {\n    if (!this._screencastId) return;\n    const screencastId = this._screencastId;\n    this._page.throttleScreencastFrameAck(() => {\n      this._session.send('Page.screencastFrameAck', {\n        screencastId\n      }).catch(e => _debugLogger.debugLogger.log('error', e));\n    });\n    const buffer = Buffer.from(event.data, 'base64');\n    this._page.emit(_page.Page.Events.ScreencastFrame, {\n      buffer,\n      width: event.deviceWidth,\n      height: event.deviceHeight\n    });\n  }\n  rafCountForStablePosition() {\n    return 1;\n  }\n  async getContentQuads(handle) {\n    const result = await this._session.sendMayFail('Page.getContentQuads', {\n      frameId: handle._context.frame._id,\n      objectId: handle._objectId\n    });\n    if (!result) return null;\n    return result.quads.map(quad => [quad.p1, quad.p2, quad.p3, quad.p4]);\n  }\n  async setInputFiles(handle, files) {\n    await handle.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), files);\n  }\n  async setInputFilePaths(handle, files) {\n    await Promise.all([this._session.send('Page.setFileInputFiles', {\n      frameId: handle._context.frame._id,\n      objectId: handle._objectId,\n      files\n    }), handle.dispatchEvent('input'), handle.dispatchEvent('change')]);\n  }\n  async adoptElementHandle(handle, to) {\n    const result = await this._session.send('Page.adoptNode', {\n      frameId: handle._context.frame._id,\n      objectId: handle._objectId,\n      executionContextId: to[contextDelegateSymbol]._executionContextId\n    });\n    if (!result.remoteObject) throw new Error(dom.kUnableToAdoptErrorMessage);\n    return to.createHandle(result.remoteObject);\n  }\n  async getAccessibilityTree(needle) {\n    return (0, _ffAccessibility.getAccessibilityTree)(this._session, needle);\n  }\n  async inputActionEpilogue() {}\n  async getFrameElement(frame) {\n    const parent = frame.parentFrame();\n    if (!parent) throw new Error('Frame has been detached.');\n    const context = await parent._mainContext();\n    const result = await this._session.send('Page.adoptNode', {\n      frameId: frame._id,\n      executionContextId: context[contextDelegateSymbol]._executionContextId\n    });\n    if (!result.remoteObject) throw new Error('Frame has been detached.');\n    return context.createHandle(result.remoteObject);\n  }\n}\nexports.FFPage = FFPage;\nfunction webSocketId(frameId, wsid) {\n  return `${frameId}---${wsid}`;\n}\nconst contextDelegateSymbol = Symbol('delegate');","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Firefox = void 0;\nvar os = _interopRequireWildcard(require(\"os\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _ffBrowser = require(\"./ffBrowser\");\nvar _ffConnection = require(\"./ffConnection\");\nvar _browserType = require(\"../browserType\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _utils = require(\"../../utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Firefox extends _browserType.BrowserType {\n  constructor(playwrightOptions) {\n    super('firefox', playwrightOptions);\n  }\n  _connectToTransport(transport, options) {\n    return _ffBrowser.FFBrowser.connect(transport, options);\n  }\n  _rewriteStartupError(error) {\n    if (error.message.includes('no DISPLAY environment variable specified')) return (0, _stackTrace.rewriteErrorMessage)(error, '\\n' + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));\n    return error;\n  }\n  _amendEnvironment(env, userDataDir, executable, browserArguments) {\n    if (!_path.default.isAbsolute(os.homedir())) throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === 'win32' ? 'USERPROFILE' : 'HOME'} to a relative path?`);\n    if (os.platform() === 'linux') {\n      // Always remove SNAP_NAME and SNAP_INSTANCE_NAME env variables since they\n      // confuse Firefox: in our case, builds never come from SNAP.\n      // See https://github.com/microsoft/playwright/issues/20555\n      return {\n        ...env,\n        SNAP_NAME: undefined,\n        SNAP_INSTANCE_NAME: undefined\n      };\n    }\n    return env;\n  }\n  _attemptToGracefullyCloseBrowser(transport) {\n    const message = {\n      method: 'Browser.close',\n      params: {},\n      id: _ffConnection.kBrowserCloseMessageId\n    };\n    transport.send(message);\n  }\n  _defaultArgs(options, isPersistent, userDataDir) {\n    const {\n      args = [],\n      headless\n    } = options;\n    const userDataDirArg = args.find(arg => arg.startsWith('-profile') || arg.startsWith('--profile'));\n    if (userDataDirArg) throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument');\n    if (args.find(arg => arg.startsWith('-juggler'))) throw new Error('Use the port parameter instead of -juggler argument');\n    let firefoxUserPrefs = isPersistent ? undefined : options.firefoxUserPrefs;\n    if ((0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_DISABLE_FIREFOX_CROSS_PROCESS')) firefoxUserPrefs = {\n      ...kDisableFissionFirefoxUserPrefs,\n      ...firefoxUserPrefs\n    };\n    if (Object.keys(kBandaidFirefoxUserPrefs).length) firefoxUserPrefs = {\n      ...kBandaidFirefoxUserPrefs,\n      ...firefoxUserPrefs\n    };\n    if (firefoxUserPrefs) {\n      const lines = [];\n      for (const [name, value] of Object.entries(firefoxUserPrefs)) lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);\n      _fs.default.writeFileSync(_path.default.join(userDataDir, 'user.js'), lines.join('\\n'));\n    }\n    const firefoxArguments = ['-no-remote'];\n    if (headless) {\n      firefoxArguments.push('-headless');\n    } else {\n      firefoxArguments.push('-wait-for-browser');\n      firefoxArguments.push('-foreground');\n    }\n    firefoxArguments.push(`-profile`, userDataDir);\n    firefoxArguments.push('-juggler-pipe');\n    firefoxArguments.push(...args);\n    if (isPersistent) firefoxArguments.push('about:blank');else firefoxArguments.push('-silent');\n    return firefoxArguments;\n  }\n}\n\n// Prefs for quick fixes that didn't make it to the build.\n// Should all be moved to `playwright.cfg`.\nexports.Firefox = Firefox;\nconst kBandaidFirefoxUserPrefs = {};\nconst kDisableFissionFirefoxUserPrefs = {\n  'browser.tabs.remote.useCrossOriginEmbedderPolicy': false,\n  'browser.tabs.remote.useCrossOriginOpenerPolicy': false,\n  'browser.tabs.remote.separatePrivilegedMozillaWebContentProcess': false,\n  'fission.autostart': false,\n  'browser.tabs.remote.systemTriggeredAboutBlankAnywhere': true\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultipartFormData = void 0;\nvar _utilsBundle = require(\"../utilsBundle\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass MultipartFormData {\n  constructor() {\n    this._boundary = void 0;\n    this._chunks = [];\n    this._boundary = generateUniqueBoundaryString();\n  }\n  contentTypeHeader() {\n    return `multipart/form-data; boundary=${this._boundary}`;\n  }\n  addField(name, value) {\n    this._beginMultiPartHeader(name);\n    this._finishMultiPartHeader();\n    this._chunks.push(Buffer.from(value));\n    this._finishMultiPartField();\n  }\n  addFileField(name, value) {\n    this._beginMultiPartHeader(name);\n    this._chunks.push(Buffer.from(`; filename=\"${value.name}\"`));\n    this._chunks.push(Buffer.from(`\\r\\ncontent-type: ${value.mimeType || _utilsBundle.mime.getType(value.name) || 'application/octet-stream'}`));\n    this._finishMultiPartHeader();\n    this._chunks.push(value.buffer);\n    this._finishMultiPartField();\n  }\n  finish() {\n    this._addBoundary(true);\n    return Buffer.concat(this._chunks);\n  }\n  _beginMultiPartHeader(name) {\n    this._addBoundary();\n    this._chunks.push(Buffer.from(`content-disposition: form-data; name=\"${name}\"`));\n  }\n  _finishMultiPartHeader() {\n    this._chunks.push(Buffer.from(`\\r\\n\\r\\n`));\n  }\n  _finishMultiPartField() {\n    this._chunks.push(Buffer.from(`\\r\\n`));\n  }\n  _addBoundary(isLastBoundary) {\n    this._chunks.push(Buffer.from('--' + this._boundary));\n    if (isLastBoundary) this._chunks.push(Buffer.from('--'));\n    this._chunks.push(Buffer.from('\\r\\n'));\n  }\n}\nexports.MultipartFormData = MultipartFormData;\nconst alphaNumericEncodingMap = [0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42];\n\n// See generateUniqueBoundaryString() in WebKit\nfunction generateUniqueBoundaryString() {\n  const charCodes = [];\n  for (let i = 0; i < 16; i++) charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);\n  return '----WebKitFormBoundary' + String.fromCharCode(...charCodes);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NavigationAbortedError = exports.FrameManager = exports.Frame = void 0;\nvar dom = _interopRequireWildcard(require(\"./dom\"));\nvar _helper = require(\"./helper\");\nvar _eventsHelper = require(\"../utils/eventsHelper\");\nvar js = _interopRequireWildcard(require(\"./javascript\"));\nvar network = _interopRequireWildcard(require(\"./network\"));\nvar _page = require(\"./page\");\nvar types = _interopRequireWildcard(require(\"./types\"));\nvar _browserContext = require(\"./browserContext\");\nvar _progress = require(\"./progress\");\nvar _utils = require(\"../utils\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _protocolError = require(\"./protocolError\");\nvar _selectorParser = require(\"./isomorphic/selectorParser\");\nvar _locatorGenerators = require(\"./isomorphic/locatorGenerators\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass NavigationAbortedError extends Error {\n  constructor(documentId, message) {\n    super(message);\n    this.documentId = void 0;\n    this.documentId = documentId;\n  }\n}\nexports.NavigationAbortedError = NavigationAbortedError;\nconst kDummyFrameId = '<dummy>';\nclass FrameManager {\n  constructor(page) {\n    this._page = void 0;\n    this._frames = new Map();\n    this._mainFrame = void 0;\n    this._consoleMessageTags = new Map();\n    this._signalBarriers = new Set();\n    this._webSockets = new Map();\n    this._openedDialogs = new Set();\n    this._closeAllOpeningDialogs = false;\n    this._page = page;\n    this._mainFrame = undefined;\n  }\n  createDummyMainFrameIfNeeded() {\n    if (!this._mainFrame) this.frameAttached(kDummyFrameId, null);\n  }\n  dispose() {\n    for (const frame of this._frames.values()) {\n      frame._stopNetworkIdleTimer();\n      frame._invalidateNonStallingEvaluations('Target crashed');\n    }\n  }\n  mainFrame() {\n    return this._mainFrame;\n  }\n  frames() {\n    const frames = [];\n    collect(this._mainFrame);\n    return frames;\n    function collect(frame) {\n      frames.push(frame);\n      for (const subframe of frame.childFrames()) collect(subframe);\n    }\n  }\n  frame(frameId) {\n    return this._frames.get(frameId) || null;\n  }\n  frameAttached(frameId, parentFrameId) {\n    const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;\n    if (!parentFrame) {\n      if (this._mainFrame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frames.delete(this._mainFrame._id);\n        this._mainFrame._id = frameId;\n      } else {\n        (0, _utils.assert)(!this._frames.has(frameId));\n        this._mainFrame = new Frame(this._page, frameId, parentFrame);\n      }\n      this._frames.set(frameId, this._mainFrame);\n      return this._mainFrame;\n    } else {\n      (0, _utils.assert)(!this._frames.has(frameId));\n      const frame = new Frame(this._page, frameId, parentFrame);\n      this._frames.set(frameId, frame);\n      this._page.emit(_page.Page.Events.FrameAttached, frame);\n      return frame;\n    }\n  }\n  async waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {\n    if (noWaitAfter) return action();\n    const barrier = new SignalBarrier(progress);\n    this._signalBarriers.add(barrier);\n    if (progress) progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));\n    const result = await action();\n    if (source === 'input') await this._page._delegate.inputActionEpilogue();\n    await barrier.waitFor();\n    this._signalBarriers.delete(barrier);\n    // Resolve in the next task, after all waitForNavigations.\n    await new Promise((0, _utils.makeWaitForNextTask)());\n    return result;\n  }\n  frameWillPotentiallyRequestNavigation() {\n    for (const barrier of this._signalBarriers) barrier.retain();\n  }\n  frameDidPotentiallyRequestNavigation() {\n    for (const barrier of this._signalBarriers) barrier.release();\n  }\n  frameRequestedNavigation(frameId, documentId) {\n    const frame = this._frames.get(frameId);\n    if (!frame) return;\n    for (const barrier of this._signalBarriers) barrier.addFrameNavigation(frame);\n    if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {\n      // Do not override request with undefined.\n      return;\n    }\n    frame.setPendingDocument({\n      documentId,\n      request: undefined\n    });\n  }\n  frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {\n    const frame = this._frames.get(frameId);\n    this.removeChildFramesRecursively(frame);\n    this.clearWebSockets(frame);\n    frame._url = url;\n    frame._name = name;\n    let keepPending;\n    const pendingDocument = frame.pendingDocument();\n    if (pendingDocument) {\n      if (pendingDocument.documentId === undefined) {\n        // Pending with unknown documentId - assume it is the one being committed.\n        pendingDocument.documentId = documentId;\n      }\n      if (pendingDocument.documentId === documentId) {\n        // Committing a pending document.\n        frame._currentDocument = pendingDocument;\n      } else {\n        // Sometimes, we already have a new pending when the old one commits.\n        // An example would be Chromium error page followed by a new navigation request,\n        // where the error page commit arrives after Network.requestWillBeSent for the\n        // new navigation.\n        // We commit, but keep the pending request since it's not done yet.\n        keepPending = pendingDocument;\n        frame._currentDocument = {\n          documentId,\n          request: undefined\n        };\n      }\n      frame.setPendingDocument(undefined);\n    } else {\n      // No pending - just commit a new document.\n      frame._currentDocument = {\n        documentId,\n        request: undefined\n      };\n    }\n    frame._onClearLifecycle();\n    const navigationEvent = {\n      url,\n      name,\n      newDocument: frame._currentDocument,\n      isPublic: true\n    };\n    this._fireInternalFrameNavigation(frame, navigationEvent);\n    if (!initial) {\n      _debugLogger.debugLogger.log('api', `  navigated to \"${url}\"`);\n      this._page.frameNavigatedToNewDocument(frame);\n    }\n    // Restore pending if any - see comments above about keepPending.\n    frame.setPendingDocument(keepPending);\n  }\n  frameCommittedSameDocumentNavigation(frameId, url) {\n    const frame = this._frames.get(frameId);\n    if (!frame) return;\n    frame._url = url;\n    const navigationEvent = {\n      url,\n      name: frame._name,\n      isPublic: true\n    };\n    this._fireInternalFrameNavigation(frame, navigationEvent);\n    _debugLogger.debugLogger.log('api', `  navigated to \"${url}\"`);\n  }\n  frameAbortedNavigation(frameId, errorText, documentId) {\n    const frame = this._frames.get(frameId);\n    if (!frame || !frame.pendingDocument()) return;\n    if (documentId !== undefined && frame.pendingDocument().documentId !== documentId) return;\n    const navigationEvent = {\n      url: frame._url,\n      name: frame._name,\n      newDocument: frame.pendingDocument(),\n      error: new NavigationAbortedError(documentId, errorText),\n      isPublic: !(documentId && frame._redirectedNavigations.has(documentId))\n    };\n    frame.setPendingDocument(undefined);\n    this._fireInternalFrameNavigation(frame, navigationEvent);\n  }\n  frameDetached(frameId) {\n    const frame = this._frames.get(frameId);\n    if (frame) {\n      this._removeFramesRecursively(frame);\n      this._page.mainFrame()._recalculateNetworkIdle();\n    }\n  }\n  frameLifecycleEvent(frameId, event) {\n    const frame = this._frames.get(frameId);\n    if (frame) frame._onLifecycleEvent(event);\n  }\n  requestStarted(request, route) {\n    const frame = request.frame();\n    this._inflightRequestStarted(request);\n    if (request._documentId) frame.setPendingDocument({\n      documentId: request._documentId,\n      request\n    });\n    if (request._isFavicon) {\n      if (route) route.continue(request, {});\n      return;\n    }\n    this._page.emitOnContext(_browserContext.BrowserContext.Events.Request, request);\n    if (route) {\n      var _this$_page$_serverRe, _this$_page, _this$_page$_clientRe, _this$_page2, _this$_page$_browserC, _this$_page$_browserC2;\n      const r = new network.Route(request, route);\n      if ((_this$_page$_serverRe = (_this$_page = this._page)._serverRequestInterceptor) !== null && _this$_page$_serverRe !== void 0 && _this$_page$_serverRe.call(_this$_page, r, request)) return;\n      if ((_this$_page$_clientRe = (_this$_page2 = this._page)._clientRequestInterceptor) !== null && _this$_page$_clientRe !== void 0 && _this$_page$_clientRe.call(_this$_page2, r, request)) return;\n      if ((_this$_page$_browserC = (_this$_page$_browserC2 = this._page._browserContext)._requestInterceptor) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.call(_this$_page$_browserC2, r, request)) return;\n      r.continue();\n    }\n  }\n  requestReceivedResponse(response) {\n    if (response.request()._isFavicon) return;\n    this._page.emitOnContext(_browserContext.BrowserContext.Events.Response, response);\n  }\n  reportRequestFinished(request, response) {\n    this._inflightRequestFinished(request);\n    if (request._isFavicon) return;\n    this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFinished, {\n      request,\n      response\n    });\n  }\n  requestFailed(request, canceled) {\n    const frame = request.frame();\n    this._inflightRequestFinished(request);\n    if (frame.pendingDocument() && frame.pendingDocument().request === request) {\n      let errorText = request.failure().errorText;\n      if (canceled) errorText += '; maybe frame was detached?';\n      this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);\n    }\n    if (request._isFavicon) return;\n    this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFailed, request);\n  }\n  dialogDidOpen(dialog) {\n    // Any ongoing evaluations will be stalled until the dialog is closed.\n    for (const frame of this._frames.values()) frame._invalidateNonStallingEvaluations('JavaScript dialog interrupted evaluation');\n    if (this._closeAllOpeningDialogs) dialog.close().then(() => {});else this._openedDialogs.add(dialog);\n  }\n  dialogWillClose(dialog) {\n    this._openedDialogs.delete(dialog);\n  }\n  async closeOpenDialogs() {\n    await Promise.all([...this._openedDialogs].map(dialog => dialog.close())).catch(() => {});\n    this._openedDialogs.clear();\n  }\n  setCloseAllOpeningDialogs(closeDialogs) {\n    this._closeAllOpeningDialogs = closeDialogs;\n  }\n  removeChildFramesRecursively(frame) {\n    for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n  }\n  _removeFramesRecursively(frame) {\n    this.removeChildFramesRecursively(frame);\n    frame._onDetached();\n    this._frames.delete(frame._id);\n    if (!this._page.isClosed()) this._page.emit(_page.Page.Events.FrameDetached, frame);\n  }\n  _inflightRequestFinished(request) {\n    const frame = request.frame();\n    if (request._isFavicon) return;\n    if (!frame._inflightRequests.has(request)) return;\n    frame._inflightRequests.delete(request);\n    if (frame._inflightRequests.size === 0) frame._startNetworkIdleTimer();\n  }\n  _inflightRequestStarted(request) {\n    const frame = request.frame();\n    if (request._isFavicon) return;\n    frame._inflightRequests.add(request);\n    if (frame._inflightRequests.size === 1) frame._stopNetworkIdleTimer();\n  }\n  interceptConsoleMessage(message) {\n    if (message.type() !== 'debug') return false;\n    const tag = message.text();\n    const handler = this._consoleMessageTags.get(tag);\n    if (!handler) return false;\n    this._consoleMessageTags.delete(tag);\n    handler();\n    return true;\n  }\n  clearWebSockets(frame) {\n    // TODO: attribute sockets to frames.\n    if (frame.parentFrame()) return;\n    this._webSockets.clear();\n  }\n  onWebSocketCreated(requestId, url) {\n    const ws = new network.WebSocket(this._page, url);\n    this._webSockets.set(requestId, ws);\n  }\n  onWebSocketRequest(requestId) {\n    const ws = this._webSockets.get(requestId);\n    if (ws && ws.markAsNotified()) this._page.emit(_page.Page.Events.WebSocket, ws);\n  }\n  onWebSocketResponse(requestId, status, statusText) {\n    const ws = this._webSockets.get(requestId);\n    if (status < 400) return;\n    if (ws) ws.error(`${statusText}: ${status}`);\n  }\n  onWebSocketFrameSent(requestId, opcode, data) {\n    const ws = this._webSockets.get(requestId);\n    if (ws) ws.frameSent(opcode, data);\n  }\n  webSocketFrameReceived(requestId, opcode, data) {\n    const ws = this._webSockets.get(requestId);\n    if (ws) ws.frameReceived(opcode, data);\n  }\n  webSocketClosed(requestId) {\n    const ws = this._webSockets.get(requestId);\n    if (ws) ws.closed();\n    this._webSockets.delete(requestId);\n  }\n  webSocketError(requestId, errorMessage) {\n    const ws = this._webSockets.get(requestId);\n    if (ws) ws.error(errorMessage);\n  }\n  _fireInternalFrameNavigation(frame, event) {\n    frame.emit(Frame.Events.InternalNavigation, event);\n  }\n}\nexports.FrameManager = FrameManager;\nclass Frame extends _instrumentation.SdkObject {\n  // documentId -> data\n\n  constructor(page, id, parentFrame) {\n    super(page, 'frame');\n    this._id = void 0;\n    this._firedLifecycleEvents = new Set();\n    this._firedNetworkIdleSelf = false;\n    this._currentDocument = void 0;\n    this._pendingDocument = void 0;\n    this._page = void 0;\n    this._parentFrame = void 0;\n    this._url = '';\n    this._detached = false;\n    this._contextData = new Map();\n    this._childFrames = new Set();\n    this._name = '';\n    this._inflightRequests = new Set();\n    this._networkIdleTimer = void 0;\n    this._setContentCounter = 0;\n    this._detachedPromise = void 0;\n    this._detachedCallback = () => {};\n    this._raceAgainstEvaluationStallingEventsPromises = new Set();\n    this._redirectedNavigations = new Map();\n    this.attribution.frame = this;\n    this._id = id;\n    this._page = page;\n    this._parentFrame = parentFrame;\n    this._currentDocument = {\n      documentId: undefined,\n      request: undefined\n    };\n    this._detachedPromise = new Promise(x => this._detachedCallback = x);\n    this._contextData.set('main', {\n      contextPromise: new _manualPromise.ManualPromise(),\n      context: null\n    });\n    this._contextData.set('utility', {\n      contextPromise: new _manualPromise.ManualPromise(),\n      context: null\n    });\n    this._setContext('main', null);\n    this._setContext('utility', null);\n    if (this._parentFrame) this._parentFrame._childFrames.add(this);\n    this._firedLifecycleEvents.add('commit');\n    if (id !== kDummyFrameId) this._startNetworkIdleTimer();\n  }\n  isDetached() {\n    return this._detached;\n  }\n  _onLifecycleEvent(event) {\n    if (this._firedLifecycleEvents.has(event)) return;\n    this._firedLifecycleEvents.add(event);\n    this.emit(Frame.Events.AddLifecycle, event);\n    if (this === this._page.mainFrame() && this._url !== 'about:blank') _debugLogger.debugLogger.log('api', `  \"${event}\" event fired`);\n    this._page.mainFrame()._recalculateNetworkIdle();\n  }\n  _onClearLifecycle() {\n    for (const event of this._firedLifecycleEvents) this.emit(Frame.Events.RemoveLifecycle, event);\n    this._firedLifecycleEvents.clear();\n    // Keep the current navigation request if any.\n    this._inflightRequests = new Set(Array.from(this._inflightRequests).filter(request => request === this._currentDocument.request));\n    this._stopNetworkIdleTimer();\n    if (this._inflightRequests.size === 0) this._startNetworkIdleTimer();\n    this._page.mainFrame()._recalculateNetworkIdle(this);\n    this._onLifecycleEvent('commit');\n  }\n  setPendingDocument(documentInfo) {\n    this._pendingDocument = documentInfo;\n    if (documentInfo) this._invalidateNonStallingEvaluations('Navigation interrupted the evaluation');\n  }\n  pendingDocument() {\n    return this._pendingDocument;\n  }\n  _invalidateNonStallingEvaluations(message) {\n    if (!this._raceAgainstEvaluationStallingEventsPromises.size) return;\n    const error = new Error(message);\n    for (const promise of this._raceAgainstEvaluationStallingEventsPromises) promise.reject(error);\n  }\n  async raceAgainstEvaluationStallingEvents(cb) {\n    if (this._pendingDocument) throw new Error('Frame is currently attempting a navigation');\n    if (this._page._frameManager._openedDialogs.size) throw new Error('Open JavaScript dialog prevents evaluation');\n    const promise = new _manualPromise.ManualPromise();\n    this._raceAgainstEvaluationStallingEventsPromises.add(promise);\n    try {\n      return await Promise.race([cb(), promise]);\n    } finally {\n      this._raceAgainstEvaluationStallingEventsPromises.delete(promise);\n    }\n  }\n  nonStallingRawEvaluateInExistingMainContext(expression) {\n    return this.raceAgainstEvaluationStallingEvents(() => {\n      const context = this._existingMainContext();\n      if (!context) throw new Error('Frame does not yet have a main execution context');\n      return context.rawEvaluateJSON(expression);\n    });\n  }\n  nonStallingEvaluateInExistingContext(expression, isFunction, world) {\n    return this.raceAgainstEvaluationStallingEvents(() => {\n      var _this$_contextData$ge;\n      const context = (_this$_contextData$ge = this._contextData.get(world)) === null || _this$_contextData$ge === void 0 ? void 0 : _this$_contextData$ge.context;\n      if (!context) throw new Error('Frame does not yet have the execution context');\n      return context.evaluateExpression(expression, {\n        isFunction\n      });\n    });\n  }\n  _recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle) {\n    let isNetworkIdle = this._firedNetworkIdleSelf;\n    for (const child of this._childFrames) {\n      child._recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle);\n      // We require networkidle event to be fired in the whole frame subtree, and then consider it done.\n      if (!child._firedLifecycleEvents.has('networkidle')) isNetworkIdle = false;\n    }\n    if (isNetworkIdle && !this._firedLifecycleEvents.has('networkidle')) {\n      this._firedLifecycleEvents.add('networkidle');\n      this.emit(Frame.Events.AddLifecycle, 'networkidle');\n      if (this === this._page.mainFrame() && this._url !== 'about:blank') _debugLogger.debugLogger.log('api', `  \"networkidle\" event fired`);\n    }\n    if (frameThatAllowsRemovingNetworkIdle !== this && this._firedLifecycleEvents.has('networkidle') && !isNetworkIdle) {\n      // Usually, networkidle is fired once and not removed after that.\n      // However, when we clear them right before a new commit, this is allowed for a particular frame.\n      this._firedLifecycleEvents.delete('networkidle');\n      this.emit(Frame.Events.RemoveLifecycle, 'networkidle');\n    }\n  }\n  async raceNavigationAction(progress, options, action) {\n    return Promise.race([this._page._disconnectedPromise.then(() => {\n      throw new Error('Navigation failed because page was closed!');\n    }), this._page._crashedPromise.then(() => {\n      throw new Error('Navigation failed because page crashed!');\n    }), this._detachedPromise.then(() => {\n      throw new Error('Navigating frame was detached!');\n    }), action().catch(e => {\n      if (e instanceof NavigationAbortedError && e.documentId) {\n        const data = this._redirectedNavigations.get(e.documentId);\n        if (data) {\n          progress.log(`waiting for redirected navigation to \"${data.url}\"`);\n          return data.gotoPromise;\n        }\n      }\n      throw e;\n    })]);\n  }\n  redirectNavigation(url, documentId, referer) {\n    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);\n    const data = {\n      url,\n      gotoPromise: controller.run(progress => this._gotoAction(progress, url, {\n        referer\n      }), 0)\n    };\n    this._redirectedNavigations.set(documentId, data);\n    data.gotoPromise.finally(() => this._redirectedNavigations.delete(documentId));\n  }\n  async goto(metadata, url, options = {}) {\n    const constructedNavigationURL = (0, _utils.constructURLBasedOnBaseURL)(this._page._browserContext._options.baseURL, url);\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this._goto(progress, constructedNavigationURL, options), this._page._timeoutSettings.navigationTimeout(options));\n  }\n  async _goto(progress, url, options) {\n    return this.raceNavigationAction(progress, options, async () => this._gotoAction(progress, url, options));\n  }\n  async _gotoAction(progress, url, options) {\n    const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    progress.log(`navigating to \"${url}\", waiting until \"${waitUntil}\"`);\n    const headers = this._page.extraHTTPHeaders() || [];\n    const refererHeader = headers.find(h => h.name.toLowerCase() === 'referer');\n    let referer = refererHeader ? refererHeader.value : undefined;\n    if (options.referer !== undefined) {\n      if (referer !== undefined && referer !== options.referer) throw new Error('\"referer\" is already specified as extra HTTP header');\n      referer = options.referer;\n    }\n    url = _helper.helper.completeUserURL(url);\n    const sameDocument = _helper.helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, e => !e.newDocument);\n    const navigateResult = await this._page._delegate.navigateFrame(this, url, referer);\n    let event;\n    if (navigateResult.newDocumentId) {\n      sameDocument.dispose();\n      event = await _helper.helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, event => {\n        // We are interested either in this specific document, or any other document that\n        // did commit and replaced the expected document.\n        return event.newDocument && (event.newDocument.documentId === navigateResult.newDocumentId || !event.error);\n      }).promise;\n      if (event.newDocument.documentId !== navigateResult.newDocumentId) {\n        // This is just a sanity check. In practice, new navigation should\n        // cancel the previous one and report \"request cancelled\"-like error.\n        throw new NavigationAbortedError(navigateResult.newDocumentId, 'Navigation interrupted by another one');\n      }\n      if (event.error) throw event.error;\n    } else {\n      event = await sameDocument.promise;\n    }\n    if (!this._firedLifecycleEvents.has(waitUntil)) await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, e => e === waitUntil).promise;\n    const request = event.newDocument ? event.newDocument.request : undefined;\n    const response = request ? request._finalRequest().response() : null;\n    return response;\n  }\n  async _waitForNavigation(progress, requiresNewDocument, options) {\n    const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    progress.log(`waiting for navigation until \"${waitUntil}\"`);\n    const navigationEvent = await _helper.helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, event => {\n      // Any failed navigation results in a rejection.\n      if (event.error) return true;\n      if (requiresNewDocument && !event.newDocument) return false;\n      progress.log(`  navigated to \"${this._url}\"`);\n      return true;\n    }).promise;\n    if (navigationEvent.error) throw navigationEvent.error;\n    if (!this._firedLifecycleEvents.has(waitUntil)) await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, e => e === waitUntil).promise;\n    const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : undefined;\n    return request ? request._finalRequest().response() : null;\n  }\n  async _waitForLoadState(progress, state) {\n    const waitUntil = verifyLifecycle('state', state);\n    if (!this._firedLifecycleEvents.has(waitUntil)) await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, e => e === waitUntil).promise;\n  }\n  async frameElement() {\n    return this._page._delegate.getFrameElement(this);\n  }\n  _context(world) {\n    return this._contextData.get(world).contextPromise.then(contextOrError => {\n      if (contextOrError instanceof js.ExecutionContext) return contextOrError;\n      throw contextOrError;\n    });\n  }\n  _mainContext() {\n    return this._context('main');\n  }\n  _existingMainContext() {\n    var _this$_contextData$ge2;\n    return ((_this$_contextData$ge2 = this._contextData.get('main')) === null || _this$_contextData$ge2 === void 0 ? void 0 : _this$_contextData$ge2.context) || null;\n  }\n  _utilityContext() {\n    return this._context('utility');\n  }\n  async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = 'main') {\n    const context = await this._context(world);\n    const handle = await context.evaluateExpressionHandleAndWaitForSignals(expression, {\n      isFunction\n    }, arg);\n    return handle;\n  }\n  async evaluateExpression(expression, isFunction, arg, world = 'main') {\n    const context = await this._context(world);\n    const value = await context.evaluateExpression(expression, {\n      isFunction\n    }, arg);\n    return value;\n  }\n  async evaluateExpressionAndWaitForSignals(expression, options, arg, world = 'main') {\n    const context = await this._context(world);\n    const value = await context.evaluateExpressionAndWaitForSignals(expression, options, arg);\n    return value;\n  }\n  async querySelector(selector, options) {\n    _debugLogger.debugLogger.log('api', `    finding element using the selector \"${selector}\"`);\n    const result = await this.resolveFrameForSelectorNoWait(selector, options);\n    if (!result) return null;\n    return this._page.selectors.query(result.frame, result.info);\n  }\n  async waitForSelector(metadata, selector, options, scope) {\n    const controller = new _progress.ProgressController(metadata, this);\n    if (options.visibility) throw new Error('options.visibility is not supported, did you mean options.state?');\n    if (options.waitFor && options.waitFor !== 'visible') throw new Error('options.waitFor is not supported, did you mean options.state?');\n    const {\n      state = 'visible'\n    } = options;\n    if (!['attached', 'detached', 'visible', 'hidden'].includes(state)) throw new Error(`state: expected one of (attached|detached|visible|hidden)`);\n    return controller.run(async progress => {\n      progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);\n      const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {\n        const resolved = await this._resolveInjectedForSelector(progress, selector, options, scope);\n        if (!resolved) return continuePolling;\n        const result = await resolved.injected.evaluateHandle((injected, {\n          info,\n          root\n        }) => {\n          const elements = injected.querySelectorAll(info.parsed, root || document);\n          const element = elements[0];\n          const visible = element ? injected.isVisible(element) : false;\n          let log = '';\n          if (elements.length > 1) {\n            if (info.strict) throw injected.strictModeViolationError(info.parsed, elements);\n            log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;\n          } else if (element) {\n            log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;\n          }\n          return {\n            log,\n            element,\n            visible,\n            attached: !!element\n          };\n        }, {\n          info: resolved.info,\n          root: resolved.frame === this ? scope : undefined\n        });\n        const {\n          log,\n          visible,\n          attached\n        } = await result.evaluate(r => ({\n          log: r.log,\n          visible: r.visible,\n          attached: r.attached\n        }));\n        if (log) progress.log(log);\n        const success = {\n          attached,\n          detached: !attached,\n          visible,\n          hidden: !visible\n        }[state];\n        if (!success) {\n          result.dispose();\n          return continuePolling;\n        }\n        const element = state === 'attached' || state === 'visible' ? await result.evaluateHandle(r => r.element) : null;\n        result.dispose();\n        if (!element) return null;\n        if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();\n        try {\n          return await element._adoptTo(await resolved.frame._mainContext());\n        } catch (e) {\n          return continuePolling;\n        }\n      });\n      return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async dispatchEvent(metadata, selector, type, eventInit = {}, options = {}) {\n    await this._callOnElementOnceMatches(metadata, selector, (injectedScript, element, data) => {\n      injectedScript.dispatchEvent(element, data.type, data.eventInit);\n    }, {\n      type,\n      eventInit\n    }, {\n      mainWorld: true,\n      ...options\n    });\n  }\n  async evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {\n    const pair = await this.resolveFrameForSelectorNoWait(selector, {\n      strict\n    });\n    const handle = pair ? await this._page.selectors.query(pair.frame, pair.info) : null;\n    if (!handle) throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n    const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);\n    handle.dispose();\n    return result;\n  }\n  async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {\n    const pair = await this.resolveFrameForSelectorNoWait(selector, {});\n    if (!pair) throw new Error(`Error: failed to find frame for selector \"${selector}\"`);\n    const arrayHandle = await this._page.selectors._queryArrayInMainWorld(pair.frame, pair.info);\n    const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);\n    arrayHandle.dispose();\n    return result;\n  }\n  async maskSelectors(selectors) {\n    const context = await this._utilityContext();\n    const injectedScript = await context.injectedScript();\n    await injectedScript.evaluate((injected, {\n      parsed\n    }) => {\n      injected.maskSelectors(parsed);\n    }, {\n      parsed: selectors\n    });\n  }\n  async querySelectorAll(selector) {\n    const pair = await this.resolveFrameForSelectorNoWait(selector, {});\n    if (!pair) return [];\n    return this._page.selectors._queryAll(pair.frame, pair.info, undefined, true /* adoptToMain */);\n  }\n\n  async queryCount(selector) {\n    const pair = await this.resolveFrameForSelectorNoWait(selector);\n    if (!pair) throw new Error(`Error: failed to find frame for selector \"${selector}\"`);\n    return await this._page.selectors._queryCount(pair.frame, pair.info);\n  }\n  async content() {\n    try {\n      const context = await this._utilityContext();\n      return await context.evaluate(() => {\n        let retVal = '';\n        if (document.doctype) retVal = new XMLSerializer().serializeToString(document.doctype);\n        if (document.documentElement) retVal += document.documentElement.outerHTML;\n        return retVal;\n      });\n    } catch (e) {\n      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;\n      throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);\n    }\n  }\n  async setContent(metadata, html, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      await this.raceNavigationAction(progress, options, async () => {\n        const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;\n        progress.log(`setting frame content, waiting until \"${waitUntil}\"`);\n        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;\n        const context = await this._utilityContext();\n        const lifecyclePromise = new Promise((resolve, reject) => {\n          this._page._frameManager._consoleMessageTags.set(tag, () => {\n            // Clear lifecycle right after document.open() - see 'tag' below.\n            this._onClearLifecycle();\n            this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);\n          });\n        });\n        const contentPromise = context.evaluate(({\n          html,\n          tag\n        }) => {\n          window.stop();\n          document.open();\n          console.debug(tag); // eslint-disable-line no-console\n          document.write(html);\n          document.close();\n        }, {\n          html,\n          tag\n        });\n        await Promise.all([contentPromise, lifecyclePromise]);\n        return null;\n      });\n    }, this._page._timeoutSettings.navigationTimeout(options));\n  }\n  name() {\n    return this._name || '';\n  }\n  url() {\n    return this._url;\n  }\n  parentFrame() {\n    return this._parentFrame;\n  }\n  childFrames() {\n    return Array.from(this._childFrames);\n  }\n  async addScriptTag(params) {\n    const {\n      url = null,\n      content = null,\n      type = ''\n    } = params;\n    if (!url && !content) throw new Error('Provide an object with a `url`, `path` or `content` property');\n    const context = await this._mainContext();\n    return this._raceWithCSPError(async () => {\n      if (url !== null) return (await context.evaluateHandle(addScriptUrl, {\n        url,\n        type\n      })).asElement();\n      const result = (await context.evaluateHandle(addScriptContent, {\n        content: content,\n        type\n      })).asElement();\n      // Another round trip to the browser to ensure that we receive CSP error messages\n      // (if any) logged asynchronously in a separate task on the content main thread.\n      if (this._page._delegate.cspErrorsAsynchronousForInlineScipts) await context.evaluate(() => true);\n      return result;\n    });\n    async function addScriptUrl(params) {\n      const script = document.createElement('script');\n      script.src = params.url;\n      if (params.type) script.type = params.type;\n      const promise = new Promise((res, rej) => {\n        script.onload = res;\n        script.onerror = e => rej(typeof e === 'string' ? new Error(e) : new Error(`Failed to load script at ${script.src}`));\n      });\n      document.head.appendChild(script);\n      await promise;\n      return script;\n    }\n    function addScriptContent(params) {\n      const script = document.createElement('script');\n      script.type = params.type || 'text/javascript';\n      script.text = params.content;\n      let error = null;\n      script.onerror = e => error = e;\n      document.head.appendChild(script);\n      if (error) throw error;\n      return script;\n    }\n  }\n  async addStyleTag(params) {\n    const {\n      url = null,\n      content = null\n    } = params;\n    if (!url && !content) throw new Error('Provide an object with a `url`, `path` or `content` property');\n    const context = await this._mainContext();\n    return this._raceWithCSPError(async () => {\n      if (url !== null) return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n      return (await context.evaluateHandle(addStyleContent, content)).asElement();\n    });\n    async function addStyleUrl(url) {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = url;\n      const promise = new Promise((res, rej) => {\n        link.onload = res;\n        link.onerror = rej;\n      });\n      document.head.appendChild(link);\n      await promise;\n      return link;\n    }\n    async function addStyleContent(content) {\n      const style = document.createElement('style');\n      style.type = 'text/css';\n      style.appendChild(document.createTextNode(content));\n      const promise = new Promise((res, rej) => {\n        style.onload = res;\n        style.onerror = rej;\n      });\n      document.head.appendChild(style);\n      await promise;\n      return style;\n    }\n  }\n  async _raceWithCSPError(func) {\n    const listeners = [];\n    let result;\n    let error;\n    let cspMessage;\n    const actionPromise = func().then(r => result = r).catch(e => error = e);\n    const errorPromise = new Promise(resolve => {\n      listeners.push(_eventsHelper.eventsHelper.addEventListener(this._page, _page.Page.Events.Console, message => {\n        if (message.type() === 'error' && message.text().includes('Content Security Policy')) {\n          cspMessage = message;\n          resolve();\n        }\n      }));\n    });\n    await Promise.race([actionPromise, errorPromise]);\n    _eventsHelper.eventsHelper.removeEventListeners(listeners);\n    if (cspMessage) throw new Error(cspMessage.text());\n    if (error) throw error;\n    return result;\n  }\n  async retryWithProgressAndTimeouts(progress, timeouts, action) {\n    const continuePolling = Symbol('continuePolling');\n    timeouts = [0, ...timeouts];\n    let timeoutIndex = 0;\n    while (progress.isRunning()) {\n      const timeout = timeouts[Math.min(timeoutIndex++, timeouts.length - 1)];\n      if (timeout) {\n        // Make sure we react immediately upon page close or frame detach.\n        // We need this to show expected/received values in time.\n        await Promise.race([this._page._disconnectedPromise, this._page._crashedPromise, this._detachedPromise, new Promise(f => setTimeout(f, timeout))]);\n      }\n      progress.throwIfAborted();\n      try {\n        const result = await action(continuePolling);\n        if (result === continuePolling) continue;\n        return result;\n      } catch (e) {\n        if (this._isErrorThatCannotBeRetried(e)) throw e;\n        continue;\n      }\n    }\n    progress.throwIfAborted();\n    return undefined;\n  }\n  _isErrorThatCannotBeRetried(e) {\n    // Always fail on JavaScript errors or when the main connection is closed.\n    if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) return true;\n    // Certain errors opt-out of the retries, throw.\n    if (dom.isNonRecoverableDOMError(e) || (0, _selectorParser.isInvalidSelectorError)(e)) return true;\n    // If the call is made on the detached frame - throw.\n    if (this.isDetached()) return true;\n    // Retry upon all other errors.\n    return false;\n  }\n  async _resolveInjectedForSelector(progress, selector, options, scope) {\n    const selectorInFrame = await this.resolveFrameForSelectorNoWait(selector, options, scope);\n    if (!selectorInFrame) return;\n    progress.throwIfAborted();\n\n    // Be careful, |this| can be different from |selectorInFrame.frame|.\n    const context = await selectorInFrame.frame._context(options.mainWorld ? 'main' : selectorInFrame.info.world);\n    const injected = await context.injectedScript();\n    progress.throwIfAborted();\n    return {\n      injected,\n      info: selectorInFrame.info,\n      frame: selectorInFrame.frame\n    };\n  }\n  async _retryWithProgressIfNotConnected(progress, selector, strict, action) {\n    progress.log(`waiting for ${this._asLocator(selector)}`);\n    return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {\n      const resolved = await this._resolveInjectedForSelector(progress, selector, {\n        strict\n      });\n      if (!resolved) return continuePolling;\n      const result = await resolved.injected.evaluateHandle((injected, {\n        info\n      }) => {\n        const elements = injected.querySelectorAll(info.parsed, document);\n        const element = elements[0];\n        let log = '';\n        if (elements.length > 1) {\n          if (info.strict) throw injected.strictModeViolationError(info.parsed, elements);\n          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;\n        } else if (element) {\n          log = `  locator resolved to ${injected.previewNode(element)}`;\n        }\n        return {\n          log,\n          success: !!element,\n          element\n        };\n      }, {\n        info: resolved.info\n      });\n      const {\n        log,\n        success\n      } = await result.evaluate(r => ({\n        log: r.log,\n        success: r.success\n      }));\n      if (log) progress.log(log);\n      if (!success) {\n        result.dispose();\n        return continuePolling;\n      }\n      const element = await result.evaluateHandle(r => r.element);\n      result.dispose();\n      try {\n        const result = await action(element);\n        if (result === 'error:notconnected') {\n          progress.log('element was detached from the DOM, retrying');\n          return continuePolling;\n        }\n        return result;\n      } finally {\n        element === null || element === void 0 ? void 0 : element.dispose();\n      }\n    });\n  }\n  async rafrafTimeoutScreenshotElementWithProgress(progress, selector, timeout, options) {\n    return await this._retryWithProgressIfNotConnected(progress, selector, true /* strict */, async handle => {\n      await handle._frame.rafrafTimeout(timeout);\n      return await this._page._screenshotter.screenshotElement(progress, handle, options);\n    });\n  }\n  async click(metadata, selector, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._click(progress, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async dblclick(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._dblclick(progress, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async dragAndDrop(metadata, source, target, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    await controller.run(async progress => {\n      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, source, options.strict, async handle => {\n        return handle._retryPointerAction(progress, 'move and down', false, async point => {\n          await this._page.mouse.move(point.x, point.y);\n          await this._page.mouse.down();\n        }, {\n          ...options,\n          position: options.sourcePosition,\n          timeout: progress.timeUntilDeadline()\n        });\n      }));\n      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, target, options.strict, async handle => {\n        return handle._retryPointerAction(progress, 'move and up', false, async point => {\n          await this._page.mouse.move(point.x, point.y);\n          await this._page.mouse.up();\n        }, {\n          ...options,\n          position: options.targetPosition,\n          timeout: progress.timeUntilDeadline()\n        });\n      }));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async tap(metadata, selector, options) {\n    if (!this._page._browserContext._options.hasTouch) throw new Error('The page does not support tap. Use hasTouch context option to enable touch support.');\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._tap(progress, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async fill(metadata, selector, value, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._fill(progress, value, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async focus(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    await controller.run(async progress => {\n      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._focus(progress)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async blur(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    await controller.run(async progress => {\n      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._blur(progress)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async textContent(metadata, selector, options = {}) {\n    return this._callOnElementOnceMatches(metadata, selector, (injected, element) => element.textContent, undefined, options);\n  }\n  async innerText(metadata, selector, options = {}) {\n    return this._callOnElementOnceMatches(metadata, selector, (injectedScript, element) => {\n      if (element.namespaceURI !== 'http://www.w3.org/1999/xhtml') throw injectedScript.createStacklessError('Node is not an HTMLElement');\n      return element.innerText;\n    }, undefined, options);\n  }\n  async innerHTML(metadata, selector, options = {}) {\n    return this._callOnElementOnceMatches(metadata, selector, (injected, element) => element.innerHTML, undefined, options);\n  }\n  async getAttribute(metadata, selector, name, options = {}) {\n    return this._callOnElementOnceMatches(metadata, selector, (injected, element, data) => element.getAttribute(data.name), {\n      name\n    }, options);\n  }\n  async inputValue(metadata, selector, options = {}) {\n    return this._callOnElementOnceMatches(metadata, selector, (injectedScript, node) => {\n      const element = injectedScript.retarget(node, 'follow-label');\n      if (!element || element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA' && element.nodeName !== 'SELECT') throw injectedScript.createStacklessError('Node is not an <input>, <textarea> or <select> element');\n      return element.value;\n    }, undefined, options);\n  }\n  async highlight(selector) {\n    const pair = await this.resolveFrameForSelectorNoWait(selector);\n    if (!pair) return;\n    const context = await pair.frame._utilityContext();\n    const injectedScript = await context.injectedScript();\n    return await injectedScript.evaluate((injected, {\n      parsed\n    }) => {\n      return injected.highlight(parsed);\n    }, {\n      parsed: pair.info.parsed\n    });\n  }\n  async hideHighlight() {\n    return this.raceAgainstEvaluationStallingEvents(async () => {\n      const context = await this._utilityContext();\n      const injectedScript = await context.injectedScript();\n      return await injectedScript.evaluate(injected => {\n        return injected.hideHighlight();\n      });\n    });\n  }\n  async _elementState(metadata, selector, state, options = {}) {\n    const result = await this._callOnElementOnceMatches(metadata, selector, (injected, element, data) => {\n      return injected.elementState(element, data.state);\n    }, {\n      state\n    }, options);\n    return dom.throwRetargetableDOMError(result);\n  }\n  async isVisible(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      progress.log(`  checking visibility of ${this._asLocator(selector)}`);\n      const pair = await this.resolveFrameForSelectorNoWait(selector, options);\n      if (!pair) return false;\n      const context = await pair.frame._context(pair.info.world);\n      const injectedScript = await context.injectedScript();\n      return await injectedScript.evaluate((injected, {\n        parsed,\n        strict\n      }) => {\n        const element = injected.querySelector(parsed, document, strict);\n        const state = element ? injected.elementState(element, 'visible') : false;\n        return state === 'error:notconnected' ? false : state;\n      }, {\n        parsed: pair.info.parsed,\n        strict: pair.info.strict\n      });\n    }, this._page._timeoutSettings.timeout({}));\n  }\n  async isHidden(metadata, selector, options = {}) {\n    return !(await this.isVisible(metadata, selector, options));\n  }\n  async isDisabled(metadata, selector, options = {}) {\n    return this._elementState(metadata, selector, 'disabled', options);\n  }\n  async isEnabled(metadata, selector, options = {}) {\n    return this._elementState(metadata, selector, 'enabled', options);\n  }\n  async isEditable(metadata, selector, options = {}) {\n    return this._elementState(metadata, selector, 'editable', options);\n  }\n  async isChecked(metadata, selector, options = {}) {\n    return this._elementState(metadata, selector, 'checked', options);\n  }\n  async hover(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._hover(progress, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async selectOption(metadata, selector, elements, values, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._selectOption(progress, elements, values, options));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async setInputFiles(metadata, selector, items, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._setInputFiles(progress, items, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async type(metadata, selector, text, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._type(progress, text, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async press(metadata, selector, key, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._press(progress, key, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async check(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._setChecked(progress, true, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async uncheck(metadata, selector, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._setChecked(progress, false, options)));\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async waitForTimeout(metadata, timeout) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async () => {\n      await new Promise(resolve => setTimeout(resolve, timeout));\n    });\n  }\n  async expect(metadata, selector, options) {\n    let timeout = this._page._timeoutSettings.timeout(options);\n    const start = timeout > 0 ? (0, _utils.monotonicTime)() : 0;\n    const lastIntermediateResult = {\n      isSet: false\n    };\n    const resultOneShot = await this._expectInternal(metadata, selector, options, true, timeout, lastIntermediateResult);\n    if (resultOneShot.matches !== options.isNot) return resultOneShot;\n    if (timeout > 0) {\n      const elapsed = (0, _utils.monotonicTime)() - start;\n      timeout -= elapsed;\n    }\n    if (timeout < 0) return {\n      matches: options.isNot,\n      log: metadata.log,\n      timedOut: true,\n      received: lastIntermediateResult.received\n    };\n    return await this._expectInternal(metadata, selector, options, false, timeout, lastIntermediateResult);\n  }\n  async _expectInternal(metadata, selector, options, oneShot, timeout, lastIntermediateResult) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      if (oneShot) progress.log(`${metadata.apiName}${timeout ? ` with timeout ${timeout}ms` : ''}`);\n      progress.log(`waiting for ${this._asLocator(selector)}`);\n      return await this.retryWithProgressAndTimeouts(progress, [100, 250, 500, 1000], async continuePolling => {\n        var _info$world;\n        const selectorInFrame = await this.resolveFrameForSelectorNoWait(selector, {\n          strict: true\n        });\n        progress.throwIfAborted();\n        const {\n          frame,\n          info\n        } = selectorInFrame || {\n          frame: this,\n          info: undefined\n        };\n        const world = options.expression === 'to.have.property' ? 'main' : (_info$world = info === null || info === void 0 ? void 0 : info.world) !== null && _info$world !== void 0 ? _info$world : 'utility';\n        const context = await frame._context(world);\n        const injected = await context.injectedScript();\n        progress.throwIfAborted();\n        const {\n          log,\n          matches,\n          received,\n          missingRecevied\n        } = await injected.evaluate(async (injected, {\n          info,\n          options,\n          snapshotName\n        }) => {\n          const elements = info ? injected.querySelectorAll(info.parsed, document) : [];\n          const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');\n          let log = '';\n          if (isArray) log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;else if (elements.length > 1) throw injected.strictModeViolationError(info.parsed, elements);else if (elements.length) log = `  locator resolved to ${injected.previewNode(elements[0])}`;\n          if (snapshotName) injected.markTargetElements(new Set(elements), snapshotName);\n          return {\n            log,\n            ...(await injected.expect(elements[0], options, elements))\n          };\n        }, {\n          info,\n          options,\n          snapshotName: progress.metadata.afterSnapshot\n        });\n        if (log) progress.log(log);\n        // Note: missingReceived avoids `unexpected value \"undefined\"` when element was not found.\n        if (matches === options.isNot && !missingRecevied) {\n          lastIntermediateResult.received = received;\n          lastIntermediateResult.isSet = true;\n          if (!Array.isArray(received)) progress.log(`  unexpected value \"${renderUnexpectedValue(options.expression, received)}\"`);\n        }\n        if (!oneShot && matches === options.isNot) {\n          // Keep waiting in these cases:\n          // expect(locator).conditionThatDoesNotMatch\n          // expect(locator).not.conditionThatDoesMatch\n          return continuePolling;\n        }\n        return {\n          matches,\n          received\n        };\n      });\n    }, oneShot ? 0 : timeout).catch(e => {\n      // Q: Why not throw upon isSessionClosedError(e) as in other places?\n      // A: We want user to receive a friendly message containing the last intermediate result.\n      if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e)) throw e;\n      const result = {\n        matches: options.isNot,\n        log: metadata.log\n      };\n      if (lastIntermediateResult.isSet) result.received = lastIntermediateResult.received;else result.timedOut = true;\n      return result;\n    });\n  }\n  async _waitForFunctionExpression(metadata, expression, isFunction, arg, options, world = 'main') {\n    const controller = new _progress.ProgressController(metadata, this);\n    if (typeof options.pollingInterval === 'number') (0, _utils.assert)(options.pollingInterval > 0, 'Cannot poll with non-positive interval: ' + options.pollingInterval);\n    expression = js.normalizeEvaluationExpression(expression, isFunction);\n    return controller.run(async progress => {\n      return this.retryWithProgressAndTimeouts(progress, [100], async () => {\n        const context = world === 'main' ? await this._mainContext() : await this._utilityContext();\n        const injectedScript = await context.injectedScript();\n        const handle = await injectedScript.evaluateHandle((injected, {\n          expression,\n          isFunction,\n          polling,\n          arg\n        }) => {\n          const predicate = () => {\n            // NOTE: make sure to use `globalThis.eval` instead of `self.eval` due to a bug with sandbox isolation\n            // in firefox.\n            // See https://bugzilla.mozilla.org/show_bug.cgi?id=1814898\n            let result = globalThis.eval(expression);\n            if (isFunction === true) {\n              result = result(arg);\n            } else if (isFunction === false) {\n              result = result;\n            } else {\n              // auto detect.\n              if (typeof result === 'function') result = result(arg);\n            }\n            return result;\n          };\n          let fulfill;\n          let reject;\n          let aborted = false;\n          const result = new Promise((f, r) => {\n            fulfill = f;\n            reject = r;\n          });\n          const next = () => {\n            if (aborted) return;\n            try {\n              const success = predicate();\n              if (success) {\n                fulfill(success);\n                return;\n              }\n              if (typeof polling !== 'number') requestAnimationFrame(next);else setTimeout(next, polling);\n            } catch (e) {\n              reject(e);\n            }\n          };\n          next();\n          return {\n            result,\n            abort: () => aborted = true\n          };\n        }, {\n          expression,\n          isFunction,\n          polling: options.pollingInterval,\n          arg\n        });\n        progress.cleanupWhenAborted(() => handle.evaluate(h => h.abort()).catch(() => {}));\n        return handle.evaluateHandle(h => h.result);\n      });\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  async waitForFunctionValueInUtility(progress, pageFunction) {\n    const expression = `() => {\n      const result = (${pageFunction})();\n      if (!result)\n        return result;\n      return JSON.stringify(result);\n    }`;\n    const handle = await this._waitForFunctionExpression((0, _instrumentation.serverSideCallMetadata)(), expression, true, undefined, {\n      timeout: progress.timeUntilDeadline()\n    }, 'utility');\n    return JSON.parse(handle.rawValue());\n  }\n  async title() {\n    const context = await this._utilityContext();\n    return context.evaluate(() => document.title);\n  }\n  async rafrafTimeout(timeout) {\n    if (timeout === 0) return;\n    const context = await this._utilityContext();\n    await Promise.all([\n    // wait for double raf\n    context.evaluate(() => new Promise(x => {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(x);\n      });\n    })), new Promise(fulfill => setTimeout(fulfill, timeout))]);\n  }\n  _onDetached() {\n    this._stopNetworkIdleTimer();\n    this._detached = true;\n    this._detachedCallback();\n    const error = new Error('Frame was detached');\n    for (const data of this._contextData.values()) {\n      if (data.context) data.context.contextDestroyed(error);\n      data.contextPromise.resolve(error);\n    }\n    if (this._parentFrame) this._parentFrame._childFrames.delete(this);\n    this._parentFrame = null;\n  }\n  async _callOnElementOnceMatches(metadata, selector, body, taskData, options = {}) {\n    const callbackText = body.toString();\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(async progress => {\n      progress.log(`waiting for ${this._asLocator(selector)}`);\n      return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {\n        const resolved = await this._resolveInjectedForSelector(progress, selector, options);\n        if (!resolved) return continuePolling;\n        const {\n          log,\n          success,\n          value\n        } = await resolved.injected.evaluate((injected, {\n          info,\n          callbackText,\n          taskData,\n          snapshotName\n        }) => {\n          const callback = injected.eval(callbackText);\n          const element = injected.querySelector(info.parsed, document, info.strict);\n          if (!element) return {\n            success: false\n          };\n          const log = `  locator resolved to ${injected.previewNode(element)}`;\n          if (snapshotName) injected.markTargetElements(new Set([element]), snapshotName);\n          return {\n            log,\n            success: true,\n            value: callback(injected, element, taskData)\n          };\n        }, {\n          info: resolved.info,\n          callbackText,\n          taskData,\n          snapshotName: progress.metadata.afterSnapshot\n        });\n        if (log) progress.log(log);\n        if (!success) return continuePolling;\n        return value;\n      });\n    }, this._page._timeoutSettings.timeout(options));\n  }\n  _setContext(world, context) {\n    const data = this._contextData.get(world);\n    data.context = context;\n    if (context) data.contextPromise.resolve(context);else data.contextPromise = new _manualPromise.ManualPromise();\n  }\n  _contextCreated(world, context) {\n    const data = this._contextData.get(world);\n    // In case of multiple sessions to the same target, there's a race between\n    // connections so we might end up creating multiple isolated worlds.\n    // We can use either.\n    if (data.context) {\n      data.context.contextDestroyed(new Error('Execution context was destroyed, most likely because of a navigation'));\n      this._setContext(world, null);\n    }\n    this._setContext(world, context);\n  }\n  _contextDestroyed(context) {\n    // Sometimes we get this after detach, in which case we should not reset\n    // our already destroyed contexts to something that will never resolve.\n    if (this._detached) return;\n    context.contextDestroyed(new Error('Execution context was destroyed, most likely because of a navigation'));\n    for (const [world, data] of this._contextData) {\n      if (data.context === context) this._setContext(world, null);\n    }\n  }\n  _startNetworkIdleTimer() {\n    (0, _utils.assert)(!this._networkIdleTimer);\n    // We should not start a timer and report networkidle in detached frames.\n    // This happens at least in Firefox for child frames, where we may get requestFinished\n    // after the frame was detached - probably a race in the Firefox itself.\n    if (this._firedLifecycleEvents.has('networkidle') || this._detached) return;\n    this._networkIdleTimer = setTimeout(() => {\n      this._firedNetworkIdleSelf = true;\n      this._page.mainFrame()._recalculateNetworkIdle();\n    }, 500);\n  }\n  _stopNetworkIdleTimer() {\n    if (this._networkIdleTimer) clearTimeout(this._networkIdleTimer);\n    this._networkIdleTimer = undefined;\n    this._firedNetworkIdleSelf = false;\n  }\n  async extendInjectedScript(source, arg) {\n    const context = await this._context('main');\n    const injectedScriptHandle = await context.injectedScript();\n    return injectedScriptHandle.evaluateHandle((injectedScript, {\n      source,\n      arg\n    }) => {\n      return injectedScript.extend(source, arg);\n    }, {\n      source,\n      arg\n    });\n  }\n  async resolveFrameForSelectorNoWait(selector, options = {}, scope) {\n    let frame = this;\n    const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);\n    for (let i = 0; i < frameChunks.length - 1; ++i) {\n      const info = this._page.parseSelector(frameChunks[i], options);\n      const context = await frame._context(info.world);\n      const injectedScript = await context.injectedScript();\n      const handle = await injectedScript.evaluateHandle((injected, {\n        info,\n        scope,\n        selectorString\n      }) => {\n        const element = injected.querySelector(info.parsed, scope || document, info.strict);\n        if (element && element.nodeName !== 'IFRAME' && element.nodeName !== 'FRAME') throw injected.createStacklessError(`Selector \"${selectorString}\" resolved to ${injected.previewNode(element)}, <iframe> was expected`);\n        return element;\n      }, {\n        info,\n        scope: i === 0 ? scope : undefined,\n        selectorString: (0, _selectorParser.stringifySelector)(info.parsed)\n      });\n      const element = handle.asElement();\n      if (!element) return null;\n      const maybeFrame = await this._page._delegate.getContentFrame(element);\n      element.dispose();\n      if (!maybeFrame) return null;\n      frame = maybeFrame;\n    }\n    return {\n      frame,\n      info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)\n    };\n  }\n  async resetStorageForCurrentOriginBestEffort(newStorage) {\n    const context = await this._utilityContext();\n    await context.evaluate(async ({\n      ls\n    }) => {\n      // Clean DOMStorage.\n      sessionStorage.clear();\n      localStorage.clear();\n\n      // Add new DOM Storage values.\n      for (const entry of ls || []) localStorage[entry.name] = entry.value;\n\n      // Clean Service Workers\n      const registrations = navigator.serviceWorker ? await navigator.serviceWorker.getRegistrations() : [];\n      await Promise.all(registrations.map(async r => {\n        // Heuristic for service workers that stalled during main script fetch or importScripts:\n        // Waiting for them to finish unregistering takes ages so we do not await.\n        // However, they will unregister immediately after fetch finishes and should not affect next page load.\n        // Unfortunately, loading next page in Chromium still takes 5 seconds waiting for\n        // some operation on this bogus service worker to finish.\n        if (!r.installing && !r.waiting && !r.active) r.unregister().catch(() => {});else await r.unregister().catch(() => {});\n      }));\n\n      // Clean IndexedDB\n      for (const db of (await ((_indexedDB$databases = (_indexedDB = indexedDB).databases) === null || _indexedDB$databases === void 0 ? void 0 : _indexedDB$databases.call(_indexedDB))) || []) {\n        var _indexedDB$databases, _indexedDB;\n        // Do not wait for the callback - it is called on timer in Chromium (slow).\n        if (db.name) indexedDB.deleteDatabase(db.name);\n      }\n    }, {\n      ls: newStorage === null || newStorage === void 0 ? void 0 : newStorage.localStorage\n    }).catch(() => {});\n  }\n  _asLocator(selector) {\n    return (0, _locatorGenerators.asLocator)(this._page.context()._browser.options.sdkLanguage, selector);\n  }\n}\nexports.Frame = Frame;\nFrame.Events = {\n  InternalNavigation: 'internalnavigation',\n  AddLifecycle: 'addlifecycle',\n  RemoveLifecycle: 'removelifecycle'\n};\nclass SignalBarrier {\n  constructor(progress) {\n    this._progress = void 0;\n    this._protectCount = 0;\n    this._promise = new _manualPromise.ManualPromise();\n    this._progress = progress;\n    this.retain();\n  }\n  waitFor() {\n    this.release();\n    return this._promise;\n  }\n  async addFrameNavigation(frame) {\n    // Auto-wait top-level navigations only.\n    if (frame.parentFrame()) return;\n    this.retain();\n    const waiter = _helper.helper.waitForEvent(null, frame, Frame.Events.InternalNavigation, e => {\n      if (!e.isPublic) return false;\n      if (!e.error && this._progress) this._progress.log(`  navigated to \"${frame._url}\"`);\n      return true;\n    });\n    await Promise.race([frame._page._disconnectedPromise, frame._page._crashedPromise, frame._detachedPromise, waiter.promise]).catch(e => {});\n    waiter.dispose();\n    this.release();\n  }\n  retain() {\n    ++this._protectCount;\n  }\n  release() {\n    --this._protectCount;\n    if (!this._protectCount) this._promise.resolve();\n  }\n}\nfunction verifyLifecycle(name, waitUntil) {\n  if (waitUntil === 'networkidle0') waitUntil = 'networkidle';\n  if (!types.kLifecycleEvents.has(waitUntil)) throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);\n  return waitUntil;\n}\nfunction renderUnexpectedValue(expression, received) {\n  if (expression === 'to.be.checked') return received ? 'checked' : 'unchecked';\n  if (expression === 'to.be.unchecked') return received ? 'unchecked' : 'checked';\n  if (expression === 'to.be.visible') return received ? 'visible' : 'hidden';\n  if (expression === 'to.be.hidden') return received ? 'hidden' : 'visible';\n  if (expression === 'to.be.enabled') return received ? 'enabled' : 'disabled';\n  if (expression === 'to.be.disabled') return received ? 'disabled' : 'enabled';\n  if (expression === 'to.be.editable') return received ? 'editable' : 'readonly';\n  if (expression === 'to.be.readonly') return received ? 'readonly' : 'editable';\n  if (expression === 'to.be.empty') return received ? 'empty' : 'not empty';\n  if (expression === 'to.be.focused') return received ? 'focused' : 'not focused';\n  return received;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.httpsHappyEyeballsAgent = exports.httpHappyEyeballsAgent = void 0;\nvar dns = _interopRequireWildcard(require(\"dns\"));\nvar http = _interopRequireWildcard(require(\"http\"));\nvar https = _interopRequireWildcard(require(\"https\"));\nvar net = _interopRequireWildcard(require(\"net\"));\nvar tls = _interopRequireWildcard(require(\"tls\"));\nvar _manualPromise = require(\"../utils/manualPromise\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Implementation(partial) of Happy Eyeballs 2 algorithm described in\n// https://www.rfc-editor.org/rfc/rfc8305\n\n// Same as in Chromium (https://source.chromium.org/chromium/chromium/src/+/5666ff4f5077a7e2f72902f3a95f5d553ea0d88d:net/socket/transport_connect_job.cc;l=102)\nconst connectionAttemptDelayMs = 300;\nclass HttpHappyEyeballsAgent extends http.Agent {\n  createConnection(options, oncreate) {\n    // There is no ambiguity in case of IP address.\n    if (net.isIP(clientRequestArgsToHostName(options))) return net.createConnection(options);\n    createConnectionAsync(options, oncreate, /* useTLS */false).catch(err => oncreate === null || oncreate === void 0 ? void 0 : oncreate(err));\n  }\n}\nclass HttpsHappyEyeballsAgent extends https.Agent {\n  createConnection(options, oncreate) {\n    // There is no ambiguity in case of IP address.\n    if (net.isIP(clientRequestArgsToHostName(options))) return tls.connect(options);\n    createConnectionAsync(options, oncreate, /* useTLS */true).catch(err => oncreate === null || oncreate === void 0 ? void 0 : oncreate(err));\n  }\n}\nconst httpsHappyEyeballsAgent = new HttpsHappyEyeballsAgent();\nexports.httpsHappyEyeballsAgent = httpsHappyEyeballsAgent;\nconst httpHappyEyeballsAgent = new HttpHappyEyeballsAgent();\nexports.httpHappyEyeballsAgent = httpHappyEyeballsAgent;\nasync function createConnectionAsync(options, oncreate, useTLS) {\n  const lookup = options.__testHookLookup || lookupAddresses;\n  const hostname = clientRequestArgsToHostName(options);\n  const addresses = await lookup(hostname);\n  const sockets = new Set();\n  let firstError;\n  let errorCount = 0;\n  const handleError = (socket, err) => {\n    var _firstError;\n    if (!sockets.delete(socket)) return;\n    ++errorCount;\n    (_firstError = firstError) !== null && _firstError !== void 0 ? _firstError : firstError = err;\n    if (errorCount === addresses.length) oncreate === null || oncreate === void 0 ? void 0 : oncreate(firstError);\n  };\n  const connected = new _manualPromise.ManualPromise();\n  for (const {\n    address\n  } of addresses) {\n    const socket = useTLS ? tls.connect({\n      ...options,\n      port: options.port,\n      host: address,\n      servername: hostname\n    }) : net.createConnection({\n      ...options,\n      port: options.port,\n      host: address\n    });\n\n    // Each socket may fire only one of 'connect', 'timeout' or 'error' events.\n    // None of these events are fired after socket.destroy() is called.\n    socket.on('connect', () => {\n      connected.resolve();\n      oncreate === null || oncreate === void 0 ? void 0 : oncreate(null, socket);\n      // TODO: Cache the result?\n      // Close other outstanding sockets.\n      sockets.delete(socket);\n      for (const s of sockets) s.destroy();\n      sockets.clear();\n    });\n    socket.on('timeout', () => {\n      // Timeout is not an error, so we have to manually close the socket.\n      socket.destroy();\n      handleError(socket, new Error('Connection timeout'));\n    });\n    socket.on('error', e => handleError(socket, e));\n    sockets.add(socket);\n    await Promise.race([connected, new Promise(f => setTimeout(f, connectionAttemptDelayMs))]);\n    if (connected.isDone()) break;\n  }\n}\nasync function lookupAddresses(hostname) {\n  const addresses = await dns.promises.lookup(hostname, {\n    all: true,\n    family: 0,\n    verbatim: true\n  });\n  let firstFamily = addresses.filter(({\n    family\n  }) => family === 6);\n  let secondFamily = addresses.filter(({\n    family\n  }) => family === 4);\n  // Make sure first address in the list is the same as in the original order.\n  if (firstFamily.length && firstFamily[0] !== addresses[0]) {\n    const tmp = firstFamily;\n    firstFamily = secondFamily;\n    secondFamily = tmp;\n  }\n  const result = [];\n  // Alternate ipv6 and ipv4 addreses.\n  for (let i = 0; i < Math.max(firstFamily.length, secondFamily.length); i++) {\n    if (firstFamily[i]) result.push(firstFamily[i]);\n    if (secondFamily[i]) result.push(secondFamily[i]);\n  }\n  return result;\n}\nfunction clientRequestArgsToHostName(options) {\n  if (options.hostname) return options.hostname;\n  if (options.host) return options.host.split(':')[0];\n  throw new Error('Either options.hostname or options.host must be provided');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HarRecorder = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _artifact = require(\"../artifact\");\nvar _harTracer = require(\"./harTracer\");\nvar _zipBundle = require(\"../../zipBundle\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nvar _utils = require(\"../../utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass HarRecorder {\n  constructor(context, page, options) {\n    this._artifact = void 0;\n    this._isFlushed = false;\n    this._tracer = void 0;\n    this._entries = [];\n    this._zipFile = null;\n    this._writtenZipEntries = new Set();\n    this._artifact = new _artifact.Artifact(context, _path.default.join(context._browser.options.artifactsDir, `${(0, _utils.createGuid)()}.har`));\n    const urlFilterRe = options.urlRegexSource !== undefined && options.urlRegexFlags !== undefined ? new RegExp(options.urlRegexSource, options.urlRegexFlags) : undefined;\n    const expectsZip = options.path.endsWith('.zip');\n    const content = options.content || (expectsZip ? 'attach' : 'embed');\n    this._tracer = new _harTracer.HarTracer(context, page, this, {\n      content,\n      slimMode: options.mode === 'minimal',\n      includeTraceInfo: false,\n      recordRequestOverrides: true,\n      waitForContentOnStop: true,\n      skipScripts: false,\n      urlFilter: urlFilterRe !== null && urlFilterRe !== void 0 ? urlFilterRe : options.urlGlob\n    });\n    this._zipFile = content === 'attach' || expectsZip ? new _zipBundle.yazl.ZipFile() : null;\n    this._tracer.start();\n  }\n  onEntryStarted(entry) {\n    this._entries.push(entry);\n  }\n  onEntryFinished(entry) {}\n  onContentBlob(sha1, buffer) {\n    if (!this._zipFile || this._writtenZipEntries.has(sha1)) return;\n    this._writtenZipEntries.add(sha1);\n    this._zipFile.addBuffer(buffer, sha1);\n  }\n  async flush() {\n    if (this._isFlushed) return;\n    this._isFlushed = true;\n    await this._tracer.flush();\n    const log = this._tracer.stop();\n    log.entries = this._entries;\n    const harFileContent = jsonStringify({\n      log\n    });\n    if (this._zipFile) {\n      const result = new _manualPromise.ManualPromise();\n      this._zipFile.on('error', error => result.reject(error));\n      this._zipFile.addBuffer(Buffer.from(harFileContent, 'utf-8'), 'har.har');\n      this._zipFile.end();\n      this._zipFile.outputStream.pipe(_fs.default.createWriteStream(this._artifact.localPath())).on('close', () => {\n        result.resolve();\n      });\n      await result;\n    } else {\n      await _fs.default.promises.writeFile(this._artifact.localPath(), harFileContent);\n    }\n  }\n  async export() {\n    await this.flush();\n    this._artifact.reportFinished();\n    return this._artifact;\n  }\n}\nexports.HarRecorder = HarRecorder;\nfunction jsonStringify(object) {\n  const tokens = [];\n  innerJsonStringify(object, tokens, '', false, undefined);\n  return tokens.join('');\n}\nfunction innerJsonStringify(object, tokens, indent, flat, parentKey) {\n  if (typeof object !== 'object' || object === null) {\n    tokens.push(JSON.stringify(object));\n    return;\n  }\n  const isArray = Array.isArray(object);\n  if (!isArray && object.constructor.name !== 'Object') {\n    tokens.push(JSON.stringify(object));\n    return;\n  }\n  const entries = isArray ? object : Object.entries(object).filter(e => e[1] !== undefined);\n  if (!entries.length) {\n    tokens.push(isArray ? `[]` : `{}`);\n    return;\n  }\n  const childIndent = `${indent}  `;\n  let brackets;\n  if (isArray) brackets = flat ? {\n    open: '[',\n    close: ']'\n  } : {\n    open: `[\\n${childIndent}`,\n    close: `\\n${indent}]`\n  };else brackets = flat ? {\n    open: '{ ',\n    close: ' }'\n  } : {\n    open: `{\\n${childIndent}`,\n    close: `\\n${indent}}`\n  };\n  tokens.push(brackets.open);\n  for (let i = 0; i < entries.length; ++i) {\n    const entry = entries[i];\n    if (i) tokens.push(flat ? `, ` : `,\\n${childIndent}`);\n    if (!isArray) tokens.push(`${JSON.stringify(entry[0])}: `);\n    const key = isArray ? undefined : entry[0];\n    const flatten = flat || key === 'timings' || parentKey === 'headers';\n    innerJsonStringify(isArray ? entry : entry[1], tokens, childIndent, flatten, key);\n  }\n  tokens.push(brackets.close);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HarTracer = void 0;\nvar _browserContext = require(\"../browserContext\");\nvar _fetch = require(\"../fetch\");\nvar _helper = require(\"../helper\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _utils = require(\"../../utils\");\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _utilsBundle = require(\"../../utilsBundle\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nvar _userAgent = require(\"../../utils/userAgent\");\nvar _network2 = require(\"../../utils/network\");\nvar _frames = require(\"../frames\");\nvar _mimeType = require(\"../../utils/mimeType\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst FALLBACK_HTTP_VERSION = 'HTTP/1.1';\nclass HarTracer {\n  constructor(context, page, delegate, options) {\n    this._context = void 0;\n    this._barrierPromises = new Set();\n    this._delegate = void 0;\n    this._options = void 0;\n    this._pageEntries = new Map();\n    this._eventListeners = [];\n    this._started = false;\n    this._entrySymbol = void 0;\n    this._baseURL = void 0;\n    this._page = void 0;\n    this._context = context;\n    this._page = page;\n    this._delegate = delegate;\n    this._options = options;\n    if (options.slimMode) {\n      options.omitSecurityDetails = true;\n      options.omitCookies = true;\n      options.omitTiming = true;\n      options.omitServerIP = true;\n      options.omitSizes = true;\n      options.omitPages = true;\n    }\n    this._entrySymbol = Symbol('requestHarEntry');\n    this._baseURL = context instanceof _fetch.APIRequestContext ? context._defaultOptions().baseURL : context._options.baseURL;\n  }\n  start() {\n    if (this._started) return;\n    this._started = true;\n    const apiRequest = this._context instanceof _fetch.APIRequestContext ? this._context : this._context.fetchRequest;\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.Request, event => this._onAPIRequest(event)), _eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.RequestFinished, event => this._onAPIRequestFinished(event))];\n    if (this._context instanceof _browserContext.BrowserContext) {\n      this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, page => this._createPageEntryIfNeeded(page)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Request, request => this._onRequest(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFinished, ({\n        request,\n        response\n      }) => this._onRequestFinished(request, response).catch(() => {})), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFailed, request => this._onRequestFailed(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Response, response => this._onResponse(response)));\n    }\n  }\n  _shouldIncludeEntryWithUrl(urlString) {\n    return !this._options.urlFilter || (0, _network2.urlMatches)(this._baseURL, urlString, this._options.urlFilter);\n  }\n  _entryForRequest(request) {\n    return request[this._entrySymbol];\n  }\n  _createPageEntryIfNeeded(page) {\n    if (!page) return;\n    if (this._options.omitPages) return;\n    if (this._page && page !== this._page) return;\n    let pageEntry = this._pageEntries.get(page);\n    if (!pageEntry) {\n      pageEntry = {\n        startedDateTime: new Date(),\n        id: page.guid,\n        title: '',\n        pageTimings: this._options.omitTiming ? {} : {\n          onContentLoad: -1,\n          onLoad: -1\n        }\n      };\n      page.mainFrame().on(_frames.Frame.Events.AddLifecycle, event => {\n        if (event === 'load') this._onLoad(page, pageEntry);\n        if (event === 'domcontentloaded') this._onDOMContentLoaded(page, pageEntry);\n      });\n      this._pageEntries.set(page, pageEntry);\n    }\n    return pageEntry;\n  }\n  _onDOMContentLoaded(page, pageEntry) {\n    const promise = page.mainFrame().evaluateExpression(String(() => {\n      return {\n        title: document.title,\n        domContentLoaded: performance.timing.domContentLoadedEventStart\n      };\n    }), true, undefined, 'utility').then(result => {\n      pageEntry.title = result.title;\n      if (!this._options.omitTiming) pageEntry.pageTimings.onContentLoad = result.domContentLoaded;\n    }).catch(() => {});\n    this._addBarrier(page, promise);\n  }\n  _onLoad(page, pageEntry) {\n    const promise = page.mainFrame().evaluateExpression(String(() => {\n      return {\n        title: document.title,\n        loaded: performance.timing.loadEventStart\n      };\n    }), true, undefined, 'utility').then(result => {\n      pageEntry.title = result.title;\n      if (!this._options.omitTiming) pageEntry.pageTimings.onLoad = result.loaded;\n    }).catch(() => {});\n    this._addBarrier(page, promise);\n  }\n  _addBarrier(target, promise) {\n    if (!target) return null;\n    if (!this._options.waitForContentOnStop) return;\n    const race = Promise.race([new Promise(f => target.on('close', () => {\n      this._barrierPromises.delete(race);\n      f();\n    })), promise]);\n    this._barrierPromises.add(race);\n    race.then(() => this._barrierPromises.delete(race));\n  }\n  _onAPIRequest(event) {\n    var _event$postData;\n    if (!this._shouldIncludeEntryWithUrl(event.url.toString())) return;\n    const harEntry = createHarEntry(event.method, event.url, undefined, this._options);\n    if (!this._options.omitCookies) harEntry.request.cookies = event.cookies;\n    harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({\n      name,\n      value\n    }));\n    harEntry.request.postData = this._postDataForBuffer(event.postData || null, event.headers['content-type'], this._options.content);\n    if (!this._options.omitSizes) harEntry.request.bodySize = ((_event$postData = event.postData) === null || _event$postData === void 0 ? void 0 : _event$postData.length) || 0;\n    event[this._entrySymbol] = harEntry;\n    if (this._started) this._delegate.onEntryStarted(harEntry);\n  }\n  _onAPIRequestFinished(event) {\n    const harEntry = this._entryForRequest(event.requestEvent);\n    if (!harEntry) return;\n    harEntry.response.status = event.statusCode;\n    harEntry.response.statusText = event.statusMessage;\n    harEntry.response.httpVersion = event.httpVersion;\n    harEntry.response.redirectURL = event.headers.location || '';\n    for (let i = 0; i < event.rawHeaders.length; i += 2) {\n      harEntry.response.headers.push({\n        name: event.rawHeaders[i],\n        value: event.rawHeaders[i + 1]\n      });\n    }\n    harEntry.response.cookies = this._options.omitCookies ? [] : event.cookies.map(c => {\n      return {\n        ...c,\n        expires: c.expires === -1 ? undefined : new Date(c.expires)\n      };\n    });\n    const content = harEntry.response.content;\n    const contentType = event.headers['content-type'];\n    if (contentType) content.mimeType = contentType;\n    this._storeResponseContent(event.body, content, 'other');\n    if (this._started) this._delegate.onEntryFinished(harEntry);\n  }\n  _onRequest(request) {\n    var _request$frame, _request$frame2;\n    if (!this._shouldIncludeEntryWithUrl(request.url())) return;\n    const page = (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page;\n    if (this._page && page !== this._page) return;\n    const url = network.parsedURL(request.url());\n    if (!url) return;\n    const pageEntry = this._createPageEntryIfNeeded(page);\n    const harEntry = createHarEntry(request.method(), url, (_request$frame2 = request.frame()) === null || _request$frame2 === void 0 ? void 0 : _request$frame2.guid, this._options);\n    if (pageEntry) harEntry.pageref = pageEntry.id;\n    this._recordRequestHeadersAndCookies(harEntry, request.headers());\n    harEntry.request.postData = this._postDataForRequest(request, this._options.content);\n    if (!this._options.omitSizes) harEntry.request.bodySize = request.bodySize();\n    if (request.redirectedFrom()) {\n      const fromEntry = this._entryForRequest(request.redirectedFrom());\n      if (fromEntry) fromEntry.response.redirectURL = request.url();\n    }\n    request[this._entrySymbol] = harEntry;\n    (0, _utils.assert)(this._started);\n    this._delegate.onEntryStarted(harEntry);\n  }\n  _recordRequestHeadersAndCookies(harEntry, headers) {\n    if (!this._options.omitCookies) {\n      harEntry.request.cookies = [];\n      for (const header of headers.filter(header => header.name.toLowerCase() === 'cookie')) harEntry.request.cookies.push(...header.value.split(';').map(parseCookie));\n    }\n    harEntry.request.headers = headers;\n  }\n  _recordRequestOverrides(harEntry, request) {\n    if (!request._hasOverrides() || !this._options.recordRequestOverrides) return;\n    harEntry.request.method = request.method();\n    harEntry.request.url = request.url();\n    harEntry.request.postData = this._postDataForRequest(request, this._options.content);\n    this._recordRequestHeadersAndCookies(harEntry, request.headers());\n  }\n  async _onRequestFinished(request, response) {\n    var _request$frame3;\n    if (!response) return;\n    const harEntry = this._entryForRequest(request);\n    if (!harEntry) return;\n    const page = (_request$frame3 = request.frame()) === null || _request$frame3 === void 0 ? void 0 : _request$frame3._page;\n    const httpVersion = response.httpVersion();\n    harEntry.request.httpVersion = httpVersion;\n    harEntry.response.httpVersion = httpVersion;\n    const compressionCalculationBarrier = this._options.omitSizes ? undefined : {\n      _encodedBodySize: -1,\n      _decodedBodySize: -1,\n      barrier: new _manualPromise.ManualPromise(),\n      _check: function () {\n        if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {\n          harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);\n          this.barrier.resolve();\n        }\n      },\n      setEncodedBodySize: function (encodedBodySize) {\n        this._encodedBodySize = encodedBodySize;\n        this._check();\n      },\n      setDecodedBodySize: function (decodedBodySize) {\n        this._decodedBodySize = decodedBodySize;\n        this._check();\n      }\n    };\n    if (compressionCalculationBarrier) this._addBarrier(page || request.serviceWorker(), compressionCalculationBarrier.barrier);\n    const promise = response.body().then(buffer => {\n      if (this._options.skipScripts && request.resourceType() === 'script') {\n        compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(0);\n        return;\n      }\n      const content = harEntry.response.content;\n      compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(buffer.length);\n      this._storeResponseContent(buffer, content, request.resourceType());\n    }).catch(() => {\n      compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(0);\n    }).then(() => {\n      if (this._started) this._delegate.onEntryFinished(harEntry);\n    });\n    this._addBarrier(page || request.serviceWorker(), promise);\n\n    // Respose end timing is only available after the response event was received.\n    const timing = response.timing();\n    harEntry.timings.receive = response.request()._responseEndTiming !== -1 ? _helper.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;\n    this._computeHarEntryTotalTime(harEntry);\n    if (!this._options.omitSizes) {\n      this._addBarrier(page || request.serviceWorker(), response.sizes().then(sizes => {\n        harEntry.response.bodySize = sizes.responseBodySize;\n        harEntry.response.headersSize = sizes.responseHeadersSize;\n        harEntry.response._transferSize = sizes.transferSize;\n        harEntry.request.headersSize = sizes.requestHeadersSize;\n        compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setEncodedBodySize(sizes.responseBodySize);\n      }));\n    }\n  }\n  async _onRequestFailed(request) {\n    const harEntry = this._entryForRequest(request);\n    if (!harEntry) return;\n    if (request._failureText !== null) harEntry.response._failureText = request._failureText;\n    this._recordRequestOverrides(harEntry, request);\n    if (this._started) this._delegate.onEntryFinished(harEntry);\n  }\n  _storeResponseContent(buffer, content, resourceType) {\n    if (!buffer) {\n      content.size = 0;\n      return;\n    }\n    if (!this._options.omitSizes) content.size = buffer.length;\n    if (this._options.content === 'embed') {\n      // Sometimes, we can receive a font/media file with textual mime type. Browser\n      // still interprets them correctly, but the 'content-type' header is obviously wrong.\n      if ((0, _mimeType.isTextualMimeType)(content.mimeType) && resourceType !== 'font') {\n        content.text = buffer.toString();\n      } else {\n        content.text = buffer.toString('base64');\n        content.encoding = 'base64';\n      }\n    } else if (this._options.content === 'attach') {\n      const sha1 = (0, _utils.calculateSha1)(buffer) + '.' + (_utilsBundle.mime.getExtension(content.mimeType) || 'dat');\n      if (this._options.includeTraceInfo) content._sha1 = sha1;else content._file = sha1;\n      if (this._started) this._delegate.onContentBlob(sha1, buffer);\n    }\n  }\n  _onResponse(response) {\n    var _response$frame;\n    const harEntry = this._entryForRequest(response.request());\n    if (!harEntry) return;\n    const page = (_response$frame = response.frame()) === null || _response$frame === void 0 ? void 0 : _response$frame._page;\n    const pageEntry = this._createPageEntryIfNeeded(page);\n    const request = response.request();\n    harEntry.response = {\n      status: response.status(),\n      statusText: response.statusText(),\n      httpVersion: response.httpVersion(),\n      // These are bad values that will be overwritten bellow.\n      cookies: [],\n      headers: [],\n      content: {\n        size: -1,\n        mimeType: 'x-unknown'\n      },\n      headersSize: -1,\n      bodySize: -1,\n      redirectURL: '',\n      _transferSize: this._options.omitSizes ? undefined : -1\n    };\n    if (!this._options.omitTiming) {\n      const timing = response.timing();\n      if (pageEntry && pageEntry.startedDateTime.valueOf() > timing.startTime) pageEntry.startedDateTime = new Date(timing.startTime);\n      const dns = timing.domainLookupEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;\n      const connect = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;\n      const ssl = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;\n      const wait = timing.responseStart !== -1 ? _helper.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;\n      const receive = -1;\n      harEntry.timings = {\n        dns,\n        connect,\n        ssl,\n        send: 0,\n        wait,\n        receive\n      };\n      this._computeHarEntryTotalTime(harEntry);\n    }\n    if (!this._options.omitServerIP) {\n      this._addBarrier(page || request.serviceWorker(), response.serverAddr().then(server => {\n        if (server !== null && server !== void 0 && server.ipAddress) harEntry.serverIPAddress = server.ipAddress;\n        if (server !== null && server !== void 0 && server.port) harEntry._serverPort = server.port;\n      }));\n    }\n    if (!this._options.omitSecurityDetails) {\n      this._addBarrier(page || request.serviceWorker(), response.securityDetails().then(details => {\n        if (details) harEntry._securityDetails = details;\n      }));\n    }\n    this._recordRequestOverrides(harEntry, request);\n    this._addBarrier(page || request.serviceWorker(), request.rawRequestHeaders().then(headers => {\n      this._recordRequestHeadersAndCookies(harEntry, headers);\n    }));\n    this._addBarrier(page || request.serviceWorker(), response.rawResponseHeaders().then(headers => {\n      if (!this._options.omitCookies) {\n        for (const header of headers.filter(header => header.name.toLowerCase() === 'set-cookie')) harEntry.response.cookies.push(parseCookie(header.value));\n      }\n      harEntry.response.headers = headers;\n      const contentType = headers.find(header => header.name.toLowerCase() === 'content-type');\n      if (contentType) harEntry.response.content.mimeType = contentType.value;\n    }));\n  }\n  _computeHarEntryTotalTime(harEntry) {\n    harEntry.time = [harEntry.timings.dns, harEntry.timings.connect, harEntry.timings.ssl, harEntry.timings.wait, harEntry.timings.receive].reduce((pre, cur) => (cur || -1) > 0 ? cur + pre : pre, 0);\n  }\n  async flush() {\n    await Promise.all(this._barrierPromises);\n  }\n  stop() {\n    this._started = false;\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n    this._barrierPromises.clear();\n    const context = this._context instanceof _browserContext.BrowserContext ? this._context : undefined;\n    const log = {\n      version: '1.2',\n      creator: {\n        name: 'Playwright',\n        version: (0, _userAgent.getPlaywrightVersion)()\n      },\n      browser: {\n        name: (context === null || context === void 0 ? void 0 : context._browser.options.name) || '',\n        version: (context === null || context === void 0 ? void 0 : context._browser.version()) || ''\n      },\n      pages: this._pageEntries.size ? Array.from(this._pageEntries.values()) : undefined,\n      entries: []\n    };\n    if (!this._options.omitTiming) {\n      for (const pageEntry of log.pages || []) {\n        if (typeof pageEntry.pageTimings.onContentLoad === 'number' && pageEntry.pageTimings.onContentLoad >= 0) pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();else pageEntry.pageTimings.onContentLoad = -1;\n        if (typeof pageEntry.pageTimings.onLoad === 'number' && pageEntry.pageTimings.onLoad >= 0) pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();else pageEntry.pageTimings.onLoad = -1;\n      }\n    }\n    this._pageEntries.clear();\n    return log;\n  }\n  _postDataForRequest(request, content) {\n    const postData = request.postDataBuffer();\n    if (!postData) return;\n    const contentType = request.headerValue('content-type');\n    return this._postDataForBuffer(postData, contentType, content);\n  }\n  _postDataForBuffer(postData, contentType, content) {\n    var _contentType;\n    if (!postData) return;\n    (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : contentType = 'application/octet-stream';\n    const result = {\n      mimeType: contentType,\n      text: '',\n      params: []\n    };\n    if (content === 'embed' && contentType !== 'application/octet-stream') result.text = postData.toString();\n    if (content === 'attach') {\n      const sha1 = (0, _utils.calculateSha1)(postData) + '.' + (_utilsBundle.mime.getExtension(contentType) || 'dat');\n      if (this._options.includeTraceInfo) result._sha1 = sha1;else result._file = sha1;\n      this._delegate.onContentBlob(sha1, postData);\n    }\n    if (contentType === 'application/x-www-form-urlencoded') {\n      const parsed = new URLSearchParams(postData.toString());\n      for (const [name, value] of parsed.entries()) result.params.push({\n        name,\n        value\n      });\n    }\n    return result;\n  }\n}\nexports.HarTracer = HarTracer;\nfunction createHarEntry(method, url, frameref, options) {\n  const harEntry = {\n    _frameref: options.includeTraceInfo ? frameref : undefined,\n    _monotonicTime: options.includeTraceInfo ? (0, _utils.monotonicTime)() : undefined,\n    startedDateTime: new Date(),\n    time: -1,\n    request: {\n      method: method,\n      url: url.toString(),\n      httpVersion: FALLBACK_HTTP_VERSION,\n      cookies: [],\n      headers: [],\n      queryString: [...url.searchParams].map(e => ({\n        name: e[0],\n        value: e[1]\n      })),\n      headersSize: -1,\n      bodySize: -1\n    },\n    response: {\n      status: -1,\n      statusText: '',\n      httpVersion: FALLBACK_HTTP_VERSION,\n      cookies: [],\n      headers: [],\n      content: {\n        size: -1,\n        mimeType: 'x-unknown'\n      },\n      headersSize: -1,\n      bodySize: -1,\n      redirectURL: '',\n      _transferSize: options.omitSizes ? undefined : -1\n    },\n    cache: {},\n    timings: {\n      send: -1,\n      wait: -1,\n      receive: -1\n    }\n  };\n  return harEntry;\n}\nfunction parseCookie(c) {\n  const cookie = {\n    name: '',\n    value: ''\n  };\n  let first = true;\n  for (const pair of c.split(/; */)) {\n    const indexOfEquals = pair.indexOf('=');\n    const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();\n    const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : '';\n    if (first) {\n      first = false;\n      cookie.name = name;\n      cookie.value = value;\n      continue;\n    }\n    if (name === 'Domain') cookie.domain = value;\n    if (name === 'Expires') cookie.expires = new Date(value);\n    if (name === 'HttpOnly') cookie.httpOnly = true;\n    if (name === 'Max-Age') cookie.expires = new Date(Date.now() + +value * 1000);\n    if (name === 'Path') cookie.path = value;\n    if (name === 'SameSite') cookie.sameSite = value;\n    if (name === 'Secure') cookie.secure = true;\n  }\n  return cookie;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.helper = void 0;\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _eventsHelper = require(\"../utils/eventsHelper\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MAX_LOG_LENGTH = process.env.MAX_LOG_LENGTH ? +process.env.MAX_LOG_LENGTH : Infinity;\nclass Helper {\n  static completeUserURL(urlString) {\n    if (urlString.startsWith('localhost') || urlString.startsWith('127.0.0.1')) urlString = 'http://' + urlString;\n    return urlString;\n  }\n  static enclosingIntRect(rect) {\n    const x = Math.floor(rect.x + 1e-3);\n    const y = Math.floor(rect.y + 1e-3);\n    const x2 = Math.ceil(rect.x + rect.width - 1e-3);\n    const y2 = Math.ceil(rect.y + rect.height - 1e-3);\n    return {\n      x,\n      y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n  static enclosingIntSize(size) {\n    return {\n      width: Math.floor(size.width + 1e-3),\n      height: Math.floor(size.height + 1e-3)\n    };\n  }\n  static getViewportSizeFromWindowFeatures(features) {\n    const widthString = features.find(f => f.startsWith('width='));\n    const heightString = features.find(f => f.startsWith('height='));\n    const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;\n    const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;\n    if (!Number.isNaN(width) && !Number.isNaN(height)) return {\n      width,\n      height\n    };\n    return null;\n  }\n  static waitForEvent(progress, emitter, event, predicate) {\n    const listeners = [];\n    const promise = new Promise((resolve, reject) => {\n      listeners.push(_eventsHelper.eventsHelper.addEventListener(emitter, event, eventArg => {\n        try {\n          if (predicate && !predicate(eventArg)) return;\n          _eventsHelper.eventsHelper.removeEventListeners(listeners);\n          resolve(eventArg);\n        } catch (e) {\n          _eventsHelper.eventsHelper.removeEventListeners(listeners);\n          reject(e);\n        }\n      }));\n    });\n    const dispose = () => _eventsHelper.eventsHelper.removeEventListeners(listeners);\n    if (progress) progress.cleanupWhenAborted(dispose);\n    return {\n      promise,\n      dispose\n    };\n  }\n  static secondsToRoundishMillis(value) {\n    return (value * 1000000 | 0) / 1000;\n  }\n  static millisToRoundishMillis(value) {\n    return (value * 1000 | 0) / 1000;\n  }\n  static debugProtocolLogger(protocolLogger) {\n    return (direction, message) => {\n      if (protocolLogger) protocolLogger(direction, message);\n      if (_debugLogger.debugLogger.isEnabled('protocol')) {\n        let text = JSON.stringify(message);\n        if (text.length > MAX_LOG_LENGTH) text = text.substring(0, MAX_LOG_LENGTH / 2) + ' <<<<<( LOG TRUNCATED )>>>>> ' + text.substring(text.length - MAX_LOG_LENGTH / 2);\n        _debugLogger.debugLogger.log('protocol', (direction === 'send' ? 'SEND ► ' : '◀ RECV ') + text);\n      }\n    };\n  }\n  static formatBrowserLogs(logs) {\n    if (!logs.length) return '';\n    return '\\n' + '='.repeat(20) + ' Browser output: ' + '='.repeat(20) + '\\n' + logs.join('\\n');\n  }\n}\nconst helper = Helper;\nexports.helper = helper;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DispatcherConnection\", {\n  enumerable: true,\n  get: function () {\n    return _dispatcher.DispatcherConnection;\n  }\n});\nObject.defineProperty(exports, \"PlaywrightDispatcher\", {\n  enumerable: true,\n  get: function () {\n    return _playwrightDispatcher.PlaywrightDispatcher;\n  }\n});\nObject.defineProperty(exports, \"Registry\", {\n  enumerable: true,\n  get: function () {\n    return _registry.Registry;\n  }\n});\nObject.defineProperty(exports, \"RootDispatcher\", {\n  enumerable: true,\n  get: function () {\n    return _dispatcher.RootDispatcher;\n  }\n});\nObject.defineProperty(exports, \"createPlaywright\", {\n  enumerable: true,\n  get: function () {\n    return _playwright.createPlaywright;\n  }\n});\nObject.defineProperty(exports, \"installBrowsersForNpmInstall\", {\n  enumerable: true,\n  get: function () {\n    return _registry.installBrowsersForNpmInstall;\n  }\n});\nObject.defineProperty(exports, \"installDefaultBrowsersForNpmInstall\", {\n  enumerable: true,\n  get: function () {\n    return _registry.installDefaultBrowsersForNpmInstall;\n  }\n});\nObject.defineProperty(exports, \"registry\", {\n  enumerable: true,\n  get: function () {\n    return _registry.registry;\n  }\n});\nObject.defineProperty(exports, \"registryDirectory\", {\n  enumerable: true,\n  get: function () {\n    return _registry.registryDirectory;\n  }\n});\nObject.defineProperty(exports, \"writeDockerVersion\", {\n  enumerable: true,\n  get: function () {\n    return _registry.writeDockerVersion;\n  }\n});\nvar _registry = require(\"./registry\");\nvar _dispatcher = require(\"./dispatchers/dispatcher\");\nvar _playwrightDispatcher = require(\"./dispatchers/playwrightDispatcher\");\nvar _playwright = require(\"./playwright\");","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keypadLocation = exports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;\nvar _utils = require(\"../utils\");\nvar keyboardLayout = _interopRequireWildcard(require(\"./usKeyboardLayout\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst keypadLocation = keyboardLayout.keypadLocation;\nexports.keypadLocation = keypadLocation;\nconst kModifiers = ['Alt', 'Control', 'Meta', 'Shift'];\nclass Keyboard {\n  constructor(raw, page) {\n    this._pressedModifiers = new Set();\n    this._pressedKeys = new Set();\n    this._raw = void 0;\n    this._page = void 0;\n    this._raw = raw;\n    this._page = page;\n  }\n  async down(key) {\n    const description = this._keyDescriptionForString(key);\n    const autoRepeat = this._pressedKeys.has(description.code);\n    this._pressedKeys.add(description.code);\n    if (kModifiers.includes(description.key)) this._pressedModifiers.add(description.key);\n    const text = description.text;\n    await this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);\n  }\n  _keyDescriptionForString(keyString) {\n    let description = usKeyboardLayout.get(keyString);\n    (0, _utils.assert)(description, `Unknown key: \"${keyString}\"`);\n    const shift = this._pressedModifiers.has('Shift');\n    description = shift && description.shifted ? description.shifted : description;\n\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has('Shift') && this._pressedModifiers.size === 1) return {\n      ...description,\n      text: ''\n    };\n    return description;\n  }\n  async up(key) {\n    const description = this._keyDescriptionForString(key);\n    if (kModifiers.includes(description.key)) this._pressedModifiers.delete(description.key);\n    this._pressedKeys.delete(description.code);\n    await this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);\n  }\n  async insertText(text) {\n    await this._raw.sendText(text);\n  }\n  async type(text, options) {\n    const delay = options && options.delay || undefined;\n    for (const char of text) {\n      if (usKeyboardLayout.has(char)) {\n        await this.press(char, {\n          delay\n        });\n      } else {\n        if (delay) await new Promise(f => setTimeout(f, delay));\n        await this.insertText(char);\n      }\n    }\n  }\n  async press(key, options = {}) {\n    function split(keyString) {\n      const keys = [];\n      let building = '';\n      for (const char of keyString) {\n        if (char === '+' && building) {\n          keys.push(building);\n          building = '';\n        } else {\n          building += char;\n        }\n      }\n      keys.push(building);\n      return keys;\n    }\n    const tokens = split(key);\n    const promises = [];\n    key = tokens[tokens.length - 1];\n    for (let i = 0; i < tokens.length - 1; ++i) promises.push(this.down(tokens[i]));\n    promises.push(this.down(key));\n    if (options.delay) {\n      await Promise.all(promises);\n      await new Promise(f => setTimeout(f, options.delay));\n    }\n    promises.push(this.up(key));\n    for (let i = tokens.length - 2; i >= 0; --i) promises.push(this.up(tokens[i]));\n    await Promise.all(promises);\n  }\n  async _ensureModifiers(modifiers) {\n    for (const modifier of modifiers) {\n      if (!kModifiers.includes(modifier)) throw new Error('Unknown modifier ' + modifier);\n    }\n    const restore = Array.from(this._pressedModifiers);\n    const promises = [];\n    for (const key of kModifiers) {\n      const needDown = modifiers.includes(key);\n      const isDown = this._pressedModifiers.has(key);\n      if (needDown && !isDown) promises.push(this.down(key));else if (!needDown && isDown) promises.push(this.up(key));\n    }\n    await Promise.all(promises);\n    return restore;\n  }\n  _modifiers() {\n    return this._pressedModifiers;\n  }\n}\nexports.Keyboard = Keyboard;\nclass Mouse {\n  constructor(raw, page) {\n    this._keyboard = void 0;\n    this._x = 0;\n    this._y = 0;\n    this._lastButton = 'none';\n    this._buttons = new Set();\n    this._raw = void 0;\n    this._page = void 0;\n    this._raw = raw;\n    this._page = page;\n    this._keyboard = this._page.keyboard;\n  }\n  async move(x, y, options = {}) {\n    const {\n      steps = 1\n    } = options;\n    const fromX = this._x;\n    const fromY = this._y;\n    this._x = x;\n    this._y = y;\n    for (let i = 1; i <= steps; i++) {\n      const middleX = fromX + (x - fromX) * (i / steps);\n      const middleY = fromY + (y - fromY) * (i / steps);\n      await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options.forClick);\n    }\n  }\n  async down(options = {}) {\n    const {\n      button = 'left',\n      clickCount = 1\n    } = options;\n    this._lastButton = button;\n    this._buttons.add(button);\n    await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);\n  }\n  async up(options = {}) {\n    const {\n      button = 'left',\n      clickCount = 1\n    } = options;\n    this._lastButton = 'none';\n    this._buttons.delete(button);\n    await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);\n  }\n  async click(x, y, options = {}) {\n    const {\n      delay = null,\n      clickCount = 1\n    } = options;\n    if (delay) {\n      this.move(x, y, {\n        forClick: true\n      });\n      for (let cc = 1; cc <= clickCount; ++cc) {\n        await this.down({\n          ...options,\n          clickCount: cc\n        });\n        await new Promise(f => setTimeout(f, delay));\n        await this.up({\n          ...options,\n          clickCount: cc\n        });\n        if (cc < clickCount) await new Promise(f => setTimeout(f, delay));\n      }\n    } else {\n      const promises = [];\n      promises.push(this.move(x, y, {\n        forClick: true\n      }));\n      for (let cc = 1; cc <= clickCount; ++cc) {\n        promises.push(this.down({\n          ...options,\n          clickCount: cc\n        }));\n        promises.push(this.up({\n          ...options,\n          clickCount: cc\n        }));\n      }\n      await Promise.all(promises);\n    }\n  }\n  async dblclick(x, y, options = {}) {\n    await this.click(x, y, {\n      ...options,\n      clickCount: 2\n    });\n  }\n  async wheel(deltaX, deltaY) {\n    await this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);\n  }\n}\nexports.Mouse = Mouse;\nconst aliases = new Map([['ShiftLeft', ['Shift']], ['ControlLeft', ['Control']], ['AltLeft', ['Alt']], ['MetaLeft', ['Meta']], ['Enter', ['\\n', '\\r']]]);\nconst usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);\nfunction buildLayoutClosure(layout) {\n  const result = new Map();\n  for (const code in layout) {\n    const definition = layout[code];\n    const description = {\n      key: definition.key || '',\n      keyCode: definition.keyCode || 0,\n      keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,\n      code,\n      text: definition.text || '',\n      location: definition.location || 0\n    };\n    if (definition.key.length === 1) description.text = description.key;\n\n    // Generate shifted definition.\n    let shiftedDescription;\n    if (definition.shiftKey) {\n      (0, _utils.assert)(definition.shiftKey.length === 1);\n      shiftedDescription = {\n        ...description\n      };\n      shiftedDescription.key = definition.shiftKey;\n      shiftedDescription.text = definition.shiftKey;\n      if (definition.shiftKeyCode) shiftedDescription.keyCode = definition.shiftKeyCode;\n    }\n\n    // Map from code: Digit3 -> { ... descrption, shifted }\n    result.set(code, {\n      ...description,\n      shifted: shiftedDescription\n    });\n\n    // Map from aliases: Shift -> non-shiftable definition\n    if (aliases.has(code)) {\n      for (const alias of aliases.get(code)) result.set(alias, description);\n    }\n\n    // Do not use numpad when converting keys to codes.\n    if (definition.location) continue;\n\n    // Map from key, no shifted\n    if (description.key.length === 1) result.set(description.key, description);\n\n    // Map from shiftKey, no shifted\n    if (shiftedDescription) result.set(shiftedDescription.key, {\n      ...shiftedDescription,\n      shifted: undefined\n    });\n  }\n  return result;\n}\nclass Touchscreen {\n  constructor(raw, page) {\n    this._raw = void 0;\n    this._page = void 0;\n    this._raw = raw;\n    this._page = page;\n  }\n  async tap(x, y) {\n    if (!this._page._browserContext._options.hasTouch) throw new Error('hasTouch must be enabled on the browser context before using the touchscreen.');\n    await this._raw.tap(x, y, this._page.keyboard._modifiers());\n  }\n}\nexports.Touchscreen = Touchscreen;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SdkObject = void 0;\nexports.createInstrumentation = createInstrumentation;\nexports.kTestSdkObjects = void 0;\nexports.serverSideCallMetadata = serverSideCallMetadata;\nvar _events = require(\"events\");\nvar _utils = require(\"../utils\");\n/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst kTestSdkObjects = new WeakSet();\nexports.kTestSdkObjects = kTestSdkObjects;\nclass SdkObject extends _events.EventEmitter {\n  constructor(parent, guidPrefix, guid) {\n    super();\n    this.guid = void 0;\n    this.attribution = void 0;\n    this.instrumentation = void 0;\n    this.guid = guid || `${guidPrefix || ''}@${(0, _utils.createGuid)()}`;\n    this.setMaxListeners(0);\n    this.attribution = {\n      ...parent.attribution\n    };\n    this.instrumentation = parent.instrumentation;\n    if (process.env._PW_INTERNAL_COUNT_SDK_OBJECTS) kTestSdkObjects.add(this);\n  }\n}\nexports.SdkObject = SdkObject;\nfunction createInstrumentation() {\n  const listeners = new Map();\n  return new Proxy({}, {\n    get: (obj, prop) => {\n      if (prop === 'addListener') return (listener, context) => listeners.set(listener, context);\n      if (prop === 'removeListener') return listener => listeners.delete(listener);\n      if (!prop.startsWith('on')) return obj[prop];\n      return async (sdkObject, ...params) => {\n        for (const [listener, context] of listeners) {\n          var _prop, _ref;\n          if (!context || sdkObject.attribution.context === context) await ((_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, sdkObject, ...params));\n        }\n      };\n    }\n  });\n}\nfunction serverSideCallMetadata() {\n  return {\n    id: '',\n    wallTime: 0,\n    startTime: 0,\n    endTime: 0,\n    type: 'Internal',\n    method: '',\n    params: {},\n    log: [],\n    snapshots: [],\n    isServerSide: true\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidSelectorError = void 0;\nexports.isInvalidSelectorError = isInvalidSelectorError;\nexports.parseCSS = parseCSS;\nexports.serializeSelector = serializeSelector;\nvar css = _interopRequireWildcard(require(\"./cssTokenizer\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass InvalidSelectorError extends Error {}\nexports.InvalidSelectorError = InvalidSelectorError;\nfunction isInvalidSelectorError(error) {\n  return error instanceof InvalidSelectorError;\n}\n\n// Note: '>=' is used internally for text engine to preserve backwards compatibility.\n\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = css.tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof css.EOFToken)) tokens.push(new css.EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n    const index = (e.stack || '').indexOf(e.message);\n    if (index !== -1) e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find(token => {\n    return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken ||\n    // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n    token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken ||\n    // TODO: Consider treating these as strings?\n    token instanceof css.URLToken || token instanceof css.PercentageToken;\n  });\n  if (unsupportedToken) throw new InvalidSelectorError(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n  let pos = 0;\n  const names = new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof css.WhitespaceToken) pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof css.IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof css.StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof css.NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof css.CommaToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof css.CloseParenToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof css.DelimToken && tokens[p].value === '*';\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof css.EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof css.DelimToken && ['>', '+', '~'].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma()) break;\n      pos++;\n      result.push(consumeArgument());\n    }\n    return result;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber()) return tokens[pos++].value;\n    if (isString()) return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result = {\n      simples: []\n    };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      // Put implicit \":scope\" at the start. https://drafts.csswg.org/selectors-4/#absolutize\n      result.simples.push({\n        selector: {\n          functions: [{\n            name: 'scope',\n            args: []\n          }]\n        },\n        combinator: ''\n      });\n    } else {\n      result.simples.push({\n        selector: consumeSimpleSelector(),\n        combinator: ''\n      });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result.simples.push({\n        combinator: '',\n        selector: consumeSimpleSelector()\n      });\n    }\n    return result;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = '';\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === '.') {\n        pos++;\n        if (isIdent()) rawCSSString += '.' + tokens[pos++].toSource();else throw unexpected();\n      } else if (tokens[pos] instanceof css.ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ':' + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({\n              name,\n              args: []\n            });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof css.FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({\n              name,\n              args: consumeFunctionArguments()\n            });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen()) throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof css.OpenSquareToken) {\n        rawCSSString += '[';\n        pos++;\n        while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF()) rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof css.CloseSquareToken)) throw unexpected();\n        rawCSSString += ']';\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length) throw unexpected();\n    return {\n      css: rawCSSString || undefined,\n      functions\n    };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = '';\n    while (!isCloseParen() && !isEOF()) s += tokens[pos++].toSource();\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF()) throw new InvalidSelectorError(`Error while parsing selector \"${selector}\"`);\n  if (result.some(arg => typeof arg !== 'object' || !('simples' in arg))) throw new InvalidSelectorError(`Error while parsing selector \"${selector}\"`);\n  return {\n    selector: result,\n    names: Array.from(names)\n  };\n}\nfunction serializeSelector(args) {\n  return args.map(arg => {\n    if (typeof arg === 'string') return `\"${arg}\"`;\n    if (typeof arg === 'number') return String(arg);\n    return arg.simples.map(({\n      selector,\n      combinator\n    }) => {\n      let s = selector.css || '';\n      s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n      if (combinator) s += ' ' + combinator;\n      return s;\n    }).join(' ');\n  }).join(', ');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WhitespaceToken = exports.URLToken = exports.SuffixMatchToken = exports.SubstringMatchToken = exports.StringValuedToken = exports.StringToken = exports.SemicolonToken = exports.PrefixMatchToken = exports.PercentageToken = exports.OpenSquareToken = exports.OpenParenToken = exports.OpenCurlyToken = exports.NumberToken = exports.InvalidCharacterError = exports.IncludeMatchToken = exports.IdentToken = exports.HashToken = exports.GroupingToken = exports.FunctionToken = exports.EOFToken = exports.DimensionToken = exports.DelimToken = exports.DashMatchToken = exports.CommaToken = exports.ColumnToken = exports.ColonToken = exports.CloseSquareToken = exports.CloseParenToken = exports.CloseCurlyToken = exports.CSSParserToken = exports.CDOToken = exports.CDCToken = exports.BadURLToken = exports.BadStringToken = exports.AtKeywordToken = void 0;\nexports.tokenize = tokenize;\n/* eslint-disable notice/notice */\n\n/*\n * The code in this file is licensed under the CC0 license.\n * http://creativecommons.org/publicdomain/zero/1.0/\n * It is free to use for any purpose. No attribution, permission, or reproduction of this license is required.\n */\n\n// Original at https://github.com/tabatkins/parse-css\n// Changes:\n//   - JS is replaced with TS.\n//   - Universal Module Definition wrapper is removed.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n\nconst between = function (num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 0x30, 0x39);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66);\n}\nfunction uppercaseletter(code) {\n  return between(code, 0x41, 0x5a);\n}\nfunction lowercaseletter(code) {\n  return between(code, 0x61, 0x7a);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 0x80;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 0x5f;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 0x2d;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 0xb || between(code, 0xe, 0x1f) || code === 0x7f;\n}\nfunction newline(code) {\n  return code === 0xa;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 0x20;\n}\nconst maximumallowedcodepoint = 0x10ffff;\nclass InvalidCharacterError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidCharacterError';\n  }\n}\nexports.InvalidCharacterError = InvalidCharacterError;\nfunction preprocess(str) {\n  // Turn a string into an array of code points,\n  // following the preprocessing cleanup rules.\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 0xd && str.charCodeAt(i + 1) === 0xa) {\n      code = 0xa;\n      i++;\n    }\n    if (code === 0xd || code === 0xc) code = 0xa;\n    if (code === 0x0) code = 0xfffd;\n    if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n      // Decode a surrogate pair into an astral codepoint.\n      const lead = code - 0xd800;\n      const trail = str.charCodeAt(i + 1) - 0xdc00;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  // Otherwise, encode astral char as surrogate pair.\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n  const trail = code % Math.pow(2, 10) + 0xdc00;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n\n  // Line number information.\n  let line = 0;\n  let column = 0;\n  // The only use of lastLineLength is in reconsume().\n  let lastLineLength = 0;\n  const incrLineno = function () {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = {\n    line: line,\n    column: column\n  };\n  const codepoint = function (i) {\n    if (i >= str.length) return -1;\n    return str[i];\n  };\n  const next = function (num) {\n    if (num === undefined) num = 1;\n    if (num > 3) throw 'Spec Error: no more than three codepoints of lookahead.';\n    return codepoint(i + num);\n  };\n  const consume = function (num) {\n    if (num === undefined) num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code)) incrLineno();else column += num;\n    // console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n    return true;\n  };\n  const reconsume = function () {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function (codepoint) {\n    if (codepoint === undefined) codepoint = code;\n    return codepoint === -1;\n  };\n  const donothing = function () {};\n  const parseerror = function () {\n    // Language bindings don't like writing to stdout!\n    // console.log('Parse error at index ' + i + ', processing codepoint 0x' + code.toString(16) + '.'); return true;\n  };\n  const consumeAToken = function () {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next())) consume();\n      return new WhitespaceToken();\n    } else if (code === 0x22) {\n      return consumeAStringToken();\n    } else if (code === 0x23) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken('');\n        if (wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = 'id';\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x24) {\n      if (next() === 0x3d) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x27) {\n      return consumeAStringToken();\n    } else if (code === 0x28) {\n      return new OpenParenToken();\n    } else if (code === 0x29) {\n      return new CloseParenToken();\n    } else if (code === 0x2a) {\n      if (next() === 0x3d) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x2b) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x2c) {\n      return new CommaToken();\n    } else if (code === 0x2d) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 0x2d && next(2) === 0x3e) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x2e) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x3a) {\n      return new ColonToken();\n    } else if (code === 0x3b) {\n      return new SemicolonToken();\n    } else if (code === 0x3c) {\n      if (next(1) === 0x21 && next(2) === 0x2d && next(3) === 0x2d) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x40) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3))) return new AtKeywordToken(consumeAName());else return new DelimToken(code);\n    } else if (code === 0x5b) {\n      return new OpenSquareToken();\n    } else if (code === 0x5c) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 0x5d) {\n      return new CloseSquareToken();\n    } else if (code === 0x5e) {\n      if (next() === 0x3d) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x7b) {\n      return new OpenCurlyToken();\n    } else if (code === 0x7c) {\n      if (next() === 0x3d) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 0x7c) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 0x7d) {\n      return new CloseCurlyToken();\n    } else if (code === 0x7e) {\n      if (next() === 0x3d) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function () {\n    while (next(1) === 0x2f && next(2) === 0x2a) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 0x2a && next() === 0x2f) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function () {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 0x25) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function () {\n    const str = consumeAName();\n    if (str.toLowerCase() === 'url' && next() === 0x28) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2))) consume();\n      if (next() === 0x22 || next() === 0x27) return new FunctionToken(str);else if (whitespace(next()) && (next(2) === 0x22 || next(2) === 0x27)) return new FunctionToken(str);else return consumeAURLToken();\n    } else if (next() === 0x28) {\n      consume();\n      return new FunctionToken(str);\n    } else {\n      return new IdentToken(str);\n    }\n  };\n  const consumeAStringToken = function (endingCodePoint) {\n    if (endingCodePoint === undefined) endingCodePoint = code;\n    let string = '';\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 0x5c) {\n        if (eof(next())) donothing();else if (newline(next())) consume();else string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error('Internal error');\n  };\n  const consumeAURLToken = function () {\n    const token = new URLToken('');\n    while (whitespace(next())) consume();\n    if (eof(next())) return token;\n    while (consume()) {\n      if (code === 0x29 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next())) consume();\n        if (next() === 0x29 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 0x22 || code === 0x27 || code === 0x28 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 0x5c) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error('Internal error');\n  };\n  const consumeEscape = function () {\n    // Assume the the current character is the \\\n    // and the next code point is not a newline.\n    consume();\n    if (hexdigit(code)) {\n      // Consume 1-6 hex digits\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next())) consume();\n      let value = parseInt(digits.map(function (x) {\n        return String.fromCharCode(x);\n      }).join(''), 16);\n      if (value > maximumallowedcodepoint) value = 0xfffd;\n      return value;\n    } else if (eof()) {\n      return 0xfffd;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function (c1, c2) {\n    if (c1 !== 0x5c) return false;\n    if (newline(c2)) return false;\n    return true;\n  };\n  const startsWithAValidEscape = function () {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function (c1, c2, c3) {\n    if (c1 === 0x2d) return namestartchar(c2) || c2 === 0x2d || areAValidEscape(c2, c3);else if (namestartchar(c1)) return true;else if (c1 === 0x5c) return areAValidEscape(c1, c2);else return false;\n  };\n  const startsWithAnIdentifier = function () {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function (c1, c2, c3) {\n    if (c1 === 0x2b || c1 === 0x2d) {\n      if (digit(c2)) return true;\n      if (c2 === 0x2e && digit(c3)) return true;\n      return false;\n    } else if (c1 === 0x2e) {\n      if (digit(c2)) return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function () {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function () {\n    let result = '';\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error('Internal parse error');\n  };\n  const consumeANumber = function () {\n    let repr = '';\n    let type = 'integer';\n    if (next() === 0x2b || next() === 0x2d) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 0x2e && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = 'number';\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1),\n      c2 = next(2),\n      c3 = next(3);\n    if ((c1 === 0x45 || c1 === 0x65) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = 'number';\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 0x45 || c1 === 0x65) && (c2 === 0x2b || c2 === 0x2d) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = 'number';\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return {\n      type: type,\n      value: value,\n      repr: repr\n    };\n  };\n  const convertAStringToANumber = function (string) {\n    // CSS's number rules are identical to JS, afaik.\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function () {\n    while (consume()) {\n      if (code === 0x29 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2) throw new Error(\"I'm infinite-looping!\");\n  }\n  return tokens;\n}\nclass CSSParserToken {\n  constructor() {\n    this.tokenType = '';\n    this.value = void 0;\n  }\n  toJSON() {\n    return {\n      token: this.tokenType\n    };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return '' + this;\n  }\n}\nexports.CSSParserToken = CSSParserToken;\nclass BadStringToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = 'BADSTRING';\n  }\n}\nexports.BadStringToken = BadStringToken;\nclass BadURLToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = 'BADURL';\n  }\n}\nexports.BadURLToken = BadURLToken;\nclass WhitespaceToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = 'WHITESPACE';\n  }\n  toString() {\n    return 'WS';\n  }\n  toSource() {\n    return ' ';\n  }\n}\nexports.WhitespaceToken = WhitespaceToken;\nclass CDOToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = 'CDO';\n  }\n  toSource() {\n    return '<!--';\n  }\n}\nexports.CDOToken = CDOToken;\nclass CDCToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = 'CDC';\n  }\n  toSource() {\n    return '-->';\n  }\n}\nexports.CDCToken = CDCToken;\nclass ColonToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = ':';\n  }\n}\nexports.ColonToken = ColonToken;\nclass SemicolonToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = ';';\n  }\n}\nexports.SemicolonToken = SemicolonToken;\nclass CommaToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = ',';\n  }\n}\nexports.CommaToken = CommaToken;\nclass GroupingToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.value = '';\n    this.mirror = '';\n  }\n}\nexports.GroupingToken = GroupingToken;\nclass OpenCurlyToken extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = '{';\n    this.value = '{';\n    this.mirror = '}';\n  }\n}\nexports.OpenCurlyToken = OpenCurlyToken;\nclass CloseCurlyToken extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = '}';\n    this.value = '}';\n    this.mirror = '{';\n  }\n}\nexports.CloseCurlyToken = CloseCurlyToken;\nclass OpenSquareToken extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = '[';\n    this.value = '[';\n    this.mirror = ']';\n  }\n}\nexports.OpenSquareToken = OpenSquareToken;\nclass CloseSquareToken extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ']';\n    this.value = ']';\n    this.mirror = '[';\n  }\n}\nexports.CloseSquareToken = CloseSquareToken;\nclass OpenParenToken extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = '(';\n    this.value = '(';\n    this.mirror = ')';\n  }\n}\nexports.OpenParenToken = OpenParenToken;\nclass CloseParenToken extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ')';\n    this.value = ')';\n    this.mirror = '(';\n  }\n}\nexports.CloseParenToken = CloseParenToken;\nclass IncludeMatchToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = '~=';\n  }\n}\nexports.IncludeMatchToken = IncludeMatchToken;\nclass DashMatchToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = '|=';\n  }\n}\nexports.DashMatchToken = DashMatchToken;\nclass PrefixMatchToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = '^=';\n  }\n}\nexports.PrefixMatchToken = PrefixMatchToken;\nclass SuffixMatchToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = '$=';\n  }\n}\nexports.SuffixMatchToken = SuffixMatchToken;\nclass SubstringMatchToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = '*=';\n  }\n}\nexports.SubstringMatchToken = SubstringMatchToken;\nclass ColumnToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = '||';\n  }\n}\nexports.ColumnToken = ColumnToken;\nclass EOFToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.tokenType = 'EOF';\n  }\n  toSource() {\n    return '';\n  }\n}\nexports.EOFToken = EOFToken;\nclass DelimToken extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = 'DELIM';\n    this.value = '';\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return 'DELIM(' + this.value + ')';\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === '\\\\') return '\\\\\\n';else return this.value;\n  }\n}\nexports.DelimToken = DelimToken;\nclass StringValuedToken extends CSSParserToken {\n  constructor(...args) {\n    super(...args);\n    this.value = '';\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n}\nexports.StringValuedToken = StringValuedToken;\nclass IdentToken extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = 'IDENT';\n    this.value = val;\n  }\n  toString() {\n    return 'IDENT(' + this.value + ')';\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n}\nexports.IdentToken = IdentToken;\nclass FunctionToken extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = 'FUNCTION';\n    this.mirror = void 0;\n    this.value = val;\n    this.mirror = ')';\n  }\n  toString() {\n    return 'FUNCTION(' + this.value + ')';\n  }\n  toSource() {\n    return escapeIdent(this.value) + '(';\n  }\n}\nexports.FunctionToken = FunctionToken;\nclass AtKeywordToken extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = 'AT-KEYWORD';\n    this.value = val;\n  }\n  toString() {\n    return 'AT(' + this.value + ')';\n  }\n  toSource() {\n    return '@' + escapeIdent(this.value);\n  }\n}\nexports.AtKeywordToken = AtKeywordToken;\nclass HashToken extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = 'HASH';\n    this.type = void 0;\n    this.value = val;\n    this.type = 'unrestricted';\n  }\n  toString() {\n    return 'HASH(' + this.value + ')';\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === 'id') return '#' + escapeIdent(this.value);else return '#' + escapeHash(this.value);\n  }\n}\nexports.HashToken = HashToken;\nclass StringToken extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = 'STRING';\n    this.value = val;\n  }\n  toString() {\n    return '\"' + escapeString(this.value) + '\"';\n  }\n}\nexports.StringToken = StringToken;\nclass URLToken extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = 'URL';\n    this.value = val;\n  }\n  toString() {\n    return 'URL(' + this.value + ')';\n  }\n  toSource() {\n    return 'url(\"' + escapeString(this.value) + '\")';\n  }\n}\nexports.URLToken = URLToken;\nclass NumberToken extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = 'NUMBER';\n    this.type = void 0;\n    this.repr = void 0;\n    this.type = 'integer';\n    this.repr = '';\n  }\n  toString() {\n    if (this.type === 'integer') return 'INT(' + this.value + ')';\n    return 'NUMBER(' + this.value + ')';\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n}\nexports.NumberToken = NumberToken;\nclass PercentageToken extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = 'PERCENTAGE';\n    this.repr = void 0;\n    this.repr = '';\n  }\n  toString() {\n    return 'PERCENTAGE(' + this.value + ')';\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + '%';\n  }\n}\nexports.PercentageToken = PercentageToken;\nclass DimensionToken extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = 'DIMENSION';\n    this.type = void 0;\n    this.repr = void 0;\n    this.unit = void 0;\n    this.type = 'integer';\n    this.repr = '';\n    this.unit = '';\n  }\n  toString() {\n    return 'DIM(' + this.value + ',' + this.unit + ')';\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === 'e' && (unit[1] === '-' || between(unit.charCodeAt(1), 0x30, 0x39))) {\n      // Unit is ambiguous with scinot\n      // Remove the leading \"e\", replace with escape.\n      unit = '\\\\65 ' + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n}\nexports.DimensionToken = DimensionToken;\nfunction escapeIdent(string) {\n  string = '' + string;\n  let result = '';\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0x0) throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n    if (between(code, 0x1, 0x1f) || code === 0x7f || i === 0 && between(code, 0x30, 0x39) || i === 1 && between(code, 0x30, 0x39) && firstcode === 0x2d) result += '\\\\' + code.toString(16) + ' ';else if (code >= 0x80 || code === 0x2d || code === 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) result += string[i];else result += '\\\\' + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  // Escapes the contents of \"unrestricted\"-type hash tokens.\n  // Won't preserve the ID-ness of \"id\"-type hash tokens;\n  // use escapeIdent() for that.\n  string = '' + string;\n  let result = '';\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0x0) throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n    if (code >= 0x80 || code === 0x2d || code === 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) result += string[i];else result += '\\\\' + code.toString(16) + ' ';\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = '' + string;\n  let result = '';\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0x0) throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n    if (between(code, 0x1, 0x1f) || code === 0x7f) result += '\\\\' + code.toString(16) + ' ';else if (code === 0x22 || code === 0x5c) result += '\\\\' + string[i];else result += string[i];\n  }\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PythonLocatorFactory = exports.JavaScriptLocatorFactory = exports.JavaLocatorFactory = exports.CSharpLocatorFactory = void 0;\nexports.asLocator = asLocator;\nexports.isRegExp = isRegExp;\nvar _stringUtils = require(\"../../utils/isomorphic/stringUtils\");\nvar _selectorParser = require(\"../isomorphic/selectorParser\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction asLocator(lang, selector, isFrameLocator = false) {\n  return innerAsLocator(generators[lang], (0, _selectorParser.parseSelector)(selector), isFrameLocator);\n}\nfunction innerAsLocator(factory, parsed, isFrameLocator = false) {\n  const parts = [...parsed.parts];\n  // frameLocator('iframe').first is actually \"iframe >> nth=0 >> internal:control=enter-frame\"\n  // To make it easier to parse, we turn it into \"iframe >> internal:control=enter-frame >> nth=0\"\n  for (let index = 0; index < parts.length - 1; index++) {\n    if (parts[index].name === 'nth' && parts[index + 1].name === 'internal:control' && parts[index + 1].body === 'enter-frame') {\n      // Swap nth and enter-frame.\n      const [nth] = parts.splice(index, 1);\n      parts.splice(index + 1, 0, nth);\n    }\n  }\n  const tokens = [];\n  let nextBase = isFrameLocator ? 'frame-locator' : 'page';\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = 'locator';\n    if (part.name === 'nth') {\n      if (part.body === '0') tokens.push(factory.generateLocator(base, 'first', ''));else if (part.body === '-1') tokens.push(factory.generateLocator(base, 'last', ''));else tokens.push(factory.generateLocator(base, 'nth', part.body));\n      continue;\n    }\n    if (part.name === 'internal:text') {\n      const {\n        exact,\n        text\n      } = detectExact(part.body);\n      tokens.push(factory.generateLocator(base, 'text', text, {\n        exact\n      }));\n      continue;\n    }\n    if (part.name === 'internal:has-text') {\n      const {\n        exact,\n        text\n      } = detectExact(part.body);\n      tokens.push(factory.generateLocator(base, 'has-text', text, {\n        exact\n      }));\n      continue;\n    }\n    if (part.name === 'internal:has') {\n      const inner = innerAsLocator(factory, part.body.parsed);\n      tokens.push(factory.generateLocator(base, 'has', inner));\n      continue;\n    }\n    if (part.name === 'internal:label') {\n      const {\n        exact,\n        text\n      } = detectExact(part.body);\n      tokens.push(factory.generateLocator(base, 'label', text, {\n        exact\n      }));\n      continue;\n    }\n    if (part.name === 'internal:role') {\n      const attrSelector = (0, _selectorParser.parseAttributeSelector)(part.body, true);\n      const options = {\n        attrs: []\n      };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === 'name') {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === 'level' && typeof attr.value === 'string') attr.value = +attr.value;\n          options.attrs.push({\n            name: attr.name === 'include-hidden' ? 'includeHidden' : attr.name,\n            value: attr.value\n          });\n        }\n      }\n      tokens.push(factory.generateLocator(base, 'role', attrSelector.name, options));\n      continue;\n    }\n    if (part.name === 'internal:testid') {\n      const attrSelector = (0, _selectorParser.parseAttributeSelector)(part.body, true);\n      const {\n        value\n      } = attrSelector.attributes[0];\n      tokens.push(factory.generateLocator(base, 'test-id', value));\n      continue;\n    }\n    if (part.name === 'internal:attr') {\n      const attrSelector = (0, _selectorParser.parseAttributeSelector)(part.body, true);\n      const {\n        name,\n        value,\n        caseSensitive\n      } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === 'placeholder') {\n        tokens.push(factory.generateLocator(base, 'placeholder', text, {\n          exact\n        }));\n        continue;\n      }\n      if (name === 'alt') {\n        tokens.push(factory.generateLocator(base, 'alt', text, {\n          exact\n        }));\n        continue;\n      }\n      if (name === 'title') {\n        tokens.push(factory.generateLocator(base, 'title', text, {\n          exact\n        }));\n        continue;\n      }\n    }\n    let locatorType = 'default';\n    const nextPart = parts[index + 1];\n    if (nextPart && nextPart.name === 'internal:control' && nextPart.body === 'enter-frame') {\n      locatorType = 'frame';\n      nextBase = 'frame-locator';\n      index++;\n    }\n    const p = {\n      parts: [part]\n    };\n    tokens.push(factory.generateLocator(base, locatorType, (0, _selectorParser.stringifySelector)(p)));\n  }\n  return tokens.join('.');\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match) return {\n    text: new RegExp(match[1], match[2])\n  };\n  if (text.endsWith('\"')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith('\"s')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith('\"i')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return {\n    exact,\n    text\n  };\n}\nclass JavaScriptLocatorFactory {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case 'default':\n        return `locator(${this.quote(body)})`;\n      case 'frame':\n        return `frameLocator(${this.quote(body)})`;\n      case 'nth':\n        return `nth(${body})`;\n      case 'first':\n        return `first()`;\n      case 'last':\n        return `last()`;\n      case 'role':\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${options.name}`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact) attrs.push(`exact: true`);\n        }\n        for (const {\n          name,\n          value\n        } of options.attrs) attrs.push(`${name}: ${typeof value === 'string' ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(', ')} }` : '';\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case 'has-text':\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case 'has':\n        return `filter({ has: ${body} })`;\n      case 'test-id':\n        return `getByTestId(${this.quote(body)})`;\n      case 'text':\n        return this.toCallWithExact('getByText', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact('getByAltText', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact('getByPlaceholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact('getByLabel', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact('getByTitle', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body)) return `${method}(${body})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body)) return String(body);\n    return this.quote(body);\n  }\n  quote(text) {\n    return (0, _stringUtils.escapeWithQuotes)(text, '\\'');\n  }\n}\nexports.JavaScriptLocatorFactory = JavaScriptLocatorFactory;\nclass PythonLocatorFactory {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case 'default':\n        return `locator(${this.quote(body)})`;\n      case 'frame':\n        return `frame_locator(${this.quote(body)})`;\n      case 'nth':\n        return `nth(${body})`;\n      case 'first':\n        return `first`;\n      case 'last':\n        return `last`;\n      case 'role':\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact) attrs.push(`exact=True`);\n        }\n        for (const {\n          name,\n          value\n        } of options.attrs) {\n          let valueString = typeof value === 'string' ? this.quote(value) : value;\n          if (typeof value === 'boolean') valueString = value ? 'True' : 'False';\n          attrs.push(`${(0, _stringUtils.toSnakeCase)(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(', ')}` : '';\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case 'has-text':\n        return `filter(has_text=${this.toHasText(body)})`;\n      case 'has':\n        return `filter(has=${body})`;\n      case 'test-id':\n        return `get_by_test_id(${this.quote(body)})`;\n      case 'text':\n        return this.toCallWithExact('get_by_text', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact('get_by_alt_text', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact('get_by_placeholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact('get_by_label', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact('get_by_title', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes('i') ? ', re.IGNORECASE' : '';\n    return `re.compile(r\"${body.source.replace(/\\\\\\//, '/').replace(/\"/g, '\\\\\"')}\"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body)) return `${method}(${this.regexToString(body)})`;\n    if (exact) return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body)) return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  quote(text) {\n    return (0, _stringUtils.escapeWithQuotes)(text, '\\\"');\n  }\n}\nexports.PythonLocatorFactory = PythonLocatorFactory;\nclass JavaLocatorFactory {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case 'page':\n        clazz = 'Page';\n        break;\n      case 'frame-locator':\n        clazz = 'FrameLocator';\n        break;\n      case 'locator':\n        clazz = 'Locator';\n        break;\n    }\n    switch (kind) {\n      case 'default':\n        return `locator(${this.quote(body)})`;\n      case 'frame':\n        return `frameLocator(${this.quote(body)})`;\n      case 'nth':\n        return `nth(${body})`;\n      case 'first':\n        return `first()`;\n      case 'last':\n        return `last()`;\n      case 'role':\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact) attrs.push(`.setExact(true)`);\n        }\n        for (const {\n          name,\n          value\n        } of options.attrs) attrs.push(`.set${(0, _stringUtils.toTitleCase)(name)}(${typeof value === 'string' ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join('')}` : '';\n        return `getByRole(AriaRole.${(0, _stringUtils.toSnakeCase)(body).toUpperCase()}${attrString})`;\n      case 'has-text':\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case 'has':\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case 'test-id':\n        return `getByTestId(${this.quote(body)})`;\n      case 'text':\n        return this.toCallWithExact(clazz, 'getByText', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact(clazz, 'getByAltText', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact(clazz, 'getByPlaceholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact(clazz, 'getByLabel', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact(clazz, 'getByTitle', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes('i') ? ', Pattern.CASE_INSENSITIVE' : '';\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body)) return `${method}(${this.regexToString(body)})`;\n    if (exact) return `${method}(${this.quote(body)}, new ${clazz}.${(0, _stringUtils.toTitleCase)(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body)) return this.regexToString(body);\n    return this.quote(body);\n  }\n  quote(text) {\n    return (0, _stringUtils.escapeWithQuotes)(text, '\\\"');\n  }\n}\nexports.JavaLocatorFactory = JavaLocatorFactory;\nclass CSharpLocatorFactory {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case 'default':\n        return `Locator(${this.quote(body)})`;\n      case 'frame':\n        return `FrameLocator(${this.quote(body)})`;\n      case 'nth':\n        return `Nth(${body})`;\n      case 'first':\n        return `First`;\n      case 'last':\n        return `Last`;\n      case 'role':\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact) attrs.push(`Exact = true`);\n        }\n        for (const {\n          name,\n          value\n        } of options.attrs) attrs.push(`${(0, _stringUtils.toTitleCase)(name)} = ${typeof value === 'string' ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(', ')} }` : '';\n        return `GetByRole(AriaRole.${(0, _stringUtils.toTitleCase)(body)}${attrString})`;\n      case 'has-text':\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case 'has':\n        return `Filter(new() { Has = ${body} })`;\n      case 'test-id':\n        return `GetByTestId(${this.quote(body)})`;\n      case 'text':\n        return this.toCallWithExact('GetByText', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact('GetByAltText', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact('GetByPlaceholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact('GetByLabel', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact('GetByTitle', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes('i') ? ', RegexOptions.IgnoreCase' : '';\n    return `new Regex(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body)) return `${method}(${this.regexToString(body)})`;\n    if (exact) return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body)) return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return (0, _stringUtils.escapeWithQuotes)(text, '\\\"');\n  }\n}\nexports.CSharpLocatorFactory = CSharpLocatorFactory;\nconst generators = {\n  javascript: new JavaScriptLocatorFactory(),\n  python: new PythonLocatorFactory(),\n  java: new JavaLocatorFactory(),\n  csharp: new CSharpLocatorFactory()\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.locatorOrSelectorAsSelector = locatorOrSelectorAsSelector;\nvar _stringUtils = require(\"../../utils/isomorphic/stringUtils\");\nvar _locatorGenerators = require(\"./locatorGenerators\");\nvar _selectorParser = require(\"./selectorParser\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction parseLocator(locator, testIdAttributeName) {\n  locator = locator.replace(/AriaRole\\s*\\.\\s*([\\w]+)/g, (_, group) => group.toLowerCase()).replace(/(get_by_role|getByRole)\\s*\\(\\s*(?:[\"'`])([^'\"`]+)['\"`]/g, (_, group1, group2) => `${group1}(${group2.toLowerCase()}`);\n  const params = [];\n  let template = '';\n  for (let i = 0; i < locator.length; ++i) {\n    const quote = locator[i];\n    if (quote !== '\"' && quote !== '\\'' && quote !== '`' && quote !== '/') {\n      template += quote;\n      continue;\n    }\n    const isRegexEscaping = locator[i - 1] === 'r' || locator[i] === '/';\n    ++i;\n    let text = '';\n    while (i < locator.length) {\n      if (locator[i] === '\\\\') {\n        if (isRegexEscaping) {\n          if (locator[i + 1] !== quote) text += locator[i];\n          ++i;\n          text += locator[i];\n        } else {\n          ++i;\n          if (locator[i] === 'n') text += '\\n';else if (locator[i] === 'r') text += '\\r';else if (locator[i] === 't') text += '\\t';else text += locator[i];\n        }\n        ++i;\n        continue;\n      }\n      if (locator[i] !== quote) {\n        text += locator[i++];\n        continue;\n      }\n      break;\n    }\n    params.push({\n      quote,\n      text\n    });\n    template += (quote === '/' ? 'r' : '') + '$' + params.length;\n  }\n\n  // Equalize languages.\n  template = template.toLowerCase().replace(/get_by_alt_text/g, 'getbyalttext').replace(/get_by_test_id/g, 'getbytestid').replace(/get_by_([\\w]+)/g, 'getby$1').replace(/has_text/g, 'hastext').replace(/frame_locator/g, 'framelocator').replace(/[{}\\s]/g, '').replace(/new\\(\\)/g, '').replace(/new[\\w]+\\.[\\w]+options\\(\\)/g, '').replace(/\\.set([\\w]+)\\(([^)]+)\\)/g, (_, group1, group2) => ',' + group1.toLowerCase() + '=' + group2.toLowerCase()).replace(/:/g, '=').replace(/,re\\.ignorecase/g, 'i').replace(/,pattern.case_insensitive/g, 'i').replace(/,regexoptions.ignorecase/g, 'i').replace(/re.compile\\(([^)]+)\\)/g, '$1') // Python has regex strings as r\"foo\"\n  .replace(/pattern.compile\\(([^)]+)\\)/g, 'r$1').replace(/newregex\\(([^)]+)\\)/g, 'r$1').replace(/string=/g, '=').replace(/regex=/g, '=').replace(/,,/g, ',');\n  return transform(template, params, testIdAttributeName);\n}\nfunction countParams(template) {\n  return [...template.matchAll(/\\$\\d+/g)].length;\n}\nfunction shiftParams(template, sub) {\n  return template.replace(/\\$(\\d+)/g, (_, ordinal) => `$${ordinal - sub}`);\n}\nfunction transform(template, params, testIdAttributeName) {\n  // Recursively handle filter(has=).\n  while (true) {\n    const hasMatch = template.match(/filter\\(,?has=/);\n    if (!hasMatch) break;\n\n    // Extract inner locator based on balanced parens.\n    const start = hasMatch.index + hasMatch[0].length;\n    let balance = 0;\n    let end = start;\n    for (; end < template.length; end++) {\n      if (template[end] === '(') balance++;else if (template[end] === ')') balance--;\n      if (balance < 0) break;\n    }\n    const paramsCountBeforeHas = countParams(template.substring(0, start));\n    const hasTemplate = shiftParams(template.substring(start, end), paramsCountBeforeHas);\n    const paramsCountInHas = countParams(hasTemplate);\n    const hasParams = params.slice(paramsCountBeforeHas, paramsCountBeforeHas + paramsCountInHas);\n    const hasSelector = JSON.stringify(transform(hasTemplate, hasParams, testIdAttributeName));\n\n    // Replace filter(has=...) with filter(has2=$5). Use has2 to avoid matching the same filter again.\n    template = template.substring(0, start - 1) + `2=$${paramsCountBeforeHas + 1}` + shiftParams(template.substring(end), paramsCountInHas - 1);\n\n    // Replace inner params with $5 value.\n    const paramsBeforeHas = params.slice(0, paramsCountBeforeHas);\n    const paramsAfterHas = params.slice(paramsCountBeforeHas + paramsCountInHas);\n    params = paramsBeforeHas.concat([{\n      quote: '\"',\n      text: hasSelector\n    }]).concat(paramsAfterHas);\n  }\n\n  // Transform to selector engines.\n  template = template.replace(/framelocator\\(([^)]+)\\)/g, '$1.internal:control=enter-frame').replace(/locator\\(([^)]+)\\)/g, '$1').replace(/getbyrole\\(([^)]+)\\)/g, 'internal:role=$1').replace(/getbytext\\(([^)]+)\\)/g, 'internal:text=$1').replace(/getbylabel\\(([^)]+)\\)/g, 'internal:label=$1').replace(/getbytestid\\(([^)]+)\\)/g, `internal:testid=[${testIdAttributeName}=$1s]`).replace(/getby(placeholder|alt|title)(?:text)?\\(([^)]+)\\)/g, 'internal:attr=[$1=$2]').replace(/first(\\(\\))?/g, 'nth=0').replace(/last(\\(\\))?/g, 'nth=-1').replace(/nth\\(([^)]+)\\)/g, 'nth=$1').replace(/filter\\(,?hastext=([^)]+)\\)/g, 'internal:has-text=$1').replace(/filter\\(,?has2=([^)]+)\\)/g, 'internal:has=$1').replace(/,exact=false/g, '').replace(/,exact=true/g, 's').replace(/\\,/g, '][');\n  const parts = template.split('.');\n  // Turn \"internal:control=enter-frame >> nth=0\" into \"nth=0 >> internal:control=enter-frame\"\n  // because these are swapped in locators vs selectors.\n  for (let index = 0; index < parts.length - 1; index++) {\n    if (parts[index] === 'internal:control=enter-frame' && parts[index + 1].startsWith('nth=')) {\n      // Swap nth and enter-frame.\n      const [nth] = parts.splice(index, 1);\n      parts.splice(index + 1, 0, nth);\n    }\n  }\n\n  // Substitute params.\n  return parts.map(t => {\n    if (!t.startsWith('internal:') || t === 'internal:control') return t.replace(/\\$(\\d+)/g, (_, ordinal) => {\n      const param = params[+ordinal - 1];\n      return param.text;\n    });\n    t = t.includes('[') ? t.replace(/\\]/, '') + ']' : t;\n    t = t.replace(/(?:r)\\$(\\d+)(i)?/g, (_, ordinal, suffix) => {\n      const param = params[+ordinal - 1];\n      if (t.startsWith('internal:attr') || t.startsWith('internal:testid') || t.startsWith('internal:role')) return new RegExp(param.text) + (suffix || '');\n      return (0, _stringUtils.escapeForTextSelector)(new RegExp(param.text, suffix), false);\n    }).replace(/\\$(\\d+)(i|s)?/g, (_, ordinal, suffix) => {\n      const param = params[+ordinal - 1];\n      if (t.startsWith('internal:has=')) return param.text;\n      if (t.startsWith('internal:attr') || t.startsWith('internal:testid') || t.startsWith('internal:role')) return (0, _stringUtils.escapeForAttributeSelector)(param.text, suffix === 's');\n      return (0, _stringUtils.escapeForTextSelector)(param.text, suffix === 's');\n    });\n    return t;\n  }).join(' >> ');\n}\nfunction locatorOrSelectorAsSelector(language, locator, testIdAttributeName) {\n  try {\n    (0, _selectorParser.parseSelector)(locator);\n    return locator;\n  } catch (e) {}\n  try {\n    const selector = parseLocator(locator, testIdAttributeName);\n    if (digestForComparison((0, _locatorGenerators.asLocator)(language, selector)) === digestForComparison(locator)) return selector;\n  } catch (e) {}\n  return '';\n}\nfunction digestForComparison(locator) {\n  return locator.replace(/\\s/g, '').replace(/[\"`]/g, '\\'');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"InvalidSelectorError\", {\n  enumerable: true,\n  get: function () {\n    return _cssParser.InvalidSelectorError;\n  }\n});\nexports.allEngineNames = allEngineNames;\nexports.customCSSNames = void 0;\nObject.defineProperty(exports, \"isInvalidSelectorError\", {\n  enumerable: true,\n  get: function () {\n    return _cssParser.isInvalidSelectorError;\n  }\n});\nexports.parseAttributeSelector = parseAttributeSelector;\nexports.parseSelector = parseSelector;\nexports.splitSelectorByFrame = splitSelectorByFrame;\nexports.stringifySelector = stringifySelector;\nvar _cssParser = require(\"./cssParser\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst kNestedSelectorNames = new Set(['internal:has', 'left-of', 'right-of', 'above', 'below', 'near']);\nconst kNestedSelectorNamesWithDistance = new Set(['left-of', 'right-of', 'above', 'below', 'near']);\nconst customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nexports.customCSSNames = customCSSNames;\nfunction parseSelector(selector) {\n  const result = parseSelectorString(selector);\n  const parts = result.parts.map(part => {\n    if (part.name === 'css' || part.name === 'css:light') {\n      if (part.name === 'css:light') part.body = ':light(' + part.body + ')';\n      const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);\n      return {\n        name: 'css',\n        body: parsedCSS.selector,\n        source: part.body\n      };\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse('[' + part.body + ']');\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== 'string') throw new _cssParser.InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== 'number' || !kNestedSelectorNamesWithDistance.has(part.name)) throw new _cssParser.InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new _cssParser.InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const result = {\n        name: part.name,\n        source: part.body,\n        body: {\n          parsed: parseSelector(innerSelector),\n          distance\n        }\n      };\n      if (result.body.parsed.parts.some(part => part.name === 'internal:control' && part.body === 'enter-frame')) throw new _cssParser.InvalidSelectorError(`Frames are not allowed inside \"${part.name}\" selectors`);\n      return result;\n    }\n    return {\n      ...part,\n      source: part.body\n    };\n  });\n  if (kNestedSelectorNames.has(parts[0].name)) throw new _cssParser.InvalidSelectorError(`\"${parts[0].name}\" selector cannot be first`);\n  return {\n    capture: result.capture,\n    parts\n  };\n}\nfunction splitSelectorByFrame(selectorText) {\n  const selector = parseSelector(selectorText);\n  const result = [];\n  let chunk = {\n    parts: []\n  };\n  let chunkStartIndex = 0;\n  for (let i = 0; i < selector.parts.length; ++i) {\n    const part = selector.parts[i];\n    if (part.name === 'internal:control' && part.body === 'enter-frame') {\n      if (!chunk.parts.length) throw new _cssParser.InvalidSelectorError('Selector cannot start with entering frame, select the iframe first');\n      result.push(chunk);\n      chunk = {\n        parts: []\n      };\n      chunkStartIndex = i + 1;\n      continue;\n    }\n    if (selector.capture === i) chunk.capture = i - chunkStartIndex;\n    chunk.parts.push(part);\n  }\n  if (!chunk.parts.length) throw new _cssParser.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);\n  result.push(chunk);\n  if (typeof selector.capture === 'number' && typeof result[result.length - 1].capture !== 'number') throw new _cssParser.InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);\n  return result;\n}\nfunction stringifySelector(selector) {\n  if (typeof selector === 'string') return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === 'css' ? '' : p.name + '=';\n    return `${i === selector.capture ? '*' : ''}${prefix}${p.source}`;\n  }).join(' >> ');\n}\nfunction allEngineNames(selector) {\n  const result = new Set();\n  const visit = selector => {\n    for (const part of selector.parts) {\n      result.add(part.name);\n      if (kNestedSelectorNames.has(part.name)) visit(part.body.parsed);\n    }\n  };\n  visit(selector);\n  return result;\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = {\n    parts: []\n  };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf('=');\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n      name = 'text';\n      body = part;\n    } else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n      name = 'text';\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n      // If selector starts with '//' or '//' prefixed with multiple opening\n      // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n      // If selector starts with '..', consider xpath as well.\n      name = 'xpath';\n      body = part;\n    } else {\n      name = 'css';\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === '*') {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({\n      name,\n      body\n    });\n    if (capture) {\n      if (result.capture !== undefined) throw new _cssParser.InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes('>>')) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    // Must be a text selector with some text before the quote.\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === '\\\\' && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = undefined;\n      index++;\n    } else if (!quote && (c === '\"' || c === '\\'' || c === '`') && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === '>' && selector[index + 1] === '>') {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || '';\n  const eat1 = () => {\n    const result = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result;\n  };\n  const syntaxError = stage => {\n    if (EOL) throw new _cssParser.InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new _cssParser.InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol \"${next()}\" at position ${wp}` + (stage ? ' during ' + stage : ''));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next())) eat1();\n  }\n  function isCSSNameChar(char) {\n    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n    return char >= '\\u0080' // non-ascii\n    || char >= '\\u0030' && char <= '\\u0039' // digit\n    || char >= '\\u0041' && char <= '\\u005a' // uppercase letter\n    || char >= '\\u0061' && char <= '\\u007a' // lowercase letter\n    || char >= '\\u0030' && char <= '\\u0039' // digit\n    || char === '\\u005f' // \"_\"\n    || char === '\\u002d'; // \"-\"\n  }\n\n  function readIdentifier() {\n    let result = '';\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next())) result += eat1();\n    return result;\n  }\n  function readQuotedString(quote) {\n    let result = eat1();\n    if (result !== quote) syntaxError('parsing quoted string');\n    while (!EOL && next() !== quote) {\n      if (next() === '\\\\') eat1();\n      result += eat1();\n    }\n    if (next() !== quote) syntaxError('parsing quoted string');\n    result += eat1();\n    return result;\n  }\n  function readRegularExpression() {\n    if (eat1() !== '/') syntaxError('parsing regular expression');\n    let source = '';\n    let inClass = false;\n    // https://262.ecma-international.org/11.0/#sec-literals-regular-expression-literals\n    while (!EOL) {\n      if (next() === '\\\\') {\n        source += eat1();\n        if (EOL) syntaxError('parsing regular expressiion');\n      } else if (inClass && next() === ']') {\n        inClass = false;\n      } else if (!inClass && next() === '[') {\n        inClass = true;\n      } else if (!inClass && next() === '/') {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== '/') syntaxError('parsing regular expression');\n    let flags = '';\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n    while (!EOL && next().match(/[dgimsuy]/)) flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new _cssParser.InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = '';\n    skipSpaces();\n    if (next() === `'` || next() === `\"`) token = readQuotedString(next()).slice(1, -1);else token = readIdentifier();\n    if (!token) syntaxError('parsing property path');\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = '';\n    if (!EOL) op += eat1();\n    if (!EOL && op !== '=') op += eat1();\n    if (!['=', '*=', '^=', '$=', '|=', '~='].includes(op)) syntaxError('parsing operator');\n    return op;\n  }\n  function readAttribute() {\n    // skip leading [\n    eat1();\n\n    // read attribute name:\n    // foo.bar\n    // 'foo'  . \"ba zz\"\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === '.') {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    // check property is truthy: [enabled]\n    if (next() === ']') {\n      eat1();\n      return {\n        name: jsonPath.join('.'),\n        jsonPath,\n        op: '<truthy>',\n        value: null,\n        caseSensitive: false\n      };\n    }\n    const operator = readOperator();\n    let value = undefined;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === '/') {\n      if (operator !== '=') throw new _cssParser.InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `'` || next() === `\"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === 'i' || next() === 'I') {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === 's' || next() === 'S') {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = '';\n      while (!EOL && (isCSSNameChar(next()) || next() === '+' || next() === '.')) value += eat1();\n      if (value === 'true') {\n        value = true;\n      } else if (value === 'false') {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value)) syntaxError('parsing attribute value');\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== ']') syntaxError('parsing attribute value');\n    eat1();\n    if (operator !== '=' && typeof value !== 'string') throw new _cssParser.InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return {\n      name: jsonPath.join('.'),\n      jsonPath,\n      op: operator,\n      value,\n      caseSensitive\n    };\n  }\n  const result = {\n    name: '',\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === '[') {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL) syntaxError(undefined);\n  if (!result.name && !result.attributes.length) throw new _cssParser.InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeAsCallArgument = exports.parseEvaluationResultValue = void 0;\nexports.source = source;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction source() {\n  function isRegExp(obj) {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';\n  }\n  function isDate(obj) {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';\n  }\n  function isURL(obj) {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';\n  }\n  function isError(obj) {\n    try {\n      var _Object$getPrototypeO;\n      return obj instanceof Error || obj && ((_Object$getPrototypeO = Object.getPrototypeOf(obj)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.name) === 'Error';\n    } catch (error) {\n      return false;\n    }\n  }\n  function parseEvaluationResultValue(value, handles = [], refs = new Map()) {\n    if (Object.is(value, undefined)) return undefined;\n    if (typeof value === 'object' && value) {\n      if ('ref' in value) return refs.get(value.ref);\n      if ('v' in value) {\n        if (value.v === 'undefined') return undefined;\n        if (value.v === 'null') return null;\n        if (value.v === 'NaN') return NaN;\n        if (value.v === 'Infinity') return Infinity;\n        if (value.v === '-Infinity') return -Infinity;\n        if (value.v === '-0') return -0;\n        return undefined;\n      }\n      if ('d' in value) return new Date(value.d);\n      if ('u' in value) return new URL(value.u);\n      if ('r' in value) return new RegExp(value.r.p, value.r.f);\n      if ('a' in value) {\n        const result = [];\n        refs.set(value.id, result);\n        for (const a of value.a) result.push(parseEvaluationResultValue(a, handles, refs));\n        return result;\n      }\n      if ('o' in value) {\n        const result = {};\n        refs.set(value.id, result);\n        for (const {\n          k,\n          v\n        } of value.o) result[k] = parseEvaluationResultValue(v, handles, refs);\n        return result;\n      }\n      if ('h' in value) return handles[value.h];\n    }\n    return value;\n  }\n  function serializeAsCallArgument(value, handleSerializer) {\n    return serialize(value, handleSerializer, {\n      visited: new Map(),\n      lastId: 0\n    });\n  }\n  function serialize(value, handleSerializer, visitorInfo) {\n    if (value && typeof value === 'object') {\n      if (typeof globalThis.Window === 'function' && value instanceof globalThis.Window) return 'ref: <Window>';\n      if (typeof globalThis.Document === 'function' && value instanceof globalThis.Document) return 'ref: <Document>';\n      if (typeof globalThis.Node === 'function' && value instanceof globalThis.Node) return 'ref: <Node>';\n    }\n    return innerSerialize(value, handleSerializer, visitorInfo);\n  }\n  function innerSerialize(value, handleSerializer, visitorInfo) {\n    const result = handleSerializer(value);\n    if ('fallThrough' in result) value = result.fallThrough;else return result;\n    if (typeof value === 'symbol') return {\n      v: 'undefined'\n    };\n    if (Object.is(value, undefined)) return {\n      v: 'undefined'\n    };\n    if (Object.is(value, null)) return {\n      v: 'null'\n    };\n    if (Object.is(value, NaN)) return {\n      v: 'NaN'\n    };\n    if (Object.is(value, Infinity)) return {\n      v: 'Infinity'\n    };\n    if (Object.is(value, -Infinity)) return {\n      v: '-Infinity'\n    };\n    if (Object.is(value, -0)) return {\n      v: '-0'\n    };\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') return value;\n    if (typeof value === 'string') return value;\n    if (isError(value)) {\n      const error = value;\n      if ('captureStackTrace' in globalThis.Error) {\n        // v8\n        return error.stack || '';\n      }\n      return `${error.name}: ${error.message}\\n${error.stack}`;\n    }\n    if (isDate(value)) return {\n      d: value.toJSON()\n    };\n    if (isURL(value)) return {\n      u: value.toJSON()\n    };\n    if (isRegExp(value)) return {\n      r: {\n        p: value.source,\n        f: value.flags\n      }\n    };\n    const id = visitorInfo.visited.get(value);\n    if (id) return {\n      ref: id\n    };\n    if (Array.isArray(value)) {\n      const a = [];\n      const id = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id);\n      for (let i = 0; i < value.length; ++i) a.push(serialize(value[i], handleSerializer, visitorInfo));\n      return {\n        a,\n        id\n      };\n    }\n    if (typeof value === 'object') {\n      const o = [];\n      const id = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id);\n      for (const name of Object.keys(value)) {\n        let item;\n        try {\n          item = value[name];\n        } catch (e) {\n          continue; // native bindings will throw sometimes\n        }\n\n        if (name === 'toJSON' && typeof item === 'function') o.push({\n          k: name,\n          v: {\n            o: [],\n            id: 0\n          }\n        });else o.push({\n          k: name,\n          v: serialize(item, handleSerializer, visitorInfo)\n        });\n      }\n\n      // If Object.keys().length === 0 we fall back to toJSON if it exists\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === 'function') return innerSerialize(value.toJSON(), handleSerializer, visitorInfo);\n      return {\n        o,\n        id\n      };\n    }\n  }\n  return {\n    parseEvaluationResultValue,\n    serializeAsCallArgument\n  };\n}\nconst result = source();\nconst parseEvaluationResultValue = result.parseEvaluationResultValue;\nexports.parseEvaluationResultValue = parseEvaluationResultValue;\nconst serializeAsCallArgument = result.serializeAsCallArgument;\nexports.serializeAsCallArgument = serializeAsCallArgument;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JavaScriptErrorInEvaluate = exports.JSHandle = exports.ExecutionContext = void 0;\nexports.evaluate = evaluate;\nexports.evaluateExpression = evaluateExpression;\nexports.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;\nexports.isJavaScriptErrorInEvaluate = isJavaScriptErrorInEvaluate;\nexports.normalizeEvaluationExpression = normalizeEvaluationExpression;\nexports.parseUnserializableValue = parseUnserializableValue;\nexports.sparseArrayToString = sparseArrayToString;\nvar utilityScriptSource = _interopRequireWildcard(require(\"../generated/utilityScriptSource\"));\nvar _utilityScriptSerializers = require(\"./isomorphic/utilityScriptSerializers\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ExecutionContext extends _instrumentation.SdkObject {\n  constructor(parent, delegate) {\n    super(parent, 'execution-context');\n    this._delegate = void 0;\n    this._utilityScriptPromise = void 0;\n    this._destroyedPromise = new _manualPromise.ManualPromise();\n    this._delegate = delegate;\n  }\n  contextDestroyed(error) {\n    this._destroyedPromise.resolve(error);\n  }\n  _raceAgainstContextDestroyed(promise) {\n    return Promise.race([this._destroyedPromise.then(e => {\n      throw e;\n    }), promise]);\n  }\n  rawEvaluateJSON(expression) {\n    return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateJSON(expression));\n  }\n  rawEvaluateHandle(expression) {\n    return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(expression));\n  }\n  rawCallFunctionNoReply(func, ...args) {\n    this._delegate.rawCallFunctionNoReply(func, ...args);\n  }\n  evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {\n    return this._raceAgainstContextDestroyed(this._delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds));\n  }\n  getProperties(context, objectId) {\n    return this._raceAgainstContextDestroyed(this._delegate.getProperties(context, objectId));\n  }\n  createHandle(remoteObject) {\n    return this._delegate.createHandle(this, remoteObject);\n  }\n  releaseHandle(objectId) {\n    return this._delegate.releaseHandle(objectId);\n  }\n  async waitForSignalsCreatedBy(action) {\n    return action();\n  }\n  adoptIfNeeded(handle) {\n    return null;\n  }\n  utilityScript() {\n    if (!this._utilityScriptPromise) {\n      const source = `\n      (() => {\n        const module = {};\n        ${utilityScriptSource.source}\n        return new module.exports();\n      })();`;\n      this._utilityScriptPromise = this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(source).then(objectId => new JSHandle(this, 'object', undefined, objectId)));\n    }\n    return this._utilityScriptPromise;\n  }\n  async doSlowMo() {\n    // overridden in FrameExecutionContext\n  }\n}\nexports.ExecutionContext = ExecutionContext;\nclass JSHandle extends _instrumentation.SdkObject {\n  constructor(context, type, preview, objectId, value) {\n    super(context, 'handle');\n    this.__jshandle = true;\n    this._context = void 0;\n    this._disposed = false;\n    this._objectId = void 0;\n    this._value = void 0;\n    this._objectType = void 0;\n    this._preview = void 0;\n    this._previewCallback = void 0;\n    this._context = context;\n    this._objectId = objectId;\n    this._value = value;\n    this._objectType = type;\n    this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);\n  }\n  callFunctionNoReply(func, arg) {\n    this._context.rawCallFunctionNoReply(func, this, arg);\n  }\n  async evaluate(pageFunction, arg) {\n    return evaluate(this._context, true /* returnByValue */, pageFunction, this, arg);\n  }\n  async evaluateHandle(pageFunction, arg) {\n    return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);\n  }\n  async evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {\n    const value = await evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);\n    await this._context.doSlowMo();\n    return value;\n  }\n  async getProperty(propertyName) {\n    const objectHandle = await this.evaluateHandle((object, propertyName) => {\n      const result = {\n        __proto__: null\n      };\n      result[propertyName] = object[propertyName];\n      return result;\n    }, propertyName);\n    const properties = await objectHandle.getProperties();\n    const result = properties.get(propertyName);\n    objectHandle.dispose();\n    return result;\n  }\n  async getProperties() {\n    if (!this._objectId) return new Map();\n    return this._context.getProperties(this._context, this._objectId);\n  }\n  rawValue() {\n    return this._value;\n  }\n  async jsonValue() {\n    if (!this._objectId) return this._value;\n    const utilityScript = await this._context.utilityScript();\n    const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;\n    return this._context.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);\n  }\n  asElement() {\n    return null;\n  }\n  dispose() {\n    if (this._disposed) return;\n    this._disposed = true;\n    if (this._objectId) this._context.releaseHandle(this._objectId).catch(e => {});\n  }\n  toString() {\n    return this._preview;\n  }\n  _setPreviewCallback(callback) {\n    this._previewCallback = callback;\n  }\n  preview() {\n    return this._preview;\n  }\n  _setPreview(preview) {\n    this._preview = preview;\n    if (this._previewCallback) this._previewCallback(preview);\n  }\n}\nexports.JSHandle = JSHandle;\nasync function evaluate(context, returnByValue, pageFunction, ...args) {\n  return evaluateExpression(context, String(pageFunction), {\n    returnByValue,\n    isFunction: typeof pageFunction === 'function'\n  }, ...args);\n}\nasync function evaluateExpression(context, expression, options, ...args) {\n  const utilityScript = await context.utilityScript();\n  expression = normalizeEvaluationExpression(expression, options.isFunction);\n  const handles = [];\n  const toDispose = [];\n  const pushHandle = handle => {\n    handles.push(handle);\n    return handles.length - 1;\n  };\n  args = args.map(arg => (0, _utilityScriptSerializers.serializeAsCallArgument)(arg, handle => {\n    if (handle instanceof JSHandle) {\n      if (!handle._objectId) return {\n        fallThrough: handle._value\n      };\n      if (handle._disposed) throw new Error('JSHandle is disposed!');\n      const adopted = context.adoptIfNeeded(handle);\n      if (adopted === null) return {\n        h: pushHandle(Promise.resolve(handle))\n      };\n      toDispose.push(adopted);\n      return {\n        h: pushHandle(adopted)\n      };\n    }\n    return {\n      fallThrough: handle\n    };\n  }));\n  const utilityScriptObjectIds = [];\n  for (const handle of await Promise.all(handles)) {\n    if (handle._context !== context) throw new Error('JSHandles can be evaluated only in the context they were created!');\n    utilityScriptObjectIds.push(handle._objectId);\n  }\n\n  // See UtilityScript for arguments.\n  const utilityScriptValues = [options.isFunction, options.returnByValue, options.exposeUtilityScript, expression, args.length, ...args];\n  const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;\n  try {\n    return await context.evaluateWithArguments(script, options.returnByValue || false, utilityScript, utilityScriptValues, utilityScriptObjectIds);\n  } finally {\n    toDispose.map(handlePromise => handlePromise.then(handle => handle.dispose()));\n  }\n}\nasync function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {\n  return await context.waitForSignalsCreatedBy(() => evaluateExpression(context, expression, {\n    returnByValue,\n    isFunction\n  }, ...args));\n}\nfunction parseUnserializableValue(unserializableValue) {\n  if (unserializableValue === 'NaN') return NaN;\n  if (unserializableValue === 'Infinity') return Infinity;\n  if (unserializableValue === '-Infinity') return -Infinity;\n  if (unserializableValue === '-0') return -0;\n}\nfunction normalizeEvaluationExpression(expression, isFunction) {\n  expression = expression.trim();\n  if (isFunction) {\n    try {\n      new Function('(' + expression + ')');\n    } catch (e1) {\n      // This means we might have a function shorthand. Try another\n      // time prefixing 'function '.\n      if (expression.startsWith('async ')) expression = 'async function ' + expression.substring('async '.length);else expression = 'function ' + expression;\n      try {\n        new Function('(' + expression + ')');\n      } catch (e2) {\n        // We tried hard to serialize, but there's a weird beast here.\n        throw new Error('Passed function is not well-serializable!');\n      }\n    }\n  }\n  if (/^(async)?\\s*function(\\s|\\()/.test(expression)) expression = '(' + expression + ')';\n  return expression;\n}\n\n// Error inside the expression evaluation as opposed to a protocol error.\nclass JavaScriptErrorInEvaluate extends Error {}\nexports.JavaScriptErrorInEvaluate = JavaScriptErrorInEvaluate;\nfunction isJavaScriptErrorInEvaluate(error) {\n  return error instanceof JavaScriptErrorInEvaluate;\n}\nfunction sparseArrayToString(entries) {\n  const arrayEntries = [];\n  for (const {\n    name,\n    value\n  } of entries) {\n    const index = +name;\n    if (isNaN(index) || index < 0) continue;\n    arrayEntries.push({\n      index,\n      value\n    });\n  }\n  arrayEntries.sort((a, b) => a.index - b.index);\n  let lastIndex = -1;\n  const tokens = [];\n  for (const {\n    index,\n    value\n  } of arrayEntries) {\n    const emptyItems = index - lastIndex - 1;\n    if (emptyItems === 1) tokens.push(`empty`);else if (emptyItems > 1) tokens.push(`empty x ${emptyItems}`);\n    tokens.push(String(value));\n    lastIndex = index;\n  }\n  return '[' + tokens.join(', ') + ']';\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.macEditingCommands = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst macEditingCommands = {\n  'Backspace': 'deleteBackward:',\n  'Enter': 'insertNewline:',\n  'NumpadEnter': 'insertNewline:',\n  'Escape': 'cancelOperation:',\n  'ArrowUp': 'moveUp:',\n  'ArrowDown': 'moveDown:',\n  'ArrowLeft': 'moveLeft:',\n  'ArrowRight': 'moveRight:',\n  'F5': 'complete:',\n  'Delete': 'deleteForward:',\n  'Home': 'scrollToBeginningOfDocument:',\n  'End': 'scrollToEndOfDocument:',\n  'PageUp': 'scrollPageUp:',\n  'PageDown': 'scrollPageDown:',\n  'Shift+Backspace': 'deleteBackward:',\n  'Shift+Enter': 'insertNewline:',\n  'Shift+NumpadEnter': 'insertNewline:',\n  'Shift+Escape': 'cancelOperation:',\n  'Shift+ArrowUp': 'moveUpAndModifySelection:',\n  'Shift+ArrowDown': 'moveDownAndModifySelection:',\n  'Shift+ArrowLeft': 'moveLeftAndModifySelection:',\n  'Shift+ArrowRight': 'moveRightAndModifySelection:',\n  'Shift+F5': 'complete:',\n  'Shift+Delete': 'deleteForward:',\n  'Shift+Home': 'moveToBeginningOfDocumentAndModifySelection:',\n  'Shift+End': 'moveToEndOfDocumentAndModifySelection:',\n  'Shift+PageUp': 'pageUpAndModifySelection:',\n  'Shift+PageDown': 'pageDownAndModifySelection:',\n  'Shift+Numpad5': 'delete:',\n  'Control+Tab': 'selectNextKeyView:',\n  'Control+Enter': 'insertLineBreak:',\n  'Control+NumpadEnter': 'insertLineBreak:',\n  'Control+Quote': 'insertSingleQuoteIgnoringSubstitution:',\n  'Control+KeyA': 'moveToBeginningOfParagraph:',\n  'Control+KeyB': 'moveBackward:',\n  'Control+KeyD': 'deleteForward:',\n  'Control+KeyE': 'moveToEndOfParagraph:',\n  'Control+KeyF': 'moveForward:',\n  'Control+KeyH': 'deleteBackward:',\n  'Control+KeyK': 'deleteToEndOfParagraph:',\n  'Control+KeyL': 'centerSelectionInVisibleArea:',\n  'Control+KeyN': 'moveDown:',\n  'Control+KeyO': ['insertNewlineIgnoringFieldEditor:', 'moveBackward:'],\n  'Control+KeyP': 'moveUp:',\n  'Control+KeyT': 'transpose:',\n  'Control+KeyV': 'pageDown:',\n  'Control+KeyY': 'yank:',\n  'Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',\n  'Control+ArrowUp': 'scrollPageUp:',\n  'Control+ArrowDown': 'scrollPageDown:',\n  'Control+ArrowLeft': 'moveToLeftEndOfLine:',\n  'Control+ArrowRight': 'moveToRightEndOfLine:',\n  'Shift+Control+Enter': 'insertLineBreak:',\n  'Shift+Control+NumpadEnter': 'insertLineBreak:',\n  'Shift+Control+Tab': 'selectPreviousKeyView:',\n  'Shift+Control+Quote': 'insertDoubleQuoteIgnoringSubstitution:',\n  'Shift+Control+KeyA': 'moveToBeginningOfParagraphAndModifySelection:',\n  'Shift+Control+KeyB': 'moveBackwardAndModifySelection:',\n  'Shift+Control+KeyE': 'moveToEndOfParagraphAndModifySelection:',\n  'Shift+Control+KeyF': 'moveForwardAndModifySelection:',\n  'Shift+Control+KeyN': 'moveDownAndModifySelection:',\n  'Shift+Control+KeyP': 'moveUpAndModifySelection:',\n  'Shift+Control+KeyV': 'pageDownAndModifySelection:',\n  'Shift+Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',\n  'Shift+Control+ArrowUp': 'scrollPageUp:',\n  'Shift+Control+ArrowDown': 'scrollPageDown:',\n  'Shift+Control+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',\n  'Shift+Control+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',\n  'Alt+Backspace': 'deleteWordBackward:',\n  'Alt+Enter': 'insertNewlineIgnoringFieldEditor:',\n  'Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',\n  'Alt+Escape': 'complete:',\n  'Alt+ArrowUp': ['moveBackward:', 'moveToBeginningOfParagraph:'],\n  'Alt+ArrowDown': ['moveForward:', 'moveToEndOfParagraph:'],\n  'Alt+ArrowLeft': 'moveWordLeft:',\n  'Alt+ArrowRight': 'moveWordRight:',\n  'Alt+Delete': 'deleteWordForward:',\n  'Alt+PageUp': 'pageUp:',\n  'Alt+PageDown': 'pageDown:',\n  'Shift+Alt+Backspace': 'deleteWordBackward:',\n  'Shift+Alt+Enter': 'insertNewlineIgnoringFieldEditor:',\n  'Shift+Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',\n  'Shift+Alt+Escape': 'complete:',\n  'Shift+Alt+ArrowUp': 'moveParagraphBackwardAndModifySelection:',\n  'Shift+Alt+ArrowDown': 'moveParagraphForwardAndModifySelection:',\n  'Shift+Alt+ArrowLeft': 'moveWordLeftAndModifySelection:',\n  'Shift+Alt+ArrowRight': 'moveWordRightAndModifySelection:',\n  'Shift+Alt+Delete': 'deleteWordForward:',\n  'Shift+Alt+PageUp': 'pageUp:',\n  'Shift+Alt+PageDown': 'pageDown:',\n  'Control+Alt+KeyB': 'moveWordBackward:',\n  'Control+Alt+KeyF': 'moveWordForward:',\n  'Control+Alt+Backspace': 'deleteWordBackward:',\n  'Shift+Control+Alt+KeyB': 'moveWordBackwardAndModifySelection:',\n  'Shift+Control+Alt+KeyF': 'moveWordForwardAndModifySelection:',\n  'Shift+Control+Alt+Backspace': 'deleteWordBackward:',\n  'Meta+NumpadSubtract': 'cancel:',\n  'Meta+Backspace': 'deleteToBeginningOfLine:',\n  'Meta+ArrowUp': 'moveToBeginningOfDocument:',\n  'Meta+ArrowDown': 'moveToEndOfDocument:',\n  'Meta+ArrowLeft': 'moveToLeftEndOfLine:',\n  'Meta+ArrowRight': 'moveToRightEndOfLine:',\n  'Shift+Meta+NumpadSubtract': 'cancel:',\n  'Shift+Meta+Backspace': 'deleteToBeginningOfLine:',\n  'Shift+Meta+ArrowUp': 'moveToBeginningOfDocumentAndModifySelection:',\n  'Shift+Meta+ArrowDown': 'moveToEndOfDocumentAndModifySelection:',\n  'Shift+Meta+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',\n  'Shift+Meta+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',\n  'Meta+KeyA': 'selectAll:',\n  'Meta+KeyC': 'copy:',\n  'Meta+KeyX': 'cut:',\n  'Meta+KeyV': 'paste:',\n  'Meta+KeyZ': 'undo:',\n  'Shift+Meta+KeyZ': 'redo:'\n};\nexports.macEditingCommands = macEditingCommands;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocket = exports.STATUS_TEXTS = exports.Route = exports.Response = exports.Request = void 0;\nexports.filterCookies = filterCookies;\nexports.mergeHeaders = mergeHeaders;\nexports.parsedURL = parsedURL;\nexports.rewriteCookies = rewriteCookies;\nexports.singleHeader = singleHeader;\nexports.stripFragmentFromUrl = stripFragmentFromUrl;\nvar _utils = require(\"../utils\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _fetch = require(\"./fetch\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction filterCookies(cookies, urls) {\n  const parsedURLs = urls.map(s => new URL(s));\n  // Chromiums's cookies are missing sameSite when it is 'None'\n  return cookies.filter(c => {\n    if (!parsedURLs.length) return true;\n    for (const parsedURL of parsedURLs) {\n      let domain = c.domain;\n      if (!domain.startsWith('.')) domain = '.' + domain;\n      if (!('.' + parsedURL.hostname).endsWith(domain)) continue;\n      if (!parsedURL.pathname.startsWith(c.path)) continue;\n      if (parsedURL.protocol !== 'https:' && parsedURL.hostname !== 'localhost' && c.secure) continue;\n      return true;\n    }\n    return false;\n  });\n}\n\n// Rollover to 5-digit year:\n// 253402300799 == Fri, 31 Dec 9999 23:59:59 +0000 (UTC)\n// 253402300800 == Sat,  1 Jan 1000 00:00:00 +0000 (UTC)\nconst kMaxCookieExpiresDateInSeconds = 253402300799;\nfunction rewriteCookies(cookies) {\n  return cookies.map(c => {\n    (0, _utils.assert)(c.url || c.domain && c.path, 'Cookie should have a url or a domain/path pair');\n    (0, _utils.assert)(!(c.url && c.domain), 'Cookie should have either url or domain');\n    (0, _utils.assert)(!(c.url && c.path), 'Cookie should have either url or path');\n    (0, _utils.assert)(!(c.expires && c.expires < 0 && c.expires !== -1), 'Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed');\n    (0, _utils.assert)(!(c.expires && c.expires > 0 && c.expires > kMaxCookieExpiresDateInSeconds), 'Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed');\n    const copy = {\n      ...c\n    };\n    if (copy.url) {\n      (0, _utils.assert)(copy.url !== 'about:blank', `Blank page can not have cookie \"${c.name}\"`);\n      (0, _utils.assert)(!copy.url.startsWith('data:'), `Data URL page can not have cookie \"${c.name}\"`);\n      const url = new URL(copy.url);\n      copy.domain = url.hostname;\n      copy.path = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);\n      copy.secure = url.protocol === 'https:';\n    }\n    return copy;\n  });\n}\nfunction parsedURL(url) {\n  try {\n    return new URL(url);\n  } catch (e) {\n    return null;\n  }\n}\nfunction stripFragmentFromUrl(url) {\n  if (!url.includes('#')) return url;\n  return url.substring(0, url.indexOf('#'));\n}\nclass Request extends _instrumentation.SdkObject {\n  constructor(context, frame, serviceWorker, redirectedFrom, documentId, url, resourceType, method, postData, headers) {\n    super(frame || context, 'request');\n    this._response = null;\n    this._redirectedFrom = void 0;\n    this._redirectedTo = null;\n    this._documentId = void 0;\n    this._isFavicon = void 0;\n    this._failureText = null;\n    this._url = void 0;\n    this._resourceType = void 0;\n    this._method = void 0;\n    this._postData = void 0;\n    this._headers = void 0;\n    this._headersMap = new Map();\n    this._frame = null;\n    this._serviceWorker = null;\n    this._context = void 0;\n    this._rawRequestHeadersPromise = new _manualPromise.ManualPromise();\n    this._waitForResponsePromise = new _manualPromise.ManualPromise();\n    this._responseEndTiming = -1;\n    this._overrides = void 0;\n    (0, _utils.assert)(!url.startsWith('data:'), 'Data urls should not fire requests');\n    this._context = context;\n    this._frame = frame;\n    this._serviceWorker = serviceWorker;\n    this._redirectedFrom = redirectedFrom;\n    if (redirectedFrom) redirectedFrom._redirectedTo = this;\n    this._documentId = documentId;\n    this._url = stripFragmentFromUrl(url);\n    this._resourceType = resourceType;\n    this._method = method;\n    this._postData = postData;\n    this._headers = headers;\n    this._updateHeadersMap();\n    this._isFavicon = url.endsWith('/favicon.ico') || !!(redirectedFrom !== null && redirectedFrom !== void 0 && redirectedFrom._isFavicon);\n  }\n  _setFailureText(failureText) {\n    this._failureText = failureText;\n    this._waitForResponsePromise.resolve(null);\n  }\n  _setOverrides(overrides) {\n    this._overrides = overrides;\n    this._updateHeadersMap();\n  }\n  _updateHeadersMap() {\n    for (const {\n      name,\n      value\n    } of this.headers()) this._headersMap.set(name.toLowerCase(), value);\n  }\n  _hasOverrides() {\n    return !!this._overrides;\n  }\n  url() {\n    var _this$_overrides;\n    return ((_this$_overrides = this._overrides) === null || _this$_overrides === void 0 ? void 0 : _this$_overrides.url) || this._url;\n  }\n  resourceType() {\n    return this._resourceType;\n  }\n  method() {\n    var _this$_overrides2;\n    return ((_this$_overrides2 = this._overrides) === null || _this$_overrides2 === void 0 ? void 0 : _this$_overrides2.method) || this._method;\n  }\n  postDataBuffer() {\n    var _this$_overrides3;\n    return ((_this$_overrides3 = this._overrides) === null || _this$_overrides3 === void 0 ? void 0 : _this$_overrides3.postData) || this._postData;\n  }\n  headers() {\n    var _this$_overrides4;\n    return ((_this$_overrides4 = this._overrides) === null || _this$_overrides4 === void 0 ? void 0 : _this$_overrides4.headers) || this._headers;\n  }\n  headerValue(name) {\n    return this._headersMap.get(name);\n  }\n\n  // \"null\" means no raw headers available - we'll use provisional headers as raw headers.\n  setRawRequestHeaders(headers) {\n    if (!this._rawRequestHeadersPromise.isDone()) this._rawRequestHeadersPromise.resolve(headers || this._headers);\n  }\n  async rawRequestHeaders() {\n    var _this$_overrides5;\n    return ((_this$_overrides5 = this._overrides) === null || _this$_overrides5 === void 0 ? void 0 : _this$_overrides5.headers) || this._rawRequestHeadersPromise;\n  }\n  response() {\n    return this._waitForResponsePromise;\n  }\n  _existingResponse() {\n    return this._response;\n  }\n  _setResponse(response) {\n    this._response = response;\n    this._waitForResponsePromise.resolve(response);\n  }\n  _finalRequest() {\n    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;\n  }\n  frame() {\n    return this._frame;\n  }\n  serviceWorker() {\n    return this._serviceWorker;\n  }\n  isNavigationRequest() {\n    return !!this._documentId;\n  }\n  redirectedFrom() {\n    return this._redirectedFrom;\n  }\n  failure() {\n    if (this._failureText === null) return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n  bodySize() {\n    var _this$postDataBuffer;\n    return ((_this$postDataBuffer = this.postDataBuffer()) === null || _this$postDataBuffer === void 0 ? void 0 : _this$postDataBuffer.length) || 0;\n  }\n  async requestHeadersSize() {\n    let headersSize = 4; // 4 = 2 spaces + 2 line breaks (GET /path \\r\\n)\n    headersSize += this.method().length;\n    headersSize += new URL(this.url()).pathname.length;\n    headersSize += 8; // httpVersion\n    const headers = await this.rawRequestHeaders();\n    for (const header of headers) headersSize += header.name.length + header.value.length + 4; // 4 = ': ' + '\\r\\n'\n    return headersSize;\n  }\n}\nexports.Request = Request;\nclass Route extends _instrumentation.SdkObject {\n  constructor(request, delegate) {\n    super(request._frame || request._context, 'route');\n    this._request = void 0;\n    this._delegate = void 0;\n    this._handled = false;\n    this._request = request;\n    this._delegate = delegate;\n    this._request._context.addRouteInFlight(this);\n  }\n  request() {\n    return this._request;\n  }\n  async abort(errorCode = 'failed') {\n    this._startHandling();\n    await this._delegate.abort(errorCode);\n    this._endHandling();\n  }\n  async redirectNavigationRequest(url) {\n    this._startHandling();\n    (0, _utils.assert)(this._request.isNavigationRequest());\n    this._request.frame().redirectNavigation(url, this._request._documentId, this._request.headerValue('referer'));\n  }\n  async fulfill(overrides) {\n    this._startHandling();\n    let body = overrides.body;\n    let isBase64 = overrides.isBase64 || false;\n    if (body === undefined) {\n      if (overrides.fetchResponseUid) {\n        const buffer = this._request._context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || _fetch.APIRequestContext.findResponseBody(overrides.fetchResponseUid);\n        (0, _utils.assert)(buffer, 'Fetch response has been disposed');\n        body = buffer.toString('base64');\n        isBase64 = true;\n      } else {\n        body = '';\n        isBase64 = false;\n      }\n    }\n    const headers = [...(overrides.headers || [])];\n    this._maybeAddCorsHeaders(headers);\n    await this._delegate.fulfill({\n      status: overrides.status || 200,\n      headers,\n      body,\n      isBase64\n    });\n    this._endHandling();\n  }\n\n  // See https://github.com/microsoft/playwright/issues/12929\n  _maybeAddCorsHeaders(headers) {\n    const origin = this._request.headerValue('origin');\n    if (!origin) return;\n    const requestUrl = new URL(this._request.url());\n    if (!requestUrl.protocol.startsWith('http')) return;\n    if (requestUrl.origin === origin.trim()) return;\n    const corsHeader = headers.find(({\n      name\n    }) => name === 'access-control-allow-origin');\n    if (corsHeader) return;\n    headers.push({\n      name: 'access-control-allow-origin',\n      value: origin\n    });\n    headers.push({\n      name: 'access-control-allow-credentials',\n      value: 'true'\n    });\n    headers.push({\n      name: 'vary',\n      value: 'Origin'\n    });\n  }\n  async continue(overrides = {}) {\n    this._startHandling();\n    if (overrides.url) {\n      const newUrl = new URL(overrides.url);\n      const oldUrl = new URL(this._request.url());\n      if (oldUrl.protocol !== newUrl.protocol) throw new Error('New URL must have same protocol as overridden URL');\n    }\n    this._request._setOverrides(overrides);\n    await this._delegate.continue(this._request, overrides);\n    this._endHandling();\n  }\n  _startHandling() {\n    (0, _utils.assert)(!this._handled, 'Route is already handled!');\n    this._handled = true;\n  }\n  _endHandling() {\n    this._request._context.removeRouteInFlight(this);\n  }\n}\nexports.Route = Route;\nclass Response extends _instrumentation.SdkObject {\n  constructor(request, status, statusText, headers, timing, getResponseBodyCallback, fromServiceWorker, httpVersion) {\n    super(request.frame() || request._context, 'response');\n    this._request = void 0;\n    this._contentPromise = null;\n    this._finishedPromise = new _manualPromise.ManualPromise();\n    this._status = void 0;\n    this._statusText = void 0;\n    this._url = void 0;\n    this._headers = void 0;\n    this._headersMap = new Map();\n    this._getResponseBodyCallback = void 0;\n    this._timing = void 0;\n    this._serverAddrPromise = new _manualPromise.ManualPromise();\n    this._securityDetailsPromise = new _manualPromise.ManualPromise();\n    this._rawResponseHeadersPromise = new _manualPromise.ManualPromise();\n    this._httpVersion = void 0;\n    this._fromServiceWorker = void 0;\n    this._encodedBodySizePromise = new _manualPromise.ManualPromise();\n    this._transferSizePromise = new _manualPromise.ManualPromise();\n    this._responseHeadersSizePromise = new _manualPromise.ManualPromise();\n    this._request = request;\n    this._timing = timing;\n    this._status = status;\n    this._statusText = statusText;\n    this._url = request.url();\n    this._headers = headers;\n    for (const {\n      name,\n      value\n    } of this._headers) this._headersMap.set(name.toLowerCase(), value);\n    this._getResponseBodyCallback = getResponseBodyCallback;\n    this._request._setResponse(this);\n    this._httpVersion = httpVersion;\n    this._fromServiceWorker = fromServiceWorker;\n  }\n  _serverAddrFinished(addr) {\n    this._serverAddrPromise.resolve(addr);\n  }\n  _securityDetailsFinished(securityDetails) {\n    this._securityDetailsPromise.resolve(securityDetails);\n  }\n  _requestFinished(responseEndTiming) {\n    this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);\n    // Set start time equal to end when request is served from memory cache.\n    if (this._timing.requestStart === -1) this._timing.requestStart = this._request._responseEndTiming;\n    this._finishedPromise.resolve();\n  }\n  _setHttpVersion(httpVersion) {\n    this._httpVersion = httpVersion;\n  }\n  url() {\n    return this._url;\n  }\n  status() {\n    return this._status;\n  }\n  statusText() {\n    return this._statusText;\n  }\n  headers() {\n    return this._headers;\n  }\n  headerValue(name) {\n    return this._headersMap.get(name);\n  }\n  async rawResponseHeaders() {\n    return this._rawResponseHeadersPromise;\n  }\n\n  // \"null\" means no raw headers available - we'll use provisional headers as raw headers.\n  setRawResponseHeaders(headers) {\n    if (!this._rawResponseHeadersPromise.isDone()) this._rawResponseHeadersPromise.resolve(headers || this._headers);\n  }\n  setTransferSize(size) {\n    this._transferSizePromise.resolve(size);\n  }\n  setEncodedBodySize(size) {\n    this._encodedBodySizePromise.resolve(size);\n  }\n  setResponseHeadersSize(size) {\n    this._responseHeadersSizePromise.resolve(size);\n  }\n  timing() {\n    return this._timing;\n  }\n  async serverAddr() {\n    return (await this._serverAddrPromise) || null;\n  }\n  async securityDetails() {\n    return (await this._securityDetailsPromise) || null;\n  }\n  body() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._finishedPromise.then(async () => {\n        if (this._status >= 300 && this._status <= 399) throw new Error('Response body is unavailable for redirect responses');\n        return this._getResponseBodyCallback();\n      });\n    }\n    return this._contentPromise;\n  }\n  request() {\n    return this._request;\n  }\n  frame() {\n    return this._request.frame();\n  }\n  httpVersion() {\n    if (!this._httpVersion) return 'HTTP/1.1';\n    if (this._httpVersion === 'http/1.1') return 'HTTP/1.1';\n    if (this._httpVersion === 'h2') return 'HTTP/2.0';\n    return this._httpVersion;\n  }\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n  async responseHeadersSize() {\n    const availableSize = await this._responseHeadersSizePromise;\n    if (availableSize !== null) return availableSize;\n\n    // Fallback to calculating it manually.\n    let headersSize = 4; // 4 = 2 spaces + 2 line breaks (HTTP/1.1 200 Ok\\r\\n)\n    headersSize += 8; // httpVersion;\n    headersSize += 3; // statusCode;\n    headersSize += this.statusText().length;\n    const headers = await this._rawResponseHeadersPromise;\n    for (const header of headers) headersSize += header.name.length + header.value.length + 4; // 4 = ': ' + '\\r\\n'\n    headersSize += 2; // '\\r\\n'\n    return headersSize;\n  }\n  async sizes() {\n    const requestHeadersSize = await this._request.requestHeadersSize();\n    const responseHeadersSize = await this.responseHeadersSize();\n    let encodedBodySize = await this._encodedBodySizePromise;\n    if (encodedBodySize === null) {\n      var _headers$find;\n      // Fallback to calculating it manually.\n      const headers = await this._rawResponseHeadersPromise;\n      const contentLength = (_headers$find = headers.find(h => h.name.toLowerCase() === 'content-length')) === null || _headers$find === void 0 ? void 0 : _headers$find.value;\n      encodedBodySize = contentLength ? +contentLength : 0;\n    }\n    let transferSize = await this._transferSizePromise;\n    if (transferSize === null) {\n      // Fallback to calculating it manually.\n      transferSize = responseHeadersSize + encodedBodySize;\n    }\n    return {\n      requestBodySize: this._request.bodySize(),\n      requestHeadersSize,\n      responseBodySize: encodedBodySize,\n      responseHeadersSize,\n      transferSize\n    };\n  }\n}\nexports.Response = Response;\nclass WebSocket extends _instrumentation.SdkObject {\n  constructor(parent, url) {\n    super(parent, 'ws');\n    this._url = void 0;\n    this._notified = false;\n    this._url = url;\n  }\n  markAsNotified() {\n    // Sometimes we get \"onWebSocketRequest\" twice, at least in Chromium.\n    // Perhaps websocket is restarted because of chrome.webRequest extensions api?\n    // Or maybe the handshake response was a redirect?\n    if (this._notified) return false;\n    this._notified = true;\n    return true;\n  }\n  url() {\n    return this._url;\n  }\n  frameSent(opcode, data) {\n    this.emit(WebSocket.Events.FrameSent, {\n      opcode,\n      data\n    });\n  }\n  frameReceived(opcode, data) {\n    this.emit(WebSocket.Events.FrameReceived, {\n      opcode,\n      data\n    });\n  }\n  error(errorMessage) {\n    this.emit(WebSocket.Events.SocketError, errorMessage);\n  }\n  closed() {\n    this.emit(WebSocket.Events.Close);\n  }\n}\nexports.WebSocket = WebSocket;\nWebSocket.Events = {\n  Close: 'close',\n  SocketError: 'socketerror',\n  FrameReceived: 'framereceived',\n  FrameSent: 'framesent'\n};\n// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.\nconst STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': 'I\\'m a teapot',\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};\nexports.STATUS_TEXTS = STATUS_TEXTS;\nfunction singleHeader(name, value) {\n  return [{\n    name,\n    value\n  }];\n}\nfunction mergeHeaders(headers) {\n  const lowerCaseToValue = new Map();\n  const lowerCaseToOriginalCase = new Map();\n  for (const h of headers) {\n    if (!h) continue;\n    for (const {\n      name,\n      value\n    } of h) {\n      const lower = name.toLowerCase();\n      lowerCaseToOriginalCase.set(lower, name);\n      lowerCaseToValue.set(lower, value);\n    }\n  }\n  const result = [];\n  for (const [lower, value] of lowerCaseToValue) result.push({\n    name: lowerCaseToOriginalCase.get(lower),\n    value\n  });\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Worker = exports.PageBinding = exports.Page = void 0;\nvar frames = _interopRequireWildcard(require(\"./frames\"));\nvar input = _interopRequireWildcard(require(\"./input\"));\nvar js = _interopRequireWildcard(require(\"./javascript\"));\nvar network = _interopRequireWildcard(require(\"./network\"));\nvar _screenshotter = require(\"./screenshotter\");\nvar _timeoutSettings = require(\"../common/timeoutSettings\");\nvar _browserContext = require(\"./browserContext\");\nvar _console = require(\"./console\");\nvar accessibility = _interopRequireWildcard(require(\"./accessibility\"));\nvar _fileChooser = require(\"./fileChooser\");\nvar _progress = require(\"./progress\");\nvar _utils = require(\"../utils\");\nvar _manualPromise = require(\"../utils/manualPromise\");\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _comparators = require(\"../utils/comparators\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _selectorParser = require(\"./isomorphic/selectorParser\");\nvar _utilityScriptSerializers = require(\"./isomorphic/utilityScriptSerializers\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Page extends _instrumentation.SdkObject {\n  // Aiming at 25 fps by default - each frame is 40ms, but we give some slack with 35ms.\n  // When throttling for tracing, 200ms between frames, except for 10 frames around the action.\n\n  constructor(delegate, browserContext) {\n    super(browserContext, 'page');\n    this._closedState = 'open';\n    this._closedPromise = new _manualPromise.ManualPromise();\n    this._disconnected = false;\n    this._initialized = false;\n    this._disconnectedPromise = new _manualPromise.ManualPromise();\n    this._crashedPromise = new _manualPromise.ManualPromise();\n    this._browserContext = void 0;\n    this.keyboard = void 0;\n    this.mouse = void 0;\n    this.touchscreen = void 0;\n    this._timeoutSettings = void 0;\n    this._delegate = void 0;\n    this._emulatedSize = void 0;\n    this._extraHTTPHeaders = void 0;\n    this._emulatedMedia = {};\n    this._interceptFileChooser = false;\n    this._pageBindings = new Map();\n    this.initScripts = [];\n    this._screenshotter = void 0;\n    this._frameManager = void 0;\n    this.accessibility = void 0;\n    this._workers = new Map();\n    this.pdf = void 0;\n    this.coverage = void 0;\n    this._clientRequestInterceptor = void 0;\n    this._serverRequestInterceptor = void 0;\n    this._ownedContext = void 0;\n    this.selectors = void 0;\n    this._pageIsError = void 0;\n    this._video = null;\n    this._opener = void 0;\n    this._isServerSideOnly = false;\n    this._frameThrottler = new FrameThrottler(10, 35, 200);\n    this.attribution.page = this;\n    this._delegate = delegate;\n    this._browserContext = browserContext;\n    this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));\n    this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);\n    this.mouse = new input.Mouse(delegate.rawMouse, this);\n    this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);\n    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(browserContext._timeoutSettings);\n    this._screenshotter = new _screenshotter.Screenshotter(this);\n    this._frameManager = new frames.FrameManager(this);\n    if (delegate.pdf) this.pdf = delegate.pdf.bind(delegate);\n    this.coverage = delegate.coverage ? delegate.coverage() : null;\n    this.selectors = browserContext.selectors();\n  }\n  async initOpener(opener) {\n    if (!opener) return;\n    const openerPage = await opener.pageOrError();\n    if (openerPage instanceof Page && !openerPage.isClosed()) this._opener = openerPage;\n  }\n  reportAsNew(error = undefined, contextEvent = _browserContext.BrowserContext.Events.Page) {\n    if (error) {\n      // Initialization error could have happened because of\n      // context/browser closure. Just ignore the page.\n      if (this._browserContext.isClosingOrClosed()) return;\n      this._setIsError(error);\n    }\n    this._initialized = true;\n    this.emitOnContext(contextEvent, this);\n    // I may happen that page initialization finishes after Close event has already been sent,\n    // in that case we fire another Close event to ensure that each reported Page will have\n    // corresponding Close event after it is reported on the context.\n    if (this.isClosed()) this.emit(Page.Events.Close);\n    this.instrumentation.onPageOpen(this);\n  }\n  initializedOrUndefined() {\n    return this._initialized ? this : undefined;\n  }\n  emitOnContext(event, ...args) {\n    if (this._isServerSideOnly) return;\n    this._browserContext.emit(event, ...args);\n  }\n  async resetForReuse(metadata) {\n    this.setDefaultNavigationTimeout(undefined);\n    this.setDefaultTimeout(undefined);\n    await this._removeExposedBindings();\n    await this._removeInitScripts();\n    await this.setClientRequestInterceptor(undefined);\n    await this._setServerRequestInterceptor(undefined);\n    await this.setFileChooserIntercepted(false);\n    // Re-navigate once init scripts are gone.\n    await this.mainFrame().goto(metadata, 'about:blank');\n    this._emulatedSize = undefined;\n    this._emulatedMedia = {};\n    this._extraHTTPHeaders = undefined;\n    this._interceptFileChooser = false;\n    await Promise.all([this._delegate.updateEmulatedViewportSize(), this._delegate.updateEmulateMedia(), this._delegate.updateFileChooserInterception()]);\n  }\n  _didClose() {\n    this._frameManager.dispose();\n    this._frameThrottler.dispose();\n    (0, _utils.assert)(this._closedState !== 'closed', 'Page closed twice');\n    this._closedState = 'closed';\n    this.emit(Page.Events.Close);\n    this._closedPromise.resolve();\n    this.instrumentation.onPageClose(this);\n  }\n  _didCrash() {\n    this._frameManager.dispose();\n    this._frameThrottler.dispose();\n    this.emit(Page.Events.Crash);\n    this._crashedPromise.resolve(new Error('Page crashed'));\n    this.instrumentation.onPageClose(this);\n  }\n  _didDisconnect() {\n    this._frameManager.dispose();\n    this._frameThrottler.dispose();\n    (0, _utils.assert)(!this._disconnected, 'Page disconnected twice');\n    this._disconnected = true;\n    this._disconnectedPromise.resolve(new Error('Page closed'));\n  }\n  async _onFileChooserOpened(handle) {\n    let multiple;\n    try {\n      multiple = await handle.evaluate(element => !!element.multiple);\n    } catch (e) {\n      // Frame/context may be gone during async processing. Do not throw.\n      return;\n    }\n    if (!this.listenerCount(Page.Events.FileChooser)) {\n      handle.dispose();\n      return;\n    }\n    const fileChooser = new _fileChooser.FileChooser(this, handle, multiple);\n    this.emit(Page.Events.FileChooser, fileChooser);\n  }\n  context() {\n    return this._browserContext;\n  }\n  opener() {\n    return this._opener;\n  }\n  mainFrame() {\n    return this._frameManager.mainFrame();\n  }\n  frames() {\n    return this._frameManager.frames();\n  }\n  setDefaultNavigationTimeout(timeout) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n  async exposeBinding(name, needsHandle, playwrightBinding) {\n    if (this._pageBindings.has(name)) throw new Error(`Function \"${name}\" has been already registered`);\n    if (this._browserContext._pageBindings.has(name)) throw new Error(`Function \"${name}\" has been already registered in the browser context`);\n    const binding = new PageBinding(name, playwrightBinding, needsHandle);\n    this._pageBindings.set(name, binding);\n    await this._delegate.exposeBinding(binding);\n  }\n  async _removeExposedBindings() {\n    for (const key of this._pageBindings.keys()) {\n      if (!key.startsWith('__pw')) this._pageBindings.delete(key);\n    }\n    await this._delegate.removeExposedBindings();\n  }\n  setExtraHTTPHeaders(headers) {\n    this._extraHTTPHeaders = headers;\n    return this._delegate.updateExtraHTTPHeaders();\n  }\n  extraHTTPHeaders() {\n    return this._extraHTTPHeaders;\n  }\n  async _onBindingCalled(payload, context) {\n    if (this._disconnected || this._closedState === 'closed') return;\n    await PageBinding.dispatch(this, payload, context);\n  }\n  _addConsoleMessage(type, args, location, text) {\n    const message = new _console.ConsoleMessage(this, type, text, args, location);\n    const intercepted = this._frameManager.interceptConsoleMessage(message);\n    if (intercepted || !this.listenerCount(Page.Events.Console)) args.forEach(arg => arg.dispose());else this.emit(Page.Events.Console, message);\n  }\n  async reload(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this.mainFrame().raceNavigationAction(progress, options, async () => {\n      // Note: waitForNavigation may fail before we get response to reload(),\n      // so we should await it immediately.\n      const [response] = await Promise.all([\n      // Reload must be a new document, and should not be confused with a stray pushState.\n      this.mainFrame()._waitForNavigation(progress, true /* requiresNewDocument */, options), this._delegate.reload()]);\n      return response;\n    }), this._timeoutSettings.navigationTimeout(options));\n  }\n  async goBack(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this.mainFrame().raceNavigationAction(progress, options, async () => {\n      // Note: waitForNavigation may fail before we get response to goBack,\n      // so we should catch it immediately.\n      let error;\n      const waitPromise = this.mainFrame()._waitForNavigation(progress, false /* requiresNewDocument */, options).catch(e => {\n        error = e;\n        return null;\n      });\n      const result = await this._delegate.goBack();\n      if (!result) return null;\n      const response = await waitPromise;\n      if (error) throw error;\n      return response;\n    }), this._timeoutSettings.navigationTimeout(options));\n  }\n  async goForward(metadata, options) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this.mainFrame().raceNavigationAction(progress, options, async () => {\n      // Note: waitForNavigation may fail before we get response to goForward,\n      // so we should catch it immediately.\n      let error;\n      const waitPromise = this.mainFrame()._waitForNavigation(progress, false /* requiresNewDocument */, options).catch(e => {\n        error = e;\n        return null;\n      });\n      const result = await this._delegate.goForward();\n      if (!result) return null;\n      const response = await waitPromise;\n      if (error) throw error;\n      return response;\n    }), this._timeoutSettings.navigationTimeout(options));\n  }\n  async emulateMedia(options) {\n    if (options.media !== undefined) this._emulatedMedia.media = options.media;\n    if (options.colorScheme !== undefined) this._emulatedMedia.colorScheme = options.colorScheme;\n    if (options.reducedMotion !== undefined) this._emulatedMedia.reducedMotion = options.reducedMotion;\n    if (options.forcedColors !== undefined) this._emulatedMedia.forcedColors = options.forcedColors;\n    await this._delegate.updateEmulateMedia();\n  }\n  emulatedMedia() {\n    var _contextOptions$color, _contextOptions$reduc, _contextOptions$force;\n    const contextOptions = this._browserContext._options;\n    return {\n      media: this._emulatedMedia.media || 'no-override',\n      colorScheme: this._emulatedMedia.colorScheme !== undefined ? this._emulatedMedia.colorScheme : (_contextOptions$color = contextOptions.colorScheme) !== null && _contextOptions$color !== void 0 ? _contextOptions$color : 'light',\n      reducedMotion: this._emulatedMedia.reducedMotion !== undefined ? this._emulatedMedia.reducedMotion : (_contextOptions$reduc = contextOptions.reducedMotion) !== null && _contextOptions$reduc !== void 0 ? _contextOptions$reduc : 'no-preference',\n      forcedColors: this._emulatedMedia.forcedColors !== undefined ? this._emulatedMedia.forcedColors : (_contextOptions$force = contextOptions.forcedColors) !== null && _contextOptions$force !== void 0 ? _contextOptions$force : 'none'\n    };\n  }\n  async setViewportSize(viewportSize) {\n    this._emulatedSize = {\n      viewport: {\n        ...viewportSize\n      },\n      screen: {\n        ...viewportSize\n      }\n    };\n    await this._delegate.updateEmulatedViewportSize();\n  }\n  viewportSize() {\n    var _this$emulatedSize;\n    return ((_this$emulatedSize = this.emulatedSize()) === null || _this$emulatedSize === void 0 ? void 0 : _this$emulatedSize.viewport) || null;\n  }\n  emulatedSize() {\n    if (this._emulatedSize) return this._emulatedSize;\n    const contextOptions = this._browserContext._options;\n    return contextOptions.viewport ? {\n      viewport: contextOptions.viewport,\n      screen: contextOptions.screen || contextOptions.viewport\n    } : null;\n  }\n  async bringToFront() {\n    await this._delegate.bringToFront();\n  }\n  async addInitScript(source) {\n    this.initScripts.push(source);\n    await this._delegate.addInitScript(source);\n  }\n  async _removeInitScripts() {\n    this.initScripts.splice(0, this.initScripts.length);\n    await this._delegate.removeInitScripts();\n  }\n  needsRequestInterception() {\n    return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;\n  }\n  async setClientRequestInterceptor(handler) {\n    this._clientRequestInterceptor = handler;\n    await this._delegate.updateRequestInterception();\n  }\n  async _setServerRequestInterceptor(handler) {\n    this._serverRequestInterceptor = handler;\n    await this._delegate.updateRequestInterception();\n  }\n  async expectScreenshot(metadata, options = {}) {\n    const locator = options.locator;\n    const rafrafScreenshot = locator ? async (progress, timeout) => {\n      return await locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress, locator.selector, timeout, options.screenshotOptions || {});\n    } : async (progress, timeout) => {\n      await this.mainFrame().rafrafTimeout(timeout);\n      return await this._screenshotter.screenshotPage(progress, options.screenshotOptions || {});\n    };\n    const comparator = (0, _comparators.getComparator)('image/png');\n    const controller = new _progress.ProgressController(metadata, this);\n    if (!options.expected && options.isNot) return {\n      errorMessage: '\"not\" matcher requires expected result'\n    };\n    try {\n      const format = (0, _screenshotter.validateScreenshotOptions)(options.screenshotOptions || {});\n      if (format !== 'png') throw new Error('Only PNG screenshots are supported');\n    } catch (error) {\n      return {\n        errorMessage: error.message\n      };\n    }\n    let intermediateResult = undefined;\n    const areEqualScreenshots = (actual, expected, previous) => {\n      const comparatorResult = actual && expected ? comparator(actual, expected, options.comparatorOptions) : undefined;\n      if (comparatorResult !== undefined && !!comparatorResult === !!options.isNot) return true;\n      if (comparatorResult) intermediateResult = {\n        errorMessage: comparatorResult.errorMessage,\n        diff: comparatorResult.diff,\n        actual,\n        previous\n      };\n      return false;\n    };\n    const callTimeout = this._timeoutSettings.timeout(options);\n    return controller.run(async progress => {\n      let actual;\n      let previous;\n      const pollIntervals = [0, 100, 250, 500];\n      progress.log(`${metadata.apiName}${callTimeout ? ` with timeout ${callTimeout}ms` : ''}`);\n      if (options.expected) progress.log(`  verifying given screenshot expectation`);else progress.log(`  generating new stable screenshot expectation`);\n      let isFirstIteration = true;\n      while (true) {\n        var _pollIntervals$shift;\n        progress.throwIfAborted();\n        if (this.isClosed()) throw new Error('The page has closed');\n        const screenshotTimeout = (_pollIntervals$shift = pollIntervals.shift()) !== null && _pollIntervals$shift !== void 0 ? _pollIntervals$shift : 1000;\n        if (screenshotTimeout) progress.log(`waiting ${screenshotTimeout}ms before taking screenshot`);\n        previous = actual;\n        actual = await rafrafScreenshot(progress, screenshotTimeout).catch(e => {\n          progress.log(`failed to take screenshot - ` + e.message);\n          return undefined;\n        });\n        if (!actual) continue;\n        // Compare against expectation for the first iteration.\n        const expectation = options.expected && isFirstIteration ? options.expected : previous;\n        if (areEqualScreenshots(actual, expectation, previous)) break;\n        if (intermediateResult) progress.log(intermediateResult.errorMessage);\n        isFirstIteration = false;\n      }\n      if (!isFirstIteration) progress.log(`captured a stable screenshot`);\n      if (!options.expected) return {\n        actual\n      };\n      if (isFirstIteration) {\n        progress.log(`screenshot matched expectation`);\n        return {};\n      }\n      if (areEqualScreenshots(actual, options.expected, previous)) {\n        progress.log(`screenshot matched expectation`);\n        return {};\n      }\n      throw new Error(intermediateResult.errorMessage);\n    }, callTimeout).catch(e => {\n      // Q: Why not throw upon isSessionClosedError(e) as in other places?\n      // A: We want user to receive a friendly diff between actual and expected/previous.\n      if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e)) throw e;\n      return {\n        log: e.message ? [...metadata.log, e.message] : metadata.log,\n        ...intermediateResult,\n        errorMessage: e.message\n      };\n    });\n  }\n  async screenshot(metadata, options = {}) {\n    const controller = new _progress.ProgressController(metadata, this);\n    return controller.run(progress => this._screenshotter.screenshotPage(progress, options), this._timeoutSettings.timeout(options));\n  }\n  async close(metadata, options) {\n    if (this._closedState === 'closed') return;\n    const runBeforeUnload = !!options && !!options.runBeforeUnload;\n    if (this._closedState !== 'closing') {\n      this._closedState = 'closing';\n      (0, _utils.assert)(!this._disconnected, 'Target closed');\n      // This might throw if the browser context containing the page closes\n      // while we are trying to close the page.\n      await this._delegate.closePage(runBeforeUnload).catch(e => _debugLogger.debugLogger.log('error', e));\n    }\n    if (!runBeforeUnload) await this._closedPromise;\n    if (this._ownedContext) await this._ownedContext.close(metadata);\n  }\n  _setIsError(error) {\n    this._pageIsError = error;\n    this._frameManager.createDummyMainFrameIfNeeded();\n  }\n  isClosed() {\n    return this._closedState === 'closed';\n  }\n  isClosedOrClosingOrCrashed() {\n    return this._closedState !== 'open' || this._crashedPromise.isDone();\n  }\n  _addWorker(workerId, worker) {\n    this._workers.set(workerId, worker);\n    this.emit(Page.Events.Worker, worker);\n  }\n  _removeWorker(workerId) {\n    const worker = this._workers.get(workerId);\n    if (!worker) return;\n    worker.didClose();\n    this._workers.delete(workerId);\n  }\n  _clearWorkers() {\n    for (const [workerId, worker] of this._workers) {\n      worker.didClose();\n      this._workers.delete(workerId);\n    }\n  }\n  async setFileChooserIntercepted(enabled) {\n    this._interceptFileChooser = enabled;\n    await this._delegate.updateFileChooserInterception();\n  }\n  fileChooserIntercepted() {\n    return this._interceptFileChooser;\n  }\n  frameNavigatedToNewDocument(frame) {\n    this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);\n    const url = frame.url();\n    if (!url.startsWith('http')) return;\n    const purl = network.parsedURL(url);\n    if (purl) this._browserContext.addVisitedOrigin(purl.origin);\n  }\n  allBindings() {\n    return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];\n  }\n  getBinding(name) {\n    return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);\n  }\n  setScreencastOptions(options) {\n    this._delegate.setScreencastOptions(options).catch(e => _debugLogger.debugLogger.log('error', e));\n    this._frameThrottler.setThrottlingEnabled(!!options);\n  }\n  throttleScreencastFrameAck(ack) {\n    // Don't ack immediately, tracing has smart throttling logic that is implemented here.\n    this._frameThrottler.ack(ack);\n  }\n  temporarlyDisableTracingScreencastThrottling() {\n    this._frameThrottler.recharge();\n  }\n  firePageError(error) {\n    this.emit(Page.Events.PageError, error);\n  }\n  parseSelector(selector, options) {\n    const strict = typeof (options === null || options === void 0 ? void 0 : options.strict) === 'boolean' ? options.strict : !!this.context()._options.strictSelectors;\n    return this.selectors.parseSelector(selector, strict);\n  }\n  async hideHighlight() {\n    await Promise.all(this.frames().map(frame => frame.hideHighlight().catch(() => {})));\n  }\n  markAsServerSideOnly() {\n    this._isServerSideOnly = true;\n  }\n}\nexports.Page = Page;\nPage.Events = {\n  Close: 'close',\n  Crash: 'crash',\n  Console: 'console',\n  Dialog: 'dialog',\n  Download: 'download',\n  FileChooser: 'filechooser',\n  // Can't use just 'error' due to node.js special treatment of error events.\n  // @see https://nodejs.org/api/events.html#events_error_events\n  PageError: 'pageerror',\n  FrameAttached: 'frameattached',\n  FrameDetached: 'framedetached',\n  InternalFrameNavigatedToNewDocument: 'internalframenavigatedtonewdocument',\n  ScreencastFrame: 'screencastframe',\n  Video: 'video',\n  WebSocket: 'websocket',\n  Worker: 'worker'\n};\nclass Worker extends _instrumentation.SdkObject {\n  constructor(parent, url) {\n    super(parent, 'worker');\n    this._url = void 0;\n    this._executionContextPromise = void 0;\n    this._executionContextCallback = void 0;\n    this._existingExecutionContext = null;\n    this._url = url;\n    this._executionContextCallback = () => {};\n    this._executionContextPromise = new Promise(x => this._executionContextCallback = x);\n  }\n  _createExecutionContext(delegate) {\n    this._existingExecutionContext = new js.ExecutionContext(this, delegate);\n    this._executionContextCallback(this._existingExecutionContext);\n  }\n  url() {\n    return this._url;\n  }\n  didClose() {\n    if (this._existingExecutionContext) this._existingExecutionContext.contextDestroyed(new Error('Worker was closed'));\n    this.emit(Worker.Events.Close, this);\n  }\n  async evaluateExpression(expression, isFunction, arg) {\n    return js.evaluateExpression(await this._executionContextPromise, expression, {\n      returnByValue: true,\n      isFunction\n    }, arg);\n  }\n  async evaluateExpressionHandle(expression, isFunction, arg) {\n    return js.evaluateExpression(await this._executionContextPromise, expression, {\n      returnByValue: false,\n      isFunction\n    }, arg);\n  }\n}\nexports.Worker = Worker;\nWorker.Events = {\n  Close: 'close'\n};\nclass PageBinding {\n  constructor(name, playwrightFunction, needsHandle) {\n    this.name = void 0;\n    this.playwrightFunction = void 0;\n    this.source = void 0;\n    this.needsHandle = void 0;\n    this.name = name;\n    this.playwrightFunction = playwrightFunction;\n    this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${_utilityScriptSerializers.source})())`;\n    this.needsHandle = needsHandle;\n  }\n  static async dispatch(page, payload, context) {\n    const {\n      name,\n      seq,\n      serializedArgs\n    } = JSON.parse(payload);\n    try {\n      (0, _utils.assert)(context.world);\n      const binding = page.getBinding(name);\n      let result;\n      if (binding.needsHandle) {\n        const handle = await context.evaluateHandle(takeHandle, {\n          name,\n          seq\n        }).catch(e => null);\n        result = await binding.playwrightFunction({\n          frame: context.frame,\n          page,\n          context: page._browserContext\n        }, handle);\n      } else {\n        const args = serializedArgs.map(a => (0, _utilityScriptSerializers.parseEvaluationResultValue)(a));\n        result = await binding.playwrightFunction({\n          frame: context.frame,\n          page,\n          context: page._browserContext\n        }, ...args);\n      }\n      context.evaluate(deliverResult, {\n        name,\n        seq,\n        result\n      }).catch(e => _debugLogger.debugLogger.log('error', e));\n    } catch (error) {\n      if ((0, _utils.isError)(error)) context.evaluate(deliverError, {\n        name,\n        seq,\n        message: error.message,\n        stack: error.stack\n      }).catch(e => _debugLogger.debugLogger.log('error', e));else context.evaluate(deliverErrorValue, {\n        name,\n        seq,\n        error\n      }).catch(e => _debugLogger.debugLogger.log('error', e));\n    }\n    function takeHandle(arg) {\n      const handle = globalThis[arg.name]['handles'].get(arg.seq);\n      globalThis[arg.name]['handles'].delete(arg.seq);\n      return handle;\n    }\n    function deliverResult(arg) {\n      globalThis[arg.name]['callbacks'].get(arg.seq).resolve(arg.result);\n      globalThis[arg.name]['callbacks'].delete(arg.seq);\n    }\n    function deliverError(arg) {\n      const error = new Error(arg.message);\n      error.stack = arg.stack;\n      globalThis[arg.name]['callbacks'].get(arg.seq).reject(error);\n      globalThis[arg.name]['callbacks'].delete(arg.seq);\n    }\n    function deliverErrorValue(arg) {\n      globalThis[arg.name]['callbacks'].get(arg.seq).reject(arg.error);\n      globalThis[arg.name]['callbacks'].delete(arg.seq);\n    }\n  }\n}\nexports.PageBinding = PageBinding;\nfunction addPageBinding(bindingName, needsHandle, utilityScriptSerializers) {\n  const binding = globalThis[bindingName];\n  if (binding.__installed) return;\n  globalThis[bindingName] = (...args) => {\n    const me = globalThis[bindingName];\n    if (needsHandle && args.slice(1).some(arg => arg !== undefined)) throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);\n    let callbacks = me['callbacks'];\n    if (!callbacks) {\n      callbacks = new Map();\n      me['callbacks'] = callbacks;\n    }\n    const seq = (me['lastSeq'] || 0) + 1;\n    me['lastSeq'] = seq;\n    let handles = me['handles'];\n    if (!handles) {\n      handles = new Map();\n      me['handles'] = handles;\n    }\n    const promise = new Promise((resolve, reject) => callbacks.set(seq, {\n      resolve,\n      reject\n    }));\n    let payload;\n    if (needsHandle) {\n      handles.set(seq, args[0]);\n      payload = {\n        name: bindingName,\n        seq\n      };\n    } else {\n      const serializedArgs = args.map(a => utilityScriptSerializers.serializeAsCallArgument(a, v => {\n        return {\n          fallThrough: v\n        };\n      }));\n      payload = {\n        name: bindingName,\n        seq,\n        serializedArgs\n      };\n    }\n    binding(JSON.stringify(payload));\n    return promise;\n  };\n  globalThis[bindingName].__installed = true;\n}\nclass FrameThrottler {\n  constructor(nonThrottledFrames, defaultInterval, throttlingInterval) {\n    this._acks = [];\n    this._defaultInterval = void 0;\n    this._throttlingInterval = void 0;\n    this._nonThrottledFrames = void 0;\n    this._budget = void 0;\n    this._throttlingEnabled = false;\n    this._timeoutId = void 0;\n    this._nonThrottledFrames = nonThrottledFrames;\n    this._budget = nonThrottledFrames;\n    this._defaultInterval = defaultInterval;\n    this._throttlingInterval = throttlingInterval;\n    this._tick();\n  }\n  dispose() {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = undefined;\n    }\n  }\n  setThrottlingEnabled(enabled) {\n    this._throttlingEnabled = enabled;\n  }\n  recharge() {\n    // Send all acks, reset budget.\n    for (const ack of this._acks) ack();\n    this._acks = [];\n    this._budget = this._nonThrottledFrames;\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      this._tick();\n    }\n  }\n  ack(ack) {\n    if (!this._timeoutId) {\n      // Already disposed.\n      ack();\n      return;\n    }\n    this._acks.push(ack);\n  }\n  _tick() {\n    const ack = this._acks.shift();\n    if (ack) {\n      --this._budget;\n      ack();\n    }\n    if (this._throttlingEnabled && this._budget <= 0) {\n      // Non-throttled frame budget is exceeded. Next ack will be throttled.\n      this._timeoutId = setTimeout(() => this._tick(), this._throttlingInterval);\n    } else {\n      // Either not throttling, or still under budget. Next ack will be after the default timeout.\n      this._timeoutId = setTimeout(() => this._tick(), this._defaultInterval);\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PipeTransport = void 0;\nvar _utils = require(\"../utils\");\nvar _debugLogger = require(\"../common/debugLogger\");\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass PipeTransport {\n  constructor(pipeWrite, pipeRead) {\n    this._pipeRead = void 0;\n    this._pipeWrite = void 0;\n    this._pendingBuffers = [];\n    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();\n    this._closed = false;\n    this._onclose = void 0;\n    this.onmessage = void 0;\n    this._pipeRead = pipeRead;\n    this._pipeWrite = pipeWrite;\n    pipeRead.on('data', buffer => this._dispatch(buffer));\n    pipeRead.on('close', () => {\n      this._closed = true;\n      if (this._onclose) this._onclose.call(null);\n    });\n    pipeRead.on('error', e => _debugLogger.debugLogger.log('error', e));\n    pipeWrite.on('error', e => _debugLogger.debugLogger.log('error', e));\n    this.onmessage = undefined;\n  }\n  get onclose() {\n    return this._onclose;\n  }\n  set onclose(onclose) {\n    this._onclose = onclose;\n    if (onclose && !this._pipeRead.readable) onclose();\n  }\n  send(message) {\n    if (this._closed) throw new Error('Pipe has been closed');\n    this._pipeWrite.write(JSON.stringify(message));\n    this._pipeWrite.write('\\0');\n  }\n  close() {\n    throw new Error('unimplemented');\n  }\n  _dispatch(buffer) {\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this._pendingBuffers.push(buffer);\n      return;\n    }\n    this._pendingBuffers.push(buffer.slice(0, end));\n    const message = Buffer.concat(this._pendingBuffers).toString();\n    this._waitForNextTask(() => {\n      if (this.onmessage) this.onmessage.call(null, JSON.parse(message));\n    });\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      const message = buffer.toString(undefined, start, end);\n      this._waitForNextTask(() => {\n        if (this.onmessage) this.onmessage.call(null, JSON.parse(message));\n      });\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this._pendingBuffers = [buffer.slice(start)];\n  }\n}\nexports.PipeTransport = PipeTransport;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Playwright = void 0;\nexports.createPlaywright = createPlaywright;\nvar _android = require(\"./android/android\");\nvar _backendAdb = require(\"./android/backendAdb\");\nvar _chromium = require(\"./chromium/chromium\");\nvar _electron = require(\"./electron/electron\");\nvar _firefox = require(\"./firefox/firefox\");\nvar _selectors = require(\"./selectors\");\nvar _webkit = require(\"./webkit/webkit\");\nvar _instrumentation = require(\"./instrumentation\");\nvar _debugLogger = require(\"../common/debugLogger\");\nvar _debugController = require(\"./debugController\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Playwright extends _instrumentation.SdkObject {\n  constructor(sdkLanguage, isInternalPlaywright) {\n    super({\n      attribution: {\n        isInternalPlaywright\n      },\n      instrumentation: (0, _instrumentation.createInstrumentation)()\n    }, undefined, 'Playwright');\n    this.selectors = void 0;\n    this.chromium = void 0;\n    this.android = void 0;\n    this.electron = void 0;\n    this.firefox = void 0;\n    this.webkit = void 0;\n    this.options = void 0;\n    this.debugController = void 0;\n    this._allPages = new Set();\n    this._allBrowsers = new Set();\n    this.instrumentation.addListener({\n      onBrowserOpen: browser => this._allBrowsers.add(browser),\n      onBrowserClose: browser => this._allBrowsers.delete(browser),\n      onPageOpen: page => this._allPages.add(page),\n      onPageClose: page => this._allPages.delete(page),\n      onCallLog: (sdkObject, metadata, logName, message) => {\n        _debugLogger.debugLogger.log(logName, message);\n      }\n    }, null);\n    this.options = {\n      rootSdkObject: this,\n      selectors: new _selectors.Selectors(),\n      sdkLanguage: sdkLanguage\n    };\n    this.chromium = new _chromium.Chromium(this.options);\n    this.firefox = new _firefox.Firefox(this.options);\n    this.webkit = new _webkit.WebKit(this.options);\n    this.electron = new _electron.Electron(this.options);\n    this.android = new _android.Android(new _backendAdb.AdbBackend(), this.options);\n    this.selectors = this.options.selectors;\n    this.debugController = new _debugController.DebugController(this);\n  }\n  async hideHighlight() {\n    await Promise.all([...this._allPages].map(p => p.hideHighlight().catch(() => {})));\n  }\n  allBrowsers() {\n    return [...this._allBrowsers];\n  }\n  allPages() {\n    return [...this._allPages];\n  }\n}\nexports.Playwright = Playwright;\nfunction createPlaywright(sdkLanguage, isInternalPlaywright = false) {\n  return new Playwright(sdkLanguage, isInternalPlaywright);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProgressController = void 0;\nvar _errors = require(\"../common/errors\");\nvar _utils = require(\"../utils\");\nvar _manualPromise = require(\"../utils/manualPromise\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ProgressController {\n  // Cleanups to be run only in the case of abort.\n\n  constructor(metadata, sdkObject) {\n    this._forceAbortPromise = new _manualPromise.ManualPromise();\n    this._cleanups = [];\n    this._logName = 'api';\n    this._state = 'before';\n    this._deadline = 0;\n    this._timeout = 0;\n    this.metadata = void 0;\n    this.instrumentation = void 0;\n    this.sdkObject = void 0;\n    this.metadata = metadata;\n    this.sdkObject = sdkObject;\n    this.instrumentation = sdkObject.instrumentation;\n    this._forceAbortPromise.catch(e => null); // Prevent unhandled promise rejection.\n  }\n\n  setLogName(logName) {\n    this._logName = logName;\n  }\n  abort(error) {\n    this._forceAbortPromise.reject(error);\n  }\n  async run(task, timeout) {\n    var _this$sdkObject$attri;\n    if (timeout) {\n      this._timeout = timeout;\n      this._deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;\n    }\n    (0, _utils.assert)(this._state === 'before');\n    this._state = 'running';\n    (_this$sdkObject$attri = this.sdkObject.attribution.context) === null || _this$sdkObject$attri === void 0 ? void 0 : _this$sdkObject$attri._activeProgressControllers.add(this);\n    const progress = {\n      log: message => {\n        progress.logEntry({\n          message\n        });\n      },\n      logEntry: entry => {\n        if ('message' in entry) {\n          const message = entry.message;\n          if (this._state === 'running') this.metadata.log.push(message);\n          // Note: we might be sending logs after progress has finished, for example browser logs.\n          this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);\n        }\n      },\n      timeUntilDeadline: () => this._deadline ? this._deadline - (0, _utils.monotonicTime)() : 2147483647,\n      // 2^31-1 safe setTimeout in Node.\n      isRunning: () => this._state === 'running',\n      cleanupWhenAborted: cleanup => {\n        if (this._state === 'running') this._cleanups.push(cleanup);else runCleanup(cleanup);\n      },\n      throwIfAborted: () => {\n        if (this._state === 'aborted') throw new AbortedError();\n      },\n      beforeInputAction: async element => {\n        await this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);\n      },\n      metadata: this.metadata\n    };\n    const timeoutError = new _errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);\n    const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());\n    try {\n      const promise = task(progress);\n      const result = await Promise.race([promise, this._forceAbortPromise]);\n      this._state = 'finished';\n      return result;\n    } catch (e) {\n      this._state = 'aborted';\n      await Promise.all(this._cleanups.splice(0).map(runCleanup));\n      throw e;\n    } finally {\n      var _this$sdkObject$attri2;\n      (_this$sdkObject$attri2 = this.sdkObject.attribution.context) === null || _this$sdkObject$attri2 === void 0 ? void 0 : _this$sdkObject$attri2._activeProgressControllers.delete(this);\n      clearTimeout(timer);\n    }\n  }\n}\nexports.ProgressController = ProgressController;\nasync function runCleanup(cleanup) {\n  try {\n    await cleanup();\n  } catch (e) {}\n}\nclass AbortedError extends Error {}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProtocolError = void 0;\nexports.isSessionClosedError = isSessionClosedError;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ProtocolError extends Error {\n  constructor(sessionClosed, message) {\n    super(message);\n    this.sessionClosed = void 0;\n    this.sessionClosed = sessionClosed || false;\n  }\n}\nexports.ProtocolError = ProtocolError;\nfunction isSessionClosedError(e) {\n  return e instanceof ProtocolError && e.sessionClosed;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Recorder = void 0;\nvar fs = _interopRequireWildcard(require(\"fs\"));\nvar _codeGenerator = require(\"./recorder/codeGenerator\");\nvar _utils = require(\"./recorder/utils\");\nvar _page = require(\"./page\");\nvar _frames = require(\"./frames\");\nvar _browserContext = require(\"./browserContext\");\nvar _java = require(\"./recorder/java\");\nvar _javascript = require(\"./recorder/javascript\");\nvar _csharp = require(\"./recorder/csharp\");\nvar _python = require(\"./recorder/python\");\nvar recorderSource = _interopRequireWildcard(require(\"../generated/recorderSource\"));\nvar consoleApiSource = _interopRequireWildcard(require(\"../generated/consoleApiSource\"));\nvar _recorderApp = require(\"./recorder/recorderApp\");\nvar _utils2 = require(\"../utils\");\nvar _recorderUtils = require(\"./recorder/recorderUtils\");\nvar _debugger = require(\"./debugger\");\nvar _events = require(\"events\");\nvar _timeoutRunner = require(\"../utils/timeoutRunner\");\nvar _locatorParser = require(\"./isomorphic/locatorParser\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst recorderSymbol = Symbol('recorderSymbol');\nclass Recorder {\n  static setAppFactory(recorderAppFactory) {\n    Recorder.recorderAppFactory = recorderAppFactory;\n  }\n  static showInspector(context) {\n    Recorder.show(context, {}).catch(() => {});\n  }\n  static show(context, params = {}) {\n    let recorderPromise = context[recorderSymbol];\n    if (!recorderPromise) {\n      const recorder = new Recorder(context, params);\n      recorderPromise = recorder.install().then(() => recorder);\n      context[recorderSymbol] = recorderPromise;\n    }\n    return recorderPromise;\n  }\n  constructor(context, params) {\n    this._context = void 0;\n    this._mode = void 0;\n    this._highlightedSelector = '';\n    this._recorderApp = null;\n    this._currentCallsMetadata = new Map();\n    this._recorderSources = [];\n    this._userSources = new Map();\n    this._debugger = void 0;\n    this._contextRecorder = void 0;\n    this._handleSIGINT = void 0;\n    this._omitCallTracking = false;\n    this._currentLanguage = void 0;\n    this._mode = params.mode || 'none';\n    this._contextRecorder = new ContextRecorder(context, params);\n    this._context = context;\n    this._omitCallTracking = !!params.omitCallTracking;\n    this._debugger = context.debugger();\n    this._handleSIGINT = params.handleSIGINT;\n    context.instrumentation.addListener(this, context);\n    this._currentLanguage = this._contextRecorder.languageName();\n  }\n  static async defaultRecorderAppFactory(recorder) {\n    if (process.env.PW_CODEGEN_NO_INSPECTOR) return new _recorderApp.EmptyRecorderApp();\n    return await _recorderApp.RecorderApp.open(recorder, recorder._context, recorder._handleSIGINT);\n  }\n  async install() {\n    const recorderApp = await (Recorder.recorderAppFactory || Recorder.defaultRecorderAppFactory)(this);\n    this._recorderApp = recorderApp;\n    recorderApp.once('close', () => {\n      this._debugger.resume(false);\n      this._recorderApp = null;\n    });\n    recorderApp.on('event', data => {\n      if (data.event === 'setMode') {\n        this.setMode(data.params.mode);\n        return;\n      }\n      if (data.event === 'selectorUpdated') {\n        this.setHighlightedSelector(data.params.language, data.params.selector);\n        return;\n      }\n      if (data.event === 'step') {\n        this._debugger.resume(true);\n        return;\n      }\n      if (data.event === 'fileChanged') {\n        this._currentLanguage = this._contextRecorder.languageName(data.params.file);\n        this._refreshOverlay();\n        return;\n      }\n      if (data.event === 'resume') {\n        this._debugger.resume(false);\n        return;\n      }\n      if (data.event === 'pause') {\n        this._debugger.pauseOnNextStatement();\n        return;\n      }\n      if (data.event === 'clear') {\n        this._contextRecorder.clearScript();\n        return;\n      }\n    });\n    await Promise.all([recorderApp.setMode(this._mode), recorderApp.setPaused(this._debugger.isPaused()), this._pushAllSources()]);\n    this._context.once(_browserContext.BrowserContext.Events.Close, () => {\n      this._contextRecorder.dispose();\n      this._context.instrumentation.removeListener(this);\n      recorderApp.close().catch(() => {});\n    });\n    this._contextRecorder.on(ContextRecorder.Events.Change, data => {\n      var _this$_recorderApp;\n      this._recorderSources = data.sources;\n      this._pushAllSources();\n      (_this$_recorderApp = this._recorderApp) === null || _this$_recorderApp === void 0 ? void 0 : _this$_recorderApp.setFileIfNeeded(data.primaryFileName);\n    });\n    await this._context.exposeBinding('__pw_recorderState', false, source => {\n      let actionSelector = '';\n      let actionPoint;\n      const hasActiveScreenshotCommand = [...this._currentCallsMetadata.keys()].some(isScreenshotCommand);\n      if (!hasActiveScreenshotCommand) {\n        actionSelector = this._highlightedSelector;\n        for (const [metadata, sdkObject] of this._currentCallsMetadata) {\n          if (source.page === sdkObject.attribution.page) {\n            actionPoint = metadata.point || actionPoint;\n            actionSelector = actionSelector || metadata.params.selector;\n          }\n        }\n      }\n      const uiState = {\n        mode: this._mode,\n        actionPoint,\n        actionSelector,\n        language: this._currentLanguage,\n        testIdAttributeName: this._context.selectors().testIdAttributeName()\n      };\n      return uiState;\n    });\n    await this._context.exposeBinding('__pw_recorderSetSelector', false, async (_, selector) => {\n      var _this$_recorderApp2;\n      await ((_this$_recorderApp2 = this._recorderApp) === null || _this$_recorderApp2 === void 0 ? void 0 : _this$_recorderApp2.setSelector(selector, true));\n    });\n    await this._context.exposeBinding('__pw_resume', false, () => {\n      this._debugger.resume(false);\n    });\n    await this._context.extendInjectedScript(consoleApiSource.source);\n    await this._contextRecorder.install();\n    if (this._debugger.isPaused()) this._pausedStateChanged();\n    this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());\n    this._context.recorderAppForTest = recorderApp;\n  }\n  _pausedStateChanged() {\n    var _this$_recorderApp3;\n    // If we are called upon page.pause, we don't have metadatas, populate them.\n    for (const {\n      metadata,\n      sdkObject\n    } of this._debugger.pausedDetails()) {\n      if (!this._currentCallsMetadata.has(metadata)) this.onBeforeCall(sdkObject, metadata);\n    }\n    (_this$_recorderApp3 = this._recorderApp) === null || _this$_recorderApp3 === void 0 ? void 0 : _this$_recorderApp3.setPaused(this._debugger.isPaused());\n    this._updateUserSources();\n    this.updateCallLog([...this._currentCallsMetadata.keys()]);\n  }\n  setMode(mode) {\n    var _this$_recorderApp4;\n    if (this._mode === mode) return;\n    this._highlightedSelector = '';\n    this._mode = mode;\n    (_this$_recorderApp4 = this._recorderApp) === null || _this$_recorderApp4 === void 0 ? void 0 : _this$_recorderApp4.setMode(this._mode);\n    this._contextRecorder.setEnabled(this._mode === 'recording');\n    this._debugger.setMuted(this._mode === 'recording');\n    if (this._mode !== 'none' && this._context.pages().length === 1) this._context.pages()[0].bringToFront().catch(() => {});\n    this._refreshOverlay();\n  }\n  resume() {\n    this._debugger.resume(false);\n  }\n  setHighlightedSelector(language, selector) {\n    this._highlightedSelector = (0, _locatorParser.locatorOrSelectorAsSelector)(language, selector, this._context.selectors().testIdAttributeName());\n    this._refreshOverlay();\n  }\n  hideHighlightedSelecor() {\n    this._highlightedSelector = '';\n    this._refreshOverlay();\n  }\n  setOutput(codegenId, outputFile) {\n    this._contextRecorder.setOutput(codegenId, outputFile);\n  }\n  _refreshOverlay() {\n    for (const page of this._context.pages()) page.mainFrame().evaluateExpression('window.__pw_refreshOverlay()', false, undefined, 'main').catch(() => {});\n  }\n  async onBeforeCall(sdkObject, metadata) {\n    if (this._omitCallTracking || this._mode === 'recording') return;\n    this._currentCallsMetadata.set(metadata, sdkObject);\n    this._updateUserSources();\n    this.updateCallLog([metadata]);\n    if (isScreenshotCommand(metadata)) {\n      this.hideHighlightedSelecor();\n    } else if (metadata.params && metadata.params.selector) {\n      var _this$_recorderApp5;\n      this._highlightedSelector = metadata.params.selector;\n      (_this$_recorderApp5 = this._recorderApp) === null || _this$_recorderApp5 === void 0 ? void 0 : _this$_recorderApp5.setSelector(this._highlightedSelector).catch(() => {});\n    }\n  }\n  async onAfterCall(sdkObject, metadata) {\n    if (this._omitCallTracking || this._mode === 'recording') return;\n    if (!metadata.error) this._currentCallsMetadata.delete(metadata);\n    this._updateUserSources();\n    this.updateCallLog([metadata]);\n  }\n  _updateUserSources() {\n    var _this$_recorderApp6;\n    // Remove old decorations.\n    for (const source of this._userSources.values()) {\n      source.highlight = [];\n      source.revealLine = undefined;\n    }\n\n    // Apply new decorations.\n    let fileToSelect = undefined;\n    for (const metadata of this._currentCallsMetadata.keys()) {\n      if (!metadata.stack || !metadata.stack[0]) continue;\n      const {\n        file,\n        line\n      } = metadata.stack[0];\n      let source = this._userSources.get(file);\n      if (!source) {\n        source = {\n          isRecorded: false,\n          label: file,\n          id: file,\n          text: this._readSource(file),\n          highlight: [],\n          language: languageForFile(file)\n        };\n        this._userSources.set(file, source);\n      }\n      if (line) {\n        const paused = this._debugger.isPaused(metadata);\n        source.highlight.push({\n          line,\n          type: metadata.error ? 'error' : paused ? 'paused' : 'running'\n        });\n        source.revealLine = line;\n        fileToSelect = source.id;\n      }\n    }\n    this._pushAllSources();\n    if (fileToSelect) (_this$_recorderApp6 = this._recorderApp) === null || _this$_recorderApp6 === void 0 ? void 0 : _this$_recorderApp6.setFileIfNeeded(fileToSelect);\n  }\n  _pushAllSources() {\n    var _this$_recorderApp7;\n    (_this$_recorderApp7 = this._recorderApp) === null || _this$_recorderApp7 === void 0 ? void 0 : _this$_recorderApp7.setSources([...this._recorderSources, ...this._userSources.values()]);\n  }\n  async onBeforeInputAction(sdkObject, metadata) {}\n  async onCallLog(sdkObject, metadata, logName, message) {\n    this.updateCallLog([metadata]);\n  }\n  updateCallLog(metadatas) {\n    var _this$_recorderApp8;\n    if (this._mode === 'recording') return;\n    const logs = [];\n    for (const metadata of metadatas) {\n      if (!metadata.method || metadata.internal) continue;\n      let status = 'done';\n      if (this._currentCallsMetadata.has(metadata)) status = 'in-progress';\n      if (this._debugger.isPaused(metadata)) status = 'paused';\n      logs.push((0, _recorderUtils.metadataToCallLog)(metadata, status));\n    }\n    (_this$_recorderApp8 = this._recorderApp) === null || _this$_recorderApp8 === void 0 ? void 0 : _this$_recorderApp8.updateCallLogs(logs);\n  }\n  _readSource(fileName) {\n    try {\n      return fs.readFileSync(fileName, 'utf-8');\n    } catch (e) {\n      return '// No source available';\n    }\n  }\n}\nexports.Recorder = Recorder;\nRecorder.recorderAppFactory = void 0;\nclass ContextRecorder extends _events.EventEmitter {\n  constructor(context, params) {\n    super();\n    this._generator = void 0;\n    this._pageAliases = new Map();\n    this._lastPopupOrdinal = 0;\n    this._lastDialogOrdinal = -1;\n    this._lastDownloadOrdinal = -1;\n    this._timers = new Set();\n    this._context = void 0;\n    this._params = void 0;\n    this._recorderSources = void 0;\n    this._throttledOutputFile = null;\n    this._orderedLanguages = [];\n    this._testIdAttributeName = 'data-testid';\n    this._context = context;\n    this._params = params;\n    this._recorderSources = [];\n    const language = params.language || context._browser.options.sdkLanguage;\n    this.setOutput(language, params.outputFile);\n    const generator = new _codeGenerator.CodeGenerator(context._browser.options.name, params.mode === 'recording', params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);\n    generator.on('change', () => {\n      this._recorderSources = [];\n      for (const languageGenerator of this._orderedLanguages) {\n        var _this$_throttledOutpu;\n        const {\n          header,\n          footer,\n          actions,\n          text\n        } = generator.generateStructure(languageGenerator);\n        const source = {\n          isRecorded: true,\n          label: languageGenerator.name,\n          group: languageGenerator.groupName,\n          id: languageGenerator.id,\n          text,\n          header,\n          footer,\n          actions,\n          language: languageGenerator.highlighter,\n          highlight: []\n        };\n        source.revealLine = text.split('\\n').length - 1;\n        this._recorderSources.push(source);\n        if (languageGenerator === this._orderedLanguages[0]) (_this$_throttledOutpu = this._throttledOutputFile) === null || _this$_throttledOutpu === void 0 ? void 0 : _this$_throttledOutpu.setContent(source.text);\n      }\n      this.emit(ContextRecorder.Events.Change, {\n        sources: this._recorderSources,\n        primaryFileName: this._orderedLanguages[0].id\n      });\n    });\n    context.on(_browserContext.BrowserContext.Events.BeforeClose, () => {\n      var _this$_throttledOutpu2;\n      (_this$_throttledOutpu2 = this._throttledOutputFile) === null || _this$_throttledOutpu2 === void 0 ? void 0 : _this$_throttledOutpu2.flush();\n    });\n    process.on('exit', () => {\n      var _this$_throttledOutpu3;\n      (_this$_throttledOutpu3 = this._throttledOutputFile) === null || _this$_throttledOutpu3 === void 0 ? void 0 : _this$_throttledOutpu3.flush();\n    });\n    this._generator = generator;\n  }\n  setOutput(codegenId, outputFile) {\n    var _this$_generator;\n    const languages = new Set([new _java.JavaLanguageGenerator(), new _javascript.JavaScriptLanguageGenerator( /* isPlaywrightTest */false), new _javascript.JavaScriptLanguageGenerator( /* isPlaywrightTest */true), new _python.PythonLanguageGenerator( /* isAsync */false, /* isPytest */true), new _python.PythonLanguageGenerator( /* isAsync */false, /* isPytest */false), new _python.PythonLanguageGenerator( /* isAsync */true, /* isPytest */false), new _csharp.CSharpLanguageGenerator('mstest'), new _csharp.CSharpLanguageGenerator('nunit'), new _csharp.CSharpLanguageGenerator('library')]);\n    const primaryLanguage = [...languages].find(l => l.id === codegenId);\n    if (!primaryLanguage) throw new Error(`\\n===============================\\nUnsupported language: '${codegenId}'\\n===============================\\n`);\n    languages.delete(primaryLanguage);\n    this._orderedLanguages = [primaryLanguage, ...languages];\n    this._throttledOutputFile = outputFile ? new ThrottledFile(outputFile) : null;\n    (_this$_generator = this._generator) === null || _this$_generator === void 0 ? void 0 : _this$_generator.restart();\n  }\n  languageName(id) {\n    for (const lang of this._orderedLanguages) {\n      if (!id || lang.id === id) return lang.highlighter;\n    }\n    return 'javascript';\n  }\n  async install() {\n    this._context.on(_browserContext.BrowserContext.Events.Page, page => this._onPage(page));\n    for (const page of this._context.pages()) this._onPage(page);\n\n    // Input actions that potentially lead to navigation are intercepted on the page and are\n    // performed by the Playwright.\n    await this._context.exposeBinding('__pw_recorderPerformAction', false, (source, action) => this._performAction(source.frame, action));\n\n    // Other non-essential actions are simply being recorded.\n    await this._context.exposeBinding('__pw_recorderRecordAction', false, (source, action) => this._recordAction(source.frame, action));\n    await this._context.extendInjectedScript(recorderSource.source);\n  }\n  setEnabled(enabled) {\n    this._generator.setEnabled(enabled);\n  }\n  dispose() {\n    for (const timer of this._timers) clearTimeout(timer);\n    this._timers.clear();\n  }\n  async _onPage(page) {\n    // First page is called page, others are called popup1, popup2, etc.\n    const frame = page.mainFrame();\n    page.on('close', () => {\n      this._generator.addAction({\n        frame: this._describeMainFrame(page),\n        committed: true,\n        action: {\n          name: 'closePage',\n          signals: []\n        }\n      });\n      this._pageAliases.delete(page);\n    });\n    frame.on(_frames.Frame.Events.InternalNavigation, event => {\n      if (event.isPublic) this._onFrameNavigated(frame, page);\n    });\n    page.on(_page.Page.Events.Download, () => this._onDownload(page));\n    page.on(_page.Page.Events.Dialog, () => this._onDialog(page));\n    const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : '';\n    const pageAlias = 'page' + suffix;\n    this._pageAliases.set(page, pageAlias);\n    if (page.opener()) {\n      this._onPopup(page.opener(), page);\n    } else {\n      this._generator.addAction({\n        frame: this._describeMainFrame(page),\n        committed: true,\n        action: {\n          name: 'openPage',\n          url: page.mainFrame().url(),\n          signals: []\n        }\n      });\n    }\n  }\n  clearScript() {\n    this._generator.restart();\n    if (this._params.mode === 'recording') {\n      for (const page of this._context.pages()) this._onFrameNavigated(page.mainFrame(), page);\n    }\n  }\n  _describeMainFrame(page) {\n    return {\n      pageAlias: this._pageAliases.get(page),\n      isMainFrame: true,\n      url: page.mainFrame().url()\n    };\n  }\n  async _describeFrame(frame) {\n    const page = frame._page;\n    const pageAlias = this._pageAliases.get(page);\n    const chain = [];\n    for (let ancestor = frame; ancestor; ancestor = ancestor.parentFrame()) chain.push(ancestor);\n    chain.reverse();\n    if (chain.length === 1) return this._describeMainFrame(page);\n    const hasUniqueName = page.frames().filter(f => f.name() === frame.name()).length === 1;\n    const fallback = {\n      pageAlias,\n      isMainFrame: false,\n      url: frame.url(),\n      name: frame.name() && hasUniqueName ? frame.name() : undefined\n    };\n    if (chain.length > 3) return fallback;\n    const selectorPromises = [];\n    for (let i = 0; i < chain.length - 1; i++) selectorPromises.push(this._findFrameSelector(chain[i + 1], chain[i]));\n    const result = await (0, _timeoutRunner.raceAgainstTimeout)(() => Promise.all(selectorPromises), 2000);\n    if (!result.timedOut && result.result.every(selector => !!selector)) {\n      return {\n        ...fallback,\n        selectorsChain: result.result\n      };\n    }\n    return fallback;\n  }\n  async _findFrameSelector(frame, parent) {\n    try {\n      const frameElement = await frame.frameElement();\n      if (!frameElement) return;\n      const utility = await parent._utilityContext();\n      const injected = await utility.injectedScript();\n      const selector = await injected.evaluate((injected, element) => injected.generateSelector(element, this._testIdAttributeName), frameElement);\n      return selector;\n    } catch (e) {}\n  }\n  async _performAction(frame, action) {\n    // Commit last action so that no further signals are added to it.\n    this._generator.commitLastAction();\n    const frameDescription = await this._describeFrame(frame);\n    const actionInContext = {\n      frame: frameDescription,\n      action\n    };\n    const perform = async (action, params, cb) => {\n      const callMetadata = {\n        id: `call@${(0, _utils2.createGuid)()}`,\n        apiName: 'frame.' + action,\n        objectId: frame.guid,\n        pageId: frame._page.guid,\n        frameId: frame.guid,\n        wallTime: Date.now(),\n        startTime: (0, _utils2.monotonicTime)(),\n        endTime: 0,\n        type: 'Frame',\n        method: action,\n        params,\n        log: [],\n        snapshots: []\n      };\n      this._generator.willPerformAction(actionInContext);\n      try {\n        await frame.instrumentation.onBeforeCall(frame, callMetadata);\n        await cb(callMetadata);\n      } catch (e) {\n        callMetadata.endTime = (0, _utils2.monotonicTime)();\n        await frame.instrumentation.onAfterCall(frame, callMetadata);\n        this._generator.performedActionFailed(actionInContext);\n        return;\n      }\n      callMetadata.endTime = (0, _utils2.monotonicTime)();\n      await frame.instrumentation.onAfterCall(frame, callMetadata);\n      const timer = setTimeout(() => {\n        // Commit the action after 5 seconds so that no further signals are added to it.\n        actionInContext.committed = true;\n        this._timers.delete(timer);\n      }, 5000);\n      this._generator.didPerformAction(actionInContext);\n      this._timers.add(timer);\n    };\n    const kActionTimeout = 5000;\n    if (action.name === 'click') {\n      const {\n        options\n      } = (0, _utils.toClickOptions)(action);\n      await perform('click', {\n        selector: action.selector\n      }, callMetadata => frame.click(callMetadata, action.selector, {\n        ...options,\n        timeout: kActionTimeout,\n        strict: true\n      }));\n    }\n    if (action.name === 'press') {\n      const modifiers = (0, _utils.toModifiers)(action.modifiers);\n      const shortcut = [...modifiers, action.key].join('+');\n      await perform('press', {\n        selector: action.selector,\n        key: shortcut\n      }, callMetadata => frame.press(callMetadata, action.selector, shortcut, {\n        timeout: kActionTimeout,\n        strict: true\n      }));\n    }\n    if (action.name === 'check') await perform('check', {\n      selector: action.selector\n    }, callMetadata => frame.check(callMetadata, action.selector, {\n      timeout: kActionTimeout,\n      strict: true\n    }));\n    if (action.name === 'uncheck') await perform('uncheck', {\n      selector: action.selector\n    }, callMetadata => frame.uncheck(callMetadata, action.selector, {\n      timeout: kActionTimeout,\n      strict: true\n    }));\n    if (action.name === 'select') {\n      const values = action.options.map(value => ({\n        value\n      }));\n      await perform('selectOption', {\n        selector: action.selector,\n        values\n      }, callMetadata => frame.selectOption(callMetadata, action.selector, [], values, {\n        timeout: kActionTimeout,\n        strict: true\n      }));\n    }\n  }\n  async _recordAction(frame, action) {\n    // Commit last action so that no further signals are added to it.\n    this._generator.commitLastAction();\n    const frameDescription = await this._describeFrame(frame);\n    const actionInContext = {\n      frame: frameDescription,\n      action\n    };\n    this._generator.addAction(actionInContext);\n  }\n  _onFrameNavigated(frame, page) {\n    const pageAlias = this._pageAliases.get(page);\n    this._generator.signal(pageAlias, frame, {\n      name: 'navigation',\n      url: frame.url()\n    });\n  }\n  _onPopup(page, popup) {\n    const pageAlias = this._pageAliases.get(page);\n    const popupAlias = this._pageAliases.get(popup);\n    this._generator.signal(pageAlias, page.mainFrame(), {\n      name: 'popup',\n      popupAlias\n    });\n  }\n  _onDownload(page) {\n    const pageAlias = this._pageAliases.get(page);\n    ++this._lastDownloadOrdinal;\n    this._generator.signal(pageAlias, page.mainFrame(), {\n      name: 'download',\n      downloadAlias: this._lastDownloadOrdinal ? String(this._lastDownloadOrdinal) : ''\n    });\n  }\n  _onDialog(page) {\n    const pageAlias = this._pageAliases.get(page);\n    ++this._lastDialogOrdinal;\n    this._generator.signal(pageAlias, page.mainFrame(), {\n      name: 'dialog',\n      dialogAlias: this._lastDialogOrdinal ? String(this._lastDialogOrdinal) : ''\n    });\n  }\n}\nContextRecorder.Events = {\n  Change: 'change'\n};\nfunction languageForFile(file) {\n  if (file.endsWith('.py')) return 'python';\n  if (file.endsWith('.java')) return 'java';\n  if (file.endsWith('.cs')) return 'csharp';\n  return 'javascript';\n}\nclass ThrottledFile {\n  constructor(file) {\n    this._file = void 0;\n    this._timer = void 0;\n    this._text = void 0;\n    this._file = file;\n  }\n  setContent(text) {\n    this._text = text;\n    if (!this._timer) this._timer = setTimeout(() => this.flush(), 250);\n  }\n  flush() {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n    if (this._text) fs.writeFileSync(this._file, this._text);\n    this._text = undefined;\n  }\n}\nfunction isScreenshotCommand(metadata) {\n  return metadata.method.toLowerCase().includes('screenshot');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGenerator = void 0;\nvar _events = require(\"events\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass CodeGenerator extends _events.EventEmitter {\n  constructor(browserName, enabled, launchOptions, contextOptions, deviceName, saveStorage) {\n    super();\n\n    // Make a copy of options to modify them later.\n    this._currentAction = null;\n    this._lastAction = null;\n    this._actions = [];\n    this._enabled = void 0;\n    this._options = void 0;\n    launchOptions = {\n      headless: false,\n      ...launchOptions\n    };\n    contextOptions = {\n      ...contextOptions\n    };\n    this._enabled = enabled;\n    this._options = {\n      browserName,\n      launchOptions,\n      contextOptions,\n      deviceName,\n      saveStorage\n    };\n    this.restart();\n  }\n  restart() {\n    this._currentAction = null;\n    this._lastAction = null;\n    this._actions = [];\n    this.emit('change');\n  }\n  setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n  addAction(action) {\n    if (!this._enabled) return;\n    this.willPerformAction(action);\n    this.didPerformAction(action);\n  }\n  willPerformAction(action) {\n    if (!this._enabled) return;\n    this._currentAction = action;\n  }\n  performedActionFailed(action) {\n    if (!this._enabled) return;\n    if (this._currentAction === action) this._currentAction = null;\n  }\n  didPerformAction(actionInContext) {\n    if (!this._enabled) return;\n    const action = actionInContext.action;\n    let eraseLastAction = false;\n    if (this._lastAction && this._lastAction.frame.pageAlias === actionInContext.frame.pageAlias) {\n      const lastAction = this._lastAction.action;\n      // We augment last action based on the type.\n      if (this._lastAction && action.name === 'fill' && lastAction.name === 'fill') {\n        if (action.selector === lastAction.selector) eraseLastAction = true;\n      }\n      if (lastAction && action.name === 'click' && lastAction.name === 'click') {\n        if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount) eraseLastAction = true;\n      }\n      if (lastAction && action.name === 'navigate' && lastAction.name === 'navigate') {\n        if (action.url === lastAction.url) {\n          // Already at a target URL.\n          this._currentAction = null;\n          return;\n        }\n      }\n      // Check and uncheck erase click.\n      if (lastAction && (action.name === 'check' || action.name === 'uncheck') && lastAction.name === 'click') {\n        if (action.selector === lastAction.selector) eraseLastAction = true;\n      }\n    }\n    this._lastAction = actionInContext;\n    this._currentAction = null;\n    if (eraseLastAction) this._actions.pop();\n    this._actions.push(actionInContext);\n    this.emit('change');\n  }\n  commitLastAction() {\n    if (!this._enabled) return;\n    const action = this._lastAction;\n    if (action) action.committed = true;\n  }\n  signal(pageAlias, frame, signal) {\n    if (!this._enabled) return;\n\n    // Signal either arrives while action is being performed or shortly after.\n    if (this._currentAction) {\n      this._currentAction.action.signals.push(signal);\n      return;\n    }\n    if (this._lastAction && !this._lastAction.committed) {\n      const signals = this._lastAction.action.signals;\n      if (signal.name === 'navigation' && signals.length && signals[signals.length - 1].name === 'download') return;\n      if (signal.name === 'download' && signals.length && signals[signals.length - 1].name === 'navigation') signals.length = signals.length - 1;\n      this._lastAction.action.signals.push(signal);\n      this.emit('change');\n      return;\n    }\n    if (signal.name === 'navigation') {\n      this.addAction({\n        frame: {\n          pageAlias,\n          isMainFrame: frame._page.mainFrame() === frame,\n          url: frame.url()\n        },\n        committed: true,\n        action: {\n          name: 'navigate',\n          url: frame.url(),\n          signals: []\n        }\n      });\n    }\n  }\n  generateStructure(languageGenerator) {\n    const header = languageGenerator.generateHeader(this._options);\n    const footer = languageGenerator.generateFooter(this._options.saveStorage);\n    const actions = this._actions.map(a => languageGenerator.generateAction(a)).filter(Boolean);\n    const text = [header, ...actions, footer].join('\\n');\n    return {\n      header,\n      footer,\n      actions,\n      text\n    };\n  }\n}\nexports.CodeGenerator = CodeGenerator;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CSharpLanguageGenerator = void 0;\nvar _language = require(\"./language\");\nvar _utils = require(\"./utils\");\nvar _stringUtils = require(\"../../utils/isomorphic/stringUtils\");\nvar _locatorGenerators = require(\"../isomorphic/locatorGenerators\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst deviceDescriptors = require('../deviceDescriptorsSource.json');\nclass CSharpLanguageGenerator {\n  constructor(mode) {\n    this.id = void 0;\n    this.groupName = '.NET C#';\n    this.name = void 0;\n    this.highlighter = 'csharp';\n    this._mode = void 0;\n    if (mode === 'library') {\n      this.name = 'Library';\n      this.id = 'csharp';\n    } else if (mode === 'mstest') {\n      this.name = 'MSTest';\n      this.id = 'csharp-mstest';\n    } else if (mode === 'nunit') {\n      this.name = 'NUnit';\n      this.id = 'csharp-nunit';\n    } else {\n      throw new Error(`Unknown C# language mode: ${mode}`);\n    }\n    this._mode = mode;\n  }\n  generateAction(actionInContext) {\n    const action = this._generateActionInner(actionInContext);\n    if (action) return action + '\\n';\n    return '';\n  }\n  _generateActionInner(actionInContext) {\n    const action = actionInContext.action;\n    if (this._mode !== 'library' && (action.name === 'openPage' || action.name === 'closePage')) return '';\n    let pageAlias = actionInContext.frame.pageAlias;\n    if (this._mode !== 'library') pageAlias = pageAlias.replace('page', 'Page');\n    const formatter = new CSharpFormatter(8);\n    if (action.name === 'openPage') {\n      formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);\n      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);\n      return formatter.format();\n    }\n    let subject;\n    if (actionInContext.frame.isMainFrame) {\n      subject = pageAlias;\n    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {\n      const locators = actionInContext.frame.selectorsChain.map(selector => `.FrameLocator(${quote(selector)})`);\n      subject = `${pageAlias}${locators.join('')}`;\n    } else if (actionInContext.frame.name) {\n      subject = `${pageAlias}.Frame(${quote(actionInContext.frame.name)})`;\n    } else {\n      subject = `${pageAlias}.FrameByUrl(${quote(actionInContext.frame.url)})`;\n    }\n    const signals = (0, _language.toSignalMap)(action);\n    if (signals.dialog) {\n      formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)\n      {\n          Console.WriteLine($\"Dialog message: {dialog.Message}\");\n          dialog.DismissAsync();\n          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;\n      }\n      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);\n    }\n    const lines = [];\n    const actionCall = this._generateActionCall(action, actionInContext.frame.isMainFrame);\n    lines.push(`await ${subject}.${actionCall};`);\n    if (signals.download) {\n      lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>\\n{`);\n      lines.push(`});`);\n    }\n    if (signals.popup) {\n      lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>\\n{`);\n      lines.push(`});`);\n    }\n    for (const line of lines) formatter.add(line);\n    return formatter.format();\n  }\n  _generateActionCall(action, isPage) {\n    switch (action.name) {\n      case 'openPage':\n        throw Error('Not reached');\n      case 'closePage':\n        return 'CloseAsync()';\n      case 'click':\n        {\n          let method = 'Click';\n          if (action.clickCount === 2) method = 'DblClick';\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const options = {};\n          if (action.button !== 'left') options.button = action.button;\n          if (modifiers.length) options.modifiers = modifiers;\n          if (action.clickCount > 2) options.clickCount = action.clickCount;\n          if (action.position) options.position = action.position;\n          if (!Object.entries(options).length) return this._asLocator(action.selector) + `.${method}Async()`;\n          const optionsString = formatObject(options, '    ', 'Locator' + method + 'Options');\n          return this._asLocator(action.selector) + `.${method}Async(${optionsString})`;\n        }\n      case 'check':\n        return this._asLocator(action.selector) + `.CheckAsync()`;\n      case 'uncheck':\n        return this._asLocator(action.selector) + `.UncheckAsync()`;\n      case 'fill':\n        return this._asLocator(action.selector) + `.FillAsync(${quote(action.text)})`;\n      case 'setInputFiles':\n        return this._asLocator(action.selector) + `.SetInputFilesAsync(${formatObject(action.files)})`;\n      case 'press':\n        {\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const shortcut = [...modifiers, action.key].join('+');\n          return this._asLocator(action.selector) + `.PressAsync(${quote(shortcut)})`;\n        }\n      case 'navigate':\n        return `GotoAsync(${quote(action.url)})`;\n      case 'select':\n        return this._asLocator(action.selector) + `.SelectOptionAsync(${formatObject(action.options)})`;\n    }\n  }\n  _asLocator(selector) {\n    return (0, _locatorGenerators.asLocator)('csharp', selector);\n  }\n  generateHeader(options) {\n    if (this._mode === 'library') return this.generateStandaloneHeader(options);\n    return this.generateTestRunnerHeader(options);\n  }\n  generateStandaloneHeader(options) {\n    const formatter = new CSharpFormatter(0);\n    formatter.add(`\n      using Microsoft.Playwright;\n      using System;\n      using System.Threading.Tasks;\n\n      class Program\n      {\n          public static async Task Main()\n          {\n              using var playwright = await Playwright.CreateAsync();\n              await using var browser = await playwright.${toPascal(options.browserName)}.LaunchAsync(${formatObject(options.launchOptions, '    ', 'BrowserTypeLaunchOptions')});\n              var context = await browser.NewContextAsync(${formatContextOptions(options.contextOptions, options.deviceName)});`);\n    formatter.newLine();\n    return formatter.format();\n  }\n  generateTestRunnerHeader(options) {\n    const formatter = new CSharpFormatter(0);\n    formatter.add(`\n      using Microsoft.Playwright.${this._mode === 'nunit' ? 'NUnit' : 'MSTest'};\n      using Microsoft.Playwright;\n\n      ${this._mode === 'nunit' ? `[Parallelizable(ParallelScope.Self)]\n      [TestFixture]` : '[TestClass]'}\n      public class Tests : PageTest\n      {`);\n    const formattedContextOptions = formatContextOptions(options.contextOptions, options.deviceName);\n    if (formattedContextOptions) {\n      formatter.add(`public override BrowserNewContextOptions ContextOptions()\n      {\n          return ${formattedContextOptions};\n      }`);\n      formatter.newLine();\n    }\n    formatter.add(`    [${this._mode === 'nunit' ? 'Test' : 'TestMethod'}]\n    public async Task MyTest()\n    {`);\n    return formatter.format();\n  }\n  generateFooter(saveStorage) {\n    const storageStateLine = saveStorage ? `\\n        await context.StorageStateAsync(new BrowserContextStorageStateOptions\\n        {\\n            Path = ${quote(saveStorage)}\\n        });\\n` : '';\n    return `${storageStateLine}    }\n}\\n`;\n  }\n}\nexports.CSharpLanguageGenerator = CSharpLanguageGenerator;\nfunction formatObject(value, indent = '    ', name = '') {\n  if (typeof value === 'string') {\n    if (['permissions', 'colorScheme', 'modifiers', 'button', 'recordHarContent', 'recordHarMode', 'serviceWorkers'].includes(name)) return `${getClassName(name)}.${toPascal(value)}`;\n    return quote(value);\n  }\n  if (Array.isArray(value)) return `new[] { ${value.map(o => formatObject(o, indent, name)).join(', ')} }`;\n  if (typeof value === 'object') {\n    const keys = Object.keys(value).filter(key => value[key] !== undefined).sort();\n    if (!keys.length) return name ? `new ${getClassName(name)}` : '';\n    const tokens = [];\n    for (const key of keys) {\n      const property = getPropertyName(key);\n      tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);\n    }\n    if (name) return `new ${getClassName(name)}\\n{\\n${indent}${tokens.join(`\\n${indent}`)}\\n${indent}}`;\n    return `{\\n${indent}${tokens.join(`\\n${indent}`)}\\n${indent}}`;\n  }\n  if (name === 'latitude' || name === 'longitude') return String(value) + 'm';\n  return String(value);\n}\nfunction getClassName(value) {\n  switch (value) {\n    case 'viewport':\n      return 'ViewportSize';\n    case 'proxy':\n      return 'ProxySettings';\n    case 'permissions':\n      return 'ContextPermission';\n    case 'modifiers':\n      return 'KeyboardModifier';\n    case 'button':\n      return 'MouseButton';\n    case 'recordHarMode':\n      return 'HarMode';\n    case 'recordHarContent':\n      return 'HarContentPolicy';\n    case 'serviceWorkers':\n      return 'ServiceWorkerPolicy';\n    default:\n      return toPascal(value);\n  }\n}\nfunction getPropertyName(key) {\n  switch (key) {\n    case 'storageState':\n      return 'StorageStatePath';\n    case 'viewport':\n      return 'ViewportSize';\n    default:\n      return toPascal(key);\n  }\n}\nfunction toPascal(value) {\n  return value[0].toUpperCase() + value.slice(1);\n}\nfunction convertContextOptions(options) {\n  const result = {\n    ...options\n  };\n  if (options.recordHar) {\n    result['recordHarPath'] = options.recordHar.path;\n    result['recordHarContent'] = options.recordHar.content;\n    result['recordHarMode'] = options.recordHar.mode;\n    result['recordHarOmitContent'] = options.recordHar.omitContent;\n    result['recordHarUrlFilter'] = options.recordHar.urlFilter;\n    delete result.recordHar;\n  }\n  return result;\n}\nfunction formatContextOptions(options, deviceName) {\n  const device = deviceName && deviceDescriptors[deviceName];\n  if (!device) {\n    if (!Object.entries(options).length) return '';\n    return formatObject(convertContextOptions(options), '    ', 'BrowserNewContextOptions');\n  }\n  options = (0, _language.sanitizeDeviceOptions)(device, options);\n  if (!Object.entries(options).length) return `playwright.Devices[${quote(deviceName)}]`;\n  return formatObject(convertContextOptions(options), '    ', `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);\n}\nclass CSharpFormatter {\n  constructor(offset = 0) {\n    this._baseIndent = void 0;\n    this._baseOffset = void 0;\n    this._lines = [];\n    this._baseIndent = ' '.repeat(4);\n    this._baseOffset = ' '.repeat(offset);\n  }\n  prepend(text) {\n    this._lines = text.trim().split('\\n').map(line => line.trim()).concat(this._lines);\n  }\n  add(text) {\n    this._lines.push(...text.trim().split('\\n').map(line => line.trim()));\n  }\n  newLine() {\n    this._lines.push('');\n  }\n  format() {\n    let spaces = '';\n    let previousLine = '';\n    return this._lines.map(line => {\n      if (line === '') return line;\n      if (line.startsWith('}') || line.startsWith(']') || line.includes('});') || line === ');') spaces = spaces.substring(this._baseIndent.length);\n      const extraSpaces = /^(for|while|if).*\\(.*\\)$/.test(previousLine) ? this._baseIndent : '';\n      previousLine = line;\n      line = spaces + extraSpaces + line;\n      if (line.endsWith('{') || line.endsWith('[') || line.endsWith('(')) spaces += this._baseIndent;\n      if (line.endsWith('));')) spaces = spaces.substring(this._baseIndent.length);\n      return this._baseOffset + line;\n    }).join('\\n');\n  }\n}\nfunction quote(text) {\n  return (0, _stringUtils.escapeWithQuotes)(text, '\\\"');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JavaLanguageGenerator = void 0;\nvar _language = require(\"./language\");\nvar _utils = require(\"./utils\");\nvar _javascript = require(\"./javascript\");\nvar _stringUtils = require(\"../../utils/isomorphic/stringUtils\");\nvar _locatorGenerators = require(\"../isomorphic/locatorGenerators\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst deviceDescriptors = require('../deviceDescriptorsSource.json');\nclass JavaLanguageGenerator {\n  constructor() {\n    this.id = 'java';\n    this.groupName = 'Java';\n    this.name = 'Library';\n    this.highlighter = 'java';\n  }\n  generateAction(actionInContext) {\n    const action = actionInContext.action;\n    const pageAlias = actionInContext.frame.pageAlias;\n    const formatter = new _javascript.JavaScriptFormatter(6);\n    if (action.name === 'openPage') {\n      formatter.add(`Page ${pageAlias} = context.newPage();`);\n      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`${pageAlias}.navigate(${quote(action.url)});`);\n      return formatter.format();\n    }\n    let subject;\n    let inFrameLocator = false;\n    if (actionInContext.frame.isMainFrame) {\n      subject = pageAlias;\n    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {\n      const locators = actionInContext.frame.selectorsChain.map(selector => `.frameLocator(${quote(selector)})`);\n      subject = `${pageAlias}${locators.join('')}`;\n      inFrameLocator = true;\n    } else if (actionInContext.frame.name) {\n      subject = `${pageAlias}.frame(${quote(actionInContext.frame.name)})`;\n    } else {\n      subject = `${pageAlias}.frameByUrl(${quote(actionInContext.frame.url)})`;\n    }\n    const signals = (0, _language.toSignalMap)(action);\n    if (signals.dialog) {\n      formatter.add(`  ${pageAlias}.onceDialog(dialog -> {\n        System.out.println(String.format(\"Dialog message: %s\", dialog.message()));\n        dialog.dismiss();\n      });`);\n    }\n    const actionCall = this._generateActionCall(action, inFrameLocator);\n    let code = `${subject}.${actionCall};`;\n    if (signals.popup) {\n      code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {\n        ${code}\n      });`;\n    }\n    if (signals.download) {\n      code = `Download download${signals.download.downloadAlias} = ${pageAlias}.waitForDownload(() -> {\n        ${code}\n      });`;\n    }\n    formatter.add(code);\n    return formatter.format();\n  }\n  _generateActionCall(action, inFrameLocator) {\n    switch (action.name) {\n      case 'openPage':\n        throw Error('Not reached');\n      case 'closePage':\n        return 'close()';\n      case 'click':\n        {\n          let method = 'click';\n          if (action.clickCount === 2) method = 'dblclick';\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const options = {};\n          if (action.button !== 'left') options.button = action.button;\n          if (modifiers.length) options.modifiers = modifiers;\n          if (action.clickCount > 2) options.clickCount = action.clickCount;\n          if (action.position) options.position = action.position;\n          const optionsText = formatClickOptions(options);\n          return this._asLocator(action.selector, inFrameLocator) + `.${method}(${optionsText})`;\n        }\n      case 'check':\n        return this._asLocator(action.selector, inFrameLocator) + `.check()`;\n      case 'uncheck':\n        return this._asLocator(action.selector, inFrameLocator) + `.uncheck()`;\n      case 'fill':\n        return this._asLocator(action.selector, inFrameLocator) + `.fill(${quote(action.text)})`;\n      case 'setInputFiles':\n        return this._asLocator(action.selector, inFrameLocator) + `.setInputFiles(${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;\n      case 'press':\n        {\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const shortcut = [...modifiers, action.key].join('+');\n          return this._asLocator(action.selector, inFrameLocator) + `.press(${quote(shortcut)})`;\n        }\n      case 'navigate':\n        return `navigate(${quote(action.url)})`;\n      case 'select':\n        return this._asLocator(action.selector, inFrameLocator) + `.selectOption(${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;\n    }\n  }\n  _asLocator(selector, inFrameLocator) {\n    return (0, _locatorGenerators.asLocator)('java', selector, inFrameLocator);\n  }\n  generateHeader(options) {\n    const formatter = new _javascript.JavaScriptFormatter();\n    formatter.add(`\n    import com.microsoft.playwright.*;\n    import com.microsoft.playwright.options.*;\n    import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;\n    import java.util.*;\n\n    public class Example {\n      public static void main(String[] args) {\n        try (Playwright playwright = Playwright.create()) {\n          Browser browser = playwright.${options.browserName}().launch(${formatLaunchOptions(options.launchOptions)});\n          BrowserContext context = browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);\n    return formatter.format();\n  }\n  generateFooter(saveStorage) {\n    const storageStateLine = saveStorage ? `\\n      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));\\n` : '';\n    return `${storageStateLine}    }\n  }\n}`;\n  }\n}\nexports.JavaLanguageGenerator = JavaLanguageGenerator;\nfunction formatPath(files) {\n  if (Array.isArray(files)) {\n    if (files.length === 0) return 'new Path[0]';\n    return `new Path[] {${files.map(s => 'Paths.get(' + quote(s) + ')').join(', ')}}`;\n  }\n  return `Paths.get(${quote(files)})`;\n}\nfunction formatSelectOption(options) {\n  if (Array.isArray(options)) {\n    if (options.length === 0) return 'new String[0]';\n    return `new String[] {${options.map(s => quote(s)).join(', ')}}`;\n  }\n  return quote(options);\n}\nfunction formatLaunchOptions(options) {\n  const lines = [];\n  if (!Object.keys(options).filter(key => options[key] !== undefined).length) return '';\n  lines.push('new BrowserType.LaunchOptions()');\n  if (options.channel) lines.push(`  .setChannel(${quote(options.channel)})`);\n  if (typeof options.headless === 'boolean') lines.push(`  .setHeadless(false)`);\n  return lines.join('\\n');\n}\nfunction formatContextOptions(contextOptions, deviceName) {\n  var _options$recordHar, _options$recordHar2, _options$recordHar3, _options$recordHar4, _options$recordHar5, _options$recordHar6, _options$recordHar7;\n  const lines = [];\n  if (!Object.keys(contextOptions).length && !deviceName) return '';\n  const device = deviceName ? deviceDescriptors[deviceName] : {};\n  const options = {\n    ...device,\n    ...contextOptions\n  };\n  lines.push('new Browser.NewContextOptions()');\n  if (options.acceptDownloads) lines.push(`  .setAcceptDownloads(true)`);\n  if (options.bypassCSP) lines.push(`  .setBypassCSP(true)`);\n  if (options.colorScheme) lines.push(`  .setColorScheme(ColorScheme.${options.colorScheme.toUpperCase()})`);\n  if (options.deviceScaleFactor) lines.push(`  .setDeviceScaleFactor(${options.deviceScaleFactor})`);\n  if (options.geolocation) lines.push(`  .setGeolocation(${options.geolocation.latitude}, ${options.geolocation.longitude})`);\n  if (options.hasTouch) lines.push(`  .setHasTouch(${options.hasTouch})`);\n  if (options.isMobile) lines.push(`  .setIsMobile(${options.isMobile})`);\n  if (options.locale) lines.push(`  .setLocale(${quote(options.locale)})`);\n  if (options.proxy) lines.push(`  .setProxy(new Proxy(${quote(options.proxy.server)}))`);\n  if ((_options$recordHar = options.recordHar) !== null && _options$recordHar !== void 0 && _options$recordHar.content) lines.push(`  .setRecordHarContent(HarContentPolicy.${(_options$recordHar2 = options.recordHar) === null || _options$recordHar2 === void 0 ? void 0 : _options$recordHar2.content.toUpperCase()})`);\n  if ((_options$recordHar3 = options.recordHar) !== null && _options$recordHar3 !== void 0 && _options$recordHar3.mode) lines.push(`  .setRecordHarMode(HarMode.${(_options$recordHar4 = options.recordHar) === null || _options$recordHar4 === void 0 ? void 0 : _options$recordHar4.mode.toUpperCase()})`);\n  if ((_options$recordHar5 = options.recordHar) !== null && _options$recordHar5 !== void 0 && _options$recordHar5.omitContent) lines.push(`  .setRecordHarOmitContent(true)`);\n  if ((_options$recordHar6 = options.recordHar) !== null && _options$recordHar6 !== void 0 && _options$recordHar6.path) lines.push(`  .setRecordHarPath(Paths.get(${quote(options.recordHar.path)}))`);\n  if ((_options$recordHar7 = options.recordHar) !== null && _options$recordHar7 !== void 0 && _options$recordHar7.urlFilter) lines.push(`  .setRecordHarUrlFilter(${quote(options.recordHar.urlFilter)})`);\n  if (options.serviceWorkers) lines.push(`  .setServiceWorkers(ServiceWorkerPolicy.${options.serviceWorkers.toUpperCase()})`);\n  if (options.storageState) lines.push(`  .setStorageStatePath(Paths.get(${quote(options.storageState)}))`);\n  if (options.timezoneId) lines.push(`  .setTimezoneId(${quote(options.timezoneId)})`);\n  if (options.userAgent) lines.push(`  .setUserAgent(${quote(options.userAgent)})`);\n  if (options.viewport) lines.push(`  .setViewportSize(${options.viewport.width}, ${options.viewport.height})`);\n  return lines.join('\\n');\n}\nfunction formatClickOptions(options) {\n  const lines = [];\n  if (options.button) lines.push(`  .setButton(MouseButton.${options.button.toUpperCase()})`);\n  if (options.modifiers) lines.push(`  .setModifiers(Arrays.asList(${options.modifiers.map(m => `KeyboardModifier.${m.toUpperCase()}`).join(', ')}))`);\n  if (options.clickCount) lines.push(`  .setClickCount(${options.clickCount})`);\n  if (options.position) lines.push(`  .setPosition(${options.position.x}, ${options.position.y})`);\n  if (!lines.length) return '';\n  lines.unshift(`new Locator.ClickOptions()`);\n  return lines.join('\\n');\n}\nfunction quote(text) {\n  return (0, _stringUtils.escapeWithQuotes)(text, '\\\"');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JavaScriptLanguageGenerator = exports.JavaScriptFormatter = void 0;\nvar _language = require(\"./language\");\nvar _utils = require(\"./utils\");\nvar _stringUtils = require(\"../../utils/isomorphic/stringUtils\");\nvar _locatorGenerators = require(\"../isomorphic/locatorGenerators\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst deviceDescriptors = require('../deviceDescriptorsSource.json');\nclass JavaScriptLanguageGenerator {\n  constructor(isTest) {\n    this.id = void 0;\n    this.groupName = 'Node.js';\n    this.name = void 0;\n    this.highlighter = 'javascript';\n    this._isTest = void 0;\n    this.id = isTest ? 'playwright-test' : 'javascript';\n    this.name = isTest ? 'Test Runner' : 'Library';\n    this._isTest = isTest;\n  }\n  generateAction(actionInContext) {\n    const action = actionInContext.action;\n    if (this._isTest && (action.name === 'openPage' || action.name === 'closePage')) return '';\n    const pageAlias = actionInContext.frame.pageAlias;\n    const formatter = new JavaScriptFormatter(2);\n    if (action.name === 'openPage') {\n      formatter.add(`const ${pageAlias} = await context.newPage();`);\n      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);\n      return formatter.format();\n    }\n    let subject;\n    if (actionInContext.frame.isMainFrame) {\n      subject = pageAlias;\n    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {\n      const locators = actionInContext.frame.selectorsChain.map(selector => `.frameLocator(${quote(selector)})`);\n      subject = `${pageAlias}${locators.join('')}`;\n    } else if (actionInContext.frame.name) {\n      subject = `${pageAlias}.frame(${formatObject({\n        name: actionInContext.frame.name\n      })})`;\n    } else {\n      subject = `${pageAlias}.frame(${formatObject({\n        url: actionInContext.frame.url\n      })})`;\n    }\n    const signals = (0, _language.toSignalMap)(action);\n    if (signals.dialog) {\n      formatter.add(`  ${pageAlias}.once('dialog', dialog => {\n    console.log(\\`Dialog message: $\\{dialog.message()}\\`);\n    dialog.dismiss().catch(() => {});\n  });`);\n    }\n    if (signals.popup) formatter.add(`const ${signals.popup.popupAlias}Promise = ${pageAlias}.waitForEvent('popup');`);\n    if (signals.download) formatter.add(`const download${signals.download.downloadAlias}Promise = ${pageAlias}.waitForEvent('download');`);\n    const actionCall = this._generateActionCall(action);\n    formatter.add(`await ${subject}.${actionCall};`);\n    if (signals.popup) formatter.add(`const ${signals.popup.popupAlias} = await ${signals.popup.popupAlias}Promise;`);\n    if (signals.download) formatter.add(`const download${signals.download.downloadAlias} = await download${signals.download.downloadAlias}Promise;`);\n    return formatter.format();\n  }\n  _generateActionCall(action) {\n    switch (action.name) {\n      case 'openPage':\n        throw Error('Not reached');\n      case 'closePage':\n        return 'close()';\n      case 'click':\n        {\n          let method = 'click';\n          if (action.clickCount === 2) method = 'dblclick';\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const options = {};\n          if (action.button !== 'left') options.button = action.button;\n          if (modifiers.length) options.modifiers = modifiers;\n          if (action.clickCount > 2) options.clickCount = action.clickCount;\n          if (action.position) options.position = action.position;\n          const optionsString = formatOptions(options, false);\n          return this._asLocator(action.selector) + `.${method}(${optionsString})`;\n        }\n      case 'check':\n        return this._asLocator(action.selector) + `.check()`;\n      case 'uncheck':\n        return this._asLocator(action.selector) + `.uncheck()`;\n      case 'fill':\n        return this._asLocator(action.selector) + `.fill(${quote(action.text)})`;\n      case 'setInputFiles':\n        return this._asLocator(action.selector) + `.setInputFiles(${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;\n      case 'press':\n        {\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const shortcut = [...modifiers, action.key].join('+');\n          return this._asLocator(action.selector) + `.press(${quote(shortcut)})`;\n        }\n      case 'navigate':\n        return `goto(${quote(action.url)})`;\n      case 'select':\n        return this._asLocator(action.selector) + `.selectOption(${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;\n    }\n  }\n  _asLocator(selector) {\n    return (0, _locatorGenerators.asLocator)('javascript', selector);\n  }\n  generateHeader(options) {\n    if (this._isTest) return this.generateTestHeader(options);\n    return this.generateStandaloneHeader(options);\n  }\n  generateFooter(saveStorage) {\n    if (this._isTest) return this.generateTestFooter(saveStorage);\n    return this.generateStandaloneFooter(saveStorage);\n  }\n  generateTestHeader(options) {\n    const formatter = new JavaScriptFormatter();\n    const useText = formatContextOptions(options.contextOptions, options.deviceName);\n    formatter.add(`\n      import { test, expect${options.deviceName ? ', devices' : ''} } from '@playwright/test';\n${useText ? '\\ntest.use(' + useText + ');\\n' : ''}\n      test('test', async ({ page }) => {`);\n    return formatter.format();\n  }\n  generateTestFooter(saveStorage) {\n    return `});`;\n  }\n  generateStandaloneHeader(options) {\n    const formatter = new JavaScriptFormatter();\n    formatter.add(`\n      const { ${options.browserName}${options.deviceName ? ', devices' : ''} } = require('playwright');\n\n      (async () => {\n        const browser = await ${options.browserName}.launch(${formatObjectOrVoid(options.launchOptions)});\n        const context = await browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);\n    return formatter.format();\n  }\n  generateStandaloneFooter(saveStorage) {\n    const storageStateLine = saveStorage ? `\\n  await context.storageState({ path: ${quote(saveStorage)} });` : '';\n    return `\\n  // ---------------------${storageStateLine}\n  await context.close();\n  await browser.close();\n})();`;\n  }\n}\nexports.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;\nfunction formatOptions(value, hasArguments) {\n  const keys = Object.keys(value);\n  if (!keys.length) return '';\n  return (hasArguments ? ', ' : '') + formatObject(value);\n}\nfunction formatObject(value, indent = '  ') {\n  if (typeof value === 'string') return quote(value);\n  if (Array.isArray(value)) return `[${value.map(o => formatObject(o)).join(', ')}]`;\n  if (typeof value === 'object') {\n    const keys = Object.keys(value).filter(key => value[key] !== undefined).sort();\n    if (!keys.length) return '{}';\n    const tokens = [];\n    for (const key of keys) tokens.push(`${key}: ${formatObject(value[key])}`);\n    return `{\\n${indent}${tokens.join(`,\\n${indent}`)}\\n}`;\n  }\n  return String(value);\n}\nfunction formatObjectOrVoid(value, indent = '  ') {\n  const result = formatObject(value, indent);\n  return result === '{}' ? '' : result;\n}\nfunction formatContextOptions(options, deviceName) {\n  const device = deviceName && deviceDescriptors[deviceName];\n  if (!device) return formatObjectOrVoid(options);\n  // Filter out all the properties from the device descriptor.\n  let serializedObject = formatObjectOrVoid((0, _language.sanitizeDeviceOptions)(device, options));\n  // When there are no additional context options, we still want to spread the device inside.\n  if (!serializedObject) serializedObject = '{\\n}';\n  const lines = serializedObject.split('\\n');\n  lines.splice(1, 0, `...devices[${quote(deviceName)}],`);\n  return lines.join('\\n');\n}\nclass JavaScriptFormatter {\n  constructor(offset = 0) {\n    this._baseIndent = void 0;\n    this._baseOffset = void 0;\n    this._lines = [];\n    this._baseIndent = ' '.repeat(2);\n    this._baseOffset = ' '.repeat(offset);\n  }\n  prepend(text) {\n    this._lines = text.trim().split('\\n').map(line => line.trim()).concat(this._lines);\n  }\n  add(text) {\n    this._lines.push(...text.trim().split('\\n').map(line => line.trim()));\n  }\n  newLine() {\n    this._lines.push('');\n  }\n  format() {\n    let spaces = '';\n    let previousLine = '';\n    return this._lines.map(line => {\n      if (line === '') return line;\n      if (line.startsWith('}') || line.startsWith(']')) spaces = spaces.substring(this._baseIndent.length);\n      const extraSpaces = /^(for|while|if|try).*\\(.*\\)$/.test(previousLine) ? this._baseIndent : '';\n      previousLine = line;\n      const callCarryOver = line.startsWith('.set');\n      line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : '') + line;\n      if (line.endsWith('{') || line.endsWith('[')) spaces += this._baseIndent;\n      return this._baseOffset + line;\n    }).join('\\n');\n  }\n}\nexports.JavaScriptFormatter = JavaScriptFormatter;\nfunction quote(text) {\n  return (0, _stringUtils.escapeWithQuotes)(text, '\\'');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sanitizeDeviceOptions = sanitizeDeviceOptions;\nexports.toSignalMap = toSignalMap;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction sanitizeDeviceOptions(device, options) {\n  // Filter out all the properties from the device descriptor.\n  const cleanedOptions = {};\n  for (const property in options) {\n    if (JSON.stringify(device[property]) !== JSON.stringify(options[property])) cleanedOptions[property] = options[property];\n  }\n  return cleanedOptions;\n}\nfunction toSignalMap(action) {\n  let popup;\n  let download;\n  let dialog;\n  for (const signal of action.signals) {\n    if (signal.name === 'popup') popup = signal;else if (signal.name === 'download') download = signal;else if (signal.name === 'dialog') dialog = signal;\n  }\n  return {\n    popup,\n    download,\n    dialog\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PythonLanguageGenerator = void 0;\nvar _language = require(\"./language\");\nvar _utils = require(\"./utils\");\nvar _stringUtils = require(\"../../utils/isomorphic/stringUtils\");\nvar _locatorGenerators = require(\"../isomorphic/locatorGenerators\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst deviceDescriptors = require('../deviceDescriptorsSource.json');\nclass PythonLanguageGenerator {\n  constructor(isAsync, isPyTest) {\n    this.id = void 0;\n    this.groupName = 'Python';\n    this.name = void 0;\n    this.highlighter = 'python';\n    this._awaitPrefix = void 0;\n    this._asyncPrefix = void 0;\n    this._isAsync = void 0;\n    this._isPyTest = void 0;\n    this.id = isPyTest ? 'python-pytest' : isAsync ? 'python-async' : 'python';\n    this.name = isPyTest ? 'Pytest' : isAsync ? 'Library Async' : 'Library';\n    this._isAsync = isAsync;\n    this._isPyTest = isPyTest;\n    this._awaitPrefix = isAsync ? 'await ' : '';\n    this._asyncPrefix = isAsync ? 'async ' : '';\n  }\n  generateAction(actionInContext) {\n    const action = actionInContext.action;\n    if (this._isPyTest && (action.name === 'openPage' || action.name === 'closePage')) return '';\n    const pageAlias = actionInContext.frame.pageAlias;\n    const formatter = new PythonFormatter(4);\n    if (action.name === 'openPage') {\n      formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);\n      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);\n      return formatter.format();\n    }\n    let subject;\n    if (actionInContext.frame.isMainFrame) {\n      subject = pageAlias;\n    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {\n      const locators = actionInContext.frame.selectorsChain.map(selector => `.frame_locator(${quote(selector)})`);\n      subject = `${pageAlias}${locators.join('')}`;\n    } else if (actionInContext.frame.name) {\n      subject = `${pageAlias}.frame(${formatOptions({\n        name: actionInContext.frame.name\n      }, false)})`;\n    } else {\n      subject = `${pageAlias}.frame(${formatOptions({\n        url: actionInContext.frame.url\n      }, false)})`;\n    }\n    const signals = (0, _language.toSignalMap)(action);\n    if (signals.dialog) formatter.add(`  ${pageAlias}.once(\"dialog\", lambda dialog: dialog.dismiss())`);\n    const actionCall = this._generateActionCall(action);\n    let code = `${this._awaitPrefix}${subject}.${actionCall}`;\n    if (signals.popup) {\n      code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as ${signals.popup.popupAlias}_info {\n        ${code}\n      }\n      ${signals.popup.popupAlias} = ${this._awaitPrefix}${signals.popup.popupAlias}_info.value`;\n    }\n    if (signals.download) {\n      code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download${signals.download.downloadAlias}_info {\n        ${code}\n      }\n      download${signals.download.downloadAlias} = ${this._awaitPrefix}download${signals.download.downloadAlias}_info.value`;\n    }\n    formatter.add(code);\n    return formatter.format();\n  }\n  _generateActionCall(action) {\n    switch (action.name) {\n      case 'openPage':\n        throw Error('Not reached');\n      case 'closePage':\n        return 'close()';\n      case 'click':\n        {\n          let method = 'click';\n          if (action.clickCount === 2) method = 'dblclick';\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const options = {};\n          if (action.button !== 'left') options.button = action.button;\n          if (modifiers.length) options.modifiers = modifiers;\n          if (action.clickCount > 2) options.clickCount = action.clickCount;\n          if (action.position) options.position = action.position;\n          const optionsString = formatOptions(options, false);\n          return this._asLocator(action.selector) + `.${method}(${optionsString})`;\n        }\n      case 'check':\n        return this._asLocator(action.selector) + `.check()`;\n      case 'uncheck':\n        return this._asLocator(action.selector) + `.uncheck()`;\n      case 'fill':\n        return this._asLocator(action.selector) + `.fill(${quote(action.text)})`;\n      case 'setInputFiles':\n        return this._asLocator(action.selector) + `.set_input_files(${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;\n      case 'press':\n        {\n          const modifiers = (0, _utils.toModifiers)(action.modifiers);\n          const shortcut = [...modifiers, action.key].join('+');\n          return this._asLocator(action.selector) + `.press(${quote(shortcut)})`;\n        }\n      case 'navigate':\n        return `goto(${quote(action.url)})`;\n      case 'select':\n        return this._asLocator(action.selector) + `.select_option(${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;\n    }\n  }\n  _asLocator(selector) {\n    return (0, _locatorGenerators.asLocator)('python', selector);\n  }\n  generateHeader(options) {\n    const formatter = new PythonFormatter();\n    if (this._isPyTest) {\n      const contextOptions = formatContextOptions(options.contextOptions, options.deviceName, true /* asDict */);\n      const fixture = contextOptions ? `\n\n@pytest.fixture(scope=\"session\")\ndef browser_context_args(browser_context_args, playwright) {\n    return {${contextOptions}}\n}\n` : '';\n      formatter.add(`${options.deviceName ? 'import pytest\\n' : ''}\nfrom playwright.sync_api import Page, expect\n${fixture}\n\ndef test_example(page: Page) -> None {`);\n    } else if (this._isAsync) {\n      formatter.add(`\nimport asyncio\n\nfrom playwright.async_api import Playwright, async_playwright, expect\n\n\nasync def run(playwright: Playwright) -> None {\n    browser = await playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})\n    context = await browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);\n    } else {\n      formatter.add(`\nfrom playwright.sync_api import Playwright, sync_playwright, expect\n\n\ndef run(playwright: Playwright) -> None {\n    browser = playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})\n    context = browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);\n    }\n    return formatter.format();\n  }\n  generateFooter(saveStorage) {\n    if (this._isPyTest) {\n      return '';\n    } else if (this._isAsync) {\n      const storageStateLine = saveStorage ? `\\n    await context.storage_state(path=${quote(saveStorage)})` : '';\n      return `\\n    # ---------------------${storageStateLine}\n    await context.close()\n    await browser.close()\n\n\nasync def main() -> None:\n    async with async_playwright() as playwright:\n        await run(playwright)\n\n\nasyncio.run(main())\n`;\n    } else {\n      const storageStateLine = saveStorage ? `\\n    context.storage_state(path=${quote(saveStorage)})` : '';\n      return `\\n    # ---------------------${storageStateLine}\n    context.close()\n    browser.close()\n\n\nwith sync_playwright() as playwright:\n    run(playwright)\n`;\n    }\n  }\n}\nexports.PythonLanguageGenerator = PythonLanguageGenerator;\nfunction formatValue(value) {\n  if (value === false) return 'False';\n  if (value === true) return 'True';\n  if (value === undefined) return 'None';\n  if (Array.isArray(value)) return `[${value.map(formatValue).join(', ')}]`;\n  if (typeof value === 'string') return quote(value);\n  if (typeof value === 'object') return JSON.stringify(value);\n  return String(value);\n}\nfunction formatOptions(value, hasArguments, asDict) {\n  const keys = Object.keys(value).filter(key => value[key] !== undefined).sort();\n  if (!keys.length) return '';\n  return (hasArguments ? ', ' : '') + keys.map(key => {\n    if (asDict) return `\"${(0, _stringUtils.toSnakeCase)(key)}\": ${formatValue(value[key])}`;\n    return `${(0, _stringUtils.toSnakeCase)(key)}=${formatValue(value[key])}`;\n  }).join(', ');\n}\nfunction convertContextOptions(options) {\n  const result = {\n    ...options\n  };\n  if (options.recordHar) {\n    result['record_har_path'] = options.recordHar.path;\n    result['record_har_content'] = options.recordHar.content;\n    result['record_har_mode'] = options.recordHar.mode;\n    result['record_har_omit_content'] = options.recordHar.omitContent;\n    result['record_har_url_filter'] = options.recordHar.urlFilter;\n    delete result.recordHar;\n  }\n  return result;\n}\nfunction formatContextOptions(options, deviceName, asDict) {\n  const device = deviceName && deviceDescriptors[deviceName];\n  if (!device) return formatOptions(convertContextOptions(options), false, asDict);\n  return `**playwright.devices[${quote(deviceName)}]` + formatOptions(convertContextOptions((0, _language.sanitizeDeviceOptions)(device, options)), true, asDict);\n}\nclass PythonFormatter {\n  constructor(offset = 0) {\n    this._baseIndent = void 0;\n    this._baseOffset = void 0;\n    this._lines = [];\n    this._baseIndent = ' '.repeat(4);\n    this._baseOffset = ' '.repeat(offset);\n  }\n  prepend(text) {\n    this._lines = text.trim().split('\\n').map(line => line.trim()).concat(this._lines);\n  }\n  add(text) {\n    this._lines.push(...text.trim().split('\\n').map(line => line.trim()));\n  }\n  newLine() {\n    this._lines.push('');\n  }\n  format() {\n    let spaces = '';\n    const lines = [];\n    this._lines.forEach(line => {\n      if (line === '') return lines.push(line);\n      if (line === '}') {\n        spaces = spaces.substring(this._baseIndent.length);\n        return;\n      }\n      line = spaces + line;\n      if (line.endsWith('{')) {\n        spaces += this._baseIndent;\n        line = line.substring(0, line.length - 1).trimEnd() + ':';\n      }\n      return lines.push(this._baseOffset + line);\n    });\n    return lines.join('\\n');\n  }\n}\nfunction quote(text) {\n  return (0, _stringUtils.escapeWithQuotes)(text, '\\\"');\n}",null,"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.metadataToCallLog = metadataToCallLog;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction metadataToCallLog(metadata, status) {\n  var _metadata$params, _metadata$params2, _metadata$error, _metadata$error$error;\n  let title = metadata.apiName || metadata.method;\n  if (metadata.method === 'waitForEventInfo') title += `(${metadata.params.info.event})`;\n  title = title.replace('object.expect', 'expect');\n  if (metadata.error) status = 'error';\n  const params = {\n    url: (_metadata$params = metadata.params) === null || _metadata$params === void 0 ? void 0 : _metadata$params.url,\n    selector: (_metadata$params2 = metadata.params) === null || _metadata$params2 === void 0 ? void 0 : _metadata$params2.selector\n  };\n  let duration = metadata.endTime ? metadata.endTime - metadata.startTime : undefined;\n  if (typeof duration === 'number' && metadata.pauseStartTime && metadata.pauseEndTime) {\n    duration -= metadata.pauseEndTime - metadata.pauseStartTime;\n    duration = Math.max(duration, 0);\n  }\n  const callLog = {\n    id: metadata.id,\n    messages: metadata.log,\n    title,\n    status,\n    error: (_metadata$error = metadata.error) === null || _metadata$error === void 0 ? void 0 : (_metadata$error$error = _metadata$error.error) === null || _metadata$error$error === void 0 ? void 0 : _metadata$error$error.message,\n    params,\n    duration\n  };\n  return callLog;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toClickOptions = toClickOptions;\nexports.toModifiers = toModifiers;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction toClickOptions(action) {\n  let method = 'click';\n  if (action.clickCount === 2) method = 'dblclick';\n  const modifiers = toModifiers(action.modifiers);\n  const options = {};\n  if (action.button !== 'left') options.button = action.button;\n  if (modifiers.length) options.modifiers = modifiers;\n  if (action.clickCount > 2) options.clickCount = action.clickCount;\n  if (action.position) options.position = action.position;\n  return {\n    method,\n    options\n  };\n}\nfunction toModifiers(modifiers) {\n  const result = [];\n  if (modifiers & 1) result.push('Alt');\n  if (modifiers & 2) result.push('Control');\n  if (modifiers & 4) result.push('Meta');\n  if (modifiers & 8) result.push('Shift');\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.downloadBrowserWithProgressBar = downloadBrowserWithProgressBar;\nexports.logPolitely = logPolitely;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _child_process = _interopRequireDefault(require(\"child_process\"));\nvar _userAgent = require(\"../../utils/userAgent\");\nvar _fileUtils = require(\"../../utils/fileUtils\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _zipBundle = require(\"../../zipBundle\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nvar _utilsBundle = require(\"../../utilsBundle\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nasync function downloadBrowserWithProgressBar(title, browserDirectory, executablePath, downloadURLs, downloadFileName, downloadConnectionTimeout) {\n  if (await (0, _fileUtils.existsAsync)(browserDirectory)) {\n    // Already downloaded.\n    _debugLogger.debugLogger.log('install', `${title} is already downloaded.`);\n    return false;\n  }\n  const zipPath = _path.default.join(_os.default.tmpdir(), downloadFileName);\n  try {\n    const retryCount = 3;\n    for (let attempt = 1; attempt <= retryCount; ++attempt) {\n      _debugLogger.debugLogger.log('install', `downloading ${title} - attempt #${attempt}`);\n      const url = downloadURLs[(attempt - 1) % downloadURLs.length];\n      logPolitely(`Downloading ${title}` + _utilsBundle.colors.dim(` from ${url}`));\n      const {\n        error\n      } = await downloadFileOutOfProcess(url, zipPath, (0, _userAgent.getUserAgent)(), downloadConnectionTimeout);\n      if (!error) {\n        _debugLogger.debugLogger.log('install', `SUCCESS downloading ${title}`);\n        break;\n      }\n      const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';\n      _debugLogger.debugLogger.log('install', `attempt #${attempt} - ERROR: ${errorMessage}`);\n      if (attempt >= retryCount) throw error;\n    }\n    _debugLogger.debugLogger.log('install', `extracting archive`);\n    _debugLogger.debugLogger.log('install', `-- zip: ${zipPath}`);\n    _debugLogger.debugLogger.log('install', `-- location: ${browserDirectory}`);\n    await (0, _zipBundle.extract)(zipPath, {\n      dir: browserDirectory\n    });\n    if (executablePath) {\n      _debugLogger.debugLogger.log('install', `fixing permissions at ${executablePath}`);\n      await _fs.default.promises.chmod(executablePath, 0o755);\n    }\n  } catch (e) {\n    _debugLogger.debugLogger.log('install', `FAILED installation ${title} with error: ${e}`);\n    process.exitCode = 1;\n    throw e;\n  } finally {\n    if (await (0, _fileUtils.existsAsync)(zipPath)) await _fs.default.promises.unlink(zipPath);\n  }\n  logPolitely(`${title} downloaded to ${browserDirectory}`);\n  return true;\n}\n\n/**\n * Node.js has a bug where the process can exit with 0 code even though there was an uncaught exception.\n * Thats why we execute it in a separate process and check manually if the destination file exists.\n * https://github.com/microsoft/playwright/issues/17394\n */\nfunction downloadFileOutOfProcess(url, destinationPath, userAgent, downloadConnectionTimeout) {\n  const cp = _child_process.default.fork(_path.default.join(__dirname, 'oopDownloadMain.js'), [url, destinationPath, userAgent, String(downloadConnectionTimeout)]);\n  const promise = new _manualPromise.ManualPromise();\n  cp.on('message', message => {\n    if ((message === null || message === void 0 ? void 0 : message.method) === 'log') _debugLogger.debugLogger.log('install', message.params.message);\n  });\n  cp.on('exit', code => {\n    if (code !== 0) {\n      promise.resolve({\n        error: new Error(`Download failure, code=${code}`)\n      });\n      return;\n    }\n    if (!_fs.default.existsSync(destinationPath)) promise.resolve({\n      error: new Error(`Download failure, ${destinationPath} does not exist`)\n    });else promise.resolve({\n      error: null\n    });\n  });\n  cp.on('error', error => {\n    promise.resolve({\n      error\n    });\n  });\n  return promise;\n}\nfunction logPolitely(toBeLogged) {\n  const logLevel = process.env.npm_config_loglevel;\n  const logLevelDisplay = ['silent', 'error', 'warn'].indexOf(logLevel || '') > -1;\n  if (!logLevelDisplay) console.log(toBeLogged); // eslint-disable-line no-console\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dockerVersion = dockerVersion;\nexports.installDependenciesLinux = installDependenciesLinux;\nexports.installDependenciesWindows = installDependenciesWindows;\nexports.readDockerVersionSync = readDockerVersionSync;\nexports.transformCommandsForRoot = transformCommandsForRoot;\nexports.validateDependenciesLinux = validateDependenciesLinux;\nexports.validateDependenciesWindows = validateDependenciesWindows;\nexports.writeDockerVersion = writeDockerVersion;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar os = _interopRequireWildcard(require(\"os\"));\nvar _child_process = _interopRequireDefault(require(\"child_process\"));\nvar utils = _interopRequireWildcard(require(\"../../utils\"));\nvar _spawnAsync = require(\"../../utils/spawnAsync\");\nvar _hostPlatform = require(\"../../utils/hostPlatform\");\nvar _ = require(\".\");\nvar _nativeDeps = require(\"./nativeDeps\");\nvar _userAgent = require(\"../../utils/userAgent\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst BIN_DIRECTORY = _path.default.join(__dirname, '..', '..', '..', 'bin');\nconst languageBindingVersion = process.env.PW_CLI_DISPLAY_VERSION || require('../../../package.json').version;\nconst dockerVersionFilePath = '/ms-playwright/.docker-info';\nasync function writeDockerVersion(dockerImageNameTemplate) {\n  await _fs.default.promises.mkdir(_path.default.dirname(dockerVersionFilePath), {\n    recursive: true\n  });\n  await _fs.default.promises.writeFile(dockerVersionFilePath, JSON.stringify(dockerVersion(dockerImageNameTemplate), null, 2), 'utf8');\n  // Make sure version file is globally accessible.\n  await _fs.default.promises.chmod(dockerVersionFilePath, 0o777);\n}\nfunction dockerVersion(dockerImageNameTemplate) {\n  return {\n    driverVersion: languageBindingVersion,\n    dockerImageName: dockerImageNameTemplate.replace('%version%', languageBindingVersion)\n  };\n}\nfunction readDockerVersionSync() {\n  try {\n    const data = JSON.parse(_fs.default.readFileSync(dockerVersionFilePath, 'utf8'));\n    return {\n      ...data,\n      dockerImageNameTemplate: data.dockerImageName.replace(data.driverVersion, '%version%')\n    };\n  } catch (e) {\n    return null;\n  }\n}\nconst checkExecutable = filePath => _fs.default.promises.access(filePath, _fs.default.constants.X_OK).then(() => true).catch(e => false);\nfunction isSupportedWindowsVersion() {\n  if (os.platform() !== 'win32' || os.arch() !== 'x64') return false;\n  const [major, minor] = os.release().split('.').map(token => parseInt(token, 10));\n  // This is based on: https://stackoverflow.com/questions/42524606/how-to-get-windows-version-using-node-js/44916050#44916050\n  // The table with versions is taken from: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoexw#remarks\n  // Windows 7 is not supported and is encoded as `6.1`.\n  return major > 6 || major === 6 && minor > 1;\n}\nasync function installDependenciesWindows(targets, dryRun) {\n  if (targets.has('chromium')) {\n    const command = 'powershell.exe';\n    const args = ['-ExecutionPolicy', 'Bypass', '-File', _path.default.join(BIN_DIRECTORY, 'install_media_pack.ps1')];\n    if (dryRun) {\n      console.log(`${command} ${quoteProcessArgs(args).join(' ')}`); // eslint-disable-line no-console\n      return;\n    }\n    const {\n      code\n    } = await (0, _spawnAsync.spawnAsync)(command, args, {\n      cwd: BIN_DIRECTORY,\n      stdio: 'inherit'\n    });\n    if (code !== 0) throw new Error('Failed to install windows dependencies!');\n  }\n}\nasync function installDependenciesLinux(targets, dryRun) {\n  const libraries = [];\n  let platform = _hostPlatform.hostPlatform;\n  if (platform === 'generic-linux' || platform === 'generic-linux-arm64') {\n    console.warn('BEWARE: your OS is not officially supported by Playwright; installing dependencies for Ubuntu as a fallback.'); // eslint-disable-line no-console\n    platform = _hostPlatform.hostPlatform === 'generic-linux' ? 'ubuntu20.04' : 'ubuntu20.04-arm64';\n  }\n  for (const target of targets) {\n    const info = _nativeDeps.deps[platform];\n    if (!info) {\n      console.warn('Cannot install dependencies for this linux distribution!'); // eslint-disable-line no-console\n      return;\n    }\n    libraries.push(...info[target]);\n  }\n  const uniqueLibraries = Array.from(new Set(libraries));\n  if (!dryRun) console.log(`Installing dependencies...`); // eslint-disable-line no-console\n  const commands = [];\n  commands.push('apt-get update');\n  commands.push(['apt-get', 'install', '-y', '--no-install-recommends', ...uniqueLibraries].join(' '));\n  const {\n    command,\n    args,\n    elevatedPermissions\n  } = await transformCommandsForRoot(commands);\n  if (dryRun) {\n    console.log(`${command} ${quoteProcessArgs(args).join(' ')}`); // eslint-disable-line no-console\n    return;\n  }\n  if (elevatedPermissions) console.log('Switching to root user to install dependencies...'); // eslint-disable-line no-console\n  const child = _child_process.default.spawn(command, args, {\n    stdio: 'inherit'\n  });\n  await new Promise((resolve, reject) => {\n    child.on('exit', code => code === 0 ? resolve() : reject(new Error(`Installation process exited with code: ${code}`)));\n    child.on('error', reject);\n  });\n}\nasync function validateDependenciesWindows(windowsExeAndDllDirectories) {\n  const directoryPaths = windowsExeAndDllDirectories;\n  const lddPaths = [];\n  for (const directoryPath of directoryPaths) lddPaths.push(...(await executablesOrSharedLibraries(directoryPath)));\n  const allMissingDeps = await Promise.all(lddPaths.map(lddPath => missingFileDependenciesWindows(lddPath)));\n  const missingDeps = new Set();\n  for (const deps of allMissingDeps) {\n    for (const dep of deps) missingDeps.add(dep);\n  }\n  if (!missingDeps.size) return;\n  let isCrtMissing = false;\n  let isMediaFoundationMissing = false;\n  for (const dep of missingDeps) {\n    if (dep.startsWith('api-ms-win-crt') || dep === 'vcruntime140.dll' || dep === 'vcruntime140_1.dll' || dep === 'msvcp140.dll') isCrtMissing = true;else if (dep === 'mf.dll' || dep === 'mfplat.dll' || dep === 'msmpeg2vdec.dll' || dep === 'evr.dll' || dep === 'avrt.dll') isMediaFoundationMissing = true;\n  }\n  const details = [];\n  if (isCrtMissing) {\n    details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);\n  }\n  if (isMediaFoundationMissing) {\n    details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);\n  }\n  details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join('\\n    ')}`, ``);\n  const message = `Host system is missing dependencies!\\n\\n${details.join('\\n')}`;\n  if (isSupportedWindowsVersion()) {\n    throw new Error(message);\n  } else {\n    // eslint-disable-next-line no-console\n    console.warn(`WARNING: running on unsupported windows version!`);\n    // eslint-disable-next-line no-console\n    console.warn(message);\n  }\n}\nasync function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {\n  var _deps$hostPlatform;\n  const directoryPaths = linuxLddDirectories;\n  const lddPaths = [];\n  for (const directoryPath of directoryPaths) lddPaths.push(...(await executablesOrSharedLibraries(directoryPath)));\n  const missingDepsPerFile = await Promise.all(lddPaths.map(lddPath => missingFileDependencies(lddPath, directoryPaths)));\n  const missingDeps = new Set();\n  for (const deps of missingDepsPerFile) {\n    for (const dep of deps) missingDeps.add(dep);\n  }\n  for (const dep of await missingDLOPENLibraries(dlOpenLibraries)) missingDeps.add(dep);\n  if (!missingDeps.size) return;\n  const allMissingDeps = new Set(missingDeps);\n  // Check Ubuntu version.\n  const missingPackages = new Set();\n  const libraryToPackageNameMapping = _nativeDeps.deps[_hostPlatform.hostPlatform] ? {\n    ...(((_deps$hostPlatform = _nativeDeps.deps[_hostPlatform.hostPlatform]) === null || _deps$hostPlatform === void 0 ? void 0 : _deps$hostPlatform.lib2package) || {}),\n    ...MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU\n  } : {};\n  // Translate missing dependencies to package names to install with apt.\n  for (const missingDep of missingDeps) {\n    const packageName = libraryToPackageNameMapping[missingDep];\n    if (packageName) {\n      missingPackages.add(packageName);\n      missingDeps.delete(missingDep);\n    }\n  }\n  const maybeSudo = process.getuid() !== 0 && os.platform() !== 'win32' ? 'sudo ' : '';\n  const dockerInfo = readDockerVersionSync();\n  const errorLines = [`Host system is missing dependencies to run browsers.`];\n  // Ignore patch versions when comparing docker container version and Playwright version:\n  // we **NEVER** roll browsers in patch releases, so native dependencies do not change.\n  if (dockerInfo && !dockerInfo.driverVersion.startsWith((0, _userAgent.getPlaywrightVersion)(true /* majorMinorOnly */) + '.')) {\n    // We are running in a docker container with unmatching version.\n    // In this case, we know how to install dependencies in it.\n    const pwVersion = (0, _userAgent.getPlaywrightVersion)();\n    const requiredDockerImage = dockerInfo.dockerImageName.replace(dockerInfo.driverVersion, pwVersion);\n    errorLines.push(...[`This is most likely due to docker image version not matching Playwright version:`, `- Playwright: ${pwVersion}`, `-     Docker: ${dockerInfo.driverVersion}`, ``, `Either:`, `- (recommended) use docker image \"${requiredDockerImage}\"`, `- (alternative 1) run the following command inside docker to install missing dependencies:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, 'install-deps')}`, ``, `- (alternative 2) use apt inside docker:`, ``, `    ${maybeSudo}apt-get install ${[...missingPackages].join('\\\\\\n        ')}`, ``, `<3 Playwright Team`]);\n  } else if (missingPackages.size && !missingDeps.size) {\n    // Only known dependencies are missing for browsers.\n    // Suggest installation with a Playwright CLI.\n    errorLines.push(...[`Please install them with the following command:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, 'install-deps')}`, ``, `Alternatively, use apt:`, `    ${maybeSudo}apt-get install ${[...missingPackages].join('\\\\\\n        ')}`, ``, `<3 Playwright Team`]);\n  } else {\n    // Unhappy path: we either run on unknown distribution, or we failed to resolve all missing\n    // libraries to package names.\n    // Print missing libraries only:\n    errorLines.push(...[`Missing libraries:`, ...[...allMissingDeps].map(dep => '    ' + dep)]);\n  }\n  throw new Error('\\n' + utils.wrapInASCIIBox(errorLines.join('\\n'), 1));\n}\nfunction isSharedLib(basename) {\n  switch (os.platform()) {\n    case 'linux':\n      return basename.endsWith('.so') || basename.includes('.so.');\n    case 'win32':\n      return basename.endsWith('.dll');\n    default:\n      return false;\n  }\n}\nasync function executablesOrSharedLibraries(directoryPath) {\n  if (!_fs.default.existsSync(directoryPath)) return [];\n  const allPaths = (await _fs.default.promises.readdir(directoryPath)).map(file => _path.default.resolve(directoryPath, file));\n  const allStats = await Promise.all(allPaths.map(aPath => _fs.default.promises.stat(aPath)));\n  const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());\n  const executablersOrLibraries = (await Promise.all(filePaths.map(async filePath => {\n    const basename = _path.default.basename(filePath).toLowerCase();\n    if (isSharedLib(basename)) return filePath;\n    if (await checkExecutable(filePath)) return filePath;\n    return false;\n  }))).filter(Boolean);\n  return executablersOrLibraries;\n}\nasync function missingFileDependenciesWindows(filePath) {\n  const executable = _path.default.join(__dirname, '..', '..', '..', 'bin', 'PrintDeps.exe');\n  const dirname = _path.default.dirname(filePath);\n  const {\n    stdout,\n    code\n  } = await (0, _spawnAsync.spawnAsync)(executable, [filePath], {\n    cwd: dirname,\n    env: {\n      ...process.env,\n      LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname\n    }\n  });\n  if (code !== 0) return [];\n  const missingDeps = stdout.split('\\n').map(line => line.trim()).filter(line => line.endsWith('not found') && line.includes('=>')).map(line => line.split('=>')[0].trim().toLowerCase());\n  return missingDeps;\n}\nasync function missingFileDependencies(filePath, extraLDPaths) {\n  const dirname = _path.default.dirname(filePath);\n  let LD_LIBRARY_PATH = extraLDPaths.join(':');\n  if (process.env.LD_LIBRARY_PATH) LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;\n  const {\n    stdout,\n    code\n  } = await (0, _spawnAsync.spawnAsync)('ldd', [filePath], {\n    cwd: dirname,\n    env: {\n      ...process.env,\n      LD_LIBRARY_PATH\n    }\n  });\n  if (code !== 0) return [];\n  const missingDeps = stdout.split('\\n').map(line => line.trim()).filter(line => line.endsWith('not found') && line.includes('=>')).map(line => line.split('=>')[0].trim());\n  return missingDeps;\n}\nasync function missingDLOPENLibraries(libraries) {\n  if (!libraries.length) return [];\n  // NOTE: Using full-qualified path to `ldconfig` since `/sbin` is not part of the\n  // default PATH in CRON.\n  // @see https://github.com/microsoft/playwright/issues/3397\n  const {\n    stdout,\n    code,\n    error\n  } = await (0, _spawnAsync.spawnAsync)('/sbin/ldconfig', ['-p'], {});\n  if (code !== 0 || error) return [];\n  const isLibraryAvailable = library => stdout.toLowerCase().includes(library.toLowerCase());\n  return libraries.filter(library => !isLibraryAvailable(library));\n}\nconst MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {\n  // libgstlibav.so (the only actual library provided by gstreamer1.0-libav) is not\n  // in the ldconfig cache, so we detect the actual library required for playing h.264\n  // and if it's missing recommend installing missing gstreamer lib.\n  // gstreamer1.0-libav -> libavcodec57 -> libx264-152\n  'libx264.so': 'gstreamer1.0-libav'\n};\nfunction quoteProcessArgs(args) {\n  return args.map(arg => {\n    if (arg.includes(' ')) return `\"${arg}\"`;\n    return arg;\n  });\n}\nasync function transformCommandsForRoot(commands) {\n  const isRoot = process.getuid() === 0;\n  if (isRoot) return {\n    command: 'sh',\n    args: ['-c', `${commands.join('&& ')}`],\n    elevatedPermissions: false\n  };\n  const sudoExists = await (0, _spawnAsync.spawnAsync)('which', ['sudo']);\n  if (sudoExists.code === 0) return {\n    command: 'sudo',\n    args: ['--', 'sh', '-c', `${commands.join('&& ')}`],\n    elevatedPermissions: true\n  };\n  return {\n    command: 'su',\n    args: ['root', '-c', `${commands.join('&& ')}`],\n    elevatedPermissions: true\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = void 0;\nexports.buildPlaywrightCLICommand = buildPlaywrightCLICommand;\nexports.findChromiumChannel = findChromiumChannel;\nexports.installBrowsersForNpmInstall = installBrowsersForNpmInstall;\nexports.installDefaultBrowsersForNpmInstall = installDefaultBrowsersForNpmInstall;\nexports.registryDirectory = exports.registry = void 0;\nObject.defineProperty(exports, \"writeDockerVersion\", {\n  enumerable: true,\n  get: function () {\n    return _dependencies.writeDockerVersion;\n  }\n});\nvar os = _interopRequireWildcard(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar util = _interopRequireWildcard(require(\"util\"));\nvar fs = _interopRequireWildcard(require(\"fs\"));\nvar _utilsBundle = require(\"../../utilsBundle\");\nvar _linuxUtils = require(\"../../utils/linuxUtils\");\nvar _network = require(\"../../utils/network\");\nvar _userAgent = require(\"../../utils/userAgent\");\nvar _utils = require(\"../../utils\");\nvar _fileUtils = require(\"../../utils/fileUtils\");\nvar _hostPlatform = require(\"../../utils/hostPlatform\");\nvar _spawnAsync = require(\"../../utils/spawnAsync\");\nvar _dependencies = require(\"./dependencies\");\nvar _browserFetcher = require(\"./browserFetcher\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst PACKAGE_PATH = _path.default.join(__dirname, '..', '..', '..');\nconst BIN_PATH = _path.default.join(__dirname, '..', '..', '..', 'bin');\nconst PLAYWRIGHT_CDN_MIRRORS = ['https://playwright.azureedge.net', 'https://playwright-akamai.azureedge.net', 'https://playwright-verizon.azureedge.net'];\nif (process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {\n  for (let i = 0; i < PLAYWRIGHT_CDN_MIRRORS.length; i++) {\n    const cdn = PLAYWRIGHT_CDN_MIRRORS[i];\n    if (cdn !== process.env.PW_TEST_CDN_THAT_SHOULD_WORK) PLAYWRIGHT_CDN_MIRRORS[i] = cdn + '.does-not-resolve.playwright.dev';\n  }\n}\nconst EXECUTABLE_PATHS = {\n  'chromium': {\n    'linux': ['chrome-linux', 'chrome'],\n    'mac': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],\n    'win': ['chrome-win', 'chrome.exe']\n  },\n  'firefox': {\n    'linux': ['firefox', 'firefox'],\n    'mac': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],\n    'win': ['firefox', 'firefox.exe']\n  },\n  'webkit': {\n    'linux': ['pw_run.sh'],\n    'mac': ['pw_run.sh'],\n    'win': ['Playwright.exe']\n  },\n  'ffmpeg': {\n    'linux': ['ffmpeg-linux'],\n    'mac': ['ffmpeg-mac'],\n    'win': ['ffmpeg-win64.exe']\n  }\n};\nconst DOWNLOAD_PATHS = {\n  'chromium': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/chromium/%s/chromium-linux.zip',\n    'generic-linux-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',\n    'ubuntu18.04': 'builds/chromium/%s/chromium-linux.zip',\n    'ubuntu20.04': 'builds/chromium/%s/chromium-linux.zip',\n    'ubuntu22.04': 'builds/chromium/%s/chromium-linux.zip',\n    'ubuntu18.04-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',\n    'ubuntu20.04-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',\n    'ubuntu22.04-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',\n    'debian11': 'builds/chromium/%s/chromium-linux.zip',\n    'debian11-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',\n    'mac10.13': 'builds/chromium/%s/chromium-mac.zip',\n    'mac10.14': 'builds/chromium/%s/chromium-mac.zip',\n    'mac10.15': 'builds/chromium/%s/chromium-mac.zip',\n    'mac11': 'builds/chromium/%s/chromium-mac.zip',\n    'mac11-arm64': 'builds/chromium/%s/chromium-mac-arm64.zip',\n    'mac12': 'builds/chromium/%s/chromium-mac.zip',\n    'mac12-arm64': 'builds/chromium/%s/chromium-mac-arm64.zip',\n    'win64': 'builds/chromium/%s/chromium-win64.zip'\n  },\n  'chromium-tip-of-tree': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',\n    'generic-linux-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',\n    'ubuntu18.04': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',\n    'ubuntu20.04': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',\n    'ubuntu22.04': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',\n    'ubuntu18.04-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',\n    'ubuntu20.04-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',\n    'ubuntu22.04-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',\n    'debian11': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',\n    'debian11-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',\n    'mac10.13': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',\n    'mac10.14': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',\n    'mac10.15': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',\n    'mac11': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',\n    'mac11-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip',\n    'mac12': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',\n    'mac12-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip',\n    'win64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-win64.zip'\n  },\n  'chromium-with-symbols': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/chromium/%s/chromium-with-symbols-linux.zip',\n    'generic-linux-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',\n    'ubuntu18.04': 'builds/chromium/%s/chromium-with-symbols-linux.zip',\n    'ubuntu20.04': 'builds/chromium/%s/chromium-with-symbols-linux.zip',\n    'ubuntu22.04': 'builds/chromium/%s/chromium-with-symbols-linux.zip',\n    'ubuntu18.04-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',\n    'ubuntu20.04-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',\n    'ubuntu22.04-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',\n    'debian11': 'builds/chromium/%s/chromium-with-symbols-linux.zip',\n    'debian11-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',\n    'mac10.13': 'builds/chromium/%s/chromium-with-symbols-mac.zip',\n    'mac10.14': 'builds/chromium/%s/chromium-with-symbols-mac.zip',\n    'mac10.15': 'builds/chromium/%s/chromium-with-symbols-mac.zip',\n    'mac11': 'builds/chromium/%s/chromium-with-symbols-mac.zip',\n    'mac11-arm64': 'builds/chromium/%s/chromium-with-symbols-mac-arm64.zip',\n    'mac12': 'builds/chromium/%s/chromium-with-symbols-mac.zip',\n    'mac12-arm64': 'builds/chromium/%s/chromium-with-symbols-mac-arm64.zip',\n    'win64': 'builds/chromium/%s/chromium-with-symbols-win64.zip'\n  },\n  'firefox': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/firefox/%s/firefox-ubuntu-20.04.zip',\n    'generic-linux-arm64': 'builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip',\n    'ubuntu18.04': 'builds/firefox/%s/firefox-ubuntu-18.04.zip',\n    'ubuntu20.04': 'builds/firefox/%s/firefox-ubuntu-20.04.zip',\n    'ubuntu22.04': 'builds/firefox/%s/firefox-ubuntu-22.04.zip',\n    'ubuntu18.04-arm64': undefined,\n    'ubuntu20.04-arm64': 'builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip',\n    'ubuntu22.04-arm64': 'builds/firefox/%s/firefox-ubuntu-22.04-arm64.zip',\n    'debian11': 'builds/firefox/%s/firefox-debian-11.zip',\n    'debian11-arm64': 'builds/firefox/%s/firefox-debian-11-arm64.zip',\n    'mac10.13': 'builds/firefox/%s/firefox-mac-11.zip',\n    'mac10.14': 'builds/firefox/%s/firefox-mac-11.zip',\n    'mac10.15': 'builds/firefox/%s/firefox-mac-11.zip',\n    'mac11': 'builds/firefox/%s/firefox-mac-11.zip',\n    'mac11-arm64': 'builds/firefox/%s/firefox-mac-11-arm64.zip',\n    'mac12': 'builds/firefox/%s/firefox-mac-11.zip',\n    'mac12-arm64': 'builds/firefox/%s/firefox-mac-11-arm64.zip',\n    'win64': 'builds/firefox/%s/firefox-win64.zip'\n  },\n  'firefox-beta': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip',\n    'generic-linux-arm64': undefined,\n    'ubuntu18.04': 'builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip',\n    'ubuntu20.04': 'builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip',\n    'ubuntu22.04': 'builds/firefox-beta/%s/firefox-beta-ubuntu-22.04.zip',\n    'ubuntu18.04-arm64': undefined,\n    'ubuntu20.04-arm64': undefined,\n    'ubuntu22.04-arm64': 'builds/firefox-beta/%s/firefox-beta-ubuntu-22.04-arm64.zip',\n    'debian11': 'builds/firefox-beta/%s/firefox-beta-debian-11.zip',\n    'debian11-arm64': 'builds/firefox-beta/%s/firefox-beta-debian-11-arm64.zip',\n    'mac10.13': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',\n    'mac10.14': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',\n    'mac10.15': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',\n    'mac11': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',\n    'mac11-arm64': 'builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip',\n    'mac12': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',\n    'mac12-arm64': 'builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip',\n    'win64': 'builds/firefox-beta/%s/firefox-beta-win64.zip'\n  },\n  'webkit': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/webkit/%s/webkit-ubuntu-20.04.zip',\n    'generic-linux-arm64': 'builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip',\n    'ubuntu18.04': 'builds/deprecated-webkit-ubuntu-18.04/%s/deprecated-webkit-ubuntu-18.04.zip',\n    'ubuntu20.04': 'builds/webkit/%s/webkit-ubuntu-20.04.zip',\n    'ubuntu22.04': 'builds/webkit/%s/webkit-ubuntu-22.04.zip',\n    'ubuntu18.04-arm64': undefined,\n    'ubuntu20.04-arm64': 'builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip',\n    'ubuntu22.04-arm64': 'builds/webkit/%s/webkit-ubuntu-22.04-arm64.zip',\n    'debian11': 'builds/webkit/%s/webkit-debian-11.zip',\n    'debian11-arm64': 'builds/webkit/%s/webkit-debian-11-arm64.zip',\n    'mac10.13': undefined,\n    'mac10.14': 'builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip',\n    'mac10.15': 'builds/deprecated-webkit-mac-10.15/%s/deprecated-webkit-mac-10.15.zip',\n    'mac11': 'builds/webkit/%s/webkit-mac-11.zip',\n    'mac11-arm64': 'builds/webkit/%s/webkit-mac-11-arm64.zip',\n    'mac12': 'builds/webkit/%s/webkit-mac-12.zip',\n    'mac12-arm64': 'builds/webkit/%s/webkit-mac-12-arm64.zip',\n    'win64': 'builds/webkit/%s/webkit-win64.zip'\n  },\n  'ffmpeg': {\n    '<unknown>': undefined,\n    'generic-linux': 'builds/ffmpeg/%s/ffmpeg-linux.zip',\n    'generic-linux-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',\n    'ubuntu18.04': 'builds/ffmpeg/%s/ffmpeg-linux.zip',\n    'ubuntu20.04': 'builds/ffmpeg/%s/ffmpeg-linux.zip',\n    'ubuntu22.04': 'builds/ffmpeg/%s/ffmpeg-linux.zip',\n    'ubuntu18.04-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',\n    'ubuntu20.04-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',\n    'ubuntu22.04-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',\n    'debian11': 'builds/ffmpeg/%s/ffmpeg-linux.zip',\n    'debian11-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',\n    'mac10.13': 'builds/ffmpeg/%s/ffmpeg-mac.zip',\n    'mac10.14': 'builds/ffmpeg/%s/ffmpeg-mac.zip',\n    'mac10.15': 'builds/ffmpeg/%s/ffmpeg-mac.zip',\n    'mac11': 'builds/ffmpeg/%s/ffmpeg-mac.zip',\n    'mac11-arm64': 'builds/ffmpeg/%s/ffmpeg-mac-arm64.zip',\n    'mac12': 'builds/ffmpeg/%s/ffmpeg-mac.zip',\n    'mac12-arm64': 'builds/ffmpeg/%s/ffmpeg-mac-arm64.zip',\n    'win64': 'builds/ffmpeg/%s/ffmpeg-win64.zip'\n  },\n  'android': {\n    '<unknown>': 'builds/android/%s/android.zip'\n  }\n};\nconst registryDirectory = (() => {\n  let result;\n  const envDefined = (0, _utils.getFromENV)('PLAYWRIGHT_BROWSERS_PATH');\n  if (envDefined === '0') {\n    result = _path.default.join(__dirname, '..', '..', '..', '.local-browsers');\n  } else if (envDefined) {\n    result = envDefined;\n  } else {\n    let cacheDirectory;\n    if (process.platform === 'linux') cacheDirectory = process.env.XDG_CACHE_HOME || _path.default.join(os.homedir(), '.cache');else if (process.platform === 'darwin') cacheDirectory = _path.default.join(os.homedir(), 'Library', 'Caches');else if (process.platform === 'win32') cacheDirectory = process.env.LOCALAPPDATA || _path.default.join(os.homedir(), 'AppData', 'Local');else throw new Error('Unsupported platform: ' + process.platform);\n    result = _path.default.join(cacheDirectory, 'ms-playwright');\n  }\n  if (!_path.default.isAbsolute(result)) {\n    // It is important to resolve to the absolute path:\n    //   - for unzipping to work correctly;\n    //   - so that registry directory matches between installation and execution.\n    // INIT_CWD points to the root of `npm/yarn install` and is probably what\n    // the user meant when typing the relative path.\n    result = _path.default.resolve((0, _utils.getFromENV)('INIT_CWD') || process.cwd(), result);\n  }\n  return result;\n})();\nexports.registryDirectory = registryDirectory;\nfunction isBrowserDirectory(browserDirectory) {\n  const baseName = _path.default.basename(browserDirectory);\n  for (const browserName of allDownloadable) {\n    if (baseName.startsWith(browserName + '-')) return true;\n  }\n  return false;\n}\nfunction readDescriptors(browsersJSON) {\n  return browsersJSON['browsers'].map(obj => {\n    const name = obj.name;\n    const revisionOverride = (obj.revisionOverrides || {})[_hostPlatform.hostPlatform];\n    const revision = revisionOverride || obj.revision;\n    const browserDirectoryPrefix = revisionOverride ? `${name}_${_hostPlatform.hostPlatform}_special` : `${name}`;\n    const descriptor = {\n      name,\n      revision,\n      // We only put browser version for the supported operating systems.\n      browserVersion: revisionOverride ? undefined : obj.browserVersion,\n      installByDefault: !!obj.installByDefault,\n      // Method `isBrowserDirectory` determines directory to be browser iff\n      // it starts with some browser name followed by '-'. Some browser names\n      // are prefixes of others, e.g. 'webkit' is a prefix of `webkit-technology-preview`.\n      // To avoid older registries erroneously removing 'webkit-technology-preview', we have to\n      // ensure that browser folders to never include dashes inside.\n      dir: _path.default.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, '_') + '-' + revision)\n    };\n    return descriptor;\n  });\n}\nconst allDownloadable = ['chromium', 'firefox', 'webkit', 'ffmpeg', 'firefox-beta', 'chromium-with-symbols', 'chromium-tip-of-tree'];\nclass Registry {\n  constructor(browsersJSON) {\n    this._executables = void 0;\n    const descriptors = readDescriptors(browsersJSON);\n    const findExecutablePath = (dir, name) => {\n      let tokens = undefined;\n      if (process.platform === 'linux') tokens = EXECUTABLE_PATHS[name]['linux'];else if (process.platform === 'darwin') tokens = EXECUTABLE_PATHS[name]['mac'];else if (process.platform === 'win32') tokens = EXECUTABLE_PATHS[name]['win'];\n      return tokens ? _path.default.join(dir, ...tokens) : undefined;\n    };\n    const executablePathOrDie = (name, e, installByDefault, sdkLanguage) => {\n      if (!e) throw new Error(`${name} is not supported on ${_hostPlatform.hostPlatform}`);\n      const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? '' : ' ' + name}`);\n      if (!(0, _fileUtils.canAccessFile)(e)) {\n        const currentDockerVersion = (0, _dependencies.readDockerVersionSync)();\n        const preferredDockerVersion = currentDockerVersion ? (0, _dependencies.dockerVersion)(currentDockerVersion.dockerImageNameTemplate) : null;\n        const isOutdatedDockerImage = currentDockerVersion && preferredDockerVersion && currentDockerVersion.dockerImageName !== preferredDockerVersion.dockerImageName;\n        const prettyMessage = isOutdatedDockerImage ? [`Looks like ${sdkLanguage === 'javascript' ? 'Playwright Test or ' : ''}Playwright was just updated to ${preferredDockerVersion.driverVersion}.`, `Please update docker image as well.`, `-  current: ${currentDockerVersion.dockerImageName}`, `- required: ${preferredDockerVersion.dockerImageName}`, ``, `<3 Playwright Team`].join('\\n') : [`Looks like ${sdkLanguage === 'javascript' ? 'Playwright Test or ' : ''}Playwright was just installed or updated.`, `Please run the following command to download new browser${installByDefault ? 's' : ''}:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join('\\n');\n        throw new Error(`Executable doesn't exist at ${e}\\n${(0, _utils.wrapInASCIIBox)(prettyMessage, 1)}`);\n      }\n      return e;\n    };\n    this._executables = [];\n    const chromium = descriptors.find(d => d.name === 'chromium');\n    const chromiumExecutable = findExecutablePath(chromium.dir, 'chromium');\n    this._executables.push({\n      type: 'browser',\n      name: 'chromium',\n      browserName: 'chromium',\n      directory: chromium.dir,\n      executablePath: () => chromiumExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('chromium', chromiumExecutable, chromium.installByDefault, sdkLanguage),\n      installType: chromium.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'chromium', chromium.dir, ['chrome-linux'], [], ['chrome-win']),\n      downloadURLs: this._downloadURLs(chromium),\n      browserVersion: chromium.browserVersion,\n      _install: () => this._downloadExecutable(chromium, chromiumExecutable),\n      _dependencyGroup: 'chromium',\n      _isHermeticInstallation: true\n    });\n    const chromiumWithSymbols = descriptors.find(d => d.name === 'chromium-with-symbols');\n    const chromiumWithSymbolsExecutable = findExecutablePath(chromiumWithSymbols.dir, 'chromium');\n    this._executables.push({\n      type: 'tool',\n      name: 'chromium-with-symbols',\n      browserName: 'chromium',\n      directory: chromiumWithSymbols.dir,\n      executablePath: () => chromiumWithSymbolsExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('chromium-with-symbols', chromiumWithSymbolsExecutable, chromiumWithSymbols.installByDefault, sdkLanguage),\n      installType: chromiumWithSymbols.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'chromium', chromiumWithSymbols.dir, ['chrome-linux'], [], ['chrome-win']),\n      downloadURLs: this._downloadURLs(chromiumWithSymbols),\n      browserVersion: chromiumWithSymbols.browserVersion,\n      _install: () => this._downloadExecutable(chromiumWithSymbols, chromiumWithSymbolsExecutable),\n      _dependencyGroup: 'chromium',\n      _isHermeticInstallation: true\n    });\n    const chromiumTipOfTree = descriptors.find(d => d.name === 'chromium-tip-of-tree');\n    const chromiumTipOfTreeExecutable = findExecutablePath(chromiumTipOfTree.dir, 'chromium');\n    this._executables.push({\n      type: 'tool',\n      name: 'chromium-tip-of-tree',\n      browserName: 'chromium',\n      directory: chromiumTipOfTree.dir,\n      executablePath: () => chromiumTipOfTreeExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('chromium-tip-of-tree', chromiumTipOfTreeExecutable, chromiumTipOfTree.installByDefault, sdkLanguage),\n      installType: chromiumTipOfTree.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'chromium', chromiumTipOfTree.dir, ['chrome-linux'], [], ['chrome-win']),\n      downloadURLs: this._downloadURLs(chromiumTipOfTree),\n      browserVersion: chromiumTipOfTree.browserVersion,\n      _install: () => this._downloadExecutable(chromiumTipOfTree, chromiumTipOfTreeExecutable),\n      _dependencyGroup: 'chromium',\n      _isHermeticInstallation: true\n    });\n    this._executables.push(this._createChromiumChannel('chrome', {\n      'linux': '/opt/google/chrome/chrome',\n      'darwin': '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n      'win32': `\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe`\n    }, () => this._installChromiumChannel('chrome', {\n      'linux': 'reinstall_chrome_stable_linux.sh',\n      'darwin': 'reinstall_chrome_stable_mac.sh',\n      'win32': 'reinstall_chrome_stable_win.ps1'\n    })));\n    this._executables.push(this._createChromiumChannel('chrome-beta', {\n      'linux': '/opt/google/chrome-beta/chrome',\n      'darwin': '/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta',\n      'win32': `\\\\Google\\\\Chrome Beta\\\\Application\\\\chrome.exe`\n    }, () => this._installChromiumChannel('chrome-beta', {\n      'linux': 'reinstall_chrome_beta_linux.sh',\n      'darwin': 'reinstall_chrome_beta_mac.sh',\n      'win32': 'reinstall_chrome_beta_win.ps1'\n    })));\n    this._executables.push(this._createChromiumChannel('chrome-dev', {\n      'linux': '/opt/google/chrome-unstable/chrome',\n      'darwin': '/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev',\n      'win32': `\\\\Google\\\\Chrome Dev\\\\Application\\\\chrome.exe`\n    }));\n    this._executables.push(this._createChromiumChannel('chrome-canary', {\n      'linux': '',\n      'darwin': '/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary',\n      'win32': `\\\\Google\\\\Chrome SxS\\\\Application\\\\chrome.exe`\n    }));\n    this._executables.push(this._createChromiumChannel('msedge', {\n      'linux': '/opt/microsoft/msedge/msedge',\n      'darwin': '/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge',\n      'win32': `\\\\Microsoft\\\\Edge\\\\Application\\\\msedge.exe`\n    }, () => this._installMSEdgeChannel('msedge', {\n      'linux': 'reinstall_msedge_stable_linux.sh',\n      'darwin': 'reinstall_msedge_stable_mac.sh',\n      'win32': 'reinstall_msedge_stable_win.ps1'\n    })));\n    this._executables.push(this._createChromiumChannel('msedge-beta', {\n      'linux': '/opt/microsoft/msedge-beta/msedge',\n      'darwin': '/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta',\n      'win32': `\\\\Microsoft\\\\Edge Beta\\\\Application\\\\msedge.exe`\n    }, () => this._installMSEdgeChannel('msedge-beta', {\n      'darwin': 'reinstall_msedge_beta_mac.sh',\n      'linux': 'reinstall_msedge_beta_linux.sh',\n      'win32': 'reinstall_msedge_beta_win.ps1'\n    })));\n    this._executables.push(this._createChromiumChannel('msedge-dev', {\n      'linux': '/opt/microsoft/msedge-dev/msedge',\n      'darwin': '/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev',\n      'win32': `\\\\Microsoft\\\\Edge Dev\\\\Application\\\\msedge.exe`\n    }, () => this._installMSEdgeChannel('msedge-dev', {\n      'darwin': 'reinstall_msedge_dev_mac.sh',\n      'linux': 'reinstall_msedge_dev_linux.sh',\n      'win32': 'reinstall_msedge_dev_win.ps1'\n    })));\n    this._executables.push(this._createChromiumChannel('msedge-canary', {\n      'linux': '',\n      'darwin': '/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary',\n      'win32': `\\\\Microsoft\\\\Edge SxS\\\\Application\\\\msedge.exe`\n    }));\n    const firefox = descriptors.find(d => d.name === 'firefox');\n    const firefoxExecutable = findExecutablePath(firefox.dir, 'firefox');\n    this._executables.push({\n      type: 'browser',\n      name: 'firefox',\n      browserName: 'firefox',\n      directory: firefox.dir,\n      executablePath: () => firefoxExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('firefox', firefoxExecutable, firefox.installByDefault, sdkLanguage),\n      installType: firefox.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'firefox', firefox.dir, ['firefox'], [], ['firefox']),\n      downloadURLs: this._downloadURLs(firefox),\n      browserVersion: firefox.browserVersion,\n      _install: () => this._downloadExecutable(firefox, firefoxExecutable),\n      _dependencyGroup: 'firefox',\n      _isHermeticInstallation: true\n    });\n    const firefoxBeta = descriptors.find(d => d.name === 'firefox-beta');\n    const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, 'firefox');\n    this._executables.push({\n      type: 'tool',\n      name: 'firefox-beta',\n      browserName: 'firefox',\n      directory: firefoxBeta.dir,\n      executablePath: () => firefoxBetaExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('firefox-beta', firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage),\n      installType: firefoxBeta.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'firefox', firefoxBeta.dir, ['firefox'], [], ['firefox']),\n      downloadURLs: this._downloadURLs(firefoxBeta),\n      browserVersion: firefoxBeta.browserVersion,\n      _install: () => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable),\n      _dependencyGroup: 'firefox',\n      _isHermeticInstallation: true\n    });\n    const webkit = descriptors.find(d => d.name === 'webkit');\n    const webkitExecutable = findExecutablePath(webkit.dir, 'webkit');\n    const webkitLinuxLddDirectories = [_path.default.join('minibrowser-gtk'), _path.default.join('minibrowser-gtk', 'bin'), _path.default.join('minibrowser-gtk', 'lib'), _path.default.join('minibrowser-gtk', 'sys', 'lib'), _path.default.join('minibrowser-wpe'), _path.default.join('minibrowser-wpe', 'bin'), _path.default.join('minibrowser-wpe', 'lib'), _path.default.join('minibrowser-wpe', 'sys', 'lib')];\n    this._executables.push({\n      type: 'browser',\n      name: 'webkit',\n      browserName: 'webkit',\n      directory: webkit.dir,\n      executablePath: () => webkitExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('webkit', webkitExecutable, webkit.installByDefault, sdkLanguage),\n      installType: webkit.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'webkit', webkit.dir, webkitLinuxLddDirectories, ['libGLESv2.so.2', 'libx264.so'], ['']),\n      downloadURLs: this._downloadURLs(webkit),\n      browserVersion: webkit.browserVersion,\n      _install: () => this._downloadExecutable(webkit, webkitExecutable),\n      _dependencyGroup: 'webkit',\n      _isHermeticInstallation: true\n    });\n    const ffmpeg = descriptors.find(d => d.name === 'ffmpeg');\n    const ffmpegExecutable = findExecutablePath(ffmpeg.dir, 'ffmpeg');\n    this._executables.push({\n      type: 'tool',\n      name: 'ffmpeg',\n      browserName: undefined,\n      directory: ffmpeg.dir,\n      executablePath: () => ffmpegExecutable,\n      executablePathOrDie: sdkLanguage => executablePathOrDie('ffmpeg', ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage),\n      installType: ffmpeg.installByDefault ? 'download-by-default' : 'download-on-demand',\n      validateHostRequirements: () => Promise.resolve(),\n      downloadURLs: this._downloadURLs(ffmpeg),\n      _install: () => this._downloadExecutable(ffmpeg, ffmpegExecutable),\n      _dependencyGroup: 'tools',\n      _isHermeticInstallation: true\n    });\n    const android = descriptors.find(d => d.name === 'android');\n    this._executables.push({\n      type: 'tool',\n      name: 'android',\n      browserName: undefined,\n      directory: android.dir,\n      executablePath: () => undefined,\n      executablePathOrDie: () => '',\n      installType: 'download-on-demand',\n      validateHostRequirements: () => Promise.resolve(),\n      downloadURLs: this._downloadURLs(android),\n      _install: () => this._downloadExecutable(android),\n      _dependencyGroup: 'tools',\n      _isHermeticInstallation: true\n    });\n  }\n  _createChromiumChannel(name, lookAt, install) {\n    const executablePath = (sdkLanguage, shouldThrow) => {\n      const suffix = lookAt[process.platform];\n      if (!suffix) {\n        if (shouldThrow) throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);\n        return undefined;\n      }\n      const prefixes = process.platform === 'win32' ? [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env['PROGRAMFILES(X86)']].filter(Boolean) : [''];\n      for (const prefix of prefixes) {\n        const executablePath = _path.default.join(prefix, suffix);\n        if ((0, _fileUtils.canAccessFile)(executablePath)) return executablePath;\n      }\n      if (!shouldThrow) return undefined;\n      const location = prefixes.length ? ` at ${_path.default.join(prefixes[0], suffix)}` : ``;\n      // TODO: language-specific error message\n      const installation = install ? `\\nRun \"${buildPlaywrightCLICommand(sdkLanguage, 'install ' + name)}\"` : '';\n      throw new Error(`Chromium distribution '${name}' is not found${location}${installation}`);\n    };\n    return {\n      type: 'channel',\n      name,\n      browserName: 'chromium',\n      directory: undefined,\n      executablePath: sdkLanguage => executablePath(sdkLanguage, false),\n      executablePathOrDie: sdkLanguage => executablePath(sdkLanguage, true),\n      installType: install ? 'install-script' : 'none',\n      validateHostRequirements: () => Promise.resolve(),\n      _isHermeticInstallation: false,\n      _install: install\n    };\n  }\n  executables() {\n    return this._executables;\n  }\n  findExecutable(name) {\n    return this._executables.find(b => b.name === name);\n  }\n  defaultExecutables() {\n    return this._executables.filter(e => e.installType === 'download-by-default');\n  }\n  _addRequirementsAndDedupe(executables) {\n    const set = new Set();\n    for (const executable of executables) {\n      set.add(executable);\n      if (executable.browserName === 'chromium') set.add(this.findExecutable('ffmpeg'));\n    }\n    return Array.from(set);\n  }\n  async _validateHostRequirements(sdkLanguage, browserName, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {\n    if ((0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS')) {\n      process.stderr.write('Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\\n');\n      return;\n    }\n    const distributionInfo = await (0, _linuxUtils.getLinuxDistributionInfo)();\n    if (browserName === 'firefox' && (distributionInfo === null || distributionInfo === void 0 ? void 0 : distributionInfo.id) === 'ubuntu' && (distributionInfo === null || distributionInfo === void 0 ? void 0 : distributionInfo.version) === '16.04') throw new Error(`Cannot launch Firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 20.04`);\n    if (os.platform() === 'linux') return await (0, _dependencies.validateDependenciesLinux)(sdkLanguage, linuxLddDirectories.map(d => _path.default.join(browserDirectory, d)), dlOpenLibraries);\n    if (os.platform() === 'win32' && os.arch() === 'x64') return await (0, _dependencies.validateDependenciesWindows)(windowsExeAndDllDirectories.map(d => _path.default.join(browserDirectory, d)));\n  }\n  async installDeps(executablesToInstallDeps, dryRun) {\n    const executables = this._addRequirementsAndDedupe(executablesToInstallDeps);\n    const targets = new Set();\n    for (const executable of executables) {\n      if (executable._dependencyGroup) targets.add(executable._dependencyGroup);\n    }\n    targets.add('tools');\n    if (os.platform() === 'win32') return await (0, _dependencies.installDependenciesWindows)(targets, dryRun);\n    if (os.platform() === 'linux') return await (0, _dependencies.installDependenciesLinux)(targets, dryRun);\n  }\n  async install(executablesToInstall, forceReinstall) {\n    const executables = this._addRequirementsAndDedupe(executablesToInstall);\n    await fs.promises.mkdir(registryDirectory, {\n      recursive: true\n    });\n    const lockfilePath = _path.default.join(registryDirectory, '__dirlock');\n    const linksDir = _path.default.join(registryDirectory, '.links');\n    let releaseLock;\n    try {\n      releaseLock = await _utilsBundle.lockfile.lock(registryDirectory, {\n        retries: {\n          // Retry 20 times during 10 minutes with\n          // exponential back-off.\n          // See documentation at: https://www.npmjs.com/package/retry#retrytimeoutsoptions\n          retries: 20,\n          factor: 1.27579\n        },\n        onCompromised: err => {\n          throw new Error(`${err.message} Path: ${lockfilePath}`);\n        },\n        lockfilePath\n      });\n      // Create a link first, so that cache validation does not remove our own browsers.\n      await fs.promises.mkdir(linksDir, {\n        recursive: true\n      });\n      await fs.promises.writeFile(_path.default.join(linksDir, (0, _utils.calculateSha1)(PACKAGE_PATH)), PACKAGE_PATH);\n\n      // Remove stale browsers.\n      await this._validateInstallationCache(linksDir);\n\n      // Install browsers for this package.\n      for (const executable of executables) {\n        if (!executable._install) throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);\n        const {\n          embedderName\n        } = (0, _userAgent.getEmbedderName)();\n        if (!(0, _utils.getAsBooleanFromENV)('CI') && !executable._isHermeticInstallation && !forceReinstall && executable.executablePath(embedderName)) {\n          const command = buildPlaywrightCLICommand(embedderName, 'install --force ' + executable.name);\n          throw new Error('\\n' + (0, _utils.wrapInASCIIBox)([`ATTENTION: \"${executable.name}\" is already installed on the system!`, ``, `\"${executable.name}\" installation is not hermetic; installing newer version`, `requires *removal* of a current installation first.`, ``, `To *uninstall* current version and re-install latest \"${executable.name}\":`, ``, `- Close all running instances of \"${executable.name}\", if any`, `- Use \"--force\" to install browser:`, ``, `    ${command}`, ``, `<3 Playwright Team`].join('\\n'), 1));\n        }\n        await executable._install();\n      }\n    } catch (e) {\n      if (e.code === 'ELOCKED') {\n        const rmCommand = process.platform === 'win32' ? 'rm -R' : 'rm -rf';\n        throw new Error('\\n' + (0, _utils.wrapInASCIIBox)([`An active lockfile is found at:`, ``, `  ${lockfilePath}`, ``, `Either:`, `- wait a few minutes if other Playwright is installing browsers in parallel`, `- remove lock manually with:`, ``, `    ${rmCommand} ${lockfilePath}`, ``, `<3 Playwright Team`].join('\\n'), 1));\n      } else {\n        throw e;\n      }\n    } finally {\n      if (releaseLock) await releaseLock();\n    }\n  }\n  _downloadURLs(descriptor) {\n    const paths = DOWNLOAD_PATHS[descriptor.name];\n    const downloadPathTemplate = paths[_hostPlatform.hostPlatform] || paths['<unknown>'];\n    if (!downloadPathTemplate) return [];\n    const downloadPath = util.format(downloadPathTemplate, descriptor.revision);\n    let downloadURLs = PLAYWRIGHT_CDN_MIRRORS.map(mirror => `${mirror}/${downloadPath}`);\n    let downloadHostEnv;\n    if (descriptor.name.startsWith('chromium')) downloadHostEnv = 'PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST';else if (descriptor.name.startsWith('firefox')) downloadHostEnv = 'PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST';else if (descriptor.name.startsWith('webkit')) downloadHostEnv = 'PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST';\n    const customHostOverride = downloadHostEnv && (0, _utils.getFromENV)(downloadHostEnv) || (0, _utils.getFromENV)('PLAYWRIGHT_DOWNLOAD_HOST');\n    if (customHostOverride) downloadURLs = [`${customHostOverride}/${downloadPath}`];\n    return downloadURLs;\n  }\n  async _downloadExecutable(descriptor, executablePath) {\n    const downloadURLs = this._downloadURLs(descriptor);\n    if (!downloadURLs.length) throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${_hostPlatform.hostPlatform}`);\n    if (_hostPlatform.hostPlatform === 'generic-linux' || _hostPlatform.hostPlatform === 'generic-linux-arm64') (0, _browserFetcher.logPolitely)('BEWARE: your OS is not officially supported by Playwright; downloading fallback build.');\n    const displayName = descriptor.name.split('-').map(word => {\n      return word === 'ffmpeg' ? 'FFMPEG' : word.charAt(0).toUpperCase() + word.slice(1);\n    }).join(' ');\n    const title = descriptor.browserVersion ? `${displayName} ${descriptor.browserVersion} (playwright build v${descriptor.revision})` : `${displayName} playwright build v${descriptor.revision}`;\n    const downloadFileName = `playwright-download-${descriptor.name}-${_hostPlatform.hostPlatform}-${descriptor.revision}.zip`;\n    const downloadConnectionTimeoutEnv = (0, _utils.getFromENV)('PLAYWRIGHT_DOWNLOAD_CONNECTION_TIMEOUT');\n    const downloadConnectionTimeout = +(downloadConnectionTimeoutEnv || '0') || 30_000;\n    await (0, _browserFetcher.downloadBrowserWithProgressBar)(title, descriptor.dir, executablePath, downloadURLs, downloadFileName, downloadConnectionTimeout).catch(e => {\n      throw new Error(`Failed to download ${title}, caused by\\n${e.stack}`);\n    });\n    await fs.promises.writeFile(markerFilePath(descriptor.dir), '');\n  }\n  async _installMSEdgeChannel(channel, scripts) {\n    const scriptArgs = [];\n    if (process.platform !== 'linux') {\n      const products = lowercaseAllKeys(JSON.parse(await (0, _network.fetchData)({\n        url: 'https://edgeupdates.microsoft.com/api/products'\n      })));\n      const productName = {\n        'msedge': 'Stable',\n        'msedge-beta': 'Beta',\n        'msedge-dev': 'Dev'\n      }[channel];\n      const product = products.find(product => product.product === productName);\n      const searchConfig = {\n        darwin: {\n          platform: 'MacOS',\n          arch: 'universal',\n          artifact: 'pkg'\n        },\n        win32: {\n          platform: 'Windows',\n          arch: 'x64',\n          artifact: 'msi'\n        }\n      }[process.platform];\n      const release = searchConfig ? product.releases.find(release => release.platform === searchConfig.platform && release.architecture === searchConfig.arch) : null;\n      const artifact = release ? release.artifacts.find(artifact => artifact.artifactname === searchConfig.artifact) : null;\n      if (artifact) scriptArgs.push(artifact.location /* url */);else throw new Error(`Cannot install ${channel} on ${process.platform}`);\n    }\n    await this._installChromiumChannel(channel, scripts, scriptArgs);\n  }\n  async _installChromiumChannel(channel, scripts, scriptArgs = []) {\n    const scriptName = scripts[process.platform];\n    if (!scriptName) throw new Error(`Cannot install ${channel} on ${process.platform}`);\n    const cwd = BIN_PATH;\n    const isPowerShell = scriptName.endsWith('.ps1');\n    if (isPowerShell) {\n      const args = ['-ExecutionPolicy', 'Bypass', '-File', _path.default.join(BIN_PATH, scriptName), ...scriptArgs];\n      const {\n        code\n      } = await (0, _spawnAsync.spawnAsync)('powershell.exe', args, {\n        cwd,\n        stdio: 'inherit'\n      });\n      if (code !== 0) throw new Error(`Failed to install ${channel}`);\n    } else {\n      const {\n        command,\n        args,\n        elevatedPermissions\n      } = await (0, _dependencies.transformCommandsForRoot)([`bash \"${_path.default.join(BIN_PATH, scriptName)}\" ${scriptArgs.join('')}`]);\n      if (elevatedPermissions) console.log('Switching to root user to install dependencies...'); // eslint-disable-line no-console\n      const {\n        code\n      } = await (0, _spawnAsync.spawnAsync)(command, args, {\n        cwd,\n        stdio: 'inherit'\n      });\n      if (code !== 0) throw new Error(`Failed to install ${channel}`);\n    }\n  }\n  async _validateInstallationCache(linksDir) {\n    // 1. Collect used downloads and package descriptors.\n    const usedBrowserPaths = new Set();\n    for (const fileName of await fs.promises.readdir(linksDir)) {\n      const linkPath = _path.default.join(linksDir, fileName);\n      let linkTarget = '';\n      try {\n        linkTarget = (await fs.promises.readFile(linkPath)).toString();\n        const browsersJSON = require(_path.default.join(linkTarget, 'browsers.json'));\n        const descriptors = readDescriptors(browsersJSON);\n        for (const browserName of allDownloadable) {\n          // We retain browsers if they are found in the descriptor.\n          // Note, however, that there are older versions out in the wild that rely on\n          // the \"download\" field in the browser descriptor and use its value\n          // to retain and download browsers.\n          // As of v1.10, we decided to abandon \"download\" field.\n          const descriptor = descriptors.find(d => d.name === browserName);\n          if (!descriptor) continue;\n          const usedBrowserPath = descriptor.dir;\n          const browserRevision = parseInt(descriptor.revision, 10);\n          // Old browser installations don't have marker file.\n          const shouldHaveMarkerFile = browserName === 'chromium' && browserRevision >= 786218 || browserName === 'firefox' && browserRevision >= 1128 || browserName === 'webkit' && browserRevision >= 1307 ||\n          // All new applications have a marker file right away.\n          browserName !== 'firefox' && browserName !== 'chromium' && browserName !== 'webkit';\n          if (!shouldHaveMarkerFile || (await (0, _fileUtils.existsAsync)(markerFilePath(usedBrowserPath)))) usedBrowserPaths.add(usedBrowserPath);\n        }\n      } catch (e) {\n        await fs.promises.unlink(linkPath).catch(e => {});\n      }\n    }\n\n    // 2. Delete all unused browsers.\n    if (!(0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_SKIP_BROWSER_GC')) {\n      let downloadedBrowsers = (await fs.promises.readdir(registryDirectory)).map(file => _path.default.join(registryDirectory, file));\n      downloadedBrowsers = downloadedBrowsers.filter(file => isBrowserDirectory(file));\n      const directories = new Set(downloadedBrowsers);\n      for (const browserDirectory of usedBrowserPaths) directories.delete(browserDirectory);\n      for (const directory of directories) (0, _browserFetcher.logPolitely)('Removing unused browser at ' + directory);\n      await (0, _fileUtils.removeFolders)([...directories]);\n    }\n  }\n}\nexports.Registry = Registry;\nfunction markerFilePath(browserDirectory) {\n  return _path.default.join(browserDirectory, 'INSTALLATION_COMPLETE');\n}\nfunction buildPlaywrightCLICommand(sdkLanguage, parameters) {\n  switch (sdkLanguage) {\n    case 'python':\n      return `playwright ${parameters}`;\n    case 'java':\n      return `mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args=\"${parameters}\"`;\n    case 'csharp':\n      return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;\n    default:\n      return `npx playwright ${parameters}`;\n  }\n}\nasync function installDefaultBrowsersForNpmInstall() {\n  const defaultBrowserNames = registry.defaultExecutables().map(e => e.name);\n  return installBrowsersForNpmInstall(defaultBrowserNames);\n}\nasync function installBrowsersForNpmInstall(browsers) {\n  // PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD should have a value of 0 or 1\n  if ((0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD')) {\n    (0, _browserFetcher.logPolitely)('Skipping browsers download because `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` env variable is set');\n    return false;\n  }\n  const executables = [];\n  for (const browserName of browsers) {\n    const executable = registry.findExecutable(browserName);\n    if (!executable || executable.installType === 'none') throw new Error(`Cannot install ${browserName}`);\n    executables.push(executable);\n  }\n  await registry.install(executables, false /* forceReinstall */);\n}\n\nfunction findChromiumChannel(sdkLanguage) {\n  // Fall back to the stable channels of popular vendors to work out of the box.\n  // Null means no installation and no channels found.\n  let channel = null;\n  for (const name of ['chromium', 'chrome', 'msedge']) {\n    try {\n      registry.findExecutable(name).executablePathOrDie(sdkLanguage);\n      channel = name === 'chromium' ? undefined : name;\n      break;\n    } catch (e) {}\n  }\n  if (channel === null) {\n    const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);\n    const prettyMessage = [`No chromium-based browser found on the system.`, `Please run the following command to download one:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join('\\n');\n    throw new Error('\\n' + (0, _utils.wrapInASCIIBox)(prettyMessage, 1));\n  }\n  return channel;\n}\nfunction lowercaseAllKeys(json) {\n  if (typeof json !== 'object' || !json) return json;\n  if (Array.isArray(json)) return json.map(lowercaseAllKeys);\n  const result = {};\n  for (const [key, value] of Object.entries(json)) result[key.toLowerCase()] = lowercaseAllKeys(value);\n  return result;\n}\nconst registry = new Registry(require('../../../browsers.json'));\nexports.registry = registry;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deps = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// - This file is used to execute 'npx playwright install-deps'\n// - The reverse mappings \"lib2package\" are generated with the following script:\n//     ./utils/linux-browser-dependencies/run.sh ubuntu:20.04\n\nconst deps = {\n  'ubuntu18.04': {\n    tools: ['xvfb', 'fonts-noto-color-emoji', 'ttf-unifont', 'libfontconfig', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'ttf-ubuntu-font-family'],\n    chromium: ['fonts-liberation', 'libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libgbm1', 'libglib2.0-0', 'libgtk-3-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxrandr2', 'libxshmfence1'],\n    firefox: ['ffmpeg', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libpangoft2-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrender1', 'libxt6', 'libxtst6'],\n    webkit: [],\n    lib2package: {\n      'libasound.so.2': 'libasound2',\n      'libatk-1.0.so.0': 'libatk1.0-0',\n      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',\n      'libatspi.so.0': 'libatspi2.0-0',\n      'libbrotlidec.so.1': 'libbrotli1',\n      'libcairo-gobject.so.2': 'libcairo-gobject2',\n      'libcairo.so.2': 'libcairo2',\n      'libcups.so.2': 'libcups2',\n      'libdbus-1.so.3': 'libdbus-1-3',\n      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',\n      'libdrm.so.2': 'libdrm2',\n      'libEGL.so.1': 'libegl1',\n      'libenchant.so.1': 'libenchant1c2a',\n      'libepoxy.so.0': 'libepoxy0',\n      'libevent-2.1.so.6': 'libevent-2.1-6',\n      'libevdev.so.2': 'libevdev2',\n      'libfontconfig.so.1': 'libfontconfig1',\n      'libfreetype.so.6': 'libfreetype6',\n      'libgbm.so.1': 'libgbm1',\n      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf2.0-0',\n      'libgdk-3.so.0': 'libgtk-3-0',\n      'libgdk-x11-2.0.so.0': 'libgtk2.0-0',\n      'libgio-2.0.so.0': 'libglib2.0-0',\n      'libGL.so.1': 'libgl1',\n      'libGLESv2.so.2': 'libgles2',\n      'libglib-2.0.so.0': 'libglib2.0-0',\n      'libgmodule-2.0.so.0': 'libglib2.0-0',\n      'libgobject-2.0.so.0': 'libglib2.0-0',\n      'libgstapp-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstaudio-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',\n      'libgstcodecparsers-1.0.so.0': 'gstreamer1.0-plugins-bad',\n      'libgstfft-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',\n      'libgstpbutils-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',\n      'libgsttag-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstvideo-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgthread-2.0.so.0': 'libglib2.0-0',\n      'libgtk-3.so.0': 'libgtk-3-0',\n      'libgtk-x11-2.0.so.0': 'libgtk2.0-0',\n      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',\n      'libharfbuzz.so.0': 'libharfbuzz0b',\n      'libhyphen.so.0': 'libhyphen0',\n      'libicudata.so.60': 'libicu60',\n      'libicui18n.so.60': 'libicu60',\n      'libicuuc.so.60': 'libicu60',\n      'libjpeg.so.8': 'libjpeg-turbo8',\n      'libnotify.so.4': 'libnotify4',\n      'libnspr4.so': 'libnspr4',\n      'libnss3.so': 'libnss3',\n      'libnssutil3.so': 'libnss3',\n      'libopenjp2.so.7': 'libopenjp2-7',\n      'libopus.so.0': 'libopus0',\n      'libpango-1.0.so.0': 'libpango-1.0-0',\n      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',\n      'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',\n      'libpng16.so.16': 'libpng16-16',\n      'libsecret-1.so.0': 'libsecret-1-0',\n      'libsmime3.so': 'libnss3',\n      'libvpx.so.5': 'libvpx5',\n      'libwayland-client.so.0': 'libwayland-client0',\n      'libwayland-egl.so.1': 'libwayland-egl1',\n      'libwayland-server.so.0': 'libwayland-server0',\n      'libwebp.so.6': 'libwebp6',\n      'libwebpdemux.so.2': 'libwebpdemux2',\n      'libwoff2dec.so.1.0.2': 'libwoff1',\n      'libX11-xcb.so.1': 'libx11-xcb1',\n      'libX11.so.6': 'libx11-6',\n      'libxcb-dri3.so.0': 'libxcb-dri3-0',\n      'libxcb-shm.so.0': 'libxcb-shm0',\n      'libxcb.so.1': 'libxcb1',\n      'libXcomposite.so.1': 'libxcomposite1',\n      'libXcursor.so.1': 'libxcursor1',\n      'libXdamage.so.1': 'libxdamage1',\n      'libXext.so.6': 'libxext6',\n      'libXfixes.so.3': 'libxfixes3',\n      'libXi.so.6': 'libxi6',\n      'libxkbcommon.so.0': 'libxkbcommon0',\n      'libxml2.so.2': 'libxml2',\n      'libXrandr.so.2': 'libxrandr2',\n      'libXrender.so.1': 'libxrender1',\n      'libxslt.so.1': 'libxslt1.1',\n      'libXt.so.6': 'libxt6',\n      'libXtst.so.6': 'libxtst6',\n      'libevent-2.1-6': 'libevent-2.1-6'\n    }\n  },\n  'ubuntu20.04': {\n    tools: ['xvfb', 'fonts-noto-color-emoji', 'ttf-unifont', 'libfontconfig', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'ttf-ubuntu-font-family'],\n    chromium: ['fonts-liberation', 'libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libgbm1', 'libglib2.0-0', 'libgtk-3-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxrandr2', 'libxshmfence1'],\n    firefox: ['ffmpeg', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libpangoft2-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrender1', 'libxt6', 'libxtst6'],\n    webkit: ['libenchant-2-2', 'gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libcairo2', 'libegl1', 'libenchant1c2a', 'libepoxy0', 'libevdev2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libgl1', 'libgles2', 'libglib2.0-0', 'libgstreamer-gl1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libicu66', 'libjpeg-turbo8', 'libnotify4', 'libopengl0', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libsecret-1-0', 'libsoup2.4-1', 'libvpx6', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebp6', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1', 'libatomic1', 'libevent-2.1-7'],\n    lib2package: {\n      'libasound.so.2': 'libasound2',\n      'libatk-1.0.so.0': 'libatk1.0-0',\n      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',\n      'libatspi.so.0': 'libatspi2.0-0',\n      'libcairo-gobject.so.2': 'libcairo-gobject2',\n      'libcairo.so.2': 'libcairo2',\n      'libcups.so.2': 'libcups2',\n      'libdbus-1.so.3': 'libdbus-1-3',\n      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',\n      'libdrm.so.2': 'libdrm2',\n      'libEGL.so.1': 'libegl1',\n      'libenchant.so.1': 'libenchant1c2a',\n      'libevdev.so.2': 'libevdev2',\n      'libepoxy.so.0': 'libepoxy0',\n      'libfontconfig.so.1': 'libfontconfig1',\n      'libfreetype.so.6': 'libfreetype6',\n      'libgbm.so.1': 'libgbm1',\n      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf2.0-0',\n      'libgdk-3.so.0': 'libgtk-3-0',\n      'libgdk-x11-2.0.so.0': 'libgtk2.0-0',\n      'libgio-2.0.so.0': 'libglib2.0-0',\n      'libGL.so.1': 'libgl1',\n      'libGLESv2.so.2': 'libgles2',\n      'libglib-2.0.so.0': 'libglib2.0-0',\n      'libgmodule-2.0.so.0': 'libglib2.0-0',\n      'libgobject-2.0.so.0': 'libglib2.0-0',\n      'libgstapp-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstaudio-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',\n      'libgstcodecparsers-1.0.so.0': 'gstreamer1.0-plugins-bad',\n      'libgstfft-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',\n      'libgstpbutils-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',\n      'libgsttag-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgstvideo-1.0.so.0': 'gstreamer1.0-plugins-base',\n      'libgthread-2.0.so.0': 'libglib2.0-0',\n      'libgtk-3.so.0': 'libgtk-3-0',\n      'libgtk-x11-2.0.so.0': 'libgtk2.0-0',\n      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',\n      'libharfbuzz.so.0': 'libharfbuzz0b',\n      'libhyphen.so.0': 'libhyphen0',\n      'libicui18n.so.66': 'libicu66',\n      'libicuuc.so.66': 'libicu66',\n      'libjpeg.so.8': 'libjpeg-turbo8',\n      'libnotify.so.4': 'libnotify4',\n      'libnspr4.so': 'libnspr4',\n      'libnss3.so': 'libnss3',\n      'libnssutil3.so': 'libnss3',\n      'libOpenGL.so.0': 'libopengl0',\n      'libopenjp2.so.7': 'libopenjp2-7',\n      'libopus.so.0': 'libopus0',\n      'libpango-1.0.so.0': 'libpango-1.0-0',\n      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',\n      'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',\n      'libpng16.so.16': 'libpng16-16',\n      'libsecret-1.so.0': 'libsecret-1-0',\n      'libsmime3.so': 'libnss3',\n      'libsoup-2.4.so.1': 'libsoup2.4-1',\n      'libvpx.so.6': 'libvpx6',\n      'libwayland-client.so.0': 'libwayland-client0',\n      'libwayland-egl.so.1': 'libwayland-egl1',\n      'libwayland-server.so.0': 'libwayland-server0',\n      'libwebp.so.6': 'libwebp6',\n      'libwebpdemux.so.2': 'libwebpdemux2',\n      'libwoff2dec.so.1.0.2': 'libwoff1',\n      'libX11-xcb.so.1': 'libx11-xcb1',\n      'libX11.so.6': 'libx11-6',\n      'libxcb-dri3.so.0': 'libxcb-dri3-0',\n      'libxcb-shm.so.0': 'libxcb-shm0',\n      'libxcb.so.1': 'libxcb1',\n      'libXcomposite.so.1': 'libxcomposite1',\n      'libXcursor.so.1': 'libxcursor1',\n      'libXdamage.so.1': 'libxdamage1',\n      'libXext.so.6': 'libxext6',\n      'libXfixes.so.3': 'libxfixes3',\n      'libXi.so.6': 'libxi6',\n      'libxkbcommon.so.0': 'libxkbcommon0',\n      'libxml2.so.2': 'libxml2',\n      'libXrandr.so.2': 'libxrandr2',\n      'libXrender.so.1': 'libxrender1',\n      'libxslt.so.1': 'libxslt1.1',\n      'libXt.so.6': 'libxt6',\n      'libXtst.so.6': 'libxtst6',\n      'libxshmfence.so.1': 'libxshmfence1',\n      'libatomic.so.1': 'libatomic1',\n      'libenchant-2.so.2': 'libenchant-2-2',\n      'libevent-2.1.so.7': 'libevent-2.1-7'\n    }\n  },\n  'ubuntu22.04': {\n    tools: ['xvfb', 'fonts-noto-color-emoji', 'fonts-unifont', 'libfontconfig1', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'fonts-freefont-ttf'],\n    chromium: ['libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libgbm1', 'libglib2.0-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libwayland-client0', 'libx11-6', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxkbcommon0', 'libxrandr2'],\n    firefox: ['ffmpeg', 'libasound2', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf-2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrandr2', 'libxrender1', 'libxtst6'],\n    webkit: ['libenchant-2-2', 'gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libicu70', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libcairo2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libepoxy0', 'libevdev2', 'libffi7', 'libfontconfig1', 'libfreetype6', 'libgbm1', 'libgdk-pixbuf-2.0-0', 'libgles2', 'libglib2.0-0', 'libglx0', 'libgstreamer-gl1.0-0', 'libgstreamer-plugins-base1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libgudev-1.0-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libjpeg-turbo8', 'liblcms2-2', 'libmanette-0.2-0', 'libnotify4', 'libopengl0', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libproxy1v5', 'libsecret-1-0', 'libsoup2.4-1', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1', 'libx264-163', 'libatomic1', 'libevent-2.1-7'],\n    lib2package: {\n      'libasound.so.2': 'libasound2',\n      'libatk-1.0.so.0': 'libatk1.0-0',\n      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',\n      'libatspi.so.0': 'libatspi2.0-0',\n      'libcairo-gobject.so.2': 'libcairo-gobject2',\n      'libcairo.so.2': 'libcairo2',\n      'libcups.so.2': 'libcups2',\n      'libdbus-1.so.3': 'libdbus-1-3',\n      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',\n      'libdrm.so.2': 'libdrm2',\n      'libEGL.so.1': 'libegl1',\n      'libepoxy.so.0': 'libepoxy0',\n      'libevdev.so.2': 'libevdev2',\n      'libffi.so.7': 'libffi7',\n      'libfontconfig.so.1': 'libfontconfig1',\n      'libfreetype.so.6': 'libfreetype6',\n      'libgbm.so.1': 'libgbm1',\n      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf-2.0-0',\n      'libgdk-3.so.0': 'libgtk-3-0',\n      'libgio-2.0.so.0': 'libglib2.0-0',\n      'libGLESv2.so.2': 'libgles2',\n      'libglib-2.0.so.0': 'libglib2.0-0',\n      'libGLX.so.0': 'libglx0',\n      'libgmodule-2.0.so.0': 'libglib2.0-0',\n      'libgobject-2.0.so.0': 'libglib2.0-0',\n      'libgstallocators-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstapp-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstaudio-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',\n      'libgstfft-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',\n      'libgstpbutils-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',\n      'libgsttag-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstvideo-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgtk-3.so.0': 'libgtk-3-0',\n      'libgudev-1.0.so.0': 'libgudev-1.0-0',\n      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',\n      'libharfbuzz.so.0': 'libharfbuzz0b',\n      'libhyphen.so.0': 'libhyphen0',\n      'libjpeg.so.8': 'libjpeg-turbo8',\n      'liblcms2.so.2': 'liblcms2-2',\n      'libmanette-0.2.so.0': 'libmanette-0.2-0',\n      'libnotify.so.4': 'libnotify4',\n      'libnspr4.so': 'libnspr4',\n      'libnss3.so': 'libnss3',\n      'libnssutil3.so': 'libnss3',\n      'libOpenGL.so.0': 'libopengl0',\n      'libopenjp2.so.7': 'libopenjp2-7',\n      'libopus.so.0': 'libopus0',\n      'libpango-1.0.so.0': 'libpango-1.0-0',\n      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',\n      'libpng16.so.16': 'libpng16-16',\n      'libproxy.so.1': 'libproxy1v5',\n      'libsecret-1.so.0': 'libsecret-1-0',\n      'libsmime3.so': 'libnss3',\n      'libsoup-2.4.so.1': 'libsoup2.4-1',\n      'libwayland-client.so.0': 'libwayland-client0',\n      'libwayland-egl.so.1': 'libwayland-egl1',\n      'libwayland-server.so.0': 'libwayland-server0',\n      'libwebpdemux.so.2': 'libwebpdemux2',\n      'libwoff2dec.so.1.0.2': 'libwoff1',\n      'libX11-xcb.so.1': 'libx11-xcb1',\n      'libX11.so.6': 'libx11-6',\n      'libxcb-shm.so.0': 'libxcb-shm0',\n      'libxcb.so.1': 'libxcb1',\n      'libXcomposite.so.1': 'libxcomposite1',\n      'libXcursor.so.1': 'libxcursor1',\n      'libXdamage.so.1': 'libxdamage1',\n      'libXext.so.6': 'libxext6',\n      'libXfixes.so.3': 'libxfixes3',\n      'libXi.so.6': 'libxi6',\n      'libxkbcommon.so.0': 'libxkbcommon0',\n      'libxml2.so.2': 'libxml2',\n      'libXrandr.so.2': 'libxrandr2',\n      'libXrender.so.1': 'libxrender1',\n      'libxslt.so.1': 'libxslt1.1',\n      'libXtst.so.6': 'libxtst6',\n      'libicui18n.so.60': 'libicu70',\n      'libicuuc.so.66': 'libicu70',\n      'libicui18n.so.66': 'libicu70',\n      'libwebp.so.6': 'libwebp6',\n      'libenchant-2.so.2': 'libenchant-2-2',\n      'libx264.so': 'libx264-163',\n      'libvpx.so.7': 'libvpx7',\n      'libatomic.so.1': 'libatomic1',\n      'libevent-2.1.so.7': 'libevent-2.1-7'\n    }\n  },\n  'debian11': {\n    tools: ['xvfb', 'fonts-noto-color-emoji', 'fonts-unifont', 'libfontconfig1', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'fonts-freefont-ttf'],\n    chromium: ['libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libgbm1', 'libglib2.0-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libwayland-client0', 'libx11-6', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxkbcommon0', 'libxrandr2'],\n    firefox: ['libasound2', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf-2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libharfbuzz0b', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrandr2', 'libxrender1', 'libxtst6'],\n    webkit: ['gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libcairo2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libenchant-2-2', 'libepoxy0', 'libevdev2', 'libfontconfig1', 'libfreetype6', 'libgbm1', 'libgdk-pixbuf-2.0-0', 'libgles2', 'libglib2.0-0', 'libglx0', 'libgstreamer-gl1.0-0', 'libgstreamer-plugins-base1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libgudev-1.0-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libicu67', 'libjpeg62-turbo', 'liblcms2-2', 'libmanette-0.2-0', 'libnotify4', 'libopengl0', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libproxy1v5', 'libsecret-1-0', 'libsoup2.4-1', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebp6', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1', 'libatomic1', 'libevent-2.1-7'],\n    lib2package: {\n      'libasound.so.2': 'libasound2',\n      'libatk-1.0.so.0': 'libatk1.0-0',\n      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',\n      'libatspi.so.0': 'libatspi2.0-0',\n      'libcairo-gobject.so.2': 'libcairo-gobject2',\n      'libcairo.so.2': 'libcairo2',\n      'libcups.so.2': 'libcups2',\n      'libdbus-1.so.3': 'libdbus-1-3',\n      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',\n      'libdrm.so.2': 'libdrm2',\n      'libEGL.so.1': 'libegl1',\n      'libenchant-2.so.2': 'libenchant-2-2',\n      'libepoxy.so.0': 'libepoxy0',\n      'libevdev.so.2': 'libevdev2',\n      'libfontconfig.so.1': 'libfontconfig1',\n      'libfreetype.so.6': 'libfreetype6',\n      'libgbm.so.1': 'libgbm1',\n      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf-2.0-0',\n      'libgdk-3.so.0': 'libgtk-3-0',\n      'libgio-2.0.so.0': 'libglib2.0-0',\n      'libGLESv2.so.2': 'libgles2',\n      'libglib-2.0.so.0': 'libglib2.0-0',\n      'libGLX.so.0': 'libglx0',\n      'libgmodule-2.0.so.0': 'libglib2.0-0',\n      'libgobject-2.0.so.0': 'libglib2.0-0',\n      'libgstallocators-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstapp-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstaudio-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',\n      'libgstfft-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',\n      'libgstpbutils-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',\n      'libgsttag-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgstvideo-1.0.so.0': 'libgstreamer-plugins-base1.0-0',\n      'libgtk-3.so.0': 'libgtk-3-0',\n      'libgudev-1.0.so.0': 'libgudev-1.0-0',\n      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',\n      'libharfbuzz.so.0': 'libharfbuzz0b',\n      'libhyphen.so.0': 'libhyphen0',\n      'libicui18n.so.67': 'libicu67',\n      'libicuuc.so.67': 'libicu67',\n      'libjpeg.so.62': 'libjpeg62-turbo',\n      'liblcms2.so.2': 'liblcms2-2',\n      'libmanette-0.2.so.0': 'libmanette-0.2-0',\n      'libnotify.so.4': 'libnotify4',\n      'libnspr4.so': 'libnspr4',\n      'libnss3.so': 'libnss3',\n      'libnssutil3.so': 'libnss3',\n      'libOpenGL.so.0': 'libopengl0',\n      'libopenjp2.so.7': 'libopenjp2-7',\n      'libopus.so.0': 'libopus0',\n      'libpango-1.0.so.0': 'libpango-1.0-0',\n      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',\n      'libpng16.so.16': 'libpng16-16',\n      'libproxy.so.1': 'libproxy1v5',\n      'libsecret-1.so.0': 'libsecret-1-0',\n      'libsmime3.so': 'libnss3',\n      'libsoup-2.4.so.1': 'libsoup2.4-1',\n      'libwayland-client.so.0': 'libwayland-client0',\n      'libwayland-egl.so.1': 'libwayland-egl1',\n      'libwayland-server.so.0': 'libwayland-server0',\n      'libwebp.so.6': 'libwebp6',\n      'libwebpdemux.so.2': 'libwebpdemux2',\n      'libwoff2dec.so.1.0.2': 'libwoff1',\n      'libX11-xcb.so.1': 'libx11-xcb1',\n      'libX11.so.6': 'libx11-6',\n      'libxcb-shm.so.0': 'libxcb-shm0',\n      'libxcb.so.1': 'libxcb1',\n      'libXcomposite.so.1': 'libxcomposite1',\n      'libXcursor.so.1': 'libxcursor1',\n      'libXdamage.so.1': 'libxdamage1',\n      'libXext.so.6': 'libxext6',\n      'libXfixes.so.3': 'libxfixes3',\n      'libXi.so.6': 'libxi6',\n      'libxkbcommon.so.0': 'libxkbcommon0',\n      'libxml2.so.2': 'libxml2',\n      'libXrandr.so.2': 'libxrandr2',\n      'libXrender.so.1': 'libxrender1',\n      'libxslt.so.1': 'libxslt1.1',\n      'libXtst.so.6': 'libxtst6',\n      'libatomic.so.1': 'libatomic1',\n      'libevent-2.1.so.7': 'libevent-2.1-7'\n    }\n  }\n};\nexports.deps = deps;\ndeps['ubuntu20.04-arm64'] = {\n  tools: [...deps['ubuntu20.04'].tools],\n  chromium: [...deps['ubuntu20.04'].chromium],\n  firefox: [...deps['ubuntu20.04'].firefox],\n  webkit: [...deps['ubuntu20.04'].webkit],\n  lib2package: {\n    ...deps['ubuntu20.04'].lib2package\n  }\n};\ndeps['ubuntu22.04-arm64'] = {\n  tools: [...deps['ubuntu22.04'].tools],\n  chromium: [...deps['ubuntu22.04'].chromium],\n  firefox: [...deps['ubuntu22.04'].firefox],\n  webkit: [...deps['ubuntu22.04'].webkit],\n  lib2package: {\n    ...deps['ubuntu22.04'].lib2package\n  }\n};\ndeps['debian11-arm64'] = {\n  tools: [...deps['debian11'].tools],\n  chromium: [...deps['debian11'].chromium],\n  firefox: [...deps['debian11'].firefox],\n  webkit: [...deps['debian11'].webkit],\n  lib2package: {\n    ...deps['debian11'].lib2package\n  }\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Screenshotter = void 0;\nexports.validateScreenshotOptions = validateScreenshotOptions;\nvar _helper = require(\"./helper\");\nvar _utils = require(\"../utils\");\nvar _multimap = require(\"../utils/multimap\");\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction inPagePrepareForScreenshots(hideCaret, disableAnimations) {\n  const collectRoots = (root, roots = []) => {\n    roots.push(root);\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n    do {\n      const node = walker.currentNode;\n      const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n      if (shadowRoot) collectRoots(shadowRoot, roots);\n    } while (walker.nextNode());\n    return roots;\n  };\n  let documentRoots;\n  const memoizedRoots = () => {\n    var _documentRoots;\n    return (_documentRoots = documentRoots) !== null && _documentRoots !== void 0 ? _documentRoots : documentRoots = collectRoots(document);\n  };\n  const styleTags = [];\n  if (hideCaret) {\n    for (const root of memoizedRoots()) {\n      const styleTag = document.createElement('style');\n      styleTag.textContent = `\n        *:not(#playwright-aaaaaaaaaa.playwright-bbbbbbbbbbb.playwright-cccccccccc.playwright-dddddddddd.playwright-eeeeeeeee) {\n          caret-color: transparent !important;\n        }\n      `;\n      if (root === document) document.documentElement.append(styleTag);else root.append(styleTag);\n      styleTags.push(styleTag);\n    }\n  }\n  const infiniteAnimationsToResume = new Set();\n  const cleanupCallbacks = [];\n  if (disableAnimations) {\n    const handleAnimations = root => {\n      for (const animation of root.getAnimations()) {\n        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation)) continue;\n        const endTime = animation.effect.getComputedTiming().endTime;\n        if (Number.isFinite(endTime)) {\n          try {\n            animation.finish();\n          } catch (e) {\n            // animation.finish() should not throw for\n            // finite animations, but we'd like to be on the\n            // safe side.\n          }\n        } else {\n          try {\n            animation.cancel();\n            infiniteAnimationsToResume.add(animation);\n          } catch (e) {\n            // animation.cancel() should not throw for\n            // infinite animations, but we'd like to be on the\n            // safe side.\n          }\n        }\n      }\n    };\n    for (const root of memoizedRoots()) {\n      const handleRootAnimations = handleAnimations.bind(null, root);\n      handleRootAnimations();\n      root.addEventListener('transitionrun', handleRootAnimations);\n      root.addEventListener('animationstart', handleRootAnimations);\n      cleanupCallbacks.push(() => {\n        root.removeEventListener('transitionrun', handleRootAnimations);\n        root.removeEventListener('animationstart', handleRootAnimations);\n      });\n    }\n  }\n  window.__cleanupScreenshot = () => {\n    for (const styleTag of styleTags) styleTag.remove();\n    for (const animation of infiniteAnimationsToResume) {\n      try {\n        animation.play();\n      } catch (e) {\n        // animation.play() should never throw, but\n        // we'd like to be on the safe side.\n      }\n    }\n    for (const cleanupCallback of cleanupCallbacks) cleanupCallback();\n    delete window.__cleanupScreenshot;\n  };\n}\nclass Screenshotter {\n  constructor(page) {\n    this._queue = new TaskQueue();\n    this._page = void 0;\n    this._page = page;\n    this._queue = new TaskQueue();\n  }\n  async _originalViewportSize(progress) {\n    const originalViewportSize = this._page.viewportSize();\n    let viewportSize = originalViewportSize;\n    if (!viewportSize) viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({\n      width: window.innerWidth,\n      height: window.innerHeight\n    }));\n    return {\n      viewportSize,\n      originalViewportSize\n    };\n  }\n  async _fullPageSize(progress) {\n    const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {\n      if (!document.body || !document.documentElement) return null;\n      return {\n        width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),\n        height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)\n      };\n    });\n    return fullPageSize;\n  }\n  async screenshotPage(progress, options) {\n    const format = validateScreenshotOptions(options);\n    return this._queue.postTask(async () => {\n      progress.log('taking page screenshot');\n      const {\n        viewportSize\n      } = await this._originalViewportSize(progress);\n      await this._preparePageForScreenshot(progress, options.caret !== 'initial', options.animations === 'disabled');\n      progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.\n\n      if (options.fullPage) {\n        const fullPageSize = await this._fullPageSize(progress);\n        let documentRect = {\n          x: 0,\n          y: 0,\n          width: fullPageSize.width,\n          height: fullPageSize.height\n        };\n        const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;\n        if (options.clip) documentRect = trimClipToSize(options.clip, documentRect);\n        const buffer = await this._screenshot(progress, format, documentRect, undefined, fitsViewport, options);\n        progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.\n        await this._restorePageAfterScreenshot();\n        return buffer;\n      }\n      const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : {\n        x: 0,\n        y: 0,\n        ...viewportSize\n      };\n      const buffer = await this._screenshot(progress, format, undefined, viewportRect, true, options);\n      progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.\n      await this._restorePageAfterScreenshot();\n      return buffer;\n    });\n  }\n  async screenshotElement(progress, handle, options) {\n    const format = validateScreenshotOptions(options);\n    return this._queue.postTask(async () => {\n      progress.log('taking element screenshot');\n      const {\n        viewportSize\n      } = await this._originalViewportSize(progress);\n      await this._preparePageForScreenshot(progress, options.caret !== 'initial', options.animations === 'disabled');\n      progress.throwIfAborted(); // Do not do extra work.\n\n      await handle._waitAndScrollIntoViewIfNeeded(progress, true /* waitForVisible */);\n\n      progress.throwIfAborted(); // Do not do extra work.\n      const boundingBox = await handle.boundingBox();\n      (0, _utils.assert)(boundingBox, 'Node is either not visible or not an HTMLElement');\n      (0, _utils.assert)(boundingBox.width !== 0, 'Node has 0 width.');\n      (0, _utils.assert)(boundingBox.height !== 0, 'Node has 0 height.');\n      const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;\n      progress.throwIfAborted(); // Avoid extra work.\n      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({\n        x: window.scrollX,\n        y: window.scrollY\n      }));\n      const documentRect = {\n        ...boundingBox\n      };\n      documentRect.x += scrollOffset.x;\n      documentRect.y += scrollOffset.y;\n      const buffer = await this._screenshot(progress, format, _helper.helper.enclosingIntRect(documentRect), undefined, fitsViewport, options);\n      progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.\n      await this._restorePageAfterScreenshot();\n      return buffer;\n    });\n  }\n  async _preparePageForScreenshot(progress, hideCaret, disableAnimations) {\n    if (!hideCaret && !disableAnimations) return;\n    if (disableAnimations) progress.log('  disabled all CSS animations');\n    await Promise.all(this._page.frames().map(async frame => {\n      await frame.nonStallingEvaluateInExistingContext('(' + inPagePrepareForScreenshots.toString() + `)(${hideCaret}, ${disableAnimations})`, false, 'utility').catch(() => {});\n    }));\n    progress.cleanupWhenAborted(() => this._restorePageAfterScreenshot());\n  }\n  async _restorePageAfterScreenshot() {\n    await Promise.all(this._page.frames().map(async frame => {\n      frame.nonStallingEvaluateInExistingContext('window.__cleanupScreenshot && window.__cleanupScreenshot()', false, 'utility').catch(() => {});\n    }));\n  }\n  async _maskElements(progress, options) {\n    const framesToParsedSelectors = new _multimap.MultiMap();\n    const cleanup = async () => {\n      await Promise.all([...framesToParsedSelectors.keys()].map(async frame => {\n        await frame.hideHighlight();\n      }));\n    };\n    if (!options.mask || !options.mask.length) return cleanup;\n    await Promise.all((options.mask || []).map(async ({\n      frame,\n      selector\n    }) => {\n      const pair = await frame.resolveFrameForSelectorNoWait(selector);\n      if (pair) framesToParsedSelectors.set(pair.frame, pair.info.parsed);\n    }));\n    progress.throwIfAborted(); // Avoid extra work.\n\n    await Promise.all([...framesToParsedSelectors.keys()].map(async frame => {\n      await frame.maskSelectors(framesToParsedSelectors.get(frame));\n    }));\n    progress.cleanupWhenAborted(cleanup);\n    return cleanup;\n  }\n  async _screenshot(progress, format, documentRect, viewportRect, fitsViewport, options) {\n    if (options.__testHookBeforeScreenshot) await options.__testHookBeforeScreenshot();\n    progress.throwIfAborted(); // Screenshotting is expensive - avoid extra work.\n    const shouldSetDefaultBackground = options.omitBackground && format === 'png';\n    if (shouldSetDefaultBackground) {\n      await this._page._delegate.setBackgroundColor({\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n      });\n      progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());\n    }\n    progress.throwIfAborted(); // Avoid extra work.\n\n    const cleanupHighlight = await this._maskElements(progress, options);\n    progress.throwIfAborted(); // Avoid extra work.\n\n    const buffer = await this._page._delegate.takeScreenshot(progress, format, documentRect, viewportRect, options.quality, fitsViewport, options.scale || 'device');\n    progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.\n\n    await cleanupHighlight();\n    progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.\n\n    if (shouldSetDefaultBackground) await this._page._delegate.setBackgroundColor();\n    progress.throwIfAborted(); // Avoid side effects.\n    if (options.__testHookAfterScreenshot) await options.__testHookAfterScreenshot();\n    return buffer;\n  }\n}\nexports.Screenshotter = Screenshotter;\nclass TaskQueue {\n  constructor() {\n    this._chain = void 0;\n    this._chain = Promise.resolve();\n  }\n  postTask(task) {\n    const result = this._chain.then(task);\n    this._chain = result.catch(() => {});\n    return result;\n  }\n}\nfunction trimClipToSize(clip, size) {\n  const p1 = {\n    x: Math.max(0, Math.min(clip.x, size.width)),\n    y: Math.max(0, Math.min(clip.y, size.height))\n  };\n  const p2 = {\n    x: Math.max(0, Math.min(clip.x + clip.width, size.width)),\n    y: Math.max(0, Math.min(clip.y + clip.height, size.height))\n  };\n  const result = {\n    x: p1.x,\n    y: p1.y,\n    width: p2.x - p1.x,\n    height: p2.y - p1.y\n  };\n  (0, _utils.assert)(result.width && result.height, 'Clipped area is either empty or outside the resulting image');\n  return result;\n}\nfunction validateScreenshotOptions(options) {\n  let format = null;\n  // options.type takes precedence over inferring the type from options.path\n  // because it may be a 0-length file with no extension created beforehand (i.e. as a temp file).\n  if (options.type) {\n    (0, _utils.assert)(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);\n    format = options.type;\n  }\n  if (!format) format = 'png';\n  if (options.quality !== undefined) {\n    (0, _utils.assert)(format === 'jpeg', 'options.quality is unsupported for the ' + format + ' screenshots');\n    (0, _utils.assert)(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + typeof options.quality);\n    (0, _utils.assert)(Number.isInteger(options.quality), 'Expected options.quality to be an integer');\n    (0, _utils.assert)(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);\n  }\n  if (options.clip) {\n    (0, _utils.assert)(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + typeof options.clip.x);\n    (0, _utils.assert)(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + typeof options.clip.y);\n    (0, _utils.assert)(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + typeof options.clip.width);\n    (0, _utils.assert)(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + typeof options.clip.height);\n    (0, _utils.assert)(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');\n    (0, _utils.assert)(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');\n  }\n  return format;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Selectors = void 0;\nvar _selectorParser = require(\"./isomorphic/selectorParser\");\nvar _utils = require(\"../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Selectors {\n  constructor() {\n    this._builtinEngines = void 0;\n    this._builtinEnginesInMainWorld = void 0;\n    this._engines = void 0;\n    this.guid = `selectors@${(0, _utils.createGuid)()}`;\n    this._testIdAttributeName = 'data-testid';\n    // Note: keep in sync with InjectedScript class.\n    this._builtinEngines = new Set(['css', 'css:light', 'xpath', 'xpath:light', '_react', '_vue', 'text', 'text:light', 'id', 'id:light', 'data-testid', 'data-testid:light', 'data-test-id', 'data-test-id:light', 'data-test', 'data-test:light', 'nth', 'visible', 'internal:control', 'internal:has', 'internal:has-text', 'role', 'internal:attr', 'internal:label', 'internal:text', 'internal:role', 'internal:testid']);\n    this._builtinEnginesInMainWorld = new Set(['_react', '_vue']);\n    this._engines = new Map();\n  }\n  async register(name, source, contentScript = false) {\n    if (!name.match(/^[a-zA-Z_0-9-]+$/)) throw new Error('Selector engine name may only contain [a-zA-Z0-9_] characters');\n    // Note: we keep 'zs' for future use.\n    if (this._builtinEngines.has(name) || name === 'zs' || name === 'zs:light') throw new Error(`\"${name}\" is a predefined selector engine`);\n    if (this._engines.has(name)) throw new Error(`\"${name}\" selector engine has been already registered`);\n    this._engines.set(name, {\n      source,\n      contentScript\n    });\n  }\n  testIdAttributeName() {\n    return this._testIdAttributeName;\n  }\n  setTestIdAttributeName(testIdAttributeName) {\n    this._testIdAttributeName = testIdAttributeName;\n  }\n  unregisterAll() {\n    this._engines.clear();\n  }\n  async query(frame, info, scope) {\n    const context = await frame._context(info.world);\n    const injectedScript = await context.injectedScript();\n    const handle = await injectedScript.evaluateHandle((injected, {\n      parsed,\n      scope,\n      strict\n    }) => {\n      return injected.querySelector(parsed, scope || document, strict);\n    }, {\n      parsed: info.parsed,\n      scope,\n      strict: info.strict\n    });\n    const elementHandle = handle.asElement();\n    if (!elementHandle) {\n      handle.dispose();\n      return null;\n    }\n    const mainContext = await frame._mainContext();\n    return this._adoptIfNeeded(elementHandle, mainContext);\n  }\n  async _queryArrayInMainWorld(frame, info, scope) {\n    const context = await frame._mainContext();\n    const injectedScript = await context.injectedScript();\n    const arrayHandle = await injectedScript.evaluateHandle((injected, {\n      parsed,\n      scope\n    }) => {\n      return injected.querySelectorAll(parsed, scope || document);\n    }, {\n      parsed: info.parsed,\n      scope\n    });\n    return arrayHandle;\n  }\n  async _queryCount(frame, info, scope) {\n    const context = await frame._context(info.world);\n    const injectedScript = await context.injectedScript();\n    return await injectedScript.evaluate((injected, {\n      parsed,\n      scope\n    }) => {\n      return injected.querySelectorAll(parsed, scope || document).length;\n    }, {\n      parsed: info.parsed,\n      scope\n    });\n  }\n  async _queryAll(frame, selector, scope, adoptToMain) {\n    const info = typeof selector === 'string' ? frame._page.parseSelector(selector) : selector;\n    const context = await frame._context(info.world);\n    const injectedScript = await context.injectedScript();\n    const arrayHandle = await injectedScript.evaluateHandle((injected, {\n      parsed,\n      scope\n    }) => {\n      return injected.querySelectorAll(parsed, scope || document);\n    }, {\n      parsed: info.parsed,\n      scope\n    });\n    const properties = await arrayHandle.getProperties();\n    arrayHandle.dispose();\n\n    // Note: adopting elements one by one may be slow. If we encounter the issue here,\n    // we might introduce 'useMainContext' option or similar to speed things up.\n    const targetContext = adoptToMain ? await frame._mainContext() : context;\n    const result = [];\n    for (const property of properties.values()) {\n      const elementHandle = property.asElement();\n      if (elementHandle) result.push(this._adoptIfNeeded(elementHandle, targetContext));else property.dispose();\n    }\n    return Promise.all(result);\n  }\n  async _adoptIfNeeded(handle, context) {\n    if (handle._context === context) return handle;\n    const adopted = handle._page._delegate.adoptElementHandle(handle, context);\n    handle.dispose();\n    return adopted;\n  }\n  parseSelector(selector, strict) {\n    const parsed = typeof selector === 'string' ? (0, _selectorParser.parseSelector)(selector) : selector;\n    let needsMainWorld = false;\n    for (const name of (0, _selectorParser.allEngineNames)(parsed)) {\n      const custom = this._engines.get(name);\n      if (!custom && !this._builtinEngines.has(name)) throw new _selectorParser.InvalidSelectorError(`Unknown engine \"${name}\" while parsing selector ${(0, _selectorParser.stringifySelector)(parsed)}`);\n      if (custom && !custom.contentScript) needsMainWorld = true;\n      if (this._builtinEnginesInMainWorld.has(name)) needsMainWorld = true;\n    }\n    return {\n      parsed,\n      world: needsMainWorld ? 'main' : 'utility',\n      strict\n    };\n  }\n}\nexports.Selectors = Selectors;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocksInterceptor = void 0;\nvar socks = _interopRequireWildcard(require(\"../common/socksProxy\"));\nvar _events = _interopRequireDefault(require(\"events\"));\nvar _validator = require(\"../protocol/validator\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass SocksInterceptor {\n  constructor(transport, pattern, redirectPortForTest) {\n    this._handler = void 0;\n    this._channel = void 0;\n    this._socksSupportObjectGuid = void 0;\n    this._ids = new Set();\n    this._handler = new socks.SocksProxyHandler(pattern, redirectPortForTest);\n    let lastId = -1;\n    this._channel = new Proxy(new _events.default(), {\n      get: (obj, prop) => {\n        if (prop in obj || obj[prop] !== undefined || typeof prop !== 'string') return obj[prop];\n        return params => {\n          try {\n            const id = --lastId;\n            this._ids.add(id);\n            const validator = (0, _validator.findValidator)('SocksSupport', prop, 'Params');\n            params = validator(params, '', {\n              tChannelImpl: tChannelForSocks,\n              binary: 'toBase64'\n            });\n            transport.send({\n              id,\n              guid: this._socksSupportObjectGuid,\n              method: prop,\n              params,\n              metadata: {\n                stack: [],\n                apiName: '',\n                internal: true\n              }\n            });\n          } catch (e) {}\n        };\n      }\n    });\n    this._handler.on(socks.SocksProxyHandler.Events.SocksConnected, payload => this._channel.socksConnected(payload));\n    this._handler.on(socks.SocksProxyHandler.Events.SocksData, payload => this._channel.socksData(payload));\n    this._handler.on(socks.SocksProxyHandler.Events.SocksError, payload => this._channel.socksError(payload));\n    this._handler.on(socks.SocksProxyHandler.Events.SocksFailed, payload => this._channel.socksFailed(payload));\n    this._handler.on(socks.SocksProxyHandler.Events.SocksEnd, payload => this._channel.socksEnd(payload));\n    this._channel.on('socksRequested', payload => this._handler.socketRequested(payload));\n    this._channel.on('socksClosed', payload => this._handler.socketClosed(payload));\n    this._channel.on('socksData', payload => this._handler.sendSocketData(payload));\n  }\n  cleanup() {\n    this._handler.cleanup();\n  }\n  interceptMessage(message) {\n    if (this._ids.has(message.id)) {\n      this._ids.delete(message.id);\n      return true;\n    }\n    if (message.method === '__create__' && message.params.type === 'SocksSupport') {\n      this._socksSupportObjectGuid = message.params.guid;\n      return false;\n    }\n    if (this._socksSupportObjectGuid && message.guid === this._socksSupportObjectGuid) {\n      const validator = (0, _validator.findValidator)('SocksSupport', message.method, 'Event');\n      const params = validator(message.params, '', {\n        tChannelImpl: tChannelForSocks,\n        binary: 'fromBase64'\n      });\n      this._channel.emit(message.method, params);\n      return true;\n    }\n    return false;\n  }\n}\nexports.SocksInterceptor = SocksInterceptor;\nfunction tChannelForSocks(names, arg, path, context) {\n  throw new _validator.ValidationError(`${path}: channels are not expected in SocksSupport`);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Snapshotter = void 0;\nvar _browserContext = require(\"../../browserContext\");\nvar _page = require(\"../../page\");\nvar _eventsHelper = require(\"../../../utils/eventsHelper\");\nvar _debugLogger = require(\"../../../common/debugLogger\");\nvar _snapshotterInjected = require(\"./snapshotterInjected\");\nvar _utils = require(\"../../../utils\");\nvar _utilsBundle = require(\"../../../utilsBundle\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass Snapshotter {\n  constructor(context, delegate) {\n    this._context = void 0;\n    this._delegate = void 0;\n    this._eventListeners = [];\n    this._snapshotStreamer = void 0;\n    this._initialized = false;\n    this._started = false;\n    this._context = context;\n    this._delegate = delegate;\n    const guid = (0, _utils.createGuid)();\n    this._snapshotStreamer = '__playwright_snapshot_streamer_' + guid;\n  }\n  started() {\n    return this._started;\n  }\n  async start() {\n    this._started = true;\n    if (!this._initialized) {\n      this._initialized = true;\n      await this._initialize();\n    }\n    await this.reset();\n  }\n  async reset() {\n    if (this._started) await this._runInAllFrames(`window[\"${this._snapshotStreamer}\"].reset()`);\n  }\n  async stop() {\n    this._started = false;\n  }\n  resetForReuse() {\n    // Next time we start recording, we will call addInitScript again.\n    this._initialized = false;\n  }\n  async _initialize() {\n    for (const page of this._context.pages()) this._onPage(page);\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._onPage.bind(this))];\n    const initScript = `(${_snapshotterInjected.frameSnapshotStreamer})(\"${this._snapshotStreamer}\")`;\n    await this._context.addInitScript(initScript);\n    await this._runInAllFrames(initScript);\n  }\n  async _runInAllFrames(expression) {\n    const frames = [];\n    for (const page of this._context.pages()) frames.push(...page.frames());\n    await Promise.all(frames.map(frame => {\n      return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(e => _debugLogger.debugLogger.log('error', e));\n    }));\n  }\n  dispose() {\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n  }\n  async captureSnapshot(page, snapshotName, element) {\n    // Prepare expression synchronously.\n    const expression = `window[\"${this._snapshotStreamer}\"].captureSnapshot(${JSON.stringify(snapshotName)})`;\n\n    // In a best-effort manner, without waiting for it, mark target element.\n    element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element, snapshotName) => {\n      element.setAttribute('__playwright_target__', snapshotName);\n    }, snapshotName);\n\n    // In each frame, in a non-stalling manner, capture the snapshots.\n    const snapshots = page.frames().map(async frame => {\n      const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(e => _debugLogger.debugLogger.log('error', e));\n      // Something went wrong -> bail out, our snapshots are best-efforty.\n      if (!data || !this._started) return;\n      const snapshot = {\n        snapshotName,\n        pageId: page.guid,\n        frameId: frame.guid,\n        frameUrl: data.url,\n        doctype: data.doctype,\n        html: data.html,\n        viewport: data.viewport,\n        timestamp: (0, _utils.monotonicTime)(),\n        collectionTime: data.collectionTime,\n        resourceOverrides: [],\n        isMainFrame: page.mainFrame() === frame\n      };\n      for (const {\n        url,\n        content,\n        contentType\n      } of data.resourceOverrides) {\n        if (typeof content === 'string') {\n          const buffer = Buffer.from(content);\n          const sha1 = (0, _utils.calculateSha1)(buffer) + '.' + (_utilsBundle.mime.getExtension(contentType) || 'dat');\n          this._delegate.onSnapshotterBlob({\n            sha1,\n            buffer\n          });\n          snapshot.resourceOverrides.push({\n            url,\n            sha1\n          });\n        } else {\n          snapshot.resourceOverrides.push({\n            url,\n            ref: content\n          });\n        }\n      }\n      this._delegate.onFrameSnapshot(snapshot);\n    });\n    await Promise.all(snapshots);\n  }\n  _onPage(page) {\n    // Annotate frame hierarchy so that snapshots could include frame ids.\n    for (const frame of page.frames()) this._annotateFrameHierarchy(frame);\n    this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.FrameAttached, frame => this._annotateFrameHierarchy(frame)));\n  }\n  async _annotateFrameHierarchy(frame) {\n    try {\n      const frameElement = await frame.frameElement();\n      const parent = frame.parentFrame();\n      if (!parent) return;\n      const context = await parent._mainContext();\n      await (context === null || context === void 0 ? void 0 : context.evaluate(({\n        snapshotStreamer,\n        frameElement,\n        frameId\n      }) => {\n        window[snapshotStreamer].markIframe(frameElement, frameId);\n      }, {\n        snapshotStreamer: this._snapshotStreamer,\n        frameElement,\n        frameId: frame.guid\n      }));\n      frameElement.dispose();\n    } catch (e) {}\n  }\n}\nexports.Snapshotter = Snapshotter;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.frameSnapshotStreamer = frameSnapshotStreamer;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction frameSnapshotStreamer(snapshotStreamer) {\n  // Communication with Playwright.\n  if (window[snapshotStreamer]) return;\n\n  // Attributes present in the snapshot.\n  const kShadowAttribute = '__playwright_shadow_root_';\n  const kValueAttribute = '__playwright_value_';\n  const kCheckedAttribute = '__playwright_checked_';\n  const kSelectedAttribute = '__playwright_selected_';\n  const kScrollTopAttribute = '__playwright_scroll_top_';\n  const kScrollLeftAttribute = '__playwright_scroll_left_';\n  const kStyleSheetAttribute = '__playwright_style_sheet_';\n  const kTargetAttribute = '__playwright_target__';\n\n  // Symbols for our own info on Nodes/StyleSheets.\n  const kSnapshotFrameId = Symbol('__playwright_snapshot_frameid_');\n  const kCachedData = Symbol('__playwright_snapshot_cache_');\n  const kEndOfList = Symbol('__playwright_end_of_list_');\n  function resetCachedData(obj) {\n    delete obj[kCachedData];\n  }\n  function ensureCachedData(obj) {\n    if (!obj[kCachedData]) obj[kCachedData] = {};\n    return obj[kCachedData];\n  }\n  function removeHash(url) {\n    try {\n      const u = new URL(url);\n      u.hash = '';\n      return u.toString();\n    } catch (e) {\n      return url;\n    }\n  }\n  class Streamer {\n    // To avoid invalidating due to our own reads.\n\n    constructor() {\n      this._removeNoScript = true;\n      this._lastSnapshotNumber = 0;\n      this._staleStyleSheets = new Set();\n      this._readingStyleSheet = false;\n      this._fakeBase = void 0;\n      this._observer = void 0;\n      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'insertRule', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'deleteRule', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'addRule', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'removeRule', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeGetter(window.CSSStyleSheet.prototype, 'rules', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeGetter(window.CSSStyleSheet.prototype, 'cssRules', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'replaceSync', sheet => this._invalidateStyleSheet(sheet));\n      this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, 'replace', sheet => this._invalidateStyleSheet(sheet));\n      this._fakeBase = document.createElement('base');\n      this._observer = new MutationObserver(list => this._handleMutations(list));\n      const observerConfig = {\n        attributes: true,\n        subtree: true\n      };\n      this._observer.observe(document, observerConfig);\n    }\n    _interceptNativeMethod(obj, method, cb) {\n      const native = obj[method];\n      if (!native) return;\n      obj[method] = function (...args) {\n        const result = native.call(this, ...args);\n        cb(this, result);\n        return result;\n      };\n    }\n    _interceptNativeAsyncMethod(obj, method, cb) {\n      const native = obj[method];\n      if (!native) return;\n      obj[method] = async function (...args) {\n        const result = await native.call(this, ...args);\n        cb(this, result);\n        return result;\n      };\n    }\n    _interceptNativeGetter(obj, prop, cb) {\n      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n      Object.defineProperty(obj, prop, {\n        ...descriptor,\n        get: function () {\n          const result = descriptor.get.call(this);\n          cb(this, result);\n          return result;\n        }\n      });\n    }\n    _handleMutations(list) {\n      for (const mutation of list) ensureCachedData(mutation.target).attributesCached = undefined;\n    }\n    _invalidateStyleSheet(sheet) {\n      if (this._readingStyleSheet) return;\n      this._staleStyleSheets.add(sheet);\n    }\n    _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {\n      const data = ensureCachedData(sheet);\n      if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === undefined) {\n        this._staleStyleSheets.delete(sheet);\n        try {\n          data.cssText = this._getSheetText(sheet);\n        } catch (e) {\n          // Sometimes we cannot access cross-origin stylesheets.\n          data.cssText = '';\n        }\n      }\n      return data.cssText;\n    }\n\n    // Returns either content, ref, or no override.\n    _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {\n      const data = ensureCachedData(sheet);\n      if (this._staleStyleSheets.has(sheet)) {\n        this._staleStyleSheets.delete(sheet);\n        try {\n          data.cssText = this._getSheetText(sheet);\n          data.cssRef = snapshotNumber;\n          return data.cssText;\n        } catch (e) {\n          // Sometimes we cannot access cross-origin stylesheets.\n        }\n      }\n      return data.cssRef === undefined ? undefined : snapshotNumber - data.cssRef;\n    }\n    markIframe(iframeElement, frameId) {\n      iframeElement[kSnapshotFrameId] = frameId;\n    }\n    reset() {\n      this._staleStyleSheets.clear();\n      const visitNode = node => {\n        resetCachedData(node);\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          const element = node;\n          if (element.shadowRoot) visitNode(element.shadowRoot);\n        }\n        for (let child = node.firstChild; child; child = child.nextSibling) visitNode(child);\n      };\n      visitNode(document.documentElement);\n      visitNode(this._fakeBase);\n    }\n    __sanitizeMetaAttribute(name, value, httpEquiv) {\n      if (name === 'charset') return 'utf-8';\n      if (httpEquiv.toLowerCase() !== 'content-type' || name !== 'content') return value;\n      const [type, ...params] = value.split(';');\n      if (type !== 'text/html' || params.length <= 0) return value;\n      const charsetParamIdx = params.findIndex(param => param.trim().startsWith('charset='));\n      if (charsetParamIdx > -1) params[charsetParamIdx] = 'charset=utf-8';\n      return `${type}; ${params.join('; ')}`;\n    }\n    _sanitizeUrl(url) {\n      if (url.startsWith('javascript:') || url.startsWith('vbscript:')) return '';\n      return url;\n    }\n    _sanitizeSrcSet(srcset) {\n      return srcset.split(',').map(src => {\n        src = src.trim();\n        const spaceIndex = src.lastIndexOf(' ');\n        if (spaceIndex === -1) return this._sanitizeUrl(src);\n        return this._sanitizeUrl(src.substring(0, spaceIndex).trim()) + src.substring(spaceIndex);\n      }).join(', ');\n    }\n    _resolveUrl(base, url) {\n      if (url === '') return '';\n      try {\n        return new URL(url, base).href;\n      } catch (e) {\n        return url;\n      }\n    }\n    _getSheetBase(sheet) {\n      let rootSheet = sheet;\n      while (rootSheet.parentStyleSheet) rootSheet = rootSheet.parentStyleSheet;\n      if (rootSheet.ownerNode) return rootSheet.ownerNode.baseURI;\n      return document.baseURI;\n    }\n    _getSheetText(sheet) {\n      this._readingStyleSheet = true;\n      try {\n        const rules = [];\n        for (const rule of sheet.cssRules) rules.push(rule.cssText);\n        return rules.join('\\n');\n      } finally {\n        this._readingStyleSheet = false;\n      }\n    }\n    captureSnapshot() {\n      const timestamp = performance.now();\n      const snapshotNumber = ++this._lastSnapshotNumber;\n      let nodeCounter = 0;\n      let shadowDomNesting = 0;\n      let headNesting = 0;\n\n      // Ensure we are up to date.\n      this._handleMutations(this._observer.takeRecords());\n\n      // Restore scroll positions for all ancestors of action target elements\n      // that will show the highlight/red dot in the trace viewer.\n      // Workaround for chromium regression:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1324419\n      // https://github.com/microsoft/playwright/issues/14037\n      // TODO: remove after chromium is fixed?\n      const elementsToRestoreScrollPosition = new Set();\n      const findElementsToRestoreScrollPositionRecursively = element => {\n        let shouldAdd = element.hasAttribute(kTargetAttribute);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) shouldAdd = shouldAdd || findElementsToRestoreScrollPositionRecursively(child);\n        if (element.shadowRoot) {\n          for (let child = element.shadowRoot.firstElementChild; child; child = child.nextElementSibling) shouldAdd = shouldAdd || findElementsToRestoreScrollPositionRecursively(child);\n        }\n        if (shouldAdd) elementsToRestoreScrollPosition.add(element);\n        return shouldAdd;\n      };\n      if (document.documentElement) findElementsToRestoreScrollPositionRecursively(document.documentElement);\n      const visitNode = node => {\n        const nodeType = node.nodeType;\n        const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? 'template' : node.nodeName;\n        if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE) return;\n        if (nodeName === 'SCRIPT') return;\n        // Don't preload resources.\n        if (nodeName === 'LINK' && nodeType === Node.ELEMENT_NODE) {\n          var _getAttribute;\n          const rel = (_getAttribute = node.getAttribute('rel')) === null || _getAttribute === void 0 ? void 0 : _getAttribute.toLowerCase();\n          if (rel === 'preload' || rel === 'prefetch') return;\n        }\n        if (this._removeNoScript && nodeName === 'NOSCRIPT') return;\n        if (nodeName === 'META' && node.httpEquiv.toLowerCase() === 'content-security-policy') return;\n        // Skip iframes which are inside document's head as they are not visisble.\n        // See https://github.com/microsoft/playwright/issues/12005.\n        if ((nodeName === 'IFRAME' || nodeName === 'FRAME') && headNesting) return;\n        const data = ensureCachedData(node);\n        const values = [];\n        let equals = !!data.cached;\n        let extraNodes = 0;\n        const expectValue = value => {\n          equals = equals && data.cached[values.length] === value;\n          values.push(value);\n        };\n        const checkAndReturn = n => {\n          data.attributesCached = true;\n          if (equals) return {\n            equals: true,\n            n: [[snapshotNumber - data.ref[0], data.ref[1]]]\n          };\n          nodeCounter += extraNodes;\n          data.ref = [snapshotNumber, nodeCounter++];\n          data.cached = values;\n          return {\n            equals: false,\n            n\n          };\n        };\n        if (nodeType === Node.TEXT_NODE) {\n          const value = node.nodeValue || '';\n          expectValue(value);\n          return checkAndReturn(value);\n        }\n        if (nodeName === 'STYLE') {\n          const sheet = node.sheet;\n          let cssText;\n          if (sheet) cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);\n          cssText = cssText || node.textContent || '';\n          expectValue(cssText);\n          // Compensate for the extra 'cssText' text node.\n          extraNodes++;\n          return checkAndReturn([nodeName, {}, cssText]);\n        }\n        const attrs = {};\n        const result = [nodeName, attrs];\n        const visitChild = child => {\n          const snapshot = visitNode(child);\n          if (snapshot) {\n            result.push(snapshot.n);\n            expectValue(child);\n            equals = equals && snapshot.equals;\n          }\n        };\n        const visitChildStyleSheet = child => {\n          const snapshot = visitStyleSheet(child);\n          if (snapshot) {\n            result.push(snapshot.n);\n            expectValue(child);\n            equals = equals && snapshot.equals;\n          }\n        };\n        if (nodeType === Node.DOCUMENT_FRAGMENT_NODE) attrs[kShadowAttribute] = 'open';\n        if (nodeType === Node.ELEMENT_NODE) {\n          const element = node;\n          if (nodeName === 'INPUT' || nodeName === 'TEXTAREA') {\n            const value = element.value;\n            expectValue(kValueAttribute);\n            expectValue(value);\n            attrs[kValueAttribute] = value;\n          }\n          if (nodeName === 'INPUT' && ['checkbox', 'radio'].includes(element.type)) {\n            const value = element.checked ? 'true' : 'false';\n            expectValue(kCheckedAttribute);\n            expectValue(value);\n            attrs[kCheckedAttribute] = value;\n          }\n          if (nodeName === 'OPTION') {\n            const value = element.selected ? 'true' : 'false';\n            expectValue(kSelectedAttribute);\n            expectValue(value);\n            attrs[kSelectedAttribute] = value;\n          }\n          if (elementsToRestoreScrollPosition.has(element) && element.scrollTop) {\n            expectValue(kScrollTopAttribute);\n            expectValue(element.scrollTop);\n            attrs[kScrollTopAttribute] = '' + element.scrollTop;\n          }\n          if (elementsToRestoreScrollPosition.has(element) && element.scrollLeft) {\n            expectValue(kScrollLeftAttribute);\n            expectValue(element.scrollLeft);\n            attrs[kScrollLeftAttribute] = '' + element.scrollLeft;\n          }\n          if (element.shadowRoot) {\n            ++shadowDomNesting;\n            visitChild(element.shadowRoot);\n            --shadowDomNesting;\n          }\n        }\n        if (nodeName === 'HEAD') {\n          ++headNesting;\n          // Insert fake <base> first, to ensure all <link> elements use the proper base uri.\n          this._fakeBase.setAttribute('href', document.baseURI);\n          visitChild(this._fakeBase);\n        }\n        for (let child = node.firstChild; child; child = child.nextSibling) visitChild(child);\n        if (nodeName === 'HEAD') --headNesting;\n        expectValue(kEndOfList);\n        let documentOrShadowRoot = null;\n        if (node.ownerDocument.documentElement === node) documentOrShadowRoot = node.ownerDocument;else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) documentOrShadowRoot = node;\n        if (documentOrShadowRoot) {\n          for (const sheet of documentOrShadowRoot.adoptedStyleSheets || []) visitChildStyleSheet(sheet);\n          expectValue(kEndOfList);\n        }\n\n        // Process iframe src attribute before bailing out since it depends on a symbol, not the DOM.\n        if (nodeName === 'IFRAME' || nodeName === 'FRAME') {\n          const element = node;\n          const frameId = element[kSnapshotFrameId];\n          const name = 'src';\n          const value = frameId ? `/snapshot/${frameId}` : '';\n          expectValue(name);\n          expectValue(value);\n          attrs[name] = value;\n        }\n\n        // We can skip attributes comparison because nothing else has changed,\n        // and mutation observer didn't tell us about the attributes.\n        if (equals && data.attributesCached && !shadowDomNesting) return checkAndReturn(result);\n        if (nodeType === Node.ELEMENT_NODE) {\n          const element = node;\n          for (let i = 0; i < element.attributes.length; i++) {\n            const name = element.attributes[i].name;\n            if (nodeName === 'LINK' && name === 'integrity') continue;\n            if (nodeName === 'IFRAME' && (name === 'src' || name === 'sandbox')) continue;\n            if (nodeName === 'FRAME' && name === 'src') continue;\n            let value = element.attributes[i].value;\n            if (nodeName === 'META') value = this.__sanitizeMetaAttribute(name, value, node.httpEquiv);else if (name === 'src' && nodeName === 'IMG') value = this._sanitizeUrl(value);else if (name === 'srcset' && nodeName === 'IMG') value = this._sanitizeSrcSet(value);else if (name === 'srcset' && nodeName === 'SOURCE') value = this._sanitizeSrcSet(value);else if (name === 'href' && nodeName === 'LINK') value = this._sanitizeUrl(value);else if (name.startsWith('on')) value = '';\n            expectValue(name);\n            expectValue(value);\n            attrs[name] = value;\n          }\n          expectValue(kEndOfList);\n        }\n        if (result.length === 2 && !Object.keys(attrs).length) result.pop(); // Remove empty attrs when there are no children.\n        return checkAndReturn(result);\n      };\n      const visitStyleSheet = sheet => {\n        const data = ensureCachedData(sheet);\n        const oldCSSText = data.cssText;\n        const cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet, true /* forceText */);\n        if (cssText === oldCSSText) return {\n          equals: true,\n          n: [[snapshotNumber - data.ref[0], data.ref[1]]]\n        };\n        data.ref = [snapshotNumber, nodeCounter++];\n        return {\n          equals: false,\n          n: ['template', {\n            [kStyleSheetAttribute]: cssText\n          }]\n        };\n      };\n      let html;\n      if (document.documentElement) {\n        const {\n          n\n        } = visitNode(document.documentElement);\n        html = n;\n      } else {\n        html = ['html'];\n      }\n      const result = {\n        html,\n        doctype: document.doctype ? document.doctype.name : undefined,\n        resourceOverrides: [],\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        url: location.href,\n        timestamp,\n        collectionTime: 0\n      };\n      for (const sheet of this._staleStyleSheets) {\n        if (sheet.href === null) continue;\n        const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);\n        if (content === undefined) {\n          // Unable to capture stylesheet contents.\n          continue;\n        }\n        const base = this._getSheetBase(sheet);\n        const url = removeHash(this._resolveUrl(base, sheet.href));\n        result.resourceOverrides.push({\n          url,\n          content,\n          contentType: 'text/css'\n        });\n      }\n      result.collectionTime = performance.now() - result.timestamp;\n      return result;\n    }\n  }\n  window[snapshotStreamer] = new Streamer();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tracing = void 0;\nexports.shouldCaptureSnapshot = shouldCaptureSnapshot;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _debug = require(\"../../../protocol/debug\");\nvar _manualPromise = require(\"../../../utils/manualPromise\");\nvar _eventsHelper = require(\"../../../utils/eventsHelper\");\nvar _utils = require(\"../../../utils\");\nvar _fileUtils = require(\"../../../utils/fileUtils\");\nvar _artifact = require(\"../../artifact\");\nvar _browserContext = require(\"../../browserContext\");\nvar _dom = require(\"../../dom\");\nvar _instrumentation = require(\"../../instrumentation\");\nvar _page = require(\"../../page\");\nvar _harTracer = require(\"../../har/harTracer\");\nvar _snapshotter = require(\"./snapshotter\");\nvar _zipBundle = require(\"../../../zipBundle\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst version = 3;\nconst kScreencastOptions = {\n  width: 800,\n  height: 600,\n  quality: 90\n};\nclass Tracing extends _instrumentation.SdkObject {\n  constructor(context, tracesDir) {\n    var _browser, _browser$options;\n    super(context, 'tracing');\n    this._writeChain = Promise.resolve();\n    this._snapshotter = void 0;\n    this._harTracer = void 0;\n    this._screencastListeners = [];\n    this._pendingCalls = new Map();\n    this._context = void 0;\n    this._state = void 0;\n    this._isStopping = false;\n    this._precreatedTracesDir = void 0;\n    this._tracesTmpDir = void 0;\n    this._allResources = new Set();\n    this._contextCreatedEvent = void 0;\n    this._context = context;\n    this._precreatedTracesDir = tracesDir;\n    this._harTracer = new _harTracer.HarTracer(context, null, this, {\n      content: 'attach',\n      includeTraceInfo: true,\n      recordRequestOverrides: false,\n      waitForContentOnStop: false,\n      skipScripts: true\n    });\n    this._contextCreatedEvent = {\n      version,\n      type: 'context-options',\n      browserName: '',\n      options: {},\n      platform: process.platform,\n      wallTime: 0,\n      sdkLanguage: context === null || context === void 0 ? void 0 : (_browser = context._browser) === null || _browser === void 0 ? void 0 : (_browser$options = _browser.options) === null || _browser$options === void 0 ? void 0 : _browser$options.sdkLanguage\n    };\n    if (context instanceof _browserContext.BrowserContext) {\n      this._snapshotter = new _snapshotter.Snapshotter(context, this);\n      (0, _utils.assert)(tracesDir, 'tracesDir must be specified for BrowserContext');\n      this._contextCreatedEvent.browserName = context._browser.options.name;\n      this._contextCreatedEvent.options = context._options;\n    }\n  }\n  resetForReuse() {\n    var _this$_snapshotter;\n    (_this$_snapshotter = this._snapshotter) === null || _this$_snapshotter === void 0 ? void 0 : _this$_snapshotter.resetForReuse();\n  }\n  async start(options) {\n    var _this$_context, _this$_context$_brows, _this$_context$_brows2;\n    if (this._isStopping) throw new Error('Cannot start tracing while stopping');\n\n    // Re-write for testing.\n    this._contextCreatedEvent.sdkLanguage = (_this$_context = this._context) === null || _this$_context === void 0 ? void 0 : (_this$_context$_brows = _this$_context._browser) === null || _this$_context$_brows === void 0 ? void 0 : (_this$_context$_brows2 = _this$_context$_brows.options) === null || _this$_context$_brows2 === void 0 ? void 0 : _this$_context$_brows2.sdkLanguage;\n    if (this._state) {\n      const o = this._state.options;\n      if (o.name !== options.name || !o.screenshots !== !options.screenshots || !o.snapshots !== !options.snapshots) throw new Error('Tracing has been already started with different options');\n      return;\n    }\n    // TODO: passing the same name for two contexts makes them write into a single file\n    // and conflict.\n    const traceName = options.name || (0, _utils.createGuid)();\n    // Init the state synchrounously.\n    this._state = {\n      options,\n      traceName,\n      traceFile: '',\n      networkFile: '',\n      tracesDir: '',\n      resourcesDir: '',\n      filesCount: 0,\n      traceSha1s: new Set(),\n      networkSha1s: new Set(),\n      sources: new Set(),\n      recording: false\n    };\n    const state = this._state;\n    state.tracesDir = await this._createTracesDirIfNeeded();\n    state.resourcesDir = _path.default.join(state.tracesDir, 'resources');\n    state.traceFile = _path.default.join(state.tracesDir, traceName + '.trace');\n    state.networkFile = _path.default.join(state.tracesDir, traceName + '.network');\n    this._writeChain = _fs.default.promises.mkdir(state.resourcesDir, {\n      recursive: true\n    }).then(() => _fs.default.promises.writeFile(state.networkFile, ''));\n    if (options.snapshots) this._harTracer.start();\n  }\n  async startChunk(options = {}) {\n    var _this$_snapshotter2;\n    if (this._state && this._state.recording) await this.stopChunk({\n      mode: 'doNotSave'\n    });\n    if (!this._state) throw new Error('Must start tracing before starting a new chunk');\n    if (this._isStopping) throw new Error('Cannot start a trace chunk while stopping');\n    const state = this._state;\n    const suffix = state.filesCount ? `-${state.filesCount}` : ``;\n    state.filesCount++;\n    state.traceFile = _path.default.join(state.tracesDir, `${state.traceName}${suffix}.trace`);\n    state.recording = true;\n    this._appendTraceOperation(async () => {\n      await (0, _fileUtils.mkdirIfNeeded)(state.traceFile);\n      await _fs.default.promises.appendFile(state.traceFile, JSON.stringify({\n        ...this._contextCreatedEvent,\n        title: options.title,\n        wallTime: Date.now()\n      }) + '\\n');\n    });\n    this._context.instrumentation.addListener(this, this._context);\n    if (state.options.screenshots) this._startScreencast();\n    if (state.options.snapshots) await ((_this$_snapshotter2 = this._snapshotter) === null || _this$_snapshotter2 === void 0 ? void 0 : _this$_snapshotter2.start());\n  }\n  _startScreencast() {\n    if (!(this._context instanceof _browserContext.BrowserContext)) return;\n    for (const page of this._context.pages()) this._startScreencastInPage(page);\n    this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._startScreencastInPage.bind(this)));\n  }\n  _stopScreencast() {\n    _eventsHelper.eventsHelper.removeEventListeners(this._screencastListeners);\n    if (!(this._context instanceof _browserContext.BrowserContext)) return;\n    for (const page of this._context.pages()) page.setScreencastOptions(null);\n  }\n  async stop() {\n    if (!this._state) return;\n    if (this._isStopping) throw new Error(`Tracing is already stopping`);\n    if (this._state.recording) throw new Error(`Must stop trace file before stopping tracing`);\n    this._harTracer.stop();\n    await this._writeChain;\n    this._state = undefined;\n  }\n  async deleteTmpTracesDir() {\n    if (this._tracesTmpDir) await (0, _fileUtils.removeFolders)([this._tracesTmpDir]);\n  }\n  async _createTracesDirIfNeeded() {\n    if (this._precreatedTracesDir) return this._precreatedTracesDir;\n    this._tracesTmpDir = await _fs.default.promises.mkdtemp(_path.default.join(_os.default.tmpdir(), 'playwright-tracing-'));\n    return this._tracesTmpDir;\n  }\n  async dispose() {\n    var _this$_snapshotter3;\n    (_this$_snapshotter3 = this._snapshotter) === null || _this$_snapshotter3 === void 0 ? void 0 : _this$_snapshotter3.dispose();\n    this._harTracer.stop();\n    await this._writeChain;\n  }\n  async stopChunk(params) {\n    var _this$_state, _this$_snapshotter4;\n    if (this._isStopping) throw new Error(`Tracing is already stopping`);\n    this._isStopping = true;\n    if (!this._state || !this._state.recording) {\n      this._isStopping = false;\n      if (params.mode !== 'doNotSave') throw new Error(`Must start tracing before stopping`);\n      return {\n        artifact: null,\n        sourceEntries: []\n      };\n    }\n    const state = this._state;\n    this._context.instrumentation.removeListener(this);\n    if ((_this$_state = this._state) !== null && _this$_state !== void 0 && _this$_state.options.screenshots) this._stopScreencast();\n    for (const {\n      sdkObject,\n      metadata,\n      beforeSnapshot,\n      actionSnapshot,\n      afterSnapshot\n    } of this._pendingCalls.values()) {\n      await Promise.all([beforeSnapshot, actionSnapshot, afterSnapshot]);\n      let callMetadata = metadata;\n      if (!afterSnapshot) {\n        // Note: we should not modify metadata here to avoid side-effects in any other place.\n        callMetadata = {\n          ...metadata,\n          error: {\n            error: {\n              name: 'Error',\n              message: 'Action was interrupted'\n            }\n          }\n        };\n      }\n      await this.onAfterCall(sdkObject, callMetadata);\n    }\n    if (state.options.snapshots) await ((_this$_snapshotter4 = this._snapshotter) === null || _this$_snapshotter4 === void 0 ? void 0 : _this$_snapshotter4.stop());\n\n    // Chain the export operation against write operations,\n    // so that neither trace files nor sha1s change during the export.\n    return (await this._appendTraceOperation(async () => {\n      if (params.mode === 'doNotSave') return {\n        artifact: null,\n        sourceEntries: undefined\n      };\n\n      // Har files a live, make a snapshot before returning the resulting entries.\n      const networkFile = _path.default.join(state.networkFile, '..', (0, _utils.createGuid)());\n      await _fs.default.promises.copyFile(state.networkFile, networkFile);\n      const entries = [];\n      entries.push({\n        name: 'trace.trace',\n        value: state.traceFile\n      });\n      entries.push({\n        name: 'trace.network',\n        value: networkFile\n      });\n      for (const sha1 of new Set([...state.traceSha1s, ...state.networkSha1s])) entries.push({\n        name: _path.default.join('resources', sha1),\n        value: _path.default.join(state.resourcesDir, sha1)\n      });\n      let sourceEntries;\n      if (state.sources.size) {\n        sourceEntries = [];\n        for (const value of state.sources) {\n          const entry = {\n            name: 'resources/src@' + (0, _utils.calculateSha1)(value) + '.txt',\n            value\n          };\n          if (params.mode === 'compressTraceAndSources') {\n            if (_fs.default.existsSync(entry.value)) entries.push(entry);\n          } else {\n            sourceEntries.push(entry);\n          }\n        }\n      }\n      const artifact = await this._exportZip(entries, state).catch(() => null);\n      return {\n        artifact,\n        sourceEntries\n      };\n    }).finally(() => {\n      // Only reset trace sha1s, network resources are preserved between chunks.\n      state.traceSha1s = new Set();\n      state.sources = new Set();\n      this._isStopping = false;\n      state.recording = false;\n    })) || {\n      artifact: null,\n      sourceEntries: undefined\n    };\n  }\n  async _exportZip(entries, state) {\n    const zipFile = new _zipBundle.yazl.ZipFile();\n    const result = new _manualPromise.ManualPromise();\n    zipFile.on('error', error => result.reject(error));\n    for (const entry of entries) zipFile.addFile(entry.value, entry.name);\n    zipFile.end();\n    const zipFileName = state.traceFile + '.zip';\n    zipFile.outputStream.pipe(_fs.default.createWriteStream(zipFileName)).on('close', () => {\n      const artifact = new _artifact.Artifact(this._context, zipFileName);\n      artifact.reportFinished();\n      result.resolve(artifact);\n    });\n    return result;\n  }\n  async _captureSnapshot(name, sdkObject, metadata, element) {\n    if (!this._snapshotter) return;\n    if (!sdkObject.attribution.page) return;\n    if (!this._snapshotter.started()) return;\n    if (!shouldCaptureSnapshot(metadata)) return;\n    const snapshotName = `${name}@${metadata.id}`;\n    metadata.snapshots.push({\n      title: name,\n      snapshotName\n    });\n    // We have |element| for input actions (page.click and handle.click)\n    // and |sdkObject| element for accessors like handle.textContent.\n    if (!element && sdkObject instanceof _dom.ElementHandle) element = sdkObject;\n    await this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element).catch(() => {});\n  }\n  async onBeforeCall(sdkObject, metadata) {\n    var _sdkObject$attributio, _this$_state2;\n    (_sdkObject$attributio = sdkObject.attribution.page) === null || _sdkObject$attributio === void 0 ? void 0 : _sdkObject$attributio.temporarlyDisableTracingScreencastThrottling();\n    // Set afterSnapshot name for all the actions that operate selectors.\n    // Elements resolved from selectors will be marked on the snapshot.\n    metadata.afterSnapshot = `after@${metadata.id}`;\n    const beforeSnapshot = this._captureSnapshot('before', sdkObject, metadata);\n    this._pendingCalls.set(metadata.id, {\n      sdkObject,\n      metadata,\n      beforeSnapshot\n    });\n    if ((_this$_state2 = this._state) !== null && _this$_state2 !== void 0 && _this$_state2.options.sources) {\n      for (const frame of metadata.stack || []) this._state.sources.add(frame.file);\n    }\n    await beforeSnapshot;\n  }\n  async onBeforeInputAction(sdkObject, metadata, element) {\n    var _sdkObject$attributio2;\n    (_sdkObject$attributio2 = sdkObject.attribution.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.temporarlyDisableTracingScreencastThrottling();\n    const actionSnapshot = this._captureSnapshot('action', sdkObject, metadata, element);\n    this._pendingCalls.get(metadata.id).actionSnapshot = actionSnapshot;\n    await actionSnapshot;\n  }\n  async onAfterCall(sdkObject, metadata) {\n    var _sdkObject$attributio3;\n    (_sdkObject$attributio3 = sdkObject.attribution.page) === null || _sdkObject$attributio3 === void 0 ? void 0 : _sdkObject$attributio3.temporarlyDisableTracingScreencastThrottling();\n    const pendingCall = this._pendingCalls.get(metadata.id);\n    if (!pendingCall || pendingCall.afterSnapshot) return;\n    if (!sdkObject.attribution.context) {\n      this._pendingCalls.delete(metadata.id);\n      return;\n    }\n    pendingCall.afterSnapshot = this._captureSnapshot('after', sdkObject, metadata);\n    await pendingCall.afterSnapshot;\n    const event = {\n      type: 'action',\n      metadata\n    };\n    this._appendTraceEvent(event);\n    this._pendingCalls.delete(metadata.id);\n  }\n  onEvent(sdkObject, metadata) {\n    if (!sdkObject.attribution.context) return;\n    const event = {\n      type: 'event',\n      metadata\n    };\n    this._appendTraceEvent(event);\n  }\n  onEntryStarted(entry) {}\n  onEntryFinished(entry) {\n    const event = {\n      type: 'resource-snapshot',\n      snapshot: entry\n    };\n    this._appendTraceOperation(async () => {\n      const visited = visitTraceEvent(event, this._state.networkSha1s);\n      await _fs.default.promises.appendFile(this._state.networkFile, JSON.stringify(visited) + '\\n');\n    });\n  }\n  onContentBlob(sha1, buffer) {\n    this._appendResource(sha1, buffer);\n  }\n  onSnapshotterBlob(blob) {\n    this._appendResource(blob.sha1, blob.buffer);\n  }\n  onFrameSnapshot(snapshot) {\n    this._appendTraceEvent({\n      type: 'frame-snapshot',\n      snapshot\n    });\n  }\n  _startScreencastInPage(page) {\n    page.setScreencastOptions(kScreencastOptions);\n    const prefix = page.guid;\n    this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.ScreencastFrame, params => {\n      const suffix = params.timestamp || Date.now();\n      const sha1 = `${prefix}-${suffix}.jpeg`;\n      const event = {\n        type: 'screencast-frame',\n        pageId: page.guid,\n        sha1,\n        width: params.width,\n        height: params.height,\n        timestamp: (0, _utils.monotonicTime)()\n      };\n      // Make sure to write the screencast frame before adding a reference to it.\n      this._appendResource(sha1, params.buffer);\n      this._appendTraceEvent(event);\n    }));\n  }\n  _appendTraceEvent(event) {\n    this._appendTraceOperation(async () => {\n      const visited = visitTraceEvent(event, this._state.traceSha1s);\n      await _fs.default.promises.appendFile(this._state.traceFile, JSON.stringify(visited) + '\\n');\n    });\n  }\n  _appendResource(sha1, buffer) {\n    if (this._allResources.has(sha1)) return;\n    this._allResources.add(sha1);\n    const resourcePath = _path.default.join(this._state.resourcesDir, sha1);\n    this._appendTraceOperation(async () => {\n      try {\n        // Perhaps we've already written this resource?\n        await _fs.default.promises.access(resourcePath);\n      } catch (e) {\n        // If not, let's write! Note that async access is safe because we\n        // never remove resources until the very end.\n        await _fs.default.promises.writeFile(resourcePath, buffer).catch(() => {});\n      }\n    });\n  }\n  async _appendTraceOperation(cb) {\n    // This method serializes all writes to the trace.\n    let error;\n    let result;\n    this._writeChain = this._writeChain.then(async () => {\n      // This check is here because closing the browser removes the tracesDir and tracing\n      // dies trying to archive.\n      if (this._context instanceof _browserContext.BrowserContext && !this._context._browser.isConnected()) return;\n      try {\n        result = await cb();\n      } catch (e) {\n        error = e;\n      }\n    });\n    await this._writeChain;\n    if (error) throw error;\n    return result;\n  }\n}\nexports.Tracing = Tracing;\nfunction visitTraceEvent(object, sha1s) {\n  if (Array.isArray(object)) return object.map(o => visitTraceEvent(o, sha1s));\n  if (object instanceof Buffer) return undefined;\n  if (typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      if (key === 'sha1' || key === '_sha1' || key.endsWith('Sha1')) {\n        const sha1 = object[key];\n        if (sha1) sha1s.add(sha1);\n      }\n      result[key] = visitTraceEvent(object[key], sha1s);\n    }\n    return result;\n  }\n  return object;\n}\nfunction shouldCaptureSnapshot(metadata) {\n  return _debug.commandsWithTracingSnapshots.has(metadata.type + '.' + metadata.method);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketTransport = void 0;\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _utils = require(\"../utils\");\nvar _happyEyeballs = require(\"./happy-eyeballs\");\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WebSocketTransport {\n  static async connect(progress, url, headers, followRedirects) {\n    const logUrl = stripQueryParams(url);\n    progress === null || progress === void 0 ? void 0 : progress.log(`<ws connecting> ${logUrl}`);\n    const transport = new WebSocketTransport(progress, url, logUrl, headers, followRedirects);\n    let success = false;\n    progress === null || progress === void 0 ? void 0 : progress.cleanupWhenAborted(async () => {\n      if (!success) await transport.closeAndWait().catch(e => null);\n    });\n    await new Promise((fulfill, reject) => {\n      transport._ws.on('open', async () => {\n        progress === null || progress === void 0 ? void 0 : progress.log(`<ws connected> ${logUrl}`);\n        fulfill(transport);\n      });\n      transport._ws.on('error', event => {\n        progress === null || progress === void 0 ? void 0 : progress.log(`<ws connect error> ${logUrl} ${event.message}`);\n        reject(new Error('WebSocket error: ' + event.message));\n        transport._ws.close();\n      });\n      transport._ws.on('unexpected-response', (request, response) => {\n        const chunks = [];\n        const errorPrefix = `${logUrl} ${response.statusCode} ${response.statusMessage}`;\n        response.on('data', chunk => chunks.push(chunk));\n        response.on('close', () => {\n          const error = chunks.length ? `${errorPrefix}\\n${Buffer.concat(chunks)}` : errorPrefix;\n          progress === null || progress === void 0 ? void 0 : progress.log(`<ws unexpected response> ${error}`);\n          reject(new Error('WebSocket error: ' + error));\n          transport._ws.close();\n        });\n      });\n    });\n    success = true;\n    return transport;\n  }\n  constructor(progress, url, logUrl, headers, followRedirects) {\n    var _progress$timeUntilDe;\n    this._ws = void 0;\n    this._progress = void 0;\n    this._logUrl = void 0;\n    this.onmessage = void 0;\n    this.onclose = void 0;\n    this.wsEndpoint = void 0;\n    this.wsEndpoint = url;\n    this._logUrl = logUrl;\n    this._ws = new _utilsBundle.ws(url, [], {\n      perMessageDeflate: false,\n      maxPayload: 256 * 1024 * 1024,\n      // 256Mb,\n      // Prevent internal http client error when passing negative timeout.\n      handshakeTimeout: Math.max((_progress$timeUntilDe = progress === null || progress === void 0 ? void 0 : progress.timeUntilDeadline()) !== null && _progress$timeUntilDe !== void 0 ? _progress$timeUntilDe : 30_000, 1),\n      headers,\n      followRedirects,\n      agent: /^(https|wss):\\/\\//.test(url) ? _happyEyeballs.httpsHappyEyeballsAgent : _happyEyeballs.httpHappyEyeballsAgent\n    });\n    this._progress = progress;\n    // The 'ws' module in node sometimes sends us multiple messages in a single task.\n    // In Web, all IO callbacks (e.g. WebSocket callbacks)\n    // are dispatched into separate tasks, so there's no need\n    // to do anything extra.\n    const messageWrap = (0, _utils.makeWaitForNextTask)();\n    this._ws.addEventListener('message', event => {\n      messageWrap(() => {\n        try {\n          if (this.onmessage) this.onmessage.call(null, JSON.parse(event.data));\n        } catch (e) {\n          this._ws.close();\n        }\n      });\n    });\n    this._ws.addEventListener('close', event => {\n      var _this$_progress;\n      (_this$_progress = this._progress) === null || _this$_progress === void 0 ? void 0 : _this$_progress.log(`<ws disconnected> ${logUrl} code=${event.code} reason=${event.reason}`);\n      if (this.onclose) this.onclose.call(null);\n    });\n    // Prevent Error: read ECONNRESET.\n    this._ws.addEventListener('error', error => {\n      var _this$_progress2;\n      return (_this$_progress2 = this._progress) === null || _this$_progress2 === void 0 ? void 0 : _this$_progress2.log(`<ws error> ${logUrl} ${error.type} ${error.message}`);\n    });\n  }\n  send(message) {\n    this._ws.send(JSON.stringify(message));\n  }\n  close() {\n    var _this$_progress3;\n    (_this$_progress3 = this._progress) === null || _this$_progress3 === void 0 ? void 0 : _this$_progress3.log(`<ws disconnecting> ${this._logUrl}`);\n    this._ws.close();\n  }\n  async closeAndWait() {\n    if (this._ws.readyState === _utilsBundle.ws.CLOSED) return;\n    const promise = new Promise(f => this._ws.once('close', f));\n    this.close();\n    await promise; // Make sure to await the actual disconnect.\n  }\n}\nexports.WebSocketTransport = WebSocketTransport;\nfunction stripQueryParams(url) {\n  try {\n    const u = new URL(url);\n    u.search = '';\n    u.hash = '';\n    return u.toString();\n  } catch {\n    return url;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.kLifecycleEvents = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle', 'commit']);\nexports.kLifecycleEvents = kLifecycleEvents;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keypadLocation = exports.USKeyboardLayout = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst keypadLocation = 3;\nexports.keypadLocation = keypadLocation;\nconst USKeyboardLayout = {\n  // Functions row\n  'Escape': {\n    'keyCode': 27,\n    'key': 'Escape'\n  },\n  'F1': {\n    'keyCode': 112,\n    'key': 'F1'\n  },\n  'F2': {\n    'keyCode': 113,\n    'key': 'F2'\n  },\n  'F3': {\n    'keyCode': 114,\n    'key': 'F3'\n  },\n  'F4': {\n    'keyCode': 115,\n    'key': 'F4'\n  },\n  'F5': {\n    'keyCode': 116,\n    'key': 'F5'\n  },\n  'F6': {\n    'keyCode': 117,\n    'key': 'F6'\n  },\n  'F7': {\n    'keyCode': 118,\n    'key': 'F7'\n  },\n  'F8': {\n    'keyCode': 119,\n    'key': 'F8'\n  },\n  'F9': {\n    'keyCode': 120,\n    'key': 'F9'\n  },\n  'F10': {\n    'keyCode': 121,\n    'key': 'F10'\n  },\n  'F11': {\n    'keyCode': 122,\n    'key': 'F11'\n  },\n  'F12': {\n    'keyCode': 123,\n    'key': 'F12'\n  },\n  // Numbers row\n  'Backquote': {\n    'keyCode': 192,\n    'shiftKey': '~',\n    'key': '`'\n  },\n  'Digit1': {\n    'keyCode': 49,\n    'shiftKey': '!',\n    'key': '1'\n  },\n  'Digit2': {\n    'keyCode': 50,\n    'shiftKey': '@',\n    'key': '2'\n  },\n  'Digit3': {\n    'keyCode': 51,\n    'shiftKey': '#',\n    'key': '3'\n  },\n  'Digit4': {\n    'keyCode': 52,\n    'shiftKey': '$',\n    'key': '4'\n  },\n  'Digit5': {\n    'keyCode': 53,\n    'shiftKey': '%',\n    'key': '5'\n  },\n  'Digit6': {\n    'keyCode': 54,\n    'shiftKey': '^',\n    'key': '6'\n  },\n  'Digit7': {\n    'keyCode': 55,\n    'shiftKey': '&',\n    'key': '7'\n  },\n  'Digit8': {\n    'keyCode': 56,\n    'shiftKey': '*',\n    'key': '8'\n  },\n  'Digit9': {\n    'keyCode': 57,\n    'shiftKey': '\\(',\n    'key': '9'\n  },\n  'Digit0': {\n    'keyCode': 48,\n    'shiftKey': ')',\n    'key': '0'\n  },\n  'Minus': {\n    'keyCode': 189,\n    'shiftKey': '_',\n    'key': '-'\n  },\n  'Equal': {\n    'keyCode': 187,\n    'shiftKey': '+',\n    'key': '='\n  },\n  'Backslash': {\n    'keyCode': 220,\n    'shiftKey': '|',\n    'key': '\\\\'\n  },\n  'Backspace': {\n    'keyCode': 8,\n    'key': 'Backspace'\n  },\n  // First row\n  'Tab': {\n    'keyCode': 9,\n    'key': 'Tab'\n  },\n  'KeyQ': {\n    'keyCode': 81,\n    'shiftKey': 'Q',\n    'key': 'q'\n  },\n  'KeyW': {\n    'keyCode': 87,\n    'shiftKey': 'W',\n    'key': 'w'\n  },\n  'KeyE': {\n    'keyCode': 69,\n    'shiftKey': 'E',\n    'key': 'e'\n  },\n  'KeyR': {\n    'keyCode': 82,\n    'shiftKey': 'R',\n    'key': 'r'\n  },\n  'KeyT': {\n    'keyCode': 84,\n    'shiftKey': 'T',\n    'key': 't'\n  },\n  'KeyY': {\n    'keyCode': 89,\n    'shiftKey': 'Y',\n    'key': 'y'\n  },\n  'KeyU': {\n    'keyCode': 85,\n    'shiftKey': 'U',\n    'key': 'u'\n  },\n  'KeyI': {\n    'keyCode': 73,\n    'shiftKey': 'I',\n    'key': 'i'\n  },\n  'KeyO': {\n    'keyCode': 79,\n    'shiftKey': 'O',\n    'key': 'o'\n  },\n  'KeyP': {\n    'keyCode': 80,\n    'shiftKey': 'P',\n    'key': 'p'\n  },\n  'BracketLeft': {\n    'keyCode': 219,\n    'shiftKey': '{',\n    'key': '['\n  },\n  'BracketRight': {\n    'keyCode': 221,\n    'shiftKey': '}',\n    'key': ']'\n  },\n  // Second row\n  'CapsLock': {\n    'keyCode': 20,\n    'key': 'CapsLock'\n  },\n  'KeyA': {\n    'keyCode': 65,\n    'shiftKey': 'A',\n    'key': 'a'\n  },\n  'KeyS': {\n    'keyCode': 83,\n    'shiftKey': 'S',\n    'key': 's'\n  },\n  'KeyD': {\n    'keyCode': 68,\n    'shiftKey': 'D',\n    'key': 'd'\n  },\n  'KeyF': {\n    'keyCode': 70,\n    'shiftKey': 'F',\n    'key': 'f'\n  },\n  'KeyG': {\n    'keyCode': 71,\n    'shiftKey': 'G',\n    'key': 'g'\n  },\n  'KeyH': {\n    'keyCode': 72,\n    'shiftKey': 'H',\n    'key': 'h'\n  },\n  'KeyJ': {\n    'keyCode': 74,\n    'shiftKey': 'J',\n    'key': 'j'\n  },\n  'KeyK': {\n    'keyCode': 75,\n    'shiftKey': 'K',\n    'key': 'k'\n  },\n  'KeyL': {\n    'keyCode': 76,\n    'shiftKey': 'L',\n    'key': 'l'\n  },\n  'Semicolon': {\n    'keyCode': 186,\n    'shiftKey': ':',\n    'key': ';'\n  },\n  'Quote': {\n    'keyCode': 222,\n    'shiftKey': '\"',\n    'key': '\\''\n  },\n  'Enter': {\n    'keyCode': 13,\n    'key': 'Enter',\n    'text': '\\r'\n  },\n  // Third row\n  'ShiftLeft': {\n    'keyCode': 160,\n    'keyCodeWithoutLocation': 16,\n    'key': 'Shift',\n    'location': 1\n  },\n  'KeyZ': {\n    'keyCode': 90,\n    'shiftKey': 'Z',\n    'key': 'z'\n  },\n  'KeyX': {\n    'keyCode': 88,\n    'shiftKey': 'X',\n    'key': 'x'\n  },\n  'KeyC': {\n    'keyCode': 67,\n    'shiftKey': 'C',\n    'key': 'c'\n  },\n  'KeyV': {\n    'keyCode': 86,\n    'shiftKey': 'V',\n    'key': 'v'\n  },\n  'KeyB': {\n    'keyCode': 66,\n    'shiftKey': 'B',\n    'key': 'b'\n  },\n  'KeyN': {\n    'keyCode': 78,\n    'shiftKey': 'N',\n    'key': 'n'\n  },\n  'KeyM': {\n    'keyCode': 77,\n    'shiftKey': 'M',\n    'key': 'm'\n  },\n  'Comma': {\n    'keyCode': 188,\n    'shiftKey': '\\<',\n    'key': ','\n  },\n  'Period': {\n    'keyCode': 190,\n    'shiftKey': '>',\n    'key': '.'\n  },\n  'Slash': {\n    'keyCode': 191,\n    'shiftKey': '?',\n    'key': '/'\n  },\n  'ShiftRight': {\n    'keyCode': 161,\n    'keyCodeWithoutLocation': 16,\n    'key': 'Shift',\n    'location': 2\n  },\n  // Last row\n  'ControlLeft': {\n    'keyCode': 162,\n    'keyCodeWithoutLocation': 17,\n    'key': 'Control',\n    'location': 1\n  },\n  'MetaLeft': {\n    'keyCode': 91,\n    'key': 'Meta',\n    'location': 1\n  },\n  'AltLeft': {\n    'keyCode': 164,\n    'keyCodeWithoutLocation': 18,\n    'key': 'Alt',\n    'location': 1\n  },\n  'Space': {\n    'keyCode': 32,\n    'key': ' '\n  },\n  'AltRight': {\n    'keyCode': 165,\n    'keyCodeWithoutLocation': 18,\n    'key': 'Alt',\n    'location': 2\n  },\n  'AltGraph': {\n    'keyCode': 225,\n    'key': 'AltGraph'\n  },\n  'MetaRight': {\n    'keyCode': 92,\n    'key': 'Meta',\n    'location': 2\n  },\n  'ContextMenu': {\n    'keyCode': 93,\n    'key': 'ContextMenu'\n  },\n  'ControlRight': {\n    'keyCode': 163,\n    'keyCodeWithoutLocation': 17,\n    'key': 'Control',\n    'location': 2\n  },\n  // Center block\n  'PrintScreen': {\n    'keyCode': 44,\n    'key': 'PrintScreen'\n  },\n  'ScrollLock': {\n    'keyCode': 145,\n    'key': 'ScrollLock'\n  },\n  'Pause': {\n    'keyCode': 19,\n    'key': 'Pause'\n  },\n  'PageUp': {\n    'keyCode': 33,\n    'key': 'PageUp'\n  },\n  'PageDown': {\n    'keyCode': 34,\n    'key': 'PageDown'\n  },\n  'Insert': {\n    'keyCode': 45,\n    'key': 'Insert'\n  },\n  'Delete': {\n    'keyCode': 46,\n    'key': 'Delete'\n  },\n  'Home': {\n    'keyCode': 36,\n    'key': 'Home'\n  },\n  'End': {\n    'keyCode': 35,\n    'key': 'End'\n  },\n  'ArrowLeft': {\n    'keyCode': 37,\n    'key': 'ArrowLeft'\n  },\n  'ArrowUp': {\n    'keyCode': 38,\n    'key': 'ArrowUp'\n  },\n  'ArrowRight': {\n    'keyCode': 39,\n    'key': 'ArrowRight'\n  },\n  'ArrowDown': {\n    'keyCode': 40,\n    'key': 'ArrowDown'\n  },\n  // Numpad\n  'NumLock': {\n    'keyCode': 144,\n    'key': 'NumLock'\n  },\n  'NumpadDivide': {\n    'keyCode': 111,\n    'key': '/',\n    'location': 3\n  },\n  'NumpadMultiply': {\n    'keyCode': 106,\n    'key': '*',\n    'location': 3\n  },\n  'NumpadSubtract': {\n    'keyCode': 109,\n    'key': '-',\n    'location': 3\n  },\n  'Numpad7': {\n    'keyCode': 36,\n    'shiftKeyCode': 103,\n    'key': 'Home',\n    'shiftKey': '7',\n    'location': 3\n  },\n  'Numpad8': {\n    'keyCode': 38,\n    'shiftKeyCode': 104,\n    'key': 'ArrowUp',\n    'shiftKey': '8',\n    'location': 3\n  },\n  'Numpad9': {\n    'keyCode': 33,\n    'shiftKeyCode': 105,\n    'key': 'PageUp',\n    'shiftKey': '9',\n    'location': 3\n  },\n  'Numpad4': {\n    'keyCode': 37,\n    'shiftKeyCode': 100,\n    'key': 'ArrowLeft',\n    'shiftKey': '4',\n    'location': 3\n  },\n  'Numpad5': {\n    'keyCode': 12,\n    'shiftKeyCode': 101,\n    'key': 'Clear',\n    'shiftKey': '5',\n    'location': 3\n  },\n  'Numpad6': {\n    'keyCode': 39,\n    'shiftKeyCode': 102,\n    'key': 'ArrowRight',\n    'shiftKey': '6',\n    'location': 3\n  },\n  'NumpadAdd': {\n    'keyCode': 107,\n    'key': '+',\n    'location': 3\n  },\n  'Numpad1': {\n    'keyCode': 35,\n    'shiftKeyCode': 97,\n    'key': 'End',\n    'shiftKey': '1',\n    'location': 3\n  },\n  'Numpad2': {\n    'keyCode': 40,\n    'shiftKeyCode': 98,\n    'key': 'ArrowDown',\n    'shiftKey': '2',\n    'location': 3\n  },\n  'Numpad3': {\n    'keyCode': 34,\n    'shiftKeyCode': 99,\n    'key': 'PageDown',\n    'shiftKey': '3',\n    'location': 3\n  },\n  'Numpad0': {\n    'keyCode': 45,\n    'shiftKeyCode': 96,\n    'key': 'Insert',\n    'shiftKey': '0',\n    'location': 3\n  },\n  'NumpadDecimal': {\n    'keyCode': 46,\n    'shiftKeyCode': 110,\n    'key': '\\u0000',\n    'shiftKey': '.',\n    'location': 3\n  },\n  'NumpadEnter': {\n    'keyCode': 13,\n    'key': 'Enter',\n    'text': '\\r',\n    'location': 3\n  }\n};\nexports.USKeyboardLayout = USKeyboardLayout;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebKit = void 0;\nvar _wkBrowser = require(\"../webkit/wkBrowser\");\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _wkConnection = require(\"./wkConnection\");\nvar _browserType = require(\"../browserType\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _utils = require(\"../../utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WebKit extends _browserType.BrowserType {\n  constructor(playwrightOptions) {\n    super('webkit', playwrightOptions);\n  }\n  _connectToTransport(transport, options) {\n    return _wkBrowser.WKBrowser.connect(transport, options);\n  }\n  _amendEnvironment(env, userDataDir, executable, browserArguments) {\n    return {\n      ...env,\n      CURL_COOKIE_JAR_PATH: _path.default.join(userDataDir, 'cookiejar.db')\n    };\n  }\n  _rewriteStartupError(error) {\n    if (error.message.includes('cannot open display')) return (0, _stackTrace.rewriteErrorMessage)(error, '\\n' + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));\n    return error;\n  }\n  _attemptToGracefullyCloseBrowser(transport) {\n    transport.send({\n      method: 'Playwright.close',\n      params: {},\n      id: _wkConnection.kBrowserCloseMessageId\n    });\n  }\n  _defaultArgs(options, isPersistent, userDataDir) {\n    const {\n      args = [],\n      proxy,\n      headless\n    } = options;\n    const userDataDirArg = args.find(arg => arg.startsWith('--user-data-dir'));\n    if (userDataDirArg) throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument');\n    if (args.find(arg => !arg.startsWith('-'))) throw new Error('Arguments can not specify page to be opened');\n    const webkitArguments = ['--inspector-pipe'];\n    if (process.platform === 'win32') webkitArguments.push('--disable-accelerated-compositing');\n    if (headless) webkitArguments.push('--headless');\n    if (isPersistent) webkitArguments.push(`--user-data-dir=${userDataDir}`);else webkitArguments.push(`--no-startup-window`);\n    if (proxy) {\n      if (process.platform === 'darwin') {\n        webkitArguments.push(`--proxy=${proxy.server}`);\n        if (proxy.bypass) webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);\n      } else if (process.platform === 'linux') {\n        webkitArguments.push(`--proxy=${proxy.server}`);\n        if (proxy.bypass) webkitArguments.push(...proxy.bypass.split(',').map(t => `--ignore-host=${t}`));\n      } else if (process.platform === 'win32') {\n        // Enable socks5 hostname resolution on Windows. Workaround can be removed once fixed upstream.\n        // See https://github.com/microsoft/playwright/issues/20451\n        webkitArguments.push(`--curl-proxy=${proxy.server.replace(/^socks5:\\/\\//, 'socks5h://')}`);\n        if (proxy.bypass) webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);\n      }\n    }\n    webkitArguments.push(...args);\n    if (isPersistent) webkitArguments.push('about:blank');\n    return webkitArguments;\n  }\n}\nexports.WebKit = WebKit;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAccessibilityTree = getAccessibilityTree;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nasync function getAccessibilityTree(session, needle) {\n  const objectId = needle ? needle._objectId : undefined;\n  const {\n    axNode\n  } = await session.send('Page.accessibilitySnapshot', {\n    objectId\n  });\n  const tree = new WKAXNode(axNode);\n  return {\n    tree,\n    needle: needle ? tree._findNeedle() : null\n  };\n}\nconst WKRoleToARIARole = new Map(Object.entries({\n  'TextField': 'textbox'\n}));\n\n// WebKit localizes role descriptions on mac, but the english versions only add noise.\nconst WKUnhelpfulRoleDescriptions = new Map(Object.entries({\n  'WebArea': 'HTML content',\n  'Summary': 'summary',\n  'DescriptionList': 'description list',\n  'ImageMap': 'image map',\n  'ListMarker': 'list marker',\n  'Video': 'video playback',\n  'Mark': 'highlighted',\n  'contentinfo': 'content information',\n  'Details': 'details',\n  'DescriptionListDetail': 'description',\n  'DescriptionListTerm': 'term',\n  'alertdialog': 'web alert dialog',\n  'dialog': 'web dialog',\n  'status': 'application status',\n  'tabpanel': 'tab panel',\n  'application': 'web application'\n}));\nclass WKAXNode {\n  constructor(payload) {\n    this._payload = void 0;\n    this._children = void 0;\n    this._payload = payload;\n    this._children = [];\n    for (const payload of this._payload.children || []) this._children.push(new WKAXNode(payload));\n  }\n  children() {\n    return this._children;\n  }\n  _findNeedle() {\n    if (this._payload.found) return this;\n    for (const child of this._children) {\n      const found = child._findNeedle();\n      if (found) return found;\n    }\n    return null;\n  }\n  isControl() {\n    switch (this._payload.role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'TextField':\n      case 'tree':\n        return true;\n      default:\n        return false;\n    }\n  }\n  _isTextControl() {\n    switch (this._payload.role) {\n      case 'combobox':\n      case 'searchfield':\n      case 'textbox':\n      case 'TextField':\n        return true;\n    }\n    return false;\n  }\n  _name() {\n    if (this._payload.role === 'text') return this._payload.value || '';\n    return this._payload.name || '';\n  }\n  isInteresting(insideControl) {\n    const {\n      role,\n      focusable\n    } = this._payload;\n    const name = this._name();\n    if (role === 'ScrollArea') return false;\n    if (role === 'WebArea') return true;\n    if (focusable || role === 'MenuListOption') return true;\n\n    // If it's not focusable but has a control role, then it's interesting.\n    if (this.isControl()) return true;\n\n    // A non focusable child of a control is not interesting\n    if (insideControl) return false;\n    return this.isLeafNode() && !!name;\n  }\n  _hasRendundantTextChild() {\n    if (this._children.length !== 1) return false;\n    const child = this._children[0];\n    return child._payload.role === 'text' && this._payload.name === child._payload.value;\n  }\n  isLeafNode() {\n    if (!this._children.length) return true;\n    // WebKit on Linux ignores everything inside text controls, normalize this behavior\n    if (this._isTextControl()) return true;\n    // WebKit for mac has text nodes inside heading, li, menuitem, a, and p nodes\n    if (this._hasRendundantTextChild()) return true;\n    return false;\n  }\n  serialize() {\n    const node = {\n      role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,\n      name: this._name()\n    };\n    if ('description' in this._payload && this._payload.description !== node.name) node.description = this._payload.description;\n    if ('roledescription' in this._payload) {\n      const roledescription = this._payload.roledescription;\n      if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription) node.roledescription = roledescription;\n    }\n    if ('value' in this._payload && this._payload.role !== 'text') {\n      if (typeof this._payload.value === 'string') node.valueString = this._payload.value;else if (typeof this._payload.value === 'number') node.valueNumber = this._payload.value;\n    }\n    if ('checked' in this._payload) node.checked = this._payload.checked === 'true' ? 'checked' : this._payload.checked === 'false' ? 'unchecked' : 'mixed';\n    if ('pressed' in this._payload) node.pressed = this._payload.pressed === 'true' ? 'pressed' : this._payload.pressed === 'false' ? 'released' : 'mixed';\n    const userStringProperties = ['keyshortcuts', 'valuetext'];\n    for (const userStringProperty of userStringProperties) {\n      if (!(userStringProperty in this._payload)) continue;\n      node[userStringProperty] = this._payload[userStringProperty];\n    }\n    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];\n    for (const booleanProperty of booleanProperties) {\n      // WebArea and ScorllArea treat focus differently than other nodes. They report whether their frame  has focus,\n      // not whether focus is specifically on the root node.\n      if (booleanProperty === 'focused' && (this._payload.role === 'WebArea' || this._payload.role === 'ScrollArea')) continue;\n      const value = this._payload[booleanProperty];\n      if (!value) continue;\n      node[booleanProperty] = value;\n    }\n    const numericalProperties = ['level', 'valuemax', 'valuemin'];\n    for (const numericalProperty of numericalProperties) {\n      if (!(numericalProperty in this._payload)) continue;\n      node[numericalProperty] = this._payload[numericalProperty];\n    }\n    const tokenProperties = ['autocomplete', 'haspopup', 'invalid'];\n    for (const tokenProperty of tokenProperties) {\n      const value = this._payload[tokenProperty];\n      if (!value || value === 'false') continue;\n      node[tokenProperty] = value;\n    }\n    const orientationIsApplicable = new Set(['ScrollArea', 'scrollbar', 'listbox', 'combobox', 'menu', 'tree', 'separator', 'slider', 'tablist', 'toolbar']);\n    if (this._payload.orientation && orientationIsApplicable.has(this._payload.role)) node.orientation = this._payload.orientation;\n    return node;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKBrowserContext = exports.WKBrowser = void 0;\nvar _browser = require(\"../browser\");\nvar _browserContext = require(\"../browserContext\");\nvar _utils = require(\"../../utils\");\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _wkConnection = require(\"./wkConnection\");\nvar _wkPage = require(\"./wkPage\");\nvar _errors = require(\"../../common/errors\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15';\nconst BROWSER_VERSION = '16.4';\nclass WKBrowser extends _browser.Browser {\n  static async connect(transport, options) {\n    const browser = new WKBrowser(transport, options);\n    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();\n    const promises = [browser._browserSession.send('Playwright.enable')];\n    if (options.persistent) {\n      browser._defaultContext = new WKBrowserContext(browser, undefined, options.persistent);\n      promises.push(browser._defaultContext._initialize());\n    }\n    await Promise.all(promises);\n    return browser;\n  }\n  constructor(transport, options) {\n    super(options);\n    this._connection = void 0;\n    this._browserSession = void 0;\n    this._contexts = new Map();\n    this._wkPages = new Map();\n    this._eventListeners = void 0;\n    this._connection = new _wkConnection.WKConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);\n    this._browserSession = this._connection.browserSession;\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.pageProxyCreated', this._onPageProxyCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.pageProxyDestroyed', this._onPageProxyDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.provisionalLoadFailed', event => this._onProvisionalLoadFailed(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.windowOpen', event => this._onWindowOpen(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.downloadCreated', this._onDownloadCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.downloadFilenameSuggested', this._onDownloadFilenameSuggested.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.downloadFinished', this._onDownloadFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.screencastFinished', this._onScreencastFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, _wkConnection.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))];\n  }\n  _onDisconnect() {\n    for (const wkPage of this._wkPages.values()) wkPage.dispose(true);\n    for (const video of this._idToVideo.values()) video.artifact.reportFinished(_errors.kBrowserClosedError);\n    this._idToVideo.clear();\n    this._didClose();\n  }\n  async doCreateNewContext(options) {\n    const createOptions = options.proxy ? {\n      // Enable socks5 hostname resolution on Windows. Workaround can be removed once fixed upstream.\n      // See https://github.com/microsoft/playwright/issues/20451\n      proxyServer: process.platform === 'win32' ? options.proxy.server.replace(/^socks5:\\/\\//, 'socks5h://') : options.proxy.server,\n      proxyBypassList: options.proxy.bypass\n    } : undefined;\n    const {\n      browserContextId\n    } = await this._browserSession.send('Playwright.createContext', createOptions);\n    options.userAgent = options.userAgent || DEFAULT_USER_AGENT;\n    const context = new WKBrowserContext(this, browserContextId, options);\n    await context._initialize();\n    this._contexts.set(browserContextId, context);\n    return context;\n  }\n  contexts() {\n    return Array.from(this._contexts.values());\n  }\n  version() {\n    return BROWSER_VERSION;\n  }\n  userAgent() {\n    return DEFAULT_USER_AGENT;\n  }\n  _onDownloadCreated(payload) {\n    const page = this._wkPages.get(payload.pageProxyId);\n    if (!page) return;\n    // In some cases, e.g. blob url download, we receive only frameScheduledNavigation\n    // but no signals that the navigation was canceled and replaced by download. Fix it\n    // here by simulating cancelled provisional load which matches downloads from network.\n    //\n    // TODO: this is racy, because download might be unrelated any navigation, and we will\n    // abort navgitation that is still running. We should be able to fix this by\n    // instrumenting policy decision start/proceed/cancel.\n    page._page._frameManager.frameAbortedNavigation(payload.frameId, 'Download is starting');\n    let originPage = page._initializedPage;\n    // If it's a new window download, report it on the opener page.\n    if (!originPage) {\n      // Resume the page creation with an error. The page will automatically close right\n      // after the download begins.\n      page._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));\n      if (page._opener) originPage = page._opener._initializedPage;\n    }\n    if (!originPage) return;\n    this._downloadCreated(originPage, payload.uuid, payload.url);\n  }\n  _onDownloadFilenameSuggested(payload) {\n    this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);\n  }\n  _onDownloadFinished(payload) {\n    this._downloadFinished(payload.uuid, payload.error);\n  }\n  _onScreencastFinished(payload) {\n    var _this$_takeVideo;\n    (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();\n  }\n  _onPageProxyCreated(event) {\n    const pageProxyId = event.pageProxyId;\n    let context = null;\n    if (event.browserContextId) {\n      // FIXME: we don't know about the default context id, so assume that all targets from\n      // unknown contexts are created in the 'default' context which can in practice be represented\n      // by multiple actual contexts in WebKit. Solving this properly will require adding context\n      // lifecycle events.\n      context = this._contexts.get(event.browserContextId) || null;\n    }\n    if (!context) context = this._defaultContext;\n    if (!context) return;\n    const pageProxySession = new _wkConnection.WKSession(this._connection, pageProxyId, `Target closed`, message => {\n      this._connection.rawSend({\n        ...message,\n        pageProxyId\n      });\n    });\n    const opener = event.openerId ? this._wkPages.get(event.openerId) : undefined;\n    const wkPage = new _wkPage.WKPage(context, pageProxySession, opener || null);\n    this._wkPages.set(pageProxyId, wkPage);\n  }\n  _onPageProxyDestroyed(event) {\n    const pageProxyId = event.pageProxyId;\n    const wkPage = this._wkPages.get(pageProxyId);\n    if (!wkPage) return;\n    wkPage.didClose();\n    wkPage.dispose(false);\n    this._wkPages.delete(pageProxyId);\n  }\n  _onPageProxyMessageReceived(event) {\n    const wkPage = this._wkPages.get(event.pageProxyId);\n    if (!wkPage) return;\n    wkPage.dispatchMessageToSession(event.message);\n  }\n  _onProvisionalLoadFailed(event) {\n    const wkPage = this._wkPages.get(event.pageProxyId);\n    if (!wkPage) return;\n    wkPage.handleProvisionalLoadFailed(event);\n  }\n  _onWindowOpen(event) {\n    const wkPage = this._wkPages.get(event.pageProxyId);\n    if (!wkPage) return;\n    wkPage.handleWindowOpen(event);\n  }\n  isConnected() {\n    return !this._connection.isClosed();\n  }\n}\nexports.WKBrowser = WKBrowser;\nclass WKBrowserContext extends _browserContext.BrowserContext {\n  constructor(browser, browserContextId, options) {\n    super(browser, options, browserContextId);\n    this._authenticateProxyViaHeader();\n  }\n  async _initialize() {\n    (0, _utils.assert)(!this._wkPages().length);\n    const browserContextId = this._browserContextId;\n    const promises = [super._initialize()];\n    promises.push(this._browser._browserSession.send('Playwright.setDownloadBehavior', {\n      behavior: this._options.acceptDownloads ? 'allow' : 'deny',\n      downloadPath: this._browser.options.downloadsPath,\n      browserContextId\n    }));\n    if (this._options.ignoreHTTPSErrors) promises.push(this._browser._browserSession.send('Playwright.setIgnoreCertificateErrors', {\n      browserContextId,\n      ignore: true\n    }));\n    if (this._options.locale) promises.push(this._browser._browserSession.send('Playwright.setLanguages', {\n      browserContextId,\n      languages: [this._options.locale]\n    }));\n    if (this._options.geolocation) promises.push(this.setGeolocation(this._options.geolocation));\n    if (this._options.offline) promises.push(this.setOffline(this._options.offline));\n    if (this._options.httpCredentials) promises.push(this.setHTTPCredentials(this._options.httpCredentials));\n    await Promise.all(promises);\n  }\n  _wkPages() {\n    return Array.from(this._browser._wkPages.values()).filter(wkPage => wkPage._browserContext === this);\n  }\n  pages() {\n    return this._wkPages().map(wkPage => wkPage._initializedPage).filter(pageOrNull => !!pageOrNull);\n  }\n  async newPageDelegate() {\n    (0, _browserContext.assertBrowserContextIsNotOwned)(this);\n    const {\n      pageProxyId\n    } = await this._browser._browserSession.send('Playwright.createPage', {\n      browserContextId: this._browserContextId\n    });\n    return this._browser._wkPages.get(pageProxyId);\n  }\n  async doGetCookies(urls) {\n    const {\n      cookies\n    } = await this._browser._browserSession.send('Playwright.getAllCookies', {\n      browserContextId: this._browserContextId\n    });\n    return network.filterCookies(cookies.map(c => {\n      const copy = {\n        ...c\n      };\n      copy.expires = c.expires === -1 ? -1 : c.expires / 1000;\n      delete copy.session;\n      return copy;\n    }), urls);\n  }\n  async addCookies(cookies) {\n    const cc = network.rewriteCookies(cookies).map(c => ({\n      ...c,\n      session: c.expires === -1 || c.expires === undefined,\n      expires: c.expires && c.expires !== -1 ? c.expires * 1000 : c.expires\n    }));\n    await this._browser._browserSession.send('Playwright.setCookies', {\n      cookies: cc,\n      browserContextId: this._browserContextId\n    });\n  }\n  async clearCookies() {\n    await this._browser._browserSession.send('Playwright.deleteAllCookies', {\n      browserContextId: this._browserContextId\n    });\n  }\n  async doGrantPermissions(origin, permissions) {\n    await Promise.all(this.pages().map(page => page._delegate._grantPermissions(origin, permissions)));\n  }\n  async doClearPermissions() {\n    await Promise.all(this.pages().map(page => page._delegate._clearPermissions()));\n  }\n  async setGeolocation(geolocation) {\n    (0, _browserContext.verifyGeolocation)(geolocation);\n    this._options.geolocation = geolocation;\n    const payload = geolocation ? {\n      ...geolocation,\n      timestamp: Date.now()\n    } : undefined;\n    await this._browser._browserSession.send('Playwright.setGeolocationOverride', {\n      browserContextId: this._browserContextId,\n      geolocation: payload\n    });\n  }\n  async setExtraHTTPHeaders(headers) {\n    this._options.extraHTTPHeaders = headers;\n    for (const page of this.pages()) await page._delegate.updateExtraHTTPHeaders();\n  }\n  async setUserAgent(userAgent) {\n    this._options.userAgent = userAgent;\n    for (const page of this.pages()) await page._delegate.updateUserAgent();\n  }\n  async setOffline(offline) {\n    this._options.offline = offline;\n    for (const page of this.pages()) await page._delegate.updateOffline();\n  }\n  async doSetHTTPCredentials(httpCredentials) {\n    this._options.httpCredentials = httpCredentials;\n    for (const page of this.pages()) await page._delegate.updateHttpCredentials();\n  }\n  async doAddInitScript(source) {\n    for (const page of this.pages()) await page._delegate._updateBootstrapScript();\n  }\n  async doRemoveInitScripts() {\n    for (const page of this.pages()) await page._delegate._updateBootstrapScript();\n  }\n  async doExposeBinding(binding) {\n    for (const page of this.pages()) await page._delegate.exposeBinding(binding);\n  }\n  async doRemoveExposedBindings() {\n    for (const page of this.pages()) await page._delegate.removeExposedBindings();\n  }\n  async doUpdateRequestInterception() {\n    for (const page of this.pages()) await page._delegate.updateRequestInterception();\n  }\n  onClosePersistent() {}\n  async doClose() {\n    if (!this._browserContextId) {\n      await Promise.all(this._wkPages().map(wkPage => wkPage._stopVideo()));\n      // Closing persistent context should close the browser.\n      await this._browser.close();\n    } else {\n      await this._browser._browserSession.send('Playwright.deleteContext', {\n        browserContextId: this._browserContextId\n      });\n      this._browser._contexts.delete(this._browserContextId);\n    }\n  }\n  async cancelDownload(uuid) {\n    await this._browser._browserSession.send('Playwright.cancelDownload', {\n      uuid\n    });\n  }\n}\nexports.WKBrowserContext = WKBrowserContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKSession = exports.WKConnection = void 0;\nexports.createProtocolError = createProtocolError;\nexports.kPageProxyMessageReceived = exports.kBrowserCloseMessageId = void 0;\nvar _events = require(\"events\");\nvar _utils = require(\"../../utils\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _helper = require(\"../helper\");\nvar _errors = require(\"../../common/errors\");\nvar _protocolError = require(\"../protocolError\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// WKPlaywright uses this special id to issue Browser.close command which we\n// should ignore.\nconst kBrowserCloseMessageId = -9999;\n\n// We emulate kPageProxyMessageReceived message to unify it with Browser.pageProxyCreated\n// and Browser.pageProxyDestroyed for easier management.\nexports.kBrowserCloseMessageId = kBrowserCloseMessageId;\nconst kPageProxyMessageReceived = 'kPageProxyMessageReceived';\nexports.kPageProxyMessageReceived = kPageProxyMessageReceived;\nclass WKConnection {\n  constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {\n    this._transport = void 0;\n    this._onDisconnect = void 0;\n    this._protocolLogger = void 0;\n    this._browserLogsCollector = void 0;\n    this._lastId = 0;\n    this._closed = false;\n    this.browserSession = void 0;\n    this._transport = transport;\n    this._onDisconnect = onDisconnect;\n    this._protocolLogger = protocolLogger;\n    this._browserLogsCollector = browserLogsCollector;\n    this.browserSession = new WKSession(this, '', _errors.kBrowserClosedError, message => {\n      this.rawSend(message);\n    });\n    this._transport.onmessage = this._dispatchMessage.bind(this);\n    // onclose should be set last, since it can be immediately called.\n    this._transport.onclose = this._onClose.bind(this);\n  }\n  nextMessageId() {\n    return ++this._lastId;\n  }\n  rawSend(message) {\n    this._protocolLogger('send', message);\n    this._transport.send(message);\n  }\n  _dispatchMessage(message) {\n    this._protocolLogger('receive', message);\n    if (message.id === kBrowserCloseMessageId) return;\n    if (message.pageProxyId) {\n      const payload = {\n        message: message,\n        pageProxyId: message.pageProxyId\n      };\n      this.browserSession.dispatchMessage({\n        method: kPageProxyMessageReceived,\n        params: payload\n      });\n      return;\n    }\n    this.browserSession.dispatchMessage(message);\n  }\n  _onClose() {\n    this._closed = true;\n    this._transport.onmessage = undefined;\n    this._transport.onclose = undefined;\n    this.browserSession.dispose(true);\n    this._onDisconnect();\n  }\n  isClosed() {\n    return this._closed;\n  }\n  close() {\n    if (!this._closed) this._transport.close();\n  }\n}\nexports.WKConnection = WKConnection;\nclass WKSession extends _events.EventEmitter {\n  constructor(connection, sessionId, errorText, rawSend) {\n    super();\n    this.connection = void 0;\n    this.errorText = void 0;\n    this.sessionId = void 0;\n    this._disposed = false;\n    this._rawSend = void 0;\n    this._callbacks = new Map();\n    this._crashed = false;\n    this.on = void 0;\n    this.addListener = void 0;\n    this.off = void 0;\n    this.removeListener = void 0;\n    this.once = void 0;\n    this.setMaxListeners(0);\n    this.connection = connection;\n    this.sessionId = sessionId;\n    this._rawSend = rawSend;\n    this.errorText = errorText;\n    this.on = super.on;\n    this.off = super.removeListener;\n    this.addListener = super.addListener;\n    this.removeListener = super.removeListener;\n    this.once = super.once;\n  }\n  async send(method, params) {\n    if (this._crashed) throw new _protocolError.ProtocolError(true, 'Target crashed');\n    if (this._disposed) throw new _protocolError.ProtocolError(true, `Target closed`);\n    const id = this.connection.nextMessageId();\n    const messageObj = {\n      id,\n      method,\n      params\n    };\n    this._rawSend(messageObj);\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {\n        resolve,\n        reject,\n        error: new _protocolError.ProtocolError(false),\n        method\n      });\n    });\n  }\n  sendMayFail(method, params) {\n    return this.send(method, params).catch(error => _debugLogger.debugLogger.log('error', error));\n  }\n  markAsCrashed() {\n    this._crashed = true;\n  }\n  isDisposed() {\n    return this._disposed;\n  }\n  dispose(disconnected) {\n    if (disconnected) this.errorText = 'Browser closed.' + _helper.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());\n    for (const callback of this._callbacks.values()) {\n      callback.error.sessionClosed = true;\n      callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, this.errorText));\n    }\n    this._callbacks.clear();\n    this._disposed = true;\n  }\n  dispatchMessage(object) {\n    if (object.id && this._callbacks.has(object.id)) {\n      const callback = this._callbacks.get(object.id);\n      this._callbacks.delete(object.id);\n      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object.error));else callback.resolve(object.result);\n    } else if (object.id && !object.error) {\n      // Response might come after session has been disposed and rejected all callbacks.\n      (0, _utils.assert)(this.isDisposed());\n    } else {\n      Promise.resolve().then(() => this.emit(object.method, object.params));\n    }\n  }\n}\nexports.WKSession = WKSession;\nfunction createProtocolError(error, method, protocolError) {\n  let message = `Protocol error (${method}): ${protocolError.message}`;\n  if ('data' in protocolError) message += ` ${JSON.stringify(protocolError.data)}`;\n  return (0, _stackTrace.rewriteErrorMessage)(error, message);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKExecutionContext = void 0;\nvar js = _interopRequireWildcard(require(\"../javascript\"));\nvar _utilityScriptSerializers = require(\"../isomorphic/utilityScriptSerializers\");\nvar _protocolError = require(\"../protocolError\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WKExecutionContext {\n  constructor(session, contextId) {\n    this._session = void 0;\n    this._contextId = void 0;\n    this._session = session;\n    this._contextId = contextId;\n  }\n  async rawEvaluateJSON(expression) {\n    try {\n      const response = await this._session.send('Runtime.evaluate', {\n        expression,\n        contextId: this._contextId,\n        returnByValue: true\n      });\n      if (response.wasThrown) throw new js.JavaScriptErrorInEvaluate(response.result.description);\n      return response.result.value;\n    } catch (error) {\n      throw rewriteError(error);\n    }\n  }\n  async rawEvaluateHandle(expression) {\n    try {\n      const response = await this._session.send('Runtime.evaluate', {\n        expression,\n        contextId: this._contextId,\n        returnByValue: false\n      });\n      if (response.wasThrown) throw new js.JavaScriptErrorInEvaluate(response.result.description);\n      return response.result.objectId;\n    } catch (error) {\n      throw rewriteError(error);\n    }\n  }\n  rawCallFunctionNoReply(func, ...args) {\n    this._session.send('Runtime.callFunctionOn', {\n      functionDeclaration: func.toString(),\n      objectId: args.find(a => a instanceof js.JSHandle)._objectId,\n      arguments: args.map(a => a instanceof js.JSHandle ? {\n        objectId: a._objectId\n      } : {\n        value: a\n      }),\n      returnByValue: true,\n      emulateUserGesture: true\n    }).catch(() => {});\n  }\n  async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {\n    try {\n      const response = await this._session.send('Runtime.callFunctionOn', {\n        functionDeclaration: expression,\n        objectId: utilityScript._objectId,\n        arguments: [{\n          objectId: utilityScript._objectId\n        }, ...values.map(value => ({\n          value\n        })), ...objectIds.map(objectId => ({\n          objectId\n        }))],\n        returnByValue,\n        emulateUserGesture: true,\n        awaitPromise: true\n      });\n      if (response.wasThrown) throw new js.JavaScriptErrorInEvaluate(response.result.description);\n      if (returnByValue) return (0, _utilityScriptSerializers.parseEvaluationResultValue)(response.result.value);\n      return utilityScript._context.createHandle(response.result);\n    } catch (error) {\n      throw rewriteError(error);\n    }\n  }\n  async getProperties(context, objectId) {\n    const response = await this._session.send('Runtime.getProperties', {\n      objectId,\n      ownProperties: true\n    });\n    const result = new Map();\n    for (const property of response.properties) {\n      if (!property.enumerable || !property.value) continue;\n      result.set(property.name, context.createHandle(property.value));\n    }\n    return result;\n  }\n  createHandle(context, remoteObject) {\n    const isPromise = remoteObject.className === 'Promise';\n    return new js.JSHandle(context, isPromise ? 'promise' : remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));\n  }\n  async releaseHandle(objectId) {\n    await this._session.send('Runtime.releaseObject', {\n      objectId\n    });\n  }\n}\nexports.WKExecutionContext = WKExecutionContext;\nfunction potentiallyUnserializableValue(remoteObject) {\n  const value = remoteObject.value;\n  const isUnserializable = remoteObject.type === 'number' && ['NaN', '-Infinity', 'Infinity', '-0'].includes(remoteObject.description);\n  return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;\n}\nfunction rewriteError(error) {\n  if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error)) return new Error('Execution context was destroyed, most likely because of a navigation.');\n  return error;\n}\nfunction renderPreview(object) {\n  if (object.type === 'undefined') return 'undefined';\n  if ('value' in object) return String(object.value);\n  if (object.description === 'Object' && object.preview) {\n    const tokens = [];\n    for (const {\n      name,\n      value\n    } of object.preview.properties) tokens.push(`${name}: ${value}`);\n    return `{${tokens.join(', ')}}`;\n  }\n  if (object.subtype === 'array' && object.preview) return js.sparseArrayToString(object.preview.properties);\n  return object.description;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;\nvar input = _interopRequireWildcard(require(\"../input\"));\nvar _macEditingCommands = require(\"../macEditingCommands\");\nvar _utils = require(\"../../utils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction toModifiersMask(modifiers) {\n  // From Source/WebKit/Shared/WebEvent.h\n  let mask = 0;\n  if (modifiers.has('Shift')) mask |= 1;\n  if (modifiers.has('Control')) mask |= 2;\n  if (modifiers.has('Alt')) mask |= 4;\n  if (modifiers.has('Meta')) mask |= 8;\n  return mask;\n}\nfunction toButtonsMask(buttons) {\n  let mask = 0;\n  if (buttons.has('left')) mask |= 1;\n  if (buttons.has('right')) mask |= 2;\n  if (buttons.has('middle')) mask |= 4;\n  return mask;\n}\nclass RawKeyboardImpl {\n  constructor(session) {\n    this._pageProxySession = void 0;\n    this._session = void 0;\n    this._pageProxySession = session;\n  }\n  setSession(session) {\n    this._session = session;\n  }\n  async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {\n    const parts = [];\n    for (const modifier of ['Shift', 'Control', 'Alt', 'Meta']) {\n      if (modifiers.has(modifier)) parts.push(modifier);\n    }\n    parts.push(code);\n    const shortcut = parts.join('+');\n    let commands = _macEditingCommands.macEditingCommands[shortcut];\n    if ((0, _utils.isString)(commands)) commands = [commands];\n    await this._pageProxySession.send('Input.dispatchKeyEvent', {\n      type: 'keyDown',\n      modifiers: toModifiersMask(modifiers),\n      windowsVirtualKeyCode: keyCode,\n      code,\n      key,\n      text,\n      unmodifiedText: text,\n      autoRepeat,\n      macCommands: commands,\n      isKeypad: location === input.keypadLocation\n    });\n  }\n  async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {\n    await this._pageProxySession.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: toModifiersMask(modifiers),\n      key,\n      windowsVirtualKeyCode: keyCode,\n      code,\n      isKeypad: location === input.keypadLocation\n    });\n  }\n  async sendText(text) {\n    await this._session.send('Page.insertText', {\n      text\n    });\n  }\n}\nexports.RawKeyboardImpl = RawKeyboardImpl;\nclass RawMouseImpl {\n  constructor(session) {\n    this._pageProxySession = void 0;\n    this._session = void 0;\n    this._page = void 0;\n    this._pageProxySession = session;\n  }\n  setSession(session) {\n    this._session = session;\n  }\n  async move(x, y, button, buttons, modifiers, forClick) {\n    await this._pageProxySession.send('Input.dispatchMouseEvent', {\n      type: 'move',\n      button,\n      buttons: toButtonsMask(buttons),\n      x,\n      y,\n      modifiers: toModifiersMask(modifiers)\n    });\n  }\n  async down(x, y, button, buttons, modifiers, clickCount) {\n    await this._pageProxySession.send('Input.dispatchMouseEvent', {\n      type: 'down',\n      button,\n      buttons: toButtonsMask(buttons),\n      x,\n      y,\n      modifiers: toModifiersMask(modifiers),\n      clickCount\n    });\n  }\n  async up(x, y, button, buttons, modifiers, clickCount) {\n    await this._pageProxySession.send('Input.dispatchMouseEvent', {\n      type: 'up',\n      button,\n      buttons: toButtonsMask(buttons),\n      x,\n      y,\n      modifiers: toModifiersMask(modifiers),\n      clickCount\n    });\n  }\n  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {\n    var _this$_page;\n    if ((_this$_page = this._page) !== null && _this$_page !== void 0 && _this$_page._browserContext._options.isMobile) throw new Error('Mouse wheel is not supported in mobile WebKit');\n    await this._session.send('Page.updateScrollingState');\n    // Wheel events hit the compositor first, so wait one frame for it to be synced.\n    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, 'utility');\n    await this._pageProxySession.send('Input.dispatchWheelEvent', {\n      x,\n      y,\n      deltaX,\n      deltaY,\n      modifiers: toModifiersMask(modifiers)\n    });\n  }\n  setPage(page) {\n    this._page = page;\n  }\n}\nexports.RawMouseImpl = RawMouseImpl;\nclass RawTouchscreenImpl {\n  constructor(session) {\n    this._pageProxySession = void 0;\n    this._pageProxySession = session;\n  }\n  async tap(x, y, modifiers) {\n    await this._pageProxySession.send('Input.dispatchTapEvent', {\n      x,\n      y,\n      modifiers: toModifiersMask(modifiers)\n    });\n  }\n}\nexports.RawTouchscreenImpl = RawTouchscreenImpl;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKRouteImpl = exports.WKInterceptableRequest = void 0;\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _utils = require(\"../../utils\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst errorReasons = {\n  'aborted': 'Cancellation',\n  'accessdenied': 'AccessControl',\n  'addressunreachable': 'General',\n  'blockedbyclient': 'Cancellation',\n  'blockedbyresponse': 'General',\n  'connectionaborted': 'General',\n  'connectionclosed': 'General',\n  'connectionfailed': 'General',\n  'connectionrefused': 'General',\n  'connectionreset': 'General',\n  'internetdisconnected': 'General',\n  'namenotresolved': 'General',\n  'timedout': 'Timeout',\n  'failed': 'General'\n};\nclass WKInterceptableRequest {\n  constructor(session, route, frame, event, redirectedFrom, documentId) {\n    this._session = void 0;\n    this.request = void 0;\n    this._requestId = void 0;\n    this._timestamp = void 0;\n    this._wallTime = void 0;\n    this._route = void 0;\n    this._redirectedFrom = void 0;\n    this._session = session;\n    this._requestId = event.requestId;\n    this._route = route;\n    this._redirectedFrom = redirectedFrom;\n    const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : 'other';\n    let postDataBuffer = null;\n    this._timestamp = event.timestamp;\n    this._wallTime = event.walltime * 1000;\n    if (event.request.postData) postDataBuffer = Buffer.from(event.request.postData, 'base64');\n    this.request = new network.Request(frame._page._browserContext, frame, null, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, (0, _utils.headersObjectToArray)(event.request.headers));\n  }\n  _routeForRedirectChain() {\n    let request = this;\n    while (request._redirectedFrom) request = request._redirectedFrom;\n    return request._route;\n  }\n  createResponse(responsePayload) {\n    const getResponseBody = async () => {\n      const response = await this._session.send('Network.getResponseBody', {\n        requestId: this._requestId\n      });\n      return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n    };\n    const timingPayload = responsePayload.timing;\n    const timing = {\n      startTime: this._wallTime,\n      domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,\n      domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,\n      connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,\n      secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,\n      connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,\n      requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,\n      responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1\n    };\n    const setCookieSeparator = process.platform === 'darwin' ? ',' : '\\n';\n    const response = new network.Response(this.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers, ',', setCookieSeparator), timing, getResponseBody, responsePayload.source === 'service-worker');\n\n    // No raw response headers in WebKit, use \"provisional\" ones.\n    response.setRawResponseHeaders(null);\n    // Transfer size is not available in WebKit.\n    response.setTransferSize(null);\n    if (responsePayload.requestHeaders && Object.keys(responsePayload.requestHeaders).length) {\n      const headers = {\n        ...responsePayload.requestHeaders\n      };\n      if (!headers['host']) headers['Host'] = new URL(this.request.url()).host;\n      this.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(headers));\n    } else {\n      // No raw headers avaialable, use provisional ones.\n      this.request.setRawRequestHeaders(null);\n    }\n    return response;\n  }\n}\nexports.WKInterceptableRequest = WKInterceptableRequest;\nclass WKRouteImpl {\n  constructor(session, requestId) {\n    this._session = void 0;\n    this._requestId = void 0;\n    this._requestInterceptedPromise = new _manualPromise.ManualPromise();\n    this._session = session;\n    this._requestId = requestId;\n  }\n  async abort(errorCode) {\n    const errorType = errorReasons[errorCode];\n    (0, _utils.assert)(errorType, 'Unknown error code: ' + errorCode);\n    await this._requestInterceptedPromise;\n    // In certain cases, protocol will return error if the request was already canceled\n    // or the page was closed. We should tolerate these errors.\n    await this._session.sendMayFail('Network.interceptRequestWithError', {\n      requestId: this._requestId,\n      errorType\n    });\n  }\n  async fulfill(response) {\n    if (300 <= response.status && response.status < 400) throw new Error('Cannot fulfill with redirect status: ' + response.status);\n    await this._requestInterceptedPromise;\n    // In certain cases, protocol will return error if the request was already canceled\n    // or the page was closed. We should tolerate these errors.\n    let mimeType = response.isBase64 ? 'application/octet-stream' : 'text/plain';\n    const headers = (0, _utils.headersArrayToObject)(response.headers, true /* lowerCase */);\n    const contentType = headers['content-type'];\n    if (contentType) mimeType = contentType.split(';')[0].trim();\n    await this._session.sendMayFail('Network.interceptRequestWithResponse', {\n      requestId: this._requestId,\n      status: response.status,\n      statusText: network.STATUS_TEXTS[String(response.status)],\n      mimeType,\n      headers,\n      base64Encoded: response.isBase64,\n      content: response.body\n    });\n  }\n  async continue(request, overrides) {\n    await this._requestInterceptedPromise;\n    // In certain cases, protocol will return error if the request was already canceled\n    // or the page was closed. We should tolerate these errors.\n    await this._session.sendMayFail('Network.interceptWithRequest', {\n      requestId: this._requestId,\n      url: overrides.url,\n      method: overrides.method,\n      headers: overrides.headers ? (0, _utils.headersArrayToObject)(overrides.headers, false /* lowerCase */) : undefined,\n      postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined\n    });\n  }\n}\nexports.WKRouteImpl = WKRouteImpl;\nfunction wkMillisToRoundishMillis(value) {\n  // WebKit uses -1000 for unavailable.\n  if (value === -1000) return -1;\n\n  // WebKit has a bug, instead of -1 it sends -1000 to be in ms.\n  if (value <= 0) {\n    // DNS can start before request start on Mac Network Stack\n    return -1;\n  }\n  return (value * 1000 | 0) / 1000;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKPage = void 0;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _utilsBundle = require(\"../../utilsBundle\");\nvar _stackTrace = require(\"../../utils/stackTrace\");\nvar _utils = require(\"../../utils\");\nvar _hostPlatform = require(\"../../utils/hostPlatform\");\nvar dialog = _interopRequireWildcard(require(\"../dialog\"));\nvar dom = _interopRequireWildcard(require(\"../dom\"));\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _helper = require(\"../helper\");\nvar network = _interopRequireWildcard(require(\"../network\"));\nvar _page = require(\"../page\");\nvar _wkAccessibility = require(\"./wkAccessibility\");\nvar _wkConnection = require(\"./wkConnection\");\nvar _wkExecutionContext = require(\"./wkExecutionContext\");\nvar _wkInput = require(\"./wkInput\");\nvar _wkInterceptableRequest = require(\"./wkInterceptableRequest\");\nvar _wkProvisionalPage = require(\"./wkProvisionalPage\");\nvar _wkWorkers = require(\"./wkWorkers\");\nvar _debugLogger = require(\"../../common/debugLogger\");\nvar _manualPromise = require(\"../../utils/manualPromise\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst UTILITY_WORLD_NAME = '__playwright_utility_world__';\nclass WKPage {\n  // Holds window features for the next popup being opened via window.open,\n  // until the popup page proxy arrives.\n\n  constructor(browserContext, pageProxySession, opener) {\n    this.rawMouse = void 0;\n    this.rawKeyboard = void 0;\n    this.rawTouchscreen = void 0;\n    this._session = void 0;\n    this._provisionalPage = null;\n    this._page = void 0;\n    this._pagePromise = new _manualPromise.ManualPromise();\n    this._pageProxySession = void 0;\n    this._opener = void 0;\n    this._requestIdToRequest = new Map();\n    this._workers = void 0;\n    this._contextIdToContext = void 0;\n    this._mainFrameContextId = void 0;\n    this._sessionListeners = [];\n    this._eventListeners = void 0;\n    this._browserContext = void 0;\n    this._initializedPage = null;\n    this._firstNonInitialNavigationCommittedPromise = void 0;\n    this._firstNonInitialNavigationCommittedFulfill = () => {};\n    this._firstNonInitialNavigationCommittedReject = e => {};\n    this._lastConsoleMessage = null;\n    this._requestIdToResponseReceivedPayloadEvent = new Map();\n    this._nextWindowOpenPopupFeatures = void 0;\n    this._recordingVideoFile = null;\n    this._screencastGeneration = 0;\n    this._pageProxySession = pageProxySession;\n    this._opener = opener;\n    this.rawKeyboard = new _wkInput.RawKeyboardImpl(pageProxySession);\n    this.rawMouse = new _wkInput.RawMouseImpl(pageProxySession);\n    this.rawTouchscreen = new _wkInput.RawTouchscreenImpl(pageProxySession);\n    this._contextIdToContext = new Map();\n    this._page = new _page.Page(this, browserContext);\n    this.rawMouse.setPage(this._page);\n    this._workers = new _wkWorkers.WKWorkers(this._page);\n    this._session = undefined;\n    this._browserContext = browserContext;\n    this._page.on(_page.Page.Events.FrameDetached, frame => this._removeContextsForFrame(frame, false));\n    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.targetCreated', this._onTargetCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.dispatchMessageFromTarget', this._onDispatchMessageFromTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.didCommitProvisionalTarget', this._onDidCommitProvisionalTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Screencast.screencastFrame', this._onScreencastFrame.bind(this))];\n    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {\n      this._firstNonInitialNavigationCommittedFulfill = f;\n      this._firstNonInitialNavigationCommittedReject = r;\n    });\n    if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {\n      const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);\n      opener._nextWindowOpenPopupFeatures = undefined;\n      if (viewportSize) this._page._emulatedSize = {\n        viewport: viewportSize,\n        screen: viewportSize\n      };\n    }\n  }\n  potentiallyUninitializedPage() {\n    return this._page;\n  }\n  async _initializePageProxySession() {\n    if (this._page._browserContext.isSettingStorageState()) return;\n    const promises = [this._pageProxySession.send('Dialog.enable'), this._pageProxySession.send('Emulation.setActiveAndFocused', {\n      active: true\n    })];\n    const contextOptions = this._browserContext._options;\n    if (contextOptions.javaScriptEnabled === false) promises.push(this._pageProxySession.send('Emulation.setJavaScriptEnabled', {\n      enabled: false\n    }));\n    promises.push(this._updateViewport());\n    promises.push(this.updateHttpCredentials());\n    if (this._browserContext._permissions.size) {\n      for (const [key, value] of this._browserContext._permissions) promises.push(this._grantPermissions(key, value));\n    }\n    if (this._browserContext._options.recordVideo) {\n      const outputFile = _path.default.join(this._browserContext._options.recordVideo.dir, (0, _utils.createGuid)() + '.webm');\n      promises.push(this._browserContext._ensureVideosPath().then(() => {\n        return this._startVideo({\n          // validateBrowserContextOptions ensures correct video size.\n          ...this._browserContext._options.recordVideo.size,\n          outputFile\n        });\n      }));\n    }\n    await Promise.all(promises);\n  }\n  _setSession(session) {\n    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);\n    this._session = session;\n    this.rawKeyboard.setSession(session);\n    this.rawMouse.setSession(session);\n    this._addSessionListeners();\n    this._workers.setSession(session);\n  }\n\n  // This method is called for provisional targets as well. The session passed as the parameter\n  // may be different from the current session and may be destroyed without becoming current.\n  async _initializeSession(session, provisional, resourceTreeHandler) {\n    await this._initializeSessionMayThrow(session, resourceTreeHandler).catch(e => {\n      // Provisional session can be disposed at any time, for example due to new navigation initiating\n      // a new provisional page.\n      if (provisional && session.isDisposed()) return;\n      // Swallow initialization errors due to newer target swap in,\n      // since we will reinitialize again.\n      if (this._session === session) throw e;\n    });\n  }\n  async _initializeSessionMayThrow(session, resourceTreeHandler) {\n    const [, frameTree] = await Promise.all([\n    // Page agent must be enabled before Runtime.\n    session.send('Page.enable'), session.send('Page.getResourceTree')]);\n    resourceTreeHandler(frameTree);\n    const promises = [\n    // Resource tree should be received before first execution context.\n    session.send('Runtime.enable'), session.send('Page.createUserWorld', {\n      name: UTILITY_WORLD_NAME\n    }).catch(_ => {}),\n    // Worlds are per-process\n    session.send('Console.enable'), session.send('Network.enable'), this._workers.initializeSession(session)];\n    if (this._page.needsRequestInterception()) {\n      promises.push(session.send('Network.setInterceptionEnabled', {\n        enabled: true\n      }));\n      promises.push(session.send('Network.addInterception', {\n        url: '.*',\n        stage: 'request',\n        isRegex: true\n      }));\n    }\n    if (this._page._browserContext.isSettingStorageState()) {\n      await Promise.all(promises);\n      return;\n    }\n    const contextOptions = this._browserContext._options;\n    if (contextOptions.userAgent) promises.push(this.updateUserAgent());\n    const emulatedMedia = this._page.emulatedMedia();\n    if (emulatedMedia.media || emulatedMedia.colorScheme || emulatedMedia.reducedMotion || emulatedMedia.forcedColors) promises.push(WKPage._setEmulateMedia(session, emulatedMedia.media, emulatedMedia.colorScheme, emulatedMedia.reducedMotion, emulatedMedia.forcedColors));\n    for (const binding of this._page.allBindings()) promises.push(session.send('Runtime.addBinding', {\n      name: binding.name\n    }));\n    const bootstrapScript = this._calculateBootstrapScript();\n    if (bootstrapScript.length) promises.push(session.send('Page.setBootstrapScript', {\n      source: bootstrapScript\n    }));\n    this._page.frames().map(frame => frame.evaluateExpression(bootstrapScript, false, undefined).catch(e => {}));\n    if (contextOptions.bypassCSP) promises.push(session.send('Page.setBypassCSP', {\n      enabled: true\n    }));\n    const emulatedSize = this._page.emulatedSize();\n    if (emulatedSize) {\n      promises.push(session.send('Page.setScreenSizeOverride', {\n        width: emulatedSize.screen.width,\n        height: emulatedSize.screen.height\n      }));\n    }\n    promises.push(this.updateEmulateMedia());\n    promises.push(session.send('Network.setExtraHTTPHeaders', {\n      headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false /* lowerCase */)\n    }));\n    if (contextOptions.offline) promises.push(session.send('Network.setEmulateOfflineState', {\n      offline: true\n    }));\n    promises.push(session.send('Page.setTouchEmulationEnabled', {\n      enabled: !!contextOptions.hasTouch\n    }));\n    if (contextOptions.timezoneId) {\n      promises.push(session.send('Page.setTimeZone', {\n        timeZone: contextOptions.timezoneId\n      }).catch(e => {\n        throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);\n      }));\n    }\n    if (this._page.fileChooserIntercepted()) promises.push(session.send('Page.setInterceptFileChooserDialog', {\n      enabled: true\n    }));\n    promises.push(session.send('Page.overrideSetting', {\n      setting: 'DeviceOrientationEventEnabled',\n      value: contextOptions.isMobile\n    }));\n    promises.push(session.send('Page.overrideSetting', {\n      setting: 'FullScreenEnabled',\n      value: !contextOptions.isMobile\n    }));\n    promises.push(session.send('Page.overrideSetting', {\n      setting: 'NotificationsEnabled',\n      value: !contextOptions.isMobile\n    }));\n    promises.push(session.send('Page.overrideSetting', {\n      setting: 'PointerLockEnabled',\n      value: !contextOptions.isMobile\n    }));\n    promises.push(session.send('Page.overrideSetting', {\n      setting: 'InputTypeMonthEnabled',\n      value: contextOptions.isMobile\n    }));\n    promises.push(session.send('Page.overrideSetting', {\n      setting: 'InputTypeWeekEnabled',\n      value: contextOptions.isMobile\n    }));\n    await Promise.all(promises);\n  }\n  _onDidCommitProvisionalTarget(event) {\n    const {\n      oldTargetId,\n      newTargetId\n    } = event;\n    (0, _utils.assert)(this._provisionalPage);\n    (0, _utils.assert)(this._provisionalPage._session.sessionId === newTargetId, 'Unknown new target: ' + newTargetId);\n    (0, _utils.assert)(this._session.sessionId === oldTargetId, 'Unknown old target: ' + oldTargetId);\n    const newSession = this._provisionalPage._session;\n    this._provisionalPage.commit();\n    this._provisionalPage.dispose();\n    this._provisionalPage = null;\n    this._setSession(newSession);\n  }\n  _onTargetDestroyed(event) {\n    const {\n      targetId,\n      crashed\n    } = event;\n    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {\n      this._provisionalPage._session.dispose(false);\n      this._provisionalPage.dispose();\n      this._provisionalPage = null;\n    } else if (this._session.sessionId === targetId) {\n      this._session.dispose(false);\n      _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);\n      if (crashed) {\n        this._session.markAsCrashed();\n        this._page._didCrash();\n      }\n    }\n  }\n  didClose() {\n    this._page._didClose();\n  }\n  dispose(disconnected) {\n    this._pageProxySession.dispose(disconnected);\n    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);\n    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);\n    if (this._session) this._session.dispose(disconnected);\n    if (this._provisionalPage) {\n      this._provisionalPage._session.dispose(disconnected);\n      this._provisionalPage.dispose();\n      this._provisionalPage = null;\n    }\n    this._page._didDisconnect();\n    this._firstNonInitialNavigationCommittedReject(new Error('Page closed'));\n  }\n  dispatchMessageToSession(message) {\n    this._pageProxySession.dispatchMessage(message);\n  }\n  handleProvisionalLoadFailed(event) {\n    if (!this._initializedPage) {\n      this._firstNonInitialNavigationCommittedReject(new Error('Initial load failed'));\n      return;\n    }\n    if (!this._provisionalPage) return;\n    let errorText = event.error;\n    if (errorText.includes('cancelled')) errorText += '; maybe frame was detached?';\n    this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);\n  }\n  handleWindowOpen(event) {\n    (0, _utils.debugAssert)(!this._nextWindowOpenPopupFeatures);\n    this._nextWindowOpenPopupFeatures = event.windowFeatures;\n  }\n  async pageOrError() {\n    return this._pagePromise;\n  }\n  async _onTargetCreated(event) {\n    const {\n      targetInfo\n    } = event;\n    const session = new _wkConnection.WKSession(this._pageProxySession.connection, targetInfo.targetId, `Target closed`, message => {\n      this._pageProxySession.send('Target.sendMessageToTarget', {\n        message: JSON.stringify(message),\n        targetId: targetInfo.targetId\n      }).catch(e => {\n        session.dispatchMessage({\n          id: message.id,\n          error: {\n            message: e.message\n          }\n        });\n      });\n    });\n    (0, _utils.assert)(targetInfo.type === 'page', 'Only page targets are expected in WebKit, received: ' + targetInfo.type);\n    if (!targetInfo.isProvisional) {\n      (0, _utils.assert)(!this._initializedPage);\n      let pageOrError;\n      try {\n        this._setSession(session);\n        await Promise.all([this._initializePageProxySession(), this._initializeSession(session, false, ({\n          frameTree\n        }) => this._handleFrameTree(frameTree))]);\n        pageOrError = this._page;\n      } catch (e) {\n        pageOrError = e;\n      }\n      if (targetInfo.isPaused) this._pageProxySession.sendMayFail('Target.resume', {\n        targetId: targetInfo.targetId\n      });\n      if (pageOrError instanceof _page.Page && this._page.mainFrame().url() === '') {\n        try {\n          // Initial empty page has an empty url. We should wait until the first real url has been loaded,\n          // even if that url is about:blank. This is especially important for popups, where we need the\n          // actual url before interacting with it.\n          await this._firstNonInitialNavigationCommittedPromise;\n        } catch (e) {\n          pageOrError = e;\n        }\n      } else {\n        // Avoid rejection on disconnect.\n        this._firstNonInitialNavigationCommittedPromise.catch(() => {});\n      }\n      await this._page.initOpener(this._opener);\n      // Note: it is important to call |reportAsNew| before resolving pageOrError promise,\n      // so that anyone who awaits pageOrError got a ready and reported page.\n      this._initializedPage = pageOrError instanceof _page.Page ? pageOrError : null;\n      this._page.reportAsNew(pageOrError instanceof _page.Page ? undefined : pageOrError);\n      this._pagePromise.resolve(pageOrError);\n    } else {\n      (0, _utils.assert)(targetInfo.isProvisional);\n      (0, _utils.assert)(!this._provisionalPage);\n      this._provisionalPage = new _wkProvisionalPage.WKProvisionalPage(session, this);\n      if (targetInfo.isPaused) {\n        this._provisionalPage.initializationPromise.then(() => {\n          this._pageProxySession.sendMayFail('Target.resume', {\n            targetId: targetInfo.targetId\n          });\n        });\n      }\n    }\n  }\n  _onDispatchMessageFromTarget(event) {\n    const {\n      targetId,\n      message\n    } = event;\n    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) this._provisionalPage._session.dispatchMessage(JSON.parse(message));else if (this._session.sessionId === targetId) this._session.dispatchMessage(JSON.parse(message));else throw new Error('Unknown target: ' + targetId);\n  }\n  _addSessionListeners() {\n    this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.willCheckNavigationPolicy', event => this._onWillCheckNavigationPolicy(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.didCheckNavigationPolicy', event => this._onDidCheckNavigationPolicy(event.frameId, event.cancel)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameScheduledNavigation', event => this._onFrameScheduledNavigation(event.frameId, event.delay, event.targetIsCurrentFrame)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.loadEventFired', event => this._page._frameManager.frameLifecycleEvent(event.frameId, 'load')), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.domContentEventFired', event => this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded')), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.bindingCalled', event => this._onBindingCalled(event.contextId, event.argument)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Console.messageAdded', event => this._onConsoleMessage(event)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Console.messageRepeatCountUpdated', event => this._onConsoleRepeatCountUpdated(event)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Dialog.javascriptDialogOpening', event => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.requestWillBeSent', e => this._onRequestWillBeSent(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.requestIntercepted', e => this._onRequestIntercepted(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.responseReceived', e => this._onResponseReceived(e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.loadingFinished', e => this._onLoadingFinished(e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.loadingFailed', e => this._onLoadingFailed(e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketCreated', e => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketWillSendHandshakeRequest', e => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketHandshakeResponseReceived', e => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketClosed', e => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketFrameError', e => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];\n  }\n  async _updateState(method, params) {\n    await this._forAllSessions(session => session.send(method, params).then());\n  }\n  async _forAllSessions(callback) {\n    const sessions = [this._session];\n    // If the state changes during provisional load, push it to the provisional page\n    // as well to always be in sync with the backend.\n    if (this._provisionalPage) sessions.push(this._provisionalPage._session);\n    await Promise.all(sessions.map(session => callback(session).catch(e => {})));\n  }\n  _onWillCheckNavigationPolicy(frameId) {\n    // It may happen that new policy check occurs while there is an ongoing\n    // provisional load, in this case it should be safe to ignore it as it will\n    // either:\n    // - end up canceled, e.g. ctrl+click opening link in new tab, having no effect\n    //   on this page\n    // - start new provisional load which we will miss in our signal trackers but\n    //   we certainly won't hang waiting for it to finish and there is high chance\n    //   that the current provisional page will commit navigation canceling the new\n    //   one.\n    if (this._provisionalPage) return;\n    this._page._frameManager.frameRequestedNavigation(frameId);\n  }\n  _onDidCheckNavigationPolicy(frameId, cancel) {\n    if (!cancel) return;\n    // This is a cross-process navigation that is canceled in the original page and continues in\n    // the provisional page. Bail out as we are tracking it.\n    if (this._provisionalPage) return;\n    this._page._frameManager.frameAbortedNavigation(frameId, 'Navigation canceled by policy check');\n  }\n  _onFrameScheduledNavigation(frameId, delay, targetIsCurrentFrame) {\n    if (targetIsCurrentFrame) this._page._frameManager.frameRequestedNavigation(frameId);\n  }\n  _handleFrameTree(frameTree) {\n    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);\n    this._onFrameNavigated(frameTree.frame, true);\n    this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, 'domcontentloaded');\n    this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, 'load');\n    if (!frameTree.childFrames) return;\n    for (const child of frameTree.childFrames) this._handleFrameTree(child);\n  }\n  _onFrameAttached(frameId, parentFrameId) {\n    return this._page._frameManager.frameAttached(frameId, parentFrameId);\n  }\n  _onFrameNavigated(framePayload, initial) {\n    const frame = this._page._frameManager.frame(framePayload.id);\n    (0, _utils.assert)(frame);\n    this._removeContextsForFrame(frame, true);\n    if (!framePayload.parentId) this._workers.clear();\n    this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);\n    if (!initial) this._firstNonInitialNavigationCommittedFulfill();\n  }\n  _onFrameNavigatedWithinDocument(frameId, url) {\n    this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);\n  }\n  _onFrameDetached(frameId) {\n    this._page._frameManager.frameDetached(frameId);\n  }\n  _removeContextsForFrame(frame, notifyFrame) {\n    for (const [contextId, context] of this._contextIdToContext) {\n      if (context.frame === frame) {\n        this._contextIdToContext.delete(contextId);\n        if (notifyFrame) frame._contextDestroyed(context);\n      }\n    }\n  }\n  _onExecutionContextCreated(contextPayload) {\n    if (this._contextIdToContext.has(contextPayload.id)) return;\n    const frame = this._page._frameManager.frame(contextPayload.frameId);\n    if (!frame) return;\n    const delegate = new _wkExecutionContext.WKExecutionContext(this._session, contextPayload.id);\n    let worldName = null;\n    if (contextPayload.type === 'normal') worldName = 'main';else if (contextPayload.type === 'user' && contextPayload.name === UTILITY_WORLD_NAME) worldName = 'utility';\n    const context = new dom.FrameExecutionContext(delegate, frame, worldName);\n    context[contextDelegateSymbol] = delegate;\n    if (worldName) frame._contextCreated(worldName, context);\n    if (contextPayload.type === 'normal' && frame === this._page.mainFrame()) this._mainFrameContextId = contextPayload.id;\n    this._contextIdToContext.set(contextPayload.id, context);\n  }\n  async _onBindingCalled(contextId, argument) {\n    const pageOrError = await this.pageOrError();\n    if (!(pageOrError instanceof Error)) {\n      const context = this._contextIdToContext.get(contextId);\n      if (context) await this._page._onBindingCalled(argument, context);\n    }\n  }\n  async navigateFrame(frame, url, referrer) {\n    if (this._pageProxySession.isDisposed()) throw new Error('Target closed');\n    const pageProxyId = this._pageProxySession.sessionId;\n    const result = await this._pageProxySession.connection.browserSession.send('Playwright.navigate', {\n      url,\n      pageProxyId,\n      frameId: frame._id,\n      referrer\n    });\n    return {\n      newDocumentId: result.loaderId\n    };\n  }\n  _onConsoleMessage(event) {\n    // Note: do no introduce await in this function, otherwise we lose the ordering.\n    // For example, frame.setContent relies on this.\n    const {\n      type,\n      level,\n      text,\n      parameters,\n      url,\n      line: lineNumber,\n      column: columnNumber,\n      source\n    } = event.message;\n    if (level === 'error' && source === 'javascript') {\n      const {\n        name,\n        message\n      } = (0, _stackTrace.splitErrorMessage)(text);\n      let stack;\n      if (event.message.stackTrace) {\n        stack = text + '\\n' + event.message.stackTrace.callFrames.map(callFrame => {\n          return `    at ${callFrame.functionName || 'unknown'} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;\n        }).join('\\n');\n      } else {\n        stack = '';\n      }\n      const error = new Error(message);\n      error.stack = stack;\n      error.name = name;\n      this._page.firePageError(error);\n      return;\n    }\n    let derivedType = type || '';\n    if (type === 'log') derivedType = level;else if (type === 'timing') derivedType = 'timeEnd';\n    const handles = [];\n    for (const p of parameters || []) {\n      let context;\n      if (p.objectId) {\n        const objectId = JSON.parse(p.objectId);\n        context = this._contextIdToContext.get(objectId.injectedScriptId);\n      } else {\n        context = this._contextIdToContext.get(this._mainFrameContextId);\n      }\n      if (!context) return;\n      handles.push(context.createHandle(p));\n    }\n    this._lastConsoleMessage = {\n      derivedType,\n      text,\n      handles,\n      count: 0,\n      location: {\n        url: url || '',\n        lineNumber: (lineNumber || 1) - 1,\n        columnNumber: (columnNumber || 1) - 1\n      }\n    };\n    this._onConsoleRepeatCountUpdated({\n      count: 1\n    });\n  }\n  _onConsoleRepeatCountUpdated(event) {\n    if (this._lastConsoleMessage) {\n      const {\n        derivedType,\n        text,\n        handles,\n        count,\n        location\n      } = this._lastConsoleMessage;\n      for (let i = count; i < event.count; ++i) this._page._addConsoleMessage(derivedType, handles, location, handles.length ? undefined : text);\n      this._lastConsoleMessage.count = event.count;\n    }\n  }\n  _onDialog(event) {\n    this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {\n      await this._pageProxySession.send('Dialog.handleJavaScriptDialog', {\n        accept,\n        promptText\n      });\n    }, event.defaultPrompt));\n  }\n  async _onFileChooserOpened(event) {\n    let handle;\n    try {\n      const context = await this._page._frameManager.frame(event.frameId)._mainContext();\n      handle = context.createHandle(event.element).asElement();\n    } catch (e) {\n      // During async processing, frame/context may go away. We should not throw.\n      return;\n    }\n    await this._page._onFileChooserOpened(handle);\n  }\n  static async _setEmulateMedia(session, mediaType, colorScheme, reducedMotion, forcedColors) {\n    const promises = [];\n    promises.push(session.send('Page.setEmulatedMedia', {\n      media: mediaType === 'no-override' ? '' : mediaType\n    }));\n    let appearance = undefined;\n    switch (colorScheme) {\n      case 'light':\n        appearance = 'Light';\n        break;\n      case 'dark':\n        appearance = 'Dark';\n        break;\n      case 'no-override':\n        appearance = undefined;\n        break;\n    }\n    promises.push(session.send('Page.overrideUserPreference', {\n      name: 'PrefersColorScheme',\n      value: appearance\n    }));\n    let reducedMotionWk = undefined;\n    switch (reducedMotion) {\n      case 'reduce':\n        reducedMotionWk = 'Reduce';\n        break;\n      case 'no-preference':\n        reducedMotionWk = 'NoPreference';\n        break;\n      case 'no-override':\n        reducedMotionWk = undefined;\n        break;\n    }\n    promises.push(session.send('Page.overrideUserPreference', {\n      name: 'PrefersReducedMotion',\n      value: reducedMotionWk\n    }));\n    let forcedColorsWk = undefined;\n    switch (forcedColors) {\n      case 'active':\n        forcedColorsWk = 'Active';\n        break;\n      case 'none':\n        forcedColorsWk = 'None';\n        break;\n      case 'no-override':\n        forcedColorsWk = undefined;\n        break;\n    }\n    promises.push(session.send('Page.setForcedColors', {\n      forcedColors: forcedColorsWk\n    }));\n    await Promise.all(promises);\n  }\n  async updateExtraHTTPHeaders() {\n    await this._updateState('Network.setExtraHTTPHeaders', {\n      headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false /* lowerCase */)\n    });\n  }\n\n  _calculateExtraHTTPHeaders() {\n    const locale = this._browserContext._options.locale;\n    const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._page.extraHTTPHeaders(), locale ? network.singleHeader('Accept-Language', locale) : undefined]);\n    return headers;\n  }\n  async updateEmulateMedia() {\n    const emulatedMedia = this._page.emulatedMedia();\n    const colorScheme = emulatedMedia.colorScheme;\n    const reducedMotion = emulatedMedia.reducedMotion;\n    const forcedColors = emulatedMedia.forcedColors;\n    await this._forAllSessions(session => WKPage._setEmulateMedia(session, emulatedMedia.media, colorScheme, reducedMotion, forcedColors));\n  }\n  async updateEmulatedViewportSize() {\n    await this._updateViewport();\n  }\n  async updateUserAgent() {\n    const contextOptions = this._browserContext._options;\n    this._updateState('Page.overrideUserAgent', {\n      value: contextOptions.userAgent\n    });\n  }\n  async bringToFront() {\n    this._pageProxySession.send('Target.activate', {\n      targetId: this._session.sessionId\n    });\n  }\n  async _updateViewport() {\n    const options = this._browserContext._options;\n    const deviceSize = this._page.emulatedSize();\n    if (deviceSize === null) return;\n    const viewportSize = deviceSize.viewport;\n    const screenSize = deviceSize.screen;\n    const promises = [this._pageProxySession.send('Emulation.setDeviceMetricsOverride', {\n      width: viewportSize.width,\n      height: viewportSize.height,\n      fixedLayout: !!options.isMobile,\n      deviceScaleFactor: options.deviceScaleFactor || 1\n    }), this._session.send('Page.setScreenSizeOverride', {\n      width: screenSize.width,\n      height: screenSize.height\n    })];\n    if (options.isMobile) {\n      const angle = viewportSize.width > viewportSize.height ? 90 : 0;\n      promises.push(this._session.send('Page.setOrientationOverride', {\n        angle\n      }));\n    }\n    await Promise.all(promises);\n  }\n  async updateRequestInterception() {\n    const enabled = this._page.needsRequestInterception();\n    await Promise.all([this._updateState('Network.setInterceptionEnabled', {\n      enabled\n    }), this._updateState('Network.addInterception', {\n      url: '.*',\n      stage: 'request',\n      isRegex: true\n    })]);\n  }\n  async updateOffline() {\n    await this._updateState('Network.setEmulateOfflineState', {\n      offline: !!this._browserContext._options.offline\n    });\n  }\n  async updateHttpCredentials() {\n    const credentials = this._browserContext._options.httpCredentials || {\n      username: '',\n      password: ''\n    };\n    await this._pageProxySession.send('Emulation.setAuthCredentials', {\n      username: credentials.username,\n      password: credentials.password\n    });\n  }\n  async updateFileChooserInterception() {\n    const enabled = this._page.fileChooserIntercepted();\n    await this._session.send('Page.setInterceptFileChooserDialog', {\n      enabled\n    }).catch(() => {}); // target can be closed.\n  }\n\n  async reload() {\n    await this._session.send('Page.reload');\n  }\n  goBack() {\n    return this._session.send('Page.goBack').then(() => true).catch(error => {\n      if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`)) return false;\n      throw error;\n    });\n  }\n  goForward() {\n    return this._session.send('Page.goForward').then(() => true).catch(error => {\n      if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`)) return false;\n      throw error;\n    });\n  }\n  async exposeBinding(binding) {\n    this._session.send('Runtime.addBinding', {\n      name: binding.name\n    });\n    await this._updateBootstrapScript();\n    await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source, false, {}).catch(e => {})));\n  }\n  async removeExposedBindings() {\n    await this._updateBootstrapScript();\n  }\n  async addInitScript(script) {\n    await this._updateBootstrapScript();\n  }\n  async removeInitScripts() {\n    await this._updateBootstrapScript();\n  }\n  _calculateBootstrapScript() {\n    const scripts = [];\n    if (!this._page.context()._options.isMobile) {\n      scripts.push('delete window.orientation');\n      scripts.push('delete window.ondevicemotion');\n      scripts.push('delete window.ondeviceorientation');\n    }\n    for (const binding of this._page.allBindings()) scripts.push(binding.source);\n    scripts.push(...this._browserContext.initScripts);\n    scripts.push(...this._page.initScripts);\n    return scripts.join(';\\n');\n  }\n  async _updateBootstrapScript() {\n    await this._updateState('Page.setBootstrapScript', {\n      source: this._calculateBootstrapScript()\n    });\n  }\n  async closePage(runBeforeUnload) {\n    await this._stopVideo();\n    await this._pageProxySession.sendMayFail('Target.close', {\n      targetId: this._session.sessionId,\n      runBeforeUnload\n    });\n  }\n  async setBackgroundColor(color) {\n    await this._session.send('Page.setDefaultBackgroundColorOverride', {\n      color\n    });\n  }\n  _toolbarHeight() {\n    var _this$_page$_browserC;\n    if ((_this$_page$_browserC = this._page._browserContext._browser) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.options.headful) return _hostPlatform.hostPlatform === 'mac10.15' ? 55 : 59;\n    return 0;\n  }\n  async _startVideo(options) {\n    (0, _utils.assert)(!this._recordingVideoFile);\n    const {\n      screencastId\n    } = await this._pageProxySession.send('Screencast.startVideo', {\n      file: options.outputFile,\n      width: options.width,\n      height: options.height,\n      toolbarHeight: this._toolbarHeight()\n    });\n    this._recordingVideoFile = options.outputFile;\n    this._browserContext._browser._videoStarted(this._browserContext, screencastId, options.outputFile, this.pageOrError());\n  }\n  async _stopVideo() {\n    if (!this._recordingVideoFile) return;\n    await this._pageProxySession.sendMayFail('Screencast.stopVideo');\n    this._recordingVideoFile = null;\n  }\n  validateScreenshotDimension(side, omitDeviceScaleFactor) {\n    // Cairo based implementations (Linux and Windows) have hard limit of 32767\n    // (see https://github.com/microsoft/playwright/issues/16727).\n    if (process.platform === 'darwin') return;\n    if (!omitDeviceScaleFactor && this._page._browserContext._options.deviceScaleFactor) side = Math.ceil(side * this._page._browserContext._options.deviceScaleFactor);\n    if (side > 32767) throw new Error('Cannot take screenshot larger than 32767 pixels on any dimension');\n  }\n  async takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {\n    const rect = documentRect || viewportRect;\n    const omitDeviceScaleFactor = scale === 'css';\n    this.validateScreenshotDimension(rect.width, omitDeviceScaleFactor);\n    this.validateScreenshotDimension(rect.height, omitDeviceScaleFactor);\n    const result = await this._session.send('Page.snapshotRect', {\n      ...rect,\n      coordinateSystem: documentRect ? 'Page' : 'Viewport',\n      omitDeviceScaleFactor\n    });\n    const prefix = 'data:image/png;base64,';\n    let buffer = Buffer.from(result.dataURL.substr(prefix.length), 'base64');\n    if (format === 'jpeg') buffer = _utilsBundle.jpegjs.encode(_utilsBundle.PNG.sync.read(buffer), quality).data;\n    return buffer;\n  }\n  async getContentFrame(handle) {\n    const nodeInfo = await this._session.send('DOM.describeNode', {\n      objectId: handle._objectId\n    });\n    if (!nodeInfo.contentFrameId) return null;\n    return this._page._frameManager.frame(nodeInfo.contentFrameId);\n  }\n  async getOwnerFrame(handle) {\n    if (!handle._objectId) return null;\n    const nodeInfo = await this._session.send('DOM.describeNode', {\n      objectId: handle._objectId\n    });\n    return nodeInfo.ownerFrameId || null;\n  }\n  isElementHandle(remoteObject) {\n    return remoteObject.subtype === 'node';\n  }\n  async getBoundingBox(handle) {\n    const quads = await this.getContentQuads(handle);\n    if (!quads || !quads.length) return null;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (const quad of quads) {\n      for (const point of quad) {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    }\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n  async scrollRectIntoViewIfNeeded(handle, rect) {\n    return await this._session.send('DOM.scrollIntoViewIfNeeded', {\n      objectId: handle._objectId,\n      rect\n    }).then(() => 'done').catch(e => {\n      if (e instanceof Error && e.message.includes('Node does not have a layout object')) return 'error:notvisible';\n      if (e instanceof Error && e.message.includes('Node is detached from document')) return 'error:notconnected';\n      throw e;\n    });\n  }\n  async setScreencastOptions(options) {\n    if (options) {\n      const so = {\n        ...options,\n        toolbarHeight: this._toolbarHeight()\n      };\n      const {\n        generation\n      } = await this._pageProxySession.send('Screencast.startScreencast', so);\n      this._screencastGeneration = generation;\n    } else {\n      await this._pageProxySession.send('Screencast.stopScreencast');\n    }\n  }\n  _onScreencastFrame(event) {\n    const generation = this._screencastGeneration;\n    this._page.throttleScreencastFrameAck(() => {\n      this._pageProxySession.send('Screencast.screencastFrameAck', {\n        generation\n      }).catch(e => _debugLogger.debugLogger.log('error', e));\n    });\n    const buffer = Buffer.from(event.data, 'base64');\n    this._page.emit(_page.Page.Events.ScreencastFrame, {\n      buffer,\n      width: event.deviceWidth,\n      height: event.deviceHeight\n    });\n  }\n  rafCountForStablePosition() {\n    return process.platform === 'win32' ? 5 : 1;\n  }\n  async getContentQuads(handle) {\n    const result = await this._session.sendMayFail('DOM.getContentQuads', {\n      objectId: handle._objectId\n    });\n    if (!result) return null;\n    return result.quads.map(quad => [{\n      x: quad[0],\n      y: quad[1]\n    }, {\n      x: quad[2],\n      y: quad[3]\n    }, {\n      x: quad[4],\n      y: quad[5]\n    }, {\n      x: quad[6],\n      y: quad[7]\n    }]);\n  }\n  async setInputFiles(handle, files) {\n    const objectId = handle._objectId;\n    const protocolFiles = files.map(file => ({\n      name: file.name,\n      type: file.mimeType,\n      data: file.buffer\n    }));\n    await this._session.send('DOM.setInputFiles', {\n      objectId,\n      files: protocolFiles\n    });\n  }\n  async setInputFilePaths(handle, paths) {\n    const pageProxyId = this._pageProxySession.sessionId;\n    const objectId = handle._objectId;\n    await Promise.all([this._pageProxySession.connection.browserSession.send('Playwright.grantFileReadAccess', {\n      pageProxyId,\n      paths\n    }), this._session.send('DOM.setInputFiles', {\n      objectId,\n      paths\n    })]);\n  }\n  async adoptElementHandle(handle, to) {\n    const result = await this._session.sendMayFail('DOM.resolveNode', {\n      objectId: handle._objectId,\n      executionContextId: to[contextDelegateSymbol]._contextId\n    });\n    if (!result || result.object.subtype === 'null') throw new Error(dom.kUnableToAdoptErrorMessage);\n    return to.createHandle(result.object);\n  }\n  async getAccessibilityTree(needle) {\n    return (0, _wkAccessibility.getAccessibilityTree)(this._session, needle);\n  }\n  async inputActionEpilogue() {}\n  async getFrameElement(frame) {\n    const parent = frame.parentFrame();\n    if (!parent) throw new Error('Frame has been detached.');\n    const context = await parent._mainContext();\n    const result = await this._session.send('DOM.resolveNode', {\n      frameId: frame._id,\n      executionContextId: context[contextDelegateSymbol]._contextId\n    });\n    if (!result || result.object.subtype === 'null') throw new Error('Frame has been detached.');\n    return context.createHandle(result.object);\n  }\n  _onRequestWillBeSent(session, event) {\n    if (event.request.url.startsWith('data:')) return;\n    let redirectedFrom = null;\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId);\n      // If we connect late to the target, we could have missed the requestWillBeSent event.\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse, event.timestamp);\n        redirectedFrom = request;\n      }\n    }\n    const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId);\n    // sometimes we get stray network events for detached frames\n    // TODO(einbinder) why?\n    if (!frame) return;\n\n    // TODO(einbinder) this will fail if we are an XHR document request\n    const isNavigationRequest = event.type === 'Document';\n    const documentId = isNavigationRequest ? event.loaderId : undefined;\n    let route = null;\n    // We do not support intercepting redirects.\n    if (this._page.needsRequestInterception() && !redirectedFrom) route = new _wkInterceptableRequest.WKRouteImpl(session, event.requestId);\n    const request = new _wkInterceptableRequest.WKInterceptableRequest(session, route, frame, event, redirectedFrom, documentId);\n    this._requestIdToRequest.set(event.requestId, request);\n    this._page._frameManager.requestStarted(request.request, route || undefined);\n  }\n  _handleRequestRedirect(request, responsePayload, timestamp) {\n    const response = request.createResponse(responsePayload);\n    response._securityDetailsFinished();\n    response._serverAddrFinished();\n    response.setResponseHeadersSize(null);\n    response.setEncodedBodySize(null);\n    response._requestFinished(responsePayload.timing ? _helper.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1);\n    this._requestIdToRequest.delete(request._requestId);\n    this._page._frameManager.requestReceivedResponse(response);\n    this._page._frameManager.reportRequestFinished(request.request, response);\n  }\n  _onRequestIntercepted(session, event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    if (!request) {\n      session.sendMayFail('Network.interceptRequestWithError', {\n        errorType: 'Cancellation',\n        requestId: event.requestId\n      });\n      return;\n    }\n    // There is no point in waiting for the raw headers in Network.responseReceived when intercepting.\n    // Use provisional headers as raw headers, so that client can call allHeaders() from the route handler.\n    request.request.setRawRequestHeaders(null);\n    if (!request._route) {\n      // Intercepted, although we do not intend to allow interception.\n      // Just continue.\n      session.sendMayFail('Network.interceptWithRequest', {\n        requestId: request._requestId\n      });\n    } else {\n      request._route._requestInterceptedPromise.resolve();\n    }\n  }\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request) return;\n    this._requestIdToResponseReceivedPayloadEvent.set(request._requestId, event);\n    const response = request.createResponse(event.response);\n    this._page._frameManager.requestReceivedResponse(response);\n    if (response.status() === 204) {\n      this._onLoadingFailed({\n        requestId: event.requestId,\n        errorText: 'Aborted: 204 No Content',\n        timestamp: event.timestamp\n      });\n    }\n  }\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) return;\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    const response = request.request._existingResponse();\n    if (response) {\n      var _event$metrics, _event$metrics2, _event$metrics2$secur, _responseReceivedPayl, _responseReceivedPayl2, _responseReceivedPayl3, _responseReceivedPayl4, _responseReceivedPayl5, _responseReceivedPayl6, _event$metrics3, _event$metrics$respon, _event$metrics4, _event$metrics$respon2, _event$metrics5;\n      const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(request._requestId);\n      response._serverAddrFinished(parseRemoteAddress(event === null || event === void 0 ? void 0 : (_event$metrics = event.metrics) === null || _event$metrics === void 0 ? void 0 : _event$metrics.remoteAddress));\n      response._securityDetailsFinished({\n        protocol: isLoadedSecurely(response.url(), response.timing()) ? (_event$metrics2 = event.metrics) === null || _event$metrics2 === void 0 ? void 0 : (_event$metrics2$secur = _event$metrics2.securityConnection) === null || _event$metrics2$secur === void 0 ? void 0 : _event$metrics2$secur.protocol : undefined,\n        subjectName: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl = responseReceivedPayload.response.security) === null || _responseReceivedPayl === void 0 ? void 0 : (_responseReceivedPayl2 = _responseReceivedPayl.certificate) === null || _responseReceivedPayl2 === void 0 ? void 0 : _responseReceivedPayl2.subject,\n        validFrom: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl3 = responseReceivedPayload.response.security) === null || _responseReceivedPayl3 === void 0 ? void 0 : (_responseReceivedPayl4 = _responseReceivedPayl3.certificate) === null || _responseReceivedPayl4 === void 0 ? void 0 : _responseReceivedPayl4.validFrom,\n        validTo: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl5 = responseReceivedPayload.response.security) === null || _responseReceivedPayl5 === void 0 ? void 0 : (_responseReceivedPayl6 = _responseReceivedPayl5.certificate) === null || _responseReceivedPayl6 === void 0 ? void 0 : _responseReceivedPayl6.validUntil\n      });\n      if ((_event$metrics3 = event.metrics) !== null && _event$metrics3 !== void 0 && _event$metrics3.protocol) response._setHttpVersion(event.metrics.protocol);\n      response.setEncodedBodySize((_event$metrics$respon = (_event$metrics4 = event.metrics) === null || _event$metrics4 === void 0 ? void 0 : _event$metrics4.responseBodyBytesReceived) !== null && _event$metrics$respon !== void 0 ? _event$metrics$respon : null);\n      response.setResponseHeadersSize((_event$metrics$respon2 = (_event$metrics5 = event.metrics) === null || _event$metrics5 === void 0 ? void 0 : _event$metrics5.responseHeaderBytesReceived) !== null && _event$metrics$respon2 !== void 0 ? _event$metrics$respon2 : null);\n      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));\n    } else {\n      // Use provisional headers if we didn't have the response with raw headers.\n      request.request.setRawRequestHeaders(null);\n    }\n    this._requestIdToResponseReceivedPayloadEvent.delete(request._requestId);\n    this._requestIdToRequest.delete(request._requestId);\n    this._page._frameManager.reportRequestFinished(request.request, response);\n  }\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) return;\n    const response = request.request._existingResponse();\n    if (response) {\n      response._serverAddrFinished();\n      response._securityDetailsFinished();\n      response.setResponseHeadersSize(null);\n      response.setEncodedBodySize(null);\n      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));\n    } else {\n      // Use provisional headers if we didn't have the response with raw headers.\n      request.request.setRawRequestHeaders(null);\n    }\n    this._requestIdToRequest.delete(request._requestId);\n    request.request._setFailureText(event.errorText);\n    this._page._frameManager.requestFailed(request.request, event.errorText.includes('cancelled'));\n  }\n  async _grantPermissions(origin, permissions) {\n    const webPermissionToProtocol = new Map([['geolocation', 'geolocation']]);\n    const filtered = permissions.map(permission => {\n      const protocolPermission = webPermissionToProtocol.get(permission);\n      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);\n      return protocolPermission;\n    });\n    await this._pageProxySession.send('Emulation.grantPermissions', {\n      origin,\n      permissions: filtered\n    });\n  }\n  async _clearPermissions() {\n    await this._pageProxySession.send('Emulation.resetPermissions', {});\n  }\n}\n\n/**\n * WebKit Remote Addresses look like:\n *\n * macOS:\n * ::1.8911\n * 2606:2800:220:1:248:1893:25c8:1946.443\n * 127.0.0.1:8000\n *\n * ubuntu:\n * ::1:8907\n * 127.0.0.1:8000\n *\n * NB: They look IPv4 and IPv6's with ports but use an alternative notation.\n */\nexports.WKPage = WKPage;\nfunction parseRemoteAddress(value) {\n  if (!value) return;\n  try {\n    const colon = value.lastIndexOf(':');\n    const dot = value.lastIndexOf('.');\n    if (dot < 0) {\n      // IPv6ish:port\n      return {\n        ipAddress: `[${value.slice(0, colon)}]`,\n        port: +value.slice(colon + 1)\n      };\n    }\n    if (colon > dot) {\n      // IPv4:port\n      const [address, port] = value.split(':');\n      return {\n        ipAddress: address,\n        port: +port\n      };\n    } else {\n      // IPv6ish.port\n      const [address, port] = value.split('.');\n      return {\n        ipAddress: `[${address}]`,\n        port: +port\n      };\n    }\n  } catch (_) {}\n}\n\n/**\n * Adapted from Source/WebInspectorUI/UserInterface/Models/Resource.js in\n * WebKit codebase.\n */\nfunction isLoadedSecurely(url, timing) {\n  try {\n    const u = new URL(url);\n    if (u.protocol !== 'https:' && u.protocol !== 'wss:' && u.protocol !== 'sftp:') return false;\n    if (timing.secureConnectionStart === -1 && timing.connectStart !== -1) return false;\n    return true;\n  } catch (_) {}\n}\nconst contextDelegateSymbol = Symbol('delegate');","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKProvisionalPage = void 0;\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _utils = require(\"../../utils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WKProvisionalPage {\n  constructor(session, page) {\n    this._session = void 0;\n    this._wkPage = void 0;\n    this._sessionListeners = [];\n    this._mainFrameId = null;\n    this.initializationPromise = void 0;\n    this._session = session;\n    this._wkPage = page;\n    const overrideFrameId = handler => {\n      return payload => {\n        // Pretend that the events happened in the same process.\n        if (payload.frameId) payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;\n        handler(payload);\n      };\n    };\n    const wkPage = this._wkPage;\n    this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSent', overrideFrameId(e => wkPage._onRequestWillBeSent(session, e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestIntercepted', overrideFrameId(e => wkPage._onRequestIntercepted(session, e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceived', overrideFrameId(e => wkPage._onResponseReceived(e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFinished', overrideFrameId(e => wkPage._onLoadingFinished(e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFailed', overrideFrameId(e => wkPage._onLoadingFailed(e)))];\n    this.initializationPromise = this._wkPage._initializeSession(session, true, ({\n      frameTree\n    }) => this._handleFrameTree(frameTree));\n  }\n  dispose() {\n    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);\n  }\n  commit() {\n    (0, _utils.assert)(this._mainFrameId);\n    this._wkPage._onFrameAttached(this._mainFrameId, null);\n  }\n  _handleFrameTree(frameTree) {\n    (0, _utils.assert)(!frameTree.frame.parentId);\n    this._mainFrameId = frameTree.frame.id;\n  }\n}\nexports.WKProvisionalPage = WKProvisionalPage;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WKWorkers = void 0;\nvar _eventsHelper = require(\"../../utils/eventsHelper\");\nvar _page = require(\"../page\");\nvar _wkConnection = require(\"./wkConnection\");\nvar _wkExecutionContext = require(\"./wkExecutionContext\");\n/**\n * Copyright 2019 Microsoft Corporation All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass WKWorkers {\n  constructor(page) {\n    this._sessionListeners = [];\n    this._page = void 0;\n    this._workerSessions = new Map();\n    this._page = page;\n  }\n  setSession(session) {\n    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);\n    this.clear();\n    this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Worker.workerCreated', event => {\n      const worker = new _page.Worker(this._page, event.url);\n      const workerSession = new _wkConnection.WKSession(session.connection, event.workerId, 'Most likely the worker has been closed.', message => {\n        session.send('Worker.sendMessageToWorker', {\n          workerId: event.workerId,\n          message: JSON.stringify(message)\n        }).catch(e => {\n          workerSession.dispatchMessage({\n            id: message.id,\n            error: {\n              message: e.message\n            }\n          });\n        });\n      });\n      this._workerSessions.set(event.workerId, workerSession);\n      worker._createExecutionContext(new _wkExecutionContext.WKExecutionContext(workerSession, undefined));\n      this._page._addWorker(event.workerId, worker);\n      workerSession.on('Console.messageAdded', event => this._onConsoleMessage(worker, event));\n      Promise.all([workerSession.send('Runtime.enable'), workerSession.send('Console.enable'), session.send('Worker.initialized', {\n        workerId: event.workerId\n      })]).catch(e => {\n        // Worker can go as we are initializing it.\n        this._page._removeWorker(event.workerId);\n      });\n    }), _eventsHelper.eventsHelper.addEventListener(session, 'Worker.dispatchMessageFromWorker', event => {\n      const workerSession = this._workerSessions.get(event.workerId);\n      if (!workerSession) return;\n      workerSession.dispatchMessage(JSON.parse(event.message));\n    }), _eventsHelper.eventsHelper.addEventListener(session, 'Worker.workerTerminated', event => {\n      const workerSession = this._workerSessions.get(event.workerId);\n      if (!workerSession) return;\n      workerSession.dispose(false);\n      this._workerSessions.delete(event.workerId);\n      this._page._removeWorker(event.workerId);\n    })];\n  }\n  clear() {\n    this._page._clearWorkers();\n    this._workerSessions.clear();\n  }\n  async initializeSession(session) {\n    await session.send('Worker.enable');\n  }\n  async _onConsoleMessage(worker, event) {\n    const {\n      type,\n      level,\n      text,\n      parameters,\n      url,\n      line: lineNumber,\n      column: columnNumber\n    } = event.message;\n    let derivedType = type || '';\n    if (type === 'log') derivedType = level;else if (type === 'timing') derivedType = 'timeEnd';\n    const handles = (parameters || []).map(p => {\n      return worker._existingExecutionContext.createHandle(p);\n    });\n    const location = {\n      url: url || '',\n      lineNumber: (lineNumber || 1) - 1,\n      columnNumber: (columnNumber || 1) - 1\n    };\n    this._page._addConsoleMessage(derivedType, handles, location, handles.length ? undefined : text);\n  }\n}\nexports.WKWorkers = WKWorkers;","/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  this[0] = op;\n  this[1] = text;\n};\n\ndiff_match_patch.Diff.prototype.length = 2;\n\n/**\n * Emulate the output of a two-element array.\n * @return {string} Diff operation as a string.\n */\ndiff_match_patch.Diff.prototype.toString = function() {\n  return this[0] + ',' + this[1];\n};\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\nmodule.exports = { diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL };\n","/**\n * \n * ISC License\n *\n * Copyright (c) 2019, Mapbox\n\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n * THIS SOFTWARE.\n */\n\n'use strict';\n\nmodule.exports = pixelmatch;\n\nconst defaultOptions = {\n    threshold: 0.1,         // matching threshold (0 to 1); smaller is more sensitive\n    includeAA: false,       // whether to skip anti-aliasing detection\n    alpha: 0.1,             // opacity of original image in diff output\n    aaColor: [255, 255, 0], // color of anti-aliased pixels in diff output\n    diffColor: [255, 0, 0], // color of different pixels in diff output\n    diffColorAlt: null,     // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two\n    diffMask: false         // draw the diff over a transparent background (a mask)\n};\n\nfunction pixelmatch(img1, img2, output, width, height, options) {\n\n    if (!isPixelData(img1) || !isPixelData(img2) || (output && !isPixelData(output)))\n        throw new Error('Image data: Uint8Array, Uint8ClampedArray or Buffer expected.');\n\n    if (img1.length !== img2.length || (output && output.length !== img1.length))\n        throw new Error('Image sizes do not match.');\n\n    if (img1.length !== width * height * 4) throw new Error('Image data size does not match width/height.');\n\n    options = Object.assign({}, defaultOptions, options);\n\n    // check if images are identical\n    const len = width * height;\n    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);\n    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);\n    let identical = true;\n\n    for (let i = 0; i < len; i++) {\n        if (a32[i] !== b32[i]) { identical = false; break; }\n    }\n    if (identical) { // fast path if identical\n        if (output && !options.diffMask) {\n            for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options.alpha, output);\n        }\n        return 0;\n    }\n\n    // maximum acceptable square distance between two colors;\n    // 35215 is the maximum possible value for the YIQ difference metric\n    const maxDelta = 35215 * options.threshold * options.threshold;\n    let diff = 0;\n\n    // compare each pixel of one image against the other one\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n\n            const pos = (y * width + x) * 4;\n\n            // squared YUV distance between colors at this pixel position, negative if the img2 pixel is darker\n            const delta = colorDelta(img1, img2, pos, pos);\n\n            // the color difference is above the threshold\n            if (Math.abs(delta) > maxDelta) {\n                // check it's a real rendering difference or just anti-aliasing\n                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||\n                                           antialiased(img2, x, y, width, height, img1))) {\n                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference\n                    // note that we do not include such pixels in a mask\n                    if (output && !options.diffMask) drawPixel(output, pos, ...options.aaColor);\n\n                } else {\n                    // found substantial difference not caused by anti-aliasing; draw it as such\n                    if (output) {\n                        drawPixel(output, pos, ...(delta < 0 && options.diffColorAlt || options.diffColor));\n                    }\n                    diff++;\n                }\n\n            } else if (output) {\n                // pixels are similar; draw background as grayscale image blended with white\n                if (!options.diffMask) drawGrayPixel(img1, pos, options.alpha, output);\n            }\n        }\n    }\n\n    // return the number of different pixels\n    return diff;\n}\n\nfunction isPixelData(arr) {\n    // work around instanceof Uint8Array not working properly in some Jest environments\n    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;\n}\n\n// check if a pixel is likely a part of anti-aliasing;\n// based on \"Anti-aliased Pixel and Intensity Slope Detector\" paper by V. Vysniauskas, 2009\n\nfunction antialiased(img, x1, y1, width, height, img2) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n    let min = 0;\n    let max = 0;\n    let minX, minY, maxX, maxY;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            // brightness delta between the center pixel and adjacent one\n            const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);\n\n            // count the number of equal, darker and brighter adjacent pixels\n            if (delta === 0) {\n                zeroes++;\n                // if found more than 2 equal siblings, it's definitely not anti-aliasing\n                if (zeroes > 2) return false;\n\n            // remember the darkest pixel\n            } else if (delta < min) {\n                min = delta;\n                minX = x;\n                minY = y;\n\n            // remember the brightest pixel\n            } else if (delta > max) {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n\n    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing\n    if (min === 0 || max === 0) return false;\n\n    // if either the darkest or the brightest pixel has 3+ equal siblings in both images\n    // (definitely not anti-aliased), this pixel is anti-aliased\n    return (hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height)) ||\n           (hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height));\n}\n\n// check if a pixel has 3+ adjacent pixels of the same color.\nfunction hasManySiblings(img, x1, y1, width, height) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            const pos2 = (y * width + x) * 4;\n            if (img[pos] === img[pos2] &&\n                img[pos + 1] === img[pos2 + 1] &&\n                img[pos + 2] === img[pos2 + 2] &&\n                img[pos + 3] === img[pos2 + 3]) zeroes++;\n\n            if (zeroes > 2) return true;\n        }\n    }\n\n    return false;\n}\n\n// calculate color difference according to the paper \"Measuring perceived color difference\n// using YIQ NTSC transmission color space in mobile applications\" by Y. Kotsarenko and F. Ramos\n\nfunction colorDelta(img1, img2, k, m, yOnly) {\n    let r1 = img1[k + 0];\n    let g1 = img1[k + 1];\n    let b1 = img1[k + 2];\n    let a1 = img1[k + 3];\n\n    let r2 = img2[m + 0];\n    let g2 = img2[m + 1];\n    let b2 = img2[m + 2];\n    let a2 = img2[m + 3];\n\n    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;\n\n    if (a1 < 255) {\n        a1 /= 255;\n        r1 = blend(r1, a1);\n        g1 = blend(g1, a1);\n        b1 = blend(b1, a1);\n    }\n\n    if (a2 < 255) {\n        a2 /= 255;\n        r2 = blend(r2, a2);\n        g2 = blend(g2, a2);\n        b2 = blend(b2, a2);\n    }\n\n    const y1 = rgb2y(r1, g1, b1);\n    const y2 = rgb2y(r2, g2, b2);\n    const y = y1 - y2;\n\n    if (yOnly) return y; // brightness difference only\n\n    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);\n    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n\n    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;\n\n    // encode whether the pixel lightens or darkens in the sign\n    return y1 > y2 ? -delta : delta;\n}\n\nfunction rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }\nfunction rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }\nfunction rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }\n\n// blend semi-transparent color with white\nfunction blend(c, a) {\n    return 255 + (c - 255) * a;\n}\n\nfunction drawPixel(output, pos, r, g, b) {\n    output[pos + 0] = r;\n    output[pos + 1] = g;\n    output[pos + 2] = b;\n    output[pos + 3] = 255;\n}\n\nfunction drawGrayPixel(img, i, alpha, output) {\n    const r = img[i + 0];\n    const g = img[i + 1];\n    const b = img[i + 2];\n    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);\n    drawPixel(output, i, val, val, val);\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapInASCIIBox = wrapInASCIIBox;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction wrapInASCIIBox(text, padding = 0) {\n  const lines = text.split('\\n');\n  const maxLength = Math.max(...lines.map(line => line.length));\n  return ['╔' + '═'.repeat(maxLength + padding * 2) + '╗', ...lines.map(line => '║' + ' '.repeat(padding) + line + ' '.repeat(maxLength - line.length + padding) + '║'), '╚' + '═'.repeat(maxLength + padding * 2) + '╝'].join('\\n');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getComparator = getComparator;\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _compare = require(\"../image_tools/compare\");\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst pixelmatch = require('../third_party/pixelmatch');\nconst {\n  diff_match_patch,\n  DIFF_INSERT,\n  DIFF_DELETE,\n  DIFF_EQUAL\n} = require('../third_party/diff_match_patch');\nfunction getComparator(mimeType) {\n  if (mimeType === 'image/png') return compareImages.bind(null, 'image/png');\n  if (mimeType === 'image/jpeg') return compareImages.bind(null, 'image/jpeg');\n  if (mimeType === 'text/plain') return compareText;\n  return compareBuffersOrStrings;\n}\nconst JPEG_JS_MAX_BUFFER_SIZE_IN_MB = 5 * 1024; // ~5 GB\n\nfunction compareBuffersOrStrings(actualBuffer, expectedBuffer) {\n  if (typeof actualBuffer === 'string') return compareText(actualBuffer, expectedBuffer);\n  if (!actualBuffer || !(actualBuffer instanceof Buffer)) return {\n    errorMessage: 'Actual result should be a Buffer or a string.'\n  };\n  if (Buffer.compare(actualBuffer, expectedBuffer)) return {\n    errorMessage: 'Buffers differ'\n  };\n  return null;\n}\nfunction compareImages(mimeType, actualBuffer, expectedBuffer, options = {}) {\n  var _options$_comparator, _ref;\n  if (!actualBuffer || !(actualBuffer instanceof Buffer)) return {\n    errorMessage: 'Actual result should be a Buffer.'\n  };\n  let actual = mimeType === 'image/png' ? _utilsBundle.PNG.sync.read(actualBuffer) : _utilsBundle.jpegjs.decode(actualBuffer, {\n    maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB\n  });\n  let expected = mimeType === 'image/png' ? _utilsBundle.PNG.sync.read(expectedBuffer) : _utilsBundle.jpegjs.decode(expectedBuffer, {\n    maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB\n  });\n  const size = {\n    width: Math.max(expected.width, actual.width),\n    height: Math.max(expected.height, actual.height)\n  };\n  let sizesMismatchError = '';\n  if (expected.width !== actual.width || expected.height !== actual.height) {\n    sizesMismatchError = `Expected an image ${expected.width}px by ${expected.height}px, received ${actual.width}px by ${actual.height}px. `;\n    actual = resizeImage(actual, size);\n    expected = resizeImage(expected, size);\n  }\n  const diff = new _utilsBundle.PNG({\n    width: size.width,\n    height: size.height\n  });\n  let count;\n  if (options._comparator === 'ssim-cie94') {\n    count = (0, _compare.compare)(expected.data, actual.data, diff.data, size.width, size.height, {\n      // All ΔE* formulae are originally designed to have the difference of 1.0 stand for a \"just noticeable difference\" (JND).\n      // See https://en.wikipedia.org/wiki/Color_difference#CIELAB_%CE%94E*\n      maxColorDeltaE94: 1.0\n    });\n  } else if (((_options$_comparator = options._comparator) !== null && _options$_comparator !== void 0 ? _options$_comparator : 'pixelmatch') === 'pixelmatch') {\n    var _options$threshold;\n    count = pixelmatch(expected.data, actual.data, diff.data, size.width, size.height, {\n      threshold: (_options$threshold = options.threshold) !== null && _options$threshold !== void 0 ? _options$threshold : 0.2\n    });\n  } else {\n    throw new Error(`Configuration specifies unknown comparator \"${options._comparator}\"`);\n  }\n  const maxDiffPixels1 = options.maxDiffPixels;\n  const maxDiffPixels2 = options.maxDiffPixelRatio !== undefined ? expected.width * expected.height * options.maxDiffPixelRatio : undefined;\n  let maxDiffPixels;\n  if (maxDiffPixels1 !== undefined && maxDiffPixels2 !== undefined) maxDiffPixels = Math.min(maxDiffPixels1, maxDiffPixels2);else maxDiffPixels = (_ref = maxDiffPixels1 !== null && maxDiffPixels1 !== void 0 ? maxDiffPixels1 : maxDiffPixels2) !== null && _ref !== void 0 ? _ref : 0;\n  const ratio = Math.ceil(count / (expected.width * expected.height) * 100) / 100;\n  const pixelsMismatchError = count > maxDiffPixels ? `${count} pixels (ratio ${ratio.toFixed(2)} of all image pixels) are different.` : '';\n  if (pixelsMismatchError || sizesMismatchError) return {\n    errorMessage: sizesMismatchError + pixelsMismatchError,\n    diff: _utilsBundle.PNG.sync.write(diff)\n  };\n  return null;\n}\nfunction compareText(actual, expectedBuffer) {\n  if (typeof actual !== 'string') return {\n    errorMessage: 'Actual result should be a string'\n  };\n  const expected = expectedBuffer.toString('utf-8');\n  if (expected === actual) return null;\n  const dmp = new diff_match_patch();\n  const d = dmp.diff_main(expected, actual);\n  dmp.diff_cleanupSemantic(d);\n  return {\n    errorMessage: diff_prettyTerminal(d)\n  };\n}\nfunction diff_prettyTerminal(diffs) {\n  const html = [];\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0]; // Operation (insert, delete, equal)\n    const data = diffs[x][1]; // Text of change.\n    const text = data;\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = _utilsBundle.colors.green(text);\n        break;\n      case DIFF_DELETE:\n        html[x] = _utilsBundle.colors.reset(_utilsBundle.colors.strikethrough(_utilsBundle.colors.red(text)));\n        break;\n      case DIFF_EQUAL:\n        html[x] = text;\n        break;\n    }\n  }\n  return html.join('');\n}\nfunction resizeImage(image, size) {\n  if (image.width === size.width && image.height === size.height) return image;\n  const buffer = new Uint8Array(size.width * size.height * 4);\n  for (let y = 0; y < size.height; y++) {\n    for (let x = 0; x < size.width; x++) {\n      const to = (y * size.width + x) * 4;\n      if (y < image.height && x < image.width) {\n        const from = (y * image.width + x) * 4;\n        buffer[to] = image.data[from];\n        buffer[to + 1] = image.data[from + 1];\n        buffer[to + 2] = image.data[from + 2];\n        buffer[to + 3] = image.data[from + 3];\n      } else {\n        buffer[to] = 0;\n        buffer[to + 1] = 0;\n        buffer[to + 2] = 0;\n        buffer[to + 3] = 0;\n      }\n    }\n  }\n  return {\n    data: Buffer.from(buffer),\n    width: size.width,\n    height: size.height\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateSha1 = calculateSha1;\nexports.createGuid = createGuid;\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction createGuid() {\n  return _crypto.default.randomBytes(16).toString('hex');\n}\nfunction calculateSha1(buffer) {\n  const hash = _crypto.default.createHash('sha1');\n  hash.update(buffer);\n  return hash.digest('hex');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assert = assert;\nexports.debugAssert = debugAssert;\nexports.debugMode = debugMode;\nexports.isUnderTest = isUnderTest;\nexports.setUnderTest = setUnderTest;\nvar _env = require(\"./env\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction assert(value, message) {\n  if (!value) throw new Error(message || 'Assertion error');\n}\nfunction debugAssert(value, message) {\n  if (isUnderTest() && !value) throw new Error(message);\n}\nconst debugEnv = (0, _env.getFromENV)('PWDEBUG') || '';\nfunction debugMode() {\n  if (debugEnv === 'console') return 'console';\n  if (debugEnv === '0' || debugEnv === 'false') return '';\n  return debugEnv ? 'inspector' : '';\n}\nlet _isUnderTest = false;\nfunction setUnderTest() {\n  _isUnderTest = true;\n}\nfunction isUnderTest() {\n  return _isUnderTest;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAsBooleanFromENV = getAsBooleanFromENV;\nexports.getFromENV = getFromENV;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction getFromENV(name) {\n  let value = process.env[name];\n  value = value === undefined ? process.env[`npm_config_${name.toLowerCase()}`] : value;\n  value = value === undefined ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;\n  return value;\n}\nfunction getAsBooleanFromENV(name) {\n  const value = getFromENV(name);\n  return !!value && value !== 'false' && value !== '0';\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.eventsHelper = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass EventsHelper {\n  static addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return {\n      emitter,\n      eventName,\n      handler\n    };\n  }\n  static removeEventListeners(listeners) {\n    for (const listener of listeners) listener.emitter.removeListener(listener.eventName, listener.handler);\n    listeners.splice(0, listeners.length);\n  }\n}\nconst eventsHelper = EventsHelper;\nexports.eventsHelper = eventsHelper;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canAccessFile = canAccessFile;\nexports.copyFileAndMakeWritable = copyFileAndMakeWritable;\nexports.existsAsync = void 0;\nexports.mkdirIfNeeded = mkdirIfNeeded;\nexports.removeFolders = removeFolders;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _utilsBundle = require(\"../utilsBundle\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst existsAsync = path => new Promise(resolve => _fs.default.stat(path, err => resolve(!err)));\nexports.existsAsync = existsAsync;\nasync function mkdirIfNeeded(filePath) {\n  // This will harmlessly throw on windows if the dirname is the root directory.\n  await _fs.default.promises.mkdir(_path.default.dirname(filePath), {\n    recursive: true\n  }).catch(() => {});\n}\nasync function removeFolders(dirs) {\n  return await Promise.all(dirs.map(dir => {\n    return new Promise(fulfill => {\n      (0, _utilsBundle.rimraf)(dir, {\n        maxBusyTries: 10\n      }, error => {\n        fulfill(error !== null && error !== void 0 ? error : undefined);\n      });\n    });\n  }));\n}\nfunction canAccessFile(file) {\n  if (!file) return false;\n  try {\n    _fs.default.accessSync(file);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function copyFileAndMakeWritable(from, to) {\n  await _fs.default.promises.copyFile(from, to);\n  await _fs.default.promises.chmod(to, 0o664);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.globToRegex = globToRegex;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst escapeGlobChars = new Set(['/', '$', '^', '+', '.', '(', ')', '=', '!', '|']);\nfunction globToRegex(glob) {\n  const tokens = ['^'];\n  let inGroup;\n  for (let i = 0; i < glob.length; ++i) {\n    const c = glob[i];\n    if (escapeGlobChars.has(c)) {\n      tokens.push('\\\\' + c);\n      continue;\n    }\n    if (c === '*') {\n      const beforeDeep = glob[i - 1];\n      let starCount = 1;\n      while (glob[i + 1] === '*') {\n        starCount++;\n        i++;\n      }\n      const afterDeep = glob[i + 1];\n      const isDeep = starCount > 1 && (beforeDeep === '/' || beforeDeep === undefined) && (afterDeep === '/' || afterDeep === undefined);\n      if (isDeep) {\n        tokens.push('((?:[^/]*(?:\\/|$))*)');\n        i++;\n      } else {\n        tokens.push('([^/]*)');\n      }\n      continue;\n    }\n    switch (c) {\n      case '?':\n        tokens.push('.');\n        break;\n      case '{':\n        inGroup = true;\n        tokens.push('(');\n        break;\n      case '}':\n        inGroup = false;\n        tokens.push(')');\n        break;\n      case ',':\n        if (inGroup) {\n          tokens.push('|');\n          break;\n        }\n        tokens.push('\\\\' + c);\n        break;\n      default:\n        tokens.push(c);\n    }\n  }\n  tokens.push('$');\n  return new RegExp(tokens.join(''));\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.headersArrayToObject = headersArrayToObject;\nexports.headersObjectToArray = headersObjectToArray;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction headersObjectToArray(headers, separator, setCookieSeparator) {\n  if (!setCookieSeparator) setCookieSeparator = separator;\n  const result = [];\n  for (const name in headers) {\n    const values = headers[name];\n    if (values === undefined) continue;\n    if (separator) {\n      const sep = name.toLowerCase() === 'set-cookie' ? setCookieSeparator : separator;\n      for (const value of values.split(sep)) result.push({\n        name,\n        value: value.trim()\n      });\n    } else {\n      result.push({\n        name,\n        value: values\n      });\n    }\n  }\n  return result;\n}\nfunction headersArrayToObject(headers, lowerCase) {\n  const result = {};\n  for (const {\n    name,\n    value\n  } of headers) result[lowerCase ? name.toLowerCase() : name] = value;\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hostPlatform = void 0;\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _linuxUtils = require(\"./linuxUtils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst hostPlatform = (() => {\n  const platform = _os.default.platform();\n  if (platform === 'darwin') {\n    const ver = _os.default.release().split('.').map(a => parseInt(a, 10));\n    let macVersion = '';\n    if (ver[0] < 18) {\n      // Everything before 10.14 is considered 10.13.\n      macVersion = 'mac10.13';\n    } else if (ver[0] === 18) {\n      macVersion = 'mac10.14';\n    } else if (ver[0] === 19) {\n      macVersion = 'mac10.15';\n    } else {\n      // ver[0] >= 20\n      const LAST_STABLE_MAC_MAJOR_VERSION = 12;\n      // Best-effort support for MacOS beta versions.\n      macVersion = 'mac' + Math.min(ver[0] - 9, LAST_STABLE_MAC_MAJOR_VERSION);\n      // BigSur is the first version that might run on Apple Silicon.\n      if (_os.default.cpus().some(cpu => cpu.model.includes('Apple'))) macVersion += '-arm64';\n    }\n    return macVersion;\n  }\n  if (platform === 'linux') {\n    const archSuffix = _os.default.arch() === 'arm64' ? '-arm64' : '';\n    const distroInfo = (0, _linuxUtils.getLinuxDistributionInfoSync)();\n\n    // Pop!_OS is ubuntu-based and has the same versions.\n    // KDE Neon is ubuntu-based and has the same versions.\n    if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'ubuntu' || (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'pop' || (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'neon') {\n      if (parseInt(distroInfo.version, 10) <= 19) return 'ubuntu18.04' + archSuffix;\n      if (parseInt(distroInfo.version, 10) <= 21) return 'ubuntu20.04' + archSuffix;\n      return 'ubuntu22.04' + archSuffix;\n    }\n    if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'debian' && (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.version) === '11') return 'debian11' + archSuffix;\n    return 'generic-linux' + archSuffix;\n  }\n  if (platform === 'win32') return 'win64';\n  return '<unknown>';\n})();\nexports.hostPlatform = hostPlatform;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpServer = void 0;\nvar http = _interopRequireWildcard(require(\"http\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _ = require(\"./\");\nvar _manualPromise = require(\"./manualPromise\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass HttpServer {\n  constructor(address = '') {\n    this._server = void 0;\n    this._urlPrefix = void 0;\n    this._port = 0;\n    this._started = false;\n    this._routes = [];\n    this._activeSockets = new Set();\n    this._urlPrefix = address;\n    this._server = http.createServer(this._onRequest.bind(this));\n  }\n  createWebSocketServer() {\n    return new _utilsBundle.wsServer({\n      server: this._server\n    });\n  }\n  routePrefix(prefix, handler) {\n    this._routes.push({\n      prefix,\n      handler\n    });\n  }\n  routePath(path, handler) {\n    this._routes.push({\n      exact: path,\n      handler\n    });\n  }\n  port() {\n    return this._port;\n  }\n  async _tryStart(port, host) {\n    const errorPromise = new _manualPromise.ManualPromise();\n    const errorListener = error => errorPromise.reject(error);\n    this._server.on('error', errorListener);\n    try {\n      this._server.listen(port, host);\n      await Promise.race([new Promise(cb => this._server.once('listening', cb)), errorPromise]);\n    } finally {\n      this._server.removeListener('error', errorListener);\n    }\n  }\n  async start(options = {}) {\n    (0, _.assert)(!this._started, 'server already started');\n    this._started = true;\n    this._server.on('connection', socket => {\n      this._activeSockets.add(socket);\n      socket.once('close', () => this._activeSockets.delete(socket));\n    });\n    const host = options.host || 'localhost';\n    if (options.preferredPort) {\n      try {\n        await this._tryStart(options.preferredPort, host);\n      } catch (e) {\n        if (!e || !e.message || !e.message.includes('EADDRINUSE')) throw e;\n        await this._tryStart(undefined, host);\n      }\n    } else {\n      await this._tryStart(options.port, host);\n    }\n    const address = this._server.address();\n    (0, _.assert)(address, 'Could not bind server socket');\n    if (!this._urlPrefix) {\n      if (typeof address === 'string') {\n        this._urlPrefix = address;\n      } else {\n        this._port = address.port;\n        this._urlPrefix = `http://${host}:${address.port}`;\n      }\n    }\n    return this._urlPrefix;\n  }\n  async stop() {\n    for (const socket of this._activeSockets) socket.destroy();\n    await new Promise(cb => this._server.close(cb));\n  }\n  urlPrefix() {\n    return this._urlPrefix;\n  }\n  serveFile(request, response, absoluteFilePath, headers) {\n    try {\n      for (const [name, value] of Object.entries(headers || {})) response.setHeader(name, value);\n      if (request.headers.range) this._serveRangeFile(request, response, absoluteFilePath);else this._serveFile(response, absoluteFilePath);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  _serveFile(response, absoluteFilePath) {\n    const content = _fs.default.readFileSync(absoluteFilePath);\n    response.statusCode = 200;\n    const contentType = _utilsBundle.mime.getType(_path.default.extname(absoluteFilePath)) || 'application/octet-stream';\n    response.setHeader('Content-Type', contentType);\n    response.setHeader('Content-Length', content.byteLength);\n    response.end(content);\n  }\n  _serveRangeFile(request, response, absoluteFilePath) {\n    const range = request.headers.range;\n    if (!range || !range.startsWith('bytes=') || range.includes(', ') || [...range].filter(char => char === '-').length !== 1) {\n      response.statusCode = 400;\n      return response.end('Bad request');\n    }\n\n    // Parse the range header: https://datatracker.ietf.org/doc/html/rfc7233#section-2.1\n    const [startStr, endStr] = range.replace(/bytes=/, '').split('-');\n\n    // Both start and end (when passing to fs.createReadStream) and the range header are inclusive and start counting at 0.\n    let start;\n    let end;\n    const size = _fs.default.statSync(absoluteFilePath).size;\n    if (startStr !== '' && endStr === '') {\n      // No end specified: use the whole file\n      start = +startStr;\n      end = size - 1;\n    } else if (startStr === '' && endStr !== '') {\n      // No start specified: calculate start manually\n      start = size - +endStr;\n      end = size - 1;\n    } else {\n      start = +startStr;\n      end = +endStr;\n    }\n\n    // Handle unavailable range request\n    if (Number.isNaN(start) || Number.isNaN(end) || start >= size || end >= size || start > end) {\n      // Return the 416 Range Not Satisfiable: https://datatracker.ietf.org/doc/html/rfc7233#section-4.4\n      response.writeHead(416, {\n        'Content-Range': `bytes */${size}`\n      });\n      return response.end();\n    }\n\n    // Sending Partial Content: https://datatracker.ietf.org/doc/html/rfc7233#section-4.1\n    response.writeHead(206, {\n      'Content-Range': `bytes ${start}-${end}/${size}`,\n      'Accept-Ranges': 'bytes',\n      'Content-Length': end - start + 1,\n      'Content-Type': _utilsBundle.mime.getType(_path.default.extname(absoluteFilePath))\n    });\n    const readable = _fs.default.createReadStream(absoluteFilePath, {\n      start,\n      end\n    });\n    readable.pipe(response);\n  }\n  _onRequest(request, response) {\n    response.setHeader('Access-Control-Allow-Origin', '*');\n    response.setHeader('Access-Control-Request-Method', '*');\n    response.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n    if (request.headers.origin) response.setHeader('Access-Control-Allow-Headers', request.headers.origin);\n    if (request.method === 'OPTIONS') {\n      response.writeHead(200);\n      response.end();\n      return;\n    }\n    request.on('error', () => response.end());\n    try {\n      if (!request.url) {\n        response.end();\n        return;\n      }\n      const url = new URL('http://localhost' + request.url);\n      for (const route of this._routes) {\n        if (route.exact && url.pathname === route.exact && route.handler(request, response)) return;\n        if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response)) return;\n      }\n      response.statusCode = 404;\n      response.end();\n    } catch (e) {\n      response.end();\n    }\n  }\n}\nexports.HttpServer = HttpServer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _ascii = require(\"./ascii\");\nObject.keys(_ascii).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ascii[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _ascii[key];\n    }\n  });\n});\nvar _comparators = require(\"./comparators\");\nObject.keys(_comparators).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _comparators[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _comparators[key];\n    }\n  });\n});\nvar _crypto = require(\"./crypto\");\nObject.keys(_crypto).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _crypto[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _crypto[key];\n    }\n  });\n});\nvar _debug = require(\"./debug\");\nObject.keys(_debug).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _debug[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _debug[key];\n    }\n  });\n});\nvar _env = require(\"./env\");\nObject.keys(_env).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _env[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _env[key];\n    }\n  });\n});\nvar _eventsHelper = require(\"./eventsHelper\");\nObject.keys(_eventsHelper).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _eventsHelper[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _eventsHelper[key];\n    }\n  });\n});\nvar _fileUtils = require(\"./fileUtils\");\nObject.keys(_fileUtils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _fileUtils[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _fileUtils[key];\n    }\n  });\n});\nvar _glob = require(\"./glob\");\nObject.keys(_glob).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _glob[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _glob[key];\n    }\n  });\n});\nvar _headers = require(\"./headers\");\nObject.keys(_headers).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _headers[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _headers[key];\n    }\n  });\n});\nvar _httpServer = require(\"./httpServer\");\nObject.keys(_httpServer).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _httpServer[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _httpServer[key];\n    }\n  });\n});\nvar _manualPromise = require(\"./manualPromise\");\nObject.keys(_manualPromise).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _manualPromise[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _manualPromise[key];\n    }\n  });\n});\nvar _mimeType = require(\"./mimeType\");\nObject.keys(_mimeType).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _mimeType[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _mimeType[key];\n    }\n  });\n});\nvar _multimap = require(\"./multimap\");\nObject.keys(_multimap).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _multimap[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _multimap[key];\n    }\n  });\n});\nvar _network = require(\"./network\");\nObject.keys(_network).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _network[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _network[key];\n    }\n  });\n});\nvar _processLauncher = require(\"./processLauncher\");\nObject.keys(_processLauncher).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _processLauncher[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _processLauncher[key];\n    }\n  });\n});\nvar _rtti = require(\"./rtti\");\nObject.keys(_rtti).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _rtti[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _rtti[key];\n    }\n  });\n});\nvar _spawnAsync = require(\"./spawnAsync\");\nObject.keys(_spawnAsync).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _spawnAsync[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _spawnAsync[key];\n    }\n  });\n});\nvar _stackTrace = require(\"./stackTrace\");\nObject.keys(_stackTrace).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _stackTrace[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _stackTrace[key];\n    }\n  });\n});\nvar _task = require(\"./task\");\nObject.keys(_task).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _task[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _task[key];\n    }\n  });\n});\nvar _time = require(\"./time\");\nObject.keys(_time).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _time[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _time[key];\n    }\n  });\n});\nvar _timeoutRunner = require(\"./timeoutRunner\");\nObject.keys(_timeoutRunner).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _timeoutRunner[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _timeoutRunner[key];\n    }\n  });\n});\nvar _userAgent = require(\"./userAgent\");\nObject.keys(_userAgent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _userAgent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _userAgent[key];\n    }\n  });\n});\nvar _zipFile = require(\"./zipFile\");\nObject.keys(_zipFile).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _zipFile[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _zipFile[key];\n    }\n  });\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getByAltTextSelector = getByAltTextSelector;\nexports.getByLabelSelector = getByLabelSelector;\nexports.getByPlaceholderSelector = getByPlaceholderSelector;\nexports.getByRoleSelector = getByRoleSelector;\nexports.getByTestIdSelector = getByTestIdSelector;\nexports.getByTextSelector = getByTextSelector;\nexports.getByTitleSelector = getByTitleSelector;\nvar _stringUtils = require(\"./stringUtils\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction getByAttributeTextSelector(attrName, text, options) {\n  if (!(0, _stringUtils.isString)(text)) return `internal:attr=[${attrName}=${text}]`;\n  return `internal:attr=[${attrName}=${(0, _stringUtils.escapeForAttributeSelector)(text, (options === null || options === void 0 ? void 0 : options.exact) || false)}]`;\n}\nfunction getByTestIdSelector(testIdAttributeName, testId) {\n  if (!(0, _stringUtils.isString)(testId)) return `internal:testid=[${testIdAttributeName}=${testId}]`;\n  return `internal:testid=[${testIdAttributeName}=${(0, _stringUtils.escapeForAttributeSelector)(testId, true)}]`;\n}\nfunction getByLabelSelector(text, options) {\n  return 'internal:label=' + (0, _stringUtils.escapeForTextSelector)(text, !!(options !== null && options !== void 0 && options.exact));\n}\nfunction getByAltTextSelector(text, options) {\n  return getByAttributeTextSelector('alt', text, options);\n}\nfunction getByTitleSelector(text, options) {\n  return getByAttributeTextSelector('title', text, options);\n}\nfunction getByPlaceholderSelector(text, options) {\n  return getByAttributeTextSelector('placeholder', text, options);\n}\nfunction getByTextSelector(text, options) {\n  return 'internal:text=' + (0, _stringUtils.escapeForTextSelector)(text, !!(options !== null && options !== void 0 && options.exact));\n}\nfunction getByRoleSelector(role, options = {}) {\n  const props = [];\n  if (options.checked !== undefined) props.push(['checked', String(options.checked)]);\n  if (options.disabled !== undefined) props.push(['disabled', String(options.disabled)]);\n  if (options.selected !== undefined) props.push(['selected', String(options.selected)]);\n  if (options.expanded !== undefined) props.push(['expanded', String(options.expanded)]);\n  if (options.includeHidden !== undefined) props.push(['include-hidden', String(options.includeHidden)]);\n  if (options.level !== undefined) props.push(['level', String(options.level)]);\n  if (options.name !== undefined) props.push(['name', (0, _stringUtils.isString)(options.name) ? (0, _stringUtils.escapeForAttributeSelector)(options.name, !!options.exact) : String(options.name)]);\n  if (options.pressed !== undefined) props.push(['pressed', String(options.pressed)]);\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join('')}`;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cssEscape = cssEscape;\nexports.escapeForAttributeSelector = escapeForAttributeSelector;\nexports.escapeForTextSelector = escapeForTextSelector;\nexports.escapeWithQuotes = escapeWithQuotes;\nexports.isString = isString;\nexports.normalizeWhiteSpace = normalizeWhiteSpace;\nexports.toSnakeCase = toSnakeCase;\nexports.toTitleCase = toTitleCase;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTE: this function should not be used to escape any selectors.\nfunction escapeWithQuotes(text, char = '\\'') {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\"/g, '\"');\n  if (char === '\\'') return char + escapedText.replace(/[']/g, '\\\\\\'') + char;\n  if (char === '\"') return char + escapedText.replace(/[\"]/g, '\\\\\"') + char;\n  if (char === '`') return char + escapedText.replace(/[`]/g, '`') + char;\n  throw new Error('Invalid escape char');\n}\nfunction isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  // E.g. ignoreHTTPSErrors => ignore_https_errors.\n  return name.replace(/([a-z0-9])([A-Z])/g, '$1_$2').replace(/([A-Z])([A-Z][a-z])/g, '$1_$2').toLowerCase();\n}\nfunction cssEscape(s) {\n  let result = '';\n  for (let i = 0; i < s.length; i++) result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  // https://drafts.csswg.org/cssom/#serialize-an-identifier\n  const c = s.charCodeAt(i);\n  if (c === 0x0000) return '\\uFFFD';\n  if (c >= 0x0001 && c <= 0x001f || c >= 0x0030 && c <= 0x0039 && (i === 0 || i === 1 && s.charCodeAt(0) === 0x002d)) return '\\\\' + c.toString(16) + ' ';\n  if (i === 0 && c === 0x002d && s.length === 1) return '\\\\' + s.charAt(i);\n  if (c >= 0x0080 || c === 0x002d || c === 0x005f || c >= 0x0030 && c <= 0x0039 || c >= 0x0041 && c <= 0x005a || c >= 0x0061 && c <= 0x007a) return s.charAt(i);\n  return '\\\\' + s.charAt(i);\n}\nfunction normalizeWhiteSpace(text) {\n  return text.replace(/\\u200b/g, '').trim().replace(/\\s+/g, ' ');\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== 'string') return String(text);\n  return `${JSON.stringify(text)}${exact ? 's' : 'i'}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  // TODO: this should actually be\n  //   cssEscape(value).replace(/\\\\ /g, ' ')\n  // However, our attribute selectors do not conform to CSS parsing spec,\n  // so we escape them differently.\n  return `\"${value.replace(/\\\\/g, '\\\\\\\\').replace(/[\"]/g, '\\\\\"')}\"${exact ? 's' : 'i'}`;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLinuxDistributionInfo = getLinuxDistributionInfo;\nexports.getLinuxDistributionInfoSync = getLinuxDistributionInfoSync;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet didFailToReadOSRelease = false;\nlet osRelease;\nasync function getLinuxDistributionInfo() {\n  if (process.platform !== 'linux') return undefined;\n  if (!osRelease && !didFailToReadOSRelease) {\n    try {\n      var _fields$get, _fields$get2;\n      // List of /etc/os-release values for different distributions could be\n      // found here: https://gist.github.com/aslushnikov/8ceddb8288e4cf9db3039c02e0f4fb75\n      const osReleaseText = await _fs.default.promises.readFile('/etc/os-release', 'utf8');\n      const fields = parseOSReleaseText(osReleaseText);\n      osRelease = {\n        id: (_fields$get = fields.get('id')) !== null && _fields$get !== void 0 ? _fields$get : '',\n        version: (_fields$get2 = fields.get('version_id')) !== null && _fields$get2 !== void 0 ? _fields$get2 : ''\n      };\n    } catch (e) {\n      didFailToReadOSRelease = true;\n    }\n  }\n  return osRelease;\n}\nfunction getLinuxDistributionInfoSync() {\n  if (process.platform !== 'linux') return undefined;\n  if (!osRelease && !didFailToReadOSRelease) {\n    try {\n      var _fields$get3, _fields$get4;\n      // List of /etc/os-release values for different distributions could be\n      // found here: https://gist.github.com/aslushnikov/8ceddb8288e4cf9db3039c02e0f4fb75\n      const osReleaseText = _fs.default.readFileSync('/etc/os-release', 'utf8');\n      const fields = parseOSReleaseText(osReleaseText);\n      osRelease = {\n        id: (_fields$get3 = fields.get('id')) !== null && _fields$get3 !== void 0 ? _fields$get3 : '',\n        version: (_fields$get4 = fields.get('version_id')) !== null && _fields$get4 !== void 0 ? _fields$get4 : ''\n      };\n    } catch (e) {\n      didFailToReadOSRelease = true;\n    }\n  }\n  return osRelease;\n}\nfunction parseOSReleaseText(osReleaseText) {\n  const fields = new Map();\n  for (const line of osReleaseText.split('\\n')) {\n    const tokens = line.split('=');\n    const name = tokens.shift();\n    let value = tokens.join('=').trim();\n    if (value.startsWith('\"') && value.endsWith('\"')) value = value.substring(1, value.length - 1);\n    if (!name) continue;\n    fields.set(name.toLowerCase(), value);\n  }\n  return fields;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ManualPromise = void 0;\nlet _Symbol$species, _Symbol$toStringTag;\n_Symbol$species = Symbol.species;\n_Symbol$toStringTag = Symbol.toStringTag;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ManualPromise extends Promise {\n  constructor() {\n    let resolve;\n    let reject;\n    super((f, r) => {\n      resolve = f;\n      reject = r;\n    });\n    this._resolve = void 0;\n    this._reject = void 0;\n    this._isDone = void 0;\n    this._isDone = false;\n    this._resolve = resolve;\n    this._reject = reject;\n  }\n  isDone() {\n    return this._isDone;\n  }\n  resolve(t) {\n    this._isDone = true;\n    this._resolve(t);\n  }\n  reject(e) {\n    this._isDone = true;\n    this._reject(e);\n  }\n  static get [_Symbol$species]() {\n    return Promise;\n  }\n  get [_Symbol$toStringTag]() {\n    return 'ManualPromise';\n  }\n}\nexports.ManualPromise = ManualPromise;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTextualMimeType = isTextualMimeType;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction isTextualMimeType(mimeType) {\n  return !!mimeType.match(/^(text\\/.*?|application\\/(json|(x-)?javascript|xml.*?|ecmascript|graphql|x-www-form-urlencoded)|image\\/svg(\\+xml)?|application\\/.*?(\\+json|\\+xml))(;\\s*charset=.*)?$/);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiMap = void 0;\nlet _Symbol$iterator;\n_Symbol$iterator = Symbol.iterator;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass MultiMap {\n  constructor() {\n    this._map = void 0;\n    this._map = new Map();\n  }\n  set(key, value) {\n    let values = this._map.get(key);\n    if (!values) {\n      values = [];\n      this._map.set(key, values);\n    }\n    values.push(value);\n  }\n  get(key) {\n    return this._map.get(key) || [];\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  delete(key, value) {\n    const values = this._map.get(key);\n    if (!values) return;\n    if (values.includes(value)) this._map.set(key, values.filter(v => value !== v));\n  }\n  deleteAll(key) {\n    this._map.delete(key);\n  }\n  hasValue(key, value) {\n    const values = this._map.get(key);\n    if (!values) return false;\n    return values.includes(value);\n  }\n  get size() {\n    return this._map.size;\n  }\n  [_Symbol$iterator]() {\n    return this._map[Symbol.iterator]();\n  }\n  keys() {\n    return this._map.keys();\n  }\n  values() {\n    const result = [];\n    for (const key of this.keys()) result.push(...this.get(key));\n    return result;\n  }\n  clear() {\n    this._map.clear();\n  }\n}\nexports.MultiMap = MultiMap;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NET_DEFAULT_TIMEOUT = void 0;\nexports.constructURLBasedOnBaseURL = constructURLBasedOnBaseURL;\nexports.createSocket = createSocket;\nexports.fetchData = fetchData;\nexports.httpRequest = httpRequest;\nexports.urlMatches = urlMatches;\nvar _http = _interopRequireDefault(require(\"http\"));\nvar _https = _interopRequireDefault(require(\"https\"));\nvar _net = _interopRequireDefault(require(\"net\"));\nvar _utilsBundle = require(\"../utilsBundle\");\nvar URL = _interopRequireWildcard(require(\"url\"));\nvar _rtti = require(\"./rtti\");\nvar _glob = require(\"./glob\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nasync function createSocket(host, port) {\n  return new Promise((resolve, reject) => {\n    const socket = _net.default.createConnection({\n      host,\n      port\n    });\n    socket.on('connect', () => resolve(socket));\n    socket.on('error', error => reject(error));\n  });\n}\nconst NET_DEFAULT_TIMEOUT = 30_000;\nexports.NET_DEFAULT_TIMEOUT = NET_DEFAULT_TIMEOUT;\nfunction httpRequest(params, onResponse, onError) {\n  var _params$timeout;\n  const parsedUrl = URL.parse(params.url);\n  let options = {\n    ...parsedUrl\n  };\n  options.method = params.method || 'GET';\n  options.headers = params.headers;\n  const timeout = (_params$timeout = params.timeout) !== null && _params$timeout !== void 0 ? _params$timeout : NET_DEFAULT_TIMEOUT;\n  const proxyURL = (0, _utilsBundle.getProxyForUrl)(params.url);\n  if (proxyURL) {\n    const parsedProxyURL = URL.parse(proxyURL);\n    if (params.url.startsWith('http:')) {\n      options = {\n        path: parsedUrl.href,\n        host: parsedProxyURL.hostname,\n        port: parsedProxyURL.port,\n        headers: options.headers,\n        method: options.method\n      };\n    } else {\n      parsedProxyURL.secureProxy = parsedProxyURL.protocol === 'https:';\n      options.agent = new _utilsBundle.HttpsProxyAgent(parsedProxyURL);\n      options.rejectUnauthorized = false;\n    }\n  }\n  const requestCallback = res => {\n    const statusCode = res.statusCode || 0;\n    if (statusCode >= 300 && statusCode < 400 && res.headers.location) httpRequest({\n      ...params,\n      url: res.headers.location\n    }, onResponse, onError);else onResponse(res);\n  };\n  const request = options.protocol === 'https:' ? _https.default.request(options, requestCallback) : _http.default.request(options, requestCallback);\n  request.on('error', onError);\n  if (timeout !== undefined) {\n    const rejectOnTimeout = () => {\n      onError(new Error(`Request to ${params.url} timed out after ${timeout}ms`));\n      request.abort();\n    };\n    if (timeout <= 0) {\n      rejectOnTimeout();\n      return;\n    }\n    request.setTimeout(timeout, rejectOnTimeout);\n  }\n  request.end(params.data);\n}\nfunction fetchData(params, onError) {\n  return new Promise((resolve, reject) => {\n    httpRequest(params, async response => {\n      if (response.statusCode !== 200) {\n        const error = onError ? await onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);\n        reject(error);\n        return;\n      }\n      let body = '';\n      response.on('data', chunk => body += chunk);\n      response.on('error', error => reject(error));\n      response.on('end', () => resolve(body));\n    }, reject);\n  });\n}\nfunction urlMatches(baseURL, urlString, match) {\n  if (match === undefined || match === '') return true;\n  if ((0, _rtti.isString)(match) && !match.startsWith('*')) match = constructURLBasedOnBaseURL(baseURL, match);\n  if ((0, _rtti.isString)(match)) match = (0, _glob.globToRegex)(match);\n  if ((0, _rtti.isRegExp)(match)) return match.test(urlString);\n  if (typeof match === 'string' && match === urlString) return true;\n  const url = parsedURL(urlString);\n  if (!url) return false;\n  if (typeof match === 'string') return url.pathname === match;\n  if (typeof match !== 'function') throw new Error('url parameter should be string, RegExp or function');\n  return match(url);\n}\nfunction parsedURL(url) {\n  try {\n    return new URL.URL(url);\n  } catch (e) {\n    return null;\n  }\n}\nfunction constructURLBasedOnBaseURL(baseURL, givenURL) {\n  try {\n    return new URL.URL(givenURL, baseURL).toString();\n  } catch (e) {\n    return givenURL;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.envArrayToObject = envArrayToObject;\nexports.gracefullyCloseAll = gracefullyCloseAll;\nexports.gracefullyCloseSet = void 0;\nexports.launchProcess = launchProcess;\nvar childProcess = _interopRequireWildcard(require(\"child_process\"));\nvar readline = _interopRequireWildcard(require(\"readline\"));\nvar path = _interopRequireWildcard(require(\"path\"));\nvar _eventsHelper = require(\"./eventsHelper\");\nvar _ = require(\"./\");\nvar _fileUtils = require(\"./fileUtils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst gracefullyCloseSet = new Set();\nexports.gracefullyCloseSet = gracefullyCloseSet;\nasync function gracefullyCloseAll() {\n  await Promise.all(Array.from(gracefullyCloseSet).map(gracefullyClose => gracefullyClose().catch(e => {})));\n}\n\n// We currently spawn a process per page when recording video in Chromium.\n//  This triggers \"too many listeners\" on the process object once you have more than 10 pages open.\nconst maxListeners = process.getMaxListeners();\nif (maxListeners !== 0) process.setMaxListeners(Math.max(maxListeners || 0, 100));\nasync function launchProcess(options) {\n  const stdio = options.stdio === 'pipe' ? ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'] : ['pipe', 'pipe', 'pipe'];\n  options.log(`<launching> ${options.command} ${options.args ? options.args.join(' ') : ''}`);\n  const spawnOptions = {\n    // On non-windows platforms, `detached: true` makes child process a leader of a new\n    // process group, making it possible to kill child process tree with `.kill(-pid)` command.\n    // @see https://nodejs.org/api/child_process.html#child_process_options_detached\n    detached: process.platform !== 'win32',\n    env: options.env,\n    cwd: options.cwd,\n    shell: options.shell,\n    stdio\n  };\n  const spawnedProcess = childProcess.spawn(options.command, options.args || [], spawnOptions);\n  const cleanup = async () => {\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);\n    const errors = await (0, _fileUtils.removeFolders)(options.tempDirectories);\n    for (let i = 0; i < options.tempDirectories.length; ++i) {\n      if (errors[i]) options.log(`[pid=${spawnedProcess.pid || 'N/A'}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);\n    }\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);\n  };\n\n  // Prevent Unhandled 'error' event.\n  spawnedProcess.on('error', () => {});\n  if (!spawnedProcess.pid) {\n    let failed;\n    const failedPromise = new Promise((f, r) => failed = f);\n    spawnedProcess.once('error', error => {\n      failed(new Error('Failed to launch: ' + error));\n    });\n    return cleanup().then(() => failedPromise).then(e => Promise.reject(e));\n  }\n  options.log(`<launched> pid=${spawnedProcess.pid}`);\n  const stdout = readline.createInterface({\n    input: spawnedProcess.stdout\n  });\n  stdout.on('line', data => {\n    options.log(`[pid=${spawnedProcess.pid}][out] ` + data);\n  });\n  const stderr = readline.createInterface({\n    input: spawnedProcess.stderr\n  });\n  stderr.on('line', data => {\n    options.log(`[pid=${spawnedProcess.pid}][err] ` + data);\n  });\n  let processClosed = false;\n  let fulfillCleanup = () => {};\n  const waitForCleanup = new Promise(f => fulfillCleanup = f);\n  spawnedProcess.once('exit', (exitCode, signal) => {\n    options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);\n    processClosed = true;\n    _eventsHelper.eventsHelper.removeEventListeners(listeners);\n    gracefullyCloseSet.delete(gracefullyClose);\n    options.onExit(exitCode, signal);\n    // Cleanup as process exits.\n    cleanup().then(fulfillCleanup);\n  });\n  const listeners = [_eventsHelper.eventsHelper.addEventListener(process, 'exit', killProcessAndCleanup)];\n  if (options.handleSIGINT) {\n    listeners.push(_eventsHelper.eventsHelper.addEventListener(process, 'SIGINT', () => {\n      gracefullyClose().then(() => {\n        // Give tests a chance to dispatch any async calls.\n        if ((0, _.isUnderTest)()) setTimeout(() => process.exit(130), 0);else process.exit(130);\n      });\n    }));\n  }\n  if (options.handleSIGTERM) listeners.push(_eventsHelper.eventsHelper.addEventListener(process, 'SIGTERM', gracefullyClose));\n  if (options.handleSIGHUP) listeners.push(_eventsHelper.eventsHelper.addEventListener(process, 'SIGHUP', gracefullyClose));\n  gracefullyCloseSet.add(gracefullyClose);\n  let gracefullyClosing = false;\n  async function gracefullyClose() {\n    gracefullyCloseSet.delete(gracefullyClose);\n    // We keep listeners until we are done, to handle 'exit' and 'SIGINT' while\n    // asynchronously closing to prevent zombie processes. This might introduce\n    // reentrancy to this function, for example user sends SIGINT second time.\n    // In this case, let's forcefully kill the process.\n    if (gracefullyClosing) {\n      options.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);\n      killProcess();\n      await waitForCleanup; // Ensure the process is dead and we have cleaned up.\n      return;\n    }\n    gracefullyClosing = true;\n    options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);\n    await options.attemptToGracefullyClose().catch(() => killProcess());\n    await waitForCleanup; // Ensure the process is dead and we have cleaned up.\n    options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);\n  }\n\n  // This method has to be sync to be used as 'exit' event handler.\n  function killProcess() {\n    options.log(`[pid=${spawnedProcess.pid}] <kill>`);\n    _eventsHelper.eventsHelper.removeEventListeners(listeners);\n    if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {\n      options.log(`[pid=${spawnedProcess.pid}] <will force kill>`);\n      // Force kill the browser.\n      try {\n        if (process.platform === 'win32') {\n          const taskkillProcess = childProcess.spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F`, {\n            shell: true\n          });\n          const [stdout, stderr] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];\n          if (stdout) options.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout}`);\n          if (stderr) options.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr}`);\n        } else {\n          process.kill(-spawnedProcess.pid, 'SIGKILL');\n        }\n      } catch (e) {\n        options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);\n        // the process might have already stopped\n      }\n    } else {\n      options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);\n    }\n  }\n  function killProcessAndCleanup() {\n    killProcess();\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);\n    if (options.tempDirectories.length) {\n      const cleanupProcess = childProcess.spawnSync(process.argv0, [path.join(__dirname, 'processLauncherCleanupEntrypoint.js'), ...options.tempDirectories]);\n      const [stdout, stderr] = [cleanupProcess.stdout.toString(), cleanupProcess.stderr.toString()];\n      if (stdout) options.log(`[pid=${spawnedProcess.pid || 'N/A'}] ${stdout}`);\n      if (stderr) options.log(`[pid=${spawnedProcess.pid || 'N/A'}] ${stderr}`);\n    }\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);\n  }\n  function killAndWait() {\n    killProcess();\n    return waitForCleanup;\n  }\n  return {\n    launchedProcess: spawnedProcess,\n    gracefullyClose,\n    kill: killAndWait\n  };\n}\nfunction envArrayToObject(env) {\n  const result = {};\n  for (const {\n    name,\n    value\n  } of env) result[name] = value;\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isError = isError;\nexports.isLikelyNpxGlobal = void 0;\nexports.isObject = isObject;\nexports.isRegExp = isRegExp;\nexports.isString = isString;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\nfunction isRegExp(obj) {\n  return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\nfunction isError(obj) {\n  var _Object$getPrototypeO;\n  return obj instanceof Error || obj && ((_Object$getPrototypeO = Object.getPrototypeOf(obj)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.name) === 'Error';\n}\nconst isLikelyNpxGlobal = () => process.argv.length >= 2 && process.argv[1].includes('_npx');\nexports.isLikelyNpxGlobal = isLikelyNpxGlobal;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spawnAsync = spawnAsync;\nvar _child_process = require(\"child_process\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction spawnAsync(cmd, args, options = {}) {\n  const process = (0, _child_process.spawn)(cmd, args, Object.assign({\n    windowsHide: true\n  }, options));\n  return new Promise(resolve => {\n    let stdout = '';\n    let stderr = '';\n    if (process.stdout) process.stdout.on('data', data => stdout += data);\n    if (process.stderr) process.stderr.on('data', data => stderr += data);\n    process.on('close', code => resolve({\n      stdout,\n      stderr,\n      code\n    }));\n    process.on('error', error => resolve({\n      stdout,\n      stderr,\n      code: 0,\n      error\n    }));\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addStackIgnoreFilter = void 0;\nexports.captureRawStack = captureRawStack;\nexports.captureStackTrace = captureStackTrace;\nexports.isInternalFileName = isInternalFileName;\nexports.rewriteErrorMessage = rewriteErrorMessage;\nexports.splitErrorMessage = splitErrorMessage;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _utilsBundle = require(\"../utilsBundle\");\nvar _ = require(\"./\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction rewriteErrorMessage(e, newMessage) {\n  var _e$stack;\n  const lines = (((_e$stack = e.stack) === null || _e$stack === void 0 ? void 0 : _e$stack.split('\\n')) || []).filter(l => l.startsWith('    at '));\n  e.message = newMessage;\n  const errorTitle = `${e.name}: ${e.message}`;\n  if (lines.length) e.stack = `${errorTitle}\\n${lines.join('\\n')}`;\n  return e;\n}\nconst CORE_DIR = _path.default.resolve(__dirname, '..', '..');\nconst CORE_LIB = _path.default.join(CORE_DIR, 'lib');\nconst CORE_SRC = _path.default.join(CORE_DIR, 'src');\nconst COVERAGE_PATH = _path.default.join(CORE_DIR, '..', '..', 'tests', 'config', 'coverage.js');\nconst stackIgnoreFilters = [frame => frame.file.startsWith(CORE_DIR)];\nconst addStackIgnoreFilter = filter => stackIgnoreFilters.push(filter);\nexports.addStackIgnoreFilter = addStackIgnoreFilter;\nfunction captureRawStack() {\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 30;\n  const error = new Error();\n  const stack = error.stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  return stack;\n}\nfunction isInternalFileName(file, functionName) {\n  // Node 16+ has node:internal.\n  if (file.startsWith('internal') || file.startsWith('node:')) return true;\n  // EventEmitter.emit has 'events.js' file.\n  if (file === 'events.js' && functionName !== null && functionName !== void 0 && functionName.endsWith('emit')) return true;\n  return false;\n}\nfunction captureStackTrace(rawStack) {\n  const stack = rawStack || captureRawStack();\n  const isTesting = (0, _.isUnderTest)();\n  let parsedFrames = stack.split('\\n').map(line => {\n    const {\n      frame,\n      fileName\n    } = (0, _utilsBundle.parseStackTraceLine)(line);\n    if (!frame || !frame.file || !fileName) return null;\n    if (!process.env.PWDEBUGIMPL && isInternalFileName(frame.file, frame.function)) return null;\n    if (!process.env.PWDEBUGIMPL && isTesting && fileName.includes(COVERAGE_PATH)) return null;\n    const inCore = fileName.startsWith(CORE_LIB) || fileName.startsWith(CORE_SRC);\n    const parsed = {\n      frame: {\n        file: fileName,\n        line: frame.line,\n        column: frame.column,\n        function: frame.function\n      },\n      frameText: line,\n      inCore\n    };\n    return parsed;\n  }).filter(Boolean);\n  let apiName = '';\n  const allFrames = parsedFrames;\n  // Deepest transition between non-client code calling into client code\n  // is the api entry.\n  for (let i = 0; i < parsedFrames.length - 1; i++) {\n    if (parsedFrames[i].inCore && !parsedFrames[i + 1].inCore) {\n      const frame = parsedFrames[i].frame;\n      apiName = normalizeAPIName(frame.function);\n      if (!process.env.PWDEBUGIMPL) parsedFrames = parsedFrames.slice(i + 1);\n      break;\n    }\n  }\n  function normalizeAPIName(name) {\n    if (!name) return '';\n    const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);\n    if (!match) return name;\n    return match[1].toLowerCase() + match[2];\n  }\n\n  // Hide all test runner and library frames in the user stack (event handlers produce them).\n  parsedFrames = parsedFrames.filter((f, i) => {\n    if (process.env.PWDEBUGIMPL) return true;\n    if (stackIgnoreFilters.some(filter => filter(f.frame))) return false;\n    return true;\n  });\n  return {\n    allFrames: allFrames.map(p => p.frame),\n    frames: parsedFrames.map(p => p.frame),\n    frameTexts: parsedFrames.map(p => p.frameText),\n    apiName\n  };\n}\nfunction splitErrorMessage(message) {\n  const separationIdx = message.indexOf(':');\n  return {\n    name: separationIdx !== -1 ? message.slice(0, separationIdx) : '',\n    message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeWaitForNextTask = makeWaitForNextTask;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// See https://joel.tools/microtasks/\nfunction makeWaitForNextTask() {\n  // As of Mar 2021, Electron v12 doesn't create new task with `setImmediate` despite\n  // using Node 14 internally, so we fallback to `setTimeout(0)` instead.\n  // @see https://github.com/electron/electron/issues/28261\n  if (process.versions.electron) return callback => setTimeout(callback, 0);\n  if (parseInt(process.versions.node, 10) >= 11) return setImmediate;\n\n  // Unlike Node 11, Node 10 and less have a bug with Task and MicroTask execution order:\n  // - https://github.com/nodejs/node/issues/22257\n  //\n  // So we can't simply run setImmediate to dispatch code in a following task.\n  // However, we can run setImmediate from-inside setImmediate to make sure we're getting\n  // in the following task.\n\n  let spinning = false;\n  const callbacks = [];\n  const loop = () => {\n    const callback = callbacks.shift();\n    if (!callback) {\n      spinning = false;\n      return;\n    }\n    setImmediate(loop);\n    // Make sure to call callback() as the last thing since it's\n    // untrusted code that might throw.\n    callback();\n  };\n  return callback => {\n    callbacks.push(callback);\n    if (!spinning) {\n      spinning = true;\n      setImmediate(loop);\n    }\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.monotonicTime = monotonicTime;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction monotonicTime() {\n  const [seconds, nanoseconds] = process.hrtime();\n  return seconds * 1000 + (nanoseconds / 1000 | 0) / 1000;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeoutRunnerError = exports.TimeoutRunner = void 0;\nexports.pollAgainstTimeout = pollAgainstTimeout;\nexports.raceAgainstTimeout = raceAgainstTimeout;\nvar _manualPromise = require(\"./manualPromise\");\nvar _ = require(\"./\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass TimeoutRunnerError extends Error {}\nexports.TimeoutRunnerError = TimeoutRunnerError;\nclass TimeoutRunner {\n  constructor(timeout) {\n    this._running = void 0;\n    this._timeout = void 0;\n    this._elapsed = void 0;\n    this._timeout = timeout;\n    this._elapsed = 0;\n  }\n  async run(cb) {\n    const running = this._running = {\n      lastElapsedSync: (0, _.monotonicTime)(),\n      timer: undefined,\n      timeoutPromise: new _manualPromise.ManualPromise()\n    };\n    try {\n      const resultPromise = Promise.race([cb(), running.timeoutPromise]);\n      this._updateTimeout(running, this._timeout);\n      return await resultPromise;\n    } finally {\n      this._updateTimeout(running, 0);\n      if (this._running === running) this._running = undefined;\n    }\n  }\n  interrupt() {\n    if (this._running) this._updateTimeout(this._running, -1);\n  }\n  elapsed() {\n    this._syncElapsedAndStart();\n    return this._elapsed;\n  }\n  updateTimeout(timeout, elapsed) {\n    this._timeout = timeout;\n    if (elapsed !== undefined) {\n      this._syncElapsedAndStart();\n      this._elapsed = elapsed;\n    }\n    if (this._running) this._updateTimeout(this._running, timeout);\n  }\n  _syncElapsedAndStart() {\n    if (this._running) {\n      const now = (0, _.monotonicTime)();\n      this._elapsed += now - this._running.lastElapsedSync;\n      this._running.lastElapsedSync = now;\n    }\n  }\n  _updateTimeout(running, timeout) {\n    if (running.timer) {\n      clearTimeout(running.timer);\n      running.timer = undefined;\n    }\n    this._syncElapsedAndStart();\n    if (timeout === 0) return;\n    timeout = timeout - this._elapsed;\n    if (timeout <= 0) running.timeoutPromise.reject(new TimeoutRunnerError());else running.timer = setTimeout(() => running.timeoutPromise.reject(new TimeoutRunnerError()), timeout);\n  }\n}\nexports.TimeoutRunner = TimeoutRunner;\nasync function raceAgainstTimeout(cb, timeout) {\n  const runner = new TimeoutRunner(timeout);\n  try {\n    return {\n      result: await runner.run(cb),\n      timedOut: false\n    };\n  } catch (e) {\n    if (e instanceof TimeoutRunnerError) return {\n      timedOut: true\n    };\n    throw e;\n  }\n}\nasync function pollAgainstTimeout(callback, timeout, pollIntervals = [100, 250, 500, 1000]) {\n  var _pollIntervals$pop;\n  const startTime = (0, _.monotonicTime)();\n  const lastPollInterval = (_pollIntervals$pop = pollIntervals.pop()) !== null && _pollIntervals$pop !== void 0 ? _pollIntervals$pop : 1000;\n  let lastResult;\n  const wrappedCallback = () => Promise.resolve().then(callback);\n  while (true) {\n    var _shift;\n    const elapsed = (0, _.monotonicTime)() - startTime;\n    if (timeout !== 0 && elapsed >= timeout) break;\n    const received = timeout !== 0 ? await raceAgainstTimeout(wrappedCallback, timeout - elapsed) : await wrappedCallback().then(value => ({\n      result: value,\n      timedOut: false\n    }));\n    if (received.timedOut) break;\n    lastResult = received.result.result;\n    if (!received.result.continuePolling) return {\n      result: received.result.result,\n      timedOut: false\n    };\n    const interval = (_shift = pollIntervals.shift()) !== null && _shift !== void 0 ? _shift : lastPollInterval;\n    if (timeout !== 0 && startTime + timeout <= (0, _.monotonicTime)() + interval) break;\n    await new Promise(x => setTimeout(x, interval));\n  }\n  return {\n    timedOut: true,\n    result: lastResult\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEmbedderName = getEmbedderName;\nexports.getPlaywrightVersion = getPlaywrightVersion;\nexports.getUserAgent = getUserAgent;\nvar _child_process = require(\"child_process\");\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _linuxUtils = require(\"../utils/linuxUtils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet cachedUserAgent;\nfunction getUserAgent() {\n  if (cachedUserAgent) return cachedUserAgent;\n  try {\n    cachedUserAgent = determineUserAgent();\n  } catch (e) {\n    cachedUserAgent = 'Playwright/unknown';\n  }\n  return cachedUserAgent;\n}\nfunction determineUserAgent() {\n  let osIdentifier = 'unknown';\n  let osVersion = 'unknown';\n  if (process.platform === 'win32') {\n    const version = _os.default.release().split('.');\n    osIdentifier = 'windows';\n    osVersion = `${version[0]}.${version[1]}`;\n  } else if (process.platform === 'darwin') {\n    const version = (0, _child_process.execSync)('sw_vers -productVersion', {\n      stdio: ['ignore', 'pipe', 'ignore']\n    }).toString().trim().split('.');\n    osIdentifier = 'macOS';\n    osVersion = `${version[0]}.${version[1]}`;\n  } else if (process.platform === 'linux') {\n    const distroInfo = (0, _linuxUtils.getLinuxDistributionInfoSync)();\n    if (distroInfo) {\n      osIdentifier = distroInfo.id || 'linux';\n      osVersion = distroInfo.version || 'unknown';\n    } else {\n      // Linux distribution without /etc/os-release.\n      // Default to linux/unknown.\n      osIdentifier = 'linux';\n    }\n  }\n  const additionalTokens = [];\n  if (process.env.CI) additionalTokens.push('CI/1');\n  const serializedTokens = additionalTokens.length ? ' ' + additionalTokens.join(' ') : '';\n  const {\n    embedderName,\n    embedderVersion\n  } = getEmbedderName();\n  return `Playwright/${getPlaywrightVersion()} (${_os.default.arch()}; ${osIdentifier} ${osVersion}) ${embedderName}/${embedderVersion}${serializedTokens}`;\n}\nfunction getEmbedderName() {\n  let embedderName = 'unknown';\n  let embedderVersion = 'unknown';\n  if (!process.env.PW_LANG_NAME) {\n    embedderName = 'node';\n    embedderVersion = process.version.substring(1).split('.').slice(0, 2).join('.');\n  } else if (['node', 'python', 'java', 'csharp'].includes(process.env.PW_LANG_NAME)) {\n    var _process$env$PW_LANG_;\n    embedderName = process.env.PW_LANG_NAME;\n    embedderVersion = (_process$env$PW_LANG_ = process.env.PW_LANG_NAME_VERSION) !== null && _process$env$PW_LANG_ !== void 0 ? _process$env$PW_LANG_ : 'unknown';\n  }\n  return {\n    embedderName,\n    embedderVersion\n  };\n}\nfunction getPlaywrightVersion(majorMinorOnly = false) {\n  const packageJson = require('./../../package.json');\n  return majorMinorOnly ? packageJson.version.split('.').slice(0, 2).join('.') : packageJson.version;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ZipFile = void 0;\nvar _zipBundle = require(\"../zipBundle\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ZipFile {\n  constructor(fileName) {\n    this._fileName = void 0;\n    this._zipFile = void 0;\n    this._entries = new Map();\n    this._openedPromise = void 0;\n    this._fileName = fileName;\n    this._openedPromise = this._open();\n  }\n  async _open() {\n    await new Promise((fulfill, reject) => {\n      _zipBundle.yauzl.open(this._fileName, {\n        autoClose: false\n      }, (e, z) => {\n        if (e) {\n          reject(e);\n          return;\n        }\n        this._zipFile = z;\n        this._zipFile.on('entry', entry => {\n          this._entries.set(entry.fileName, entry);\n        });\n        this._zipFile.on('end', fulfill);\n      });\n    });\n  }\n  async entries() {\n    await this._openedPromise;\n    return [...this._entries.keys()];\n  }\n  async read(entryPath) {\n    await this._openedPromise;\n    const entry = this._entries.get(entryPath);\n    if (!entry) throw new Error(`${entryPath} not found in file ${this._fileName}`);\n    return new Promise((resolve, reject) => {\n      this._zipFile.openReadStream(entry, (error, readStream) => {\n        if (error || !readStream) {\n          reject(error || 'Entry not found');\n          return;\n        }\n        const buffers = [];\n        readStream.on('data', data => buffers.push(data));\n        readStream.on('end', () => resolve(Buffer.concat(buffers)));\n      });\n    });\n  }\n  close() {\n    var _this$_zipFile;\n    (_this$_zipFile = this._zipFile) === null || _this$_zipFile === void 0 ? void 0 : _this$_zipFile.close();\n  }\n}\nexports.ZipFile = ZipFile;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zones = void 0;\nvar _stackTrace = require(\"./stackTrace\");\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass ZoneManager {\n  constructor() {\n    this.lastZoneId = 0;\n    this._zones = new Map();\n  }\n  async run(type, data, func) {\n    const zone = new Zone(this, ++this.lastZoneId, type, data);\n    this._zones.set(zone.id, zone);\n    return zone.run(func);\n  }\n  zoneData(type, rawStack) {\n    const stack = rawStack || (0, _stackTrace.captureRawStack)();\n    for (const line of stack.split('\\n')) {\n      const index = line.indexOf('__PWZONE__[');\n      if (index !== -1) {\n        const zoneId = +line.substring(index + '__PWZONE__['.length, line.indexOf(']', index));\n        const zone = this._zones.get(zoneId);\n        if (zone && zone.type === type) return zone.data;\n      }\n    }\n    return null;\n  }\n}\nclass Zone {\n  constructor(manager, id, type, data) {\n    this._manager = void 0;\n    this.id = void 0;\n    this.type = void 0;\n    this.data = {};\n    this._manager = manager;\n    this.id = id;\n    this.type = type;\n    this.data = data;\n  }\n  async run(func) {\n    Object.defineProperty(func, 'name', {\n      value: `__PWZONE__[${this.id}]`\n    });\n    try {\n      return await func();\n    } finally {\n      this._manager._zones.delete(this.id);\n    }\n  }\n}\nconst zones = new ZoneManager();\nexports.zones = zones;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.minimatch = exports.mime = exports.lockfile = exports.jpegjs = exports.getProxyForUrl = exports.debug = exports.colors = exports.SocksProxyAgent = exports.PNG = exports.HttpsProxyAgent = void 0;\nexports.ms = ms;\nexports.parseStackTraceLine = parseStackTraceLine;\nexports.wsServer = exports.wsSender = exports.wsReceiver = exports.ws = exports.rimraf = exports.progress = exports.program = void 0;\nvar _url = _interopRequireDefault(require(\"url\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst colors = require('./utilsBundleImpl').colors;\nexports.colors = colors;\nconst debug = require('./utilsBundleImpl').debug;\nexports.debug = debug;\nconst getProxyForUrl = require('./utilsBundleImpl').getProxyForUrl;\nexports.getProxyForUrl = getProxyForUrl;\nconst HttpsProxyAgent = require('./utilsBundleImpl').HttpsProxyAgent;\nexports.HttpsProxyAgent = HttpsProxyAgent;\nconst jpegjs = require('./utilsBundleImpl').jpegjs;\nexports.jpegjs = jpegjs;\nconst lockfile = require('./utilsBundleImpl').lockfile;\nexports.lockfile = lockfile;\nconst mime = require('./utilsBundleImpl').mime;\nexports.mime = mime;\nconst minimatch = require('./utilsBundleImpl').minimatch;\nexports.minimatch = minimatch;\nconst PNG = require('./utilsBundleImpl').PNG;\nexports.PNG = PNG;\nconst program = require('./utilsBundleImpl').program;\nexports.program = program;\nconst progress = require('./utilsBundleImpl').progress;\nexports.progress = progress;\nconst rimraf = require('./utilsBundleImpl').rimraf;\nexports.rimraf = rimraf;\nconst SocksProxyAgent = require('./utilsBundleImpl').SocksProxyAgent;\nexports.SocksProxyAgent = SocksProxyAgent;\nconst ws = require('./utilsBundleImpl').ws;\nexports.ws = ws;\nconst wsServer = require('./utilsBundleImpl').wsServer;\nexports.wsServer = wsServer;\nconst wsReceiver = require('./utilsBundleImpl').wsReceiver;\nexports.wsReceiver = wsReceiver;\nconst wsSender = require('./utilsBundleImpl').wsSender;\nexports.wsSender = wsSender;\nconst StackUtils = require('./utilsBundleImpl').StackUtils;\nconst stackUtils = new StackUtils();\nfunction parseStackTraceLine(line) {\n  const frame = stackUtils.parseLine(line);\n  if (!frame) return {\n    frame: null,\n    fileName: null\n  };\n  let fileName = null;\n  if (frame.file) {\n    // ESM files return file:// URLs, see here: https://github.com/tapjs/stack-utils/issues/60\n    fileName = frame.file.startsWith('file://') ? _url.default.fileURLToPath(frame.file) : _path.default.resolve(process.cwd(), frame.file);\n  }\n  return {\n    frame,\n    fileName\n  };\n}\nfunction ms(ms) {\n  if (!isFinite(ms)) return '-';\n  if (ms === 0) return '0ms';\n  if (ms < 1000) return ms.toFixed(0) + 'ms';\n  const seconds = ms / 1000;\n  if (seconds < 60) return seconds.toFixed(1) + 's';\n  const minutes = seconds / 60;\n  if (minutes < 60) return minutes.toFixed(1) + 'm';\n  const hours = minutes / 60;\n  if (hours < 24) return hours.toFixed(1) + 'h';\n  const days = hours / 24;\n  return days.toFixed(1) + 'd';\n}",null,"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.yazl = exports.yauzl = exports.extract = void 0;\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst yazl = require('./zipBundleImpl').yazl;\nexports.yazl = yazl;\nconst yauzl = require('./zipBundleImpl').yauzl;\nexports.yauzl = yauzl;\nconst extract = require('./zipBundleImpl').extract;\nexports.extract = extract;","\"use strict\";var ht=Object.create;var ae=Object.defineProperty;var pt=Object.getOwnPropertyDescriptor;var mt=Object.getOwnPropertyNames;var xt=Object.getPrototypeOf,vt=Object.prototype.hasOwnProperty;var E=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),Et=(e,r)=>{for(var t in r)ae(e,t,{get:r[t],enumerable:!0})},or=(e,r,t,n)=>{if(r&&typeof r==\"object\"||typeof r==\"function\")for(let i of mt(r))!vt.call(e,i)&&i!==t&&ae(e,i,{get:()=>r[i],enumerable:!(n=pt(r,i))||n.enumerable});return e};var Ue=(e,r,t)=>(t=e!=null?ht(xt(e)):{},or(r||!e||!e.__esModule?ae(t,\"default\",{value:e,enumerable:!0}):t,e)),wt=e=>or(ae({},\"__esModule\",{value:!0}),e);var Be=E((An,fr)=>{var T=require(\"buffer\").Buffer,Te=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];typeof Int32Array!=\"undefined\"&&(Te=new Int32Array(Te));function sr(e){if(T.isBuffer(e))return e;var r=typeof T.alloc==\"function\"&&typeof T.from==\"function\";if(typeof e==\"number\")return r?T.alloc(e):new T(e);if(typeof e==\"string\")return r?T.from(e):new T(e);throw new Error(\"input must be buffer, number, or string, received \"+typeof e)}function gt(e){var r=sr(4);return r.writeInt32BE(e,0),r}function Ne(e,r){e=sr(e),T.isBuffer(r)&&(r=r.readUInt32BE(0));for(var t=~~r^-1,n=0;n<e.length;n++)t=Te[(t^e[n])&255]^t>>>8;return t^-1}function Me(){return gt(Ne.apply(null,arguments))}Me.signed=function(){return Ne.apply(null,arguments)};Me.unsigned=function(){return Ne.apply(null,arguments)>>>0};fr.exports=Me});var br=E(Ge=>{var ar=require(\"fs\"),he=require(\"stream\").Transform,ur=require(\"stream\").PassThrough,cr=require(\"zlib\"),We=require(\"util\"),yt=require(\"events\").EventEmitter,dr=Be();Ge.ZipFile=W;Ge.dateToDosDateTime=Cr;We.inherits(W,yt);function W(){this.outputStream=new ur,this.entries=[],this.outputStreamCursor=0,this.ended=!1,this.allDone=!1,this.forceZip64Eocd=!1}W.prototype.addFile=function(e,r,t){var n=this;r=pe(r,!1),t==null&&(t={});var i=new m(r,!1,t);n.entries.push(i),ar.stat(e,function(o,s){if(o)return n.emit(\"error\",o);if(!s.isFile())return n.emit(\"error\",new Error(\"not a file: \"+e));i.uncompressedSize=s.size,t.mtime==null&&i.setLastModDate(s.mtime),t.mode==null&&i.setFileAttributesMode(s.mode),i.setFileDataPumpFunction(function(){var f=ar.createReadStream(e);i.state=m.FILE_DATA_IN_PROGRESS,f.on(\"error\",function(u){n.emit(\"error\",u)}),lr(n,i,f)}),M(n)})};W.prototype.addReadStream=function(e,r,t){var n=this;r=pe(r,!1),t==null&&(t={});var i=new m(r,!1,t);n.entries.push(i),i.setFileDataPumpFunction(function(){i.state=m.FILE_DATA_IN_PROGRESS,lr(n,i,e)}),M(n)};W.prototype.addBuffer=function(e,r,t){var n=this;if(r=pe(r,!1),e.length>1073741823)throw new Error(\"buffer too large: \"+e.length+\" > \"+1073741823);if(t==null&&(t={}),t.size!=null)throw new Error(\"options.size not allowed\");var i=new m(r,!1,t);i.uncompressedSize=e.length,i.crc32=dr.unsigned(e),i.crcAndFileSizeKnown=!0,n.entries.push(i),i.compress?cr.deflateRaw(e,function(s,f){o(f)}):o(e);function o(s){i.compressedSize=s.length,i.setFileDataPumpFunction(function(){Z(n,s),Z(n,i.getDataDescriptor()),i.state=m.FILE_DATA_DONE,setImmediate(function(){M(n)})}),M(n)}};W.prototype.addEmptyDirectory=function(e,r){var t=this;if(e=pe(e,!0),r==null&&(r={}),r.size!=null)throw new Error(\"options.size not allowed\");if(r.compress!=null)throw new Error(\"options.compress not allowed\");var n=new m(e,!0,r);t.entries.push(n),n.setFileDataPumpFunction(function(){Z(t,n.getDataDescriptor()),n.state=m.FILE_DATA_DONE,M(t)}),M(t)};var Ct=N([80,75,5,6]);W.prototype.end=function(e,r){if(typeof e==\"function\"&&(r=e,e=null),e==null&&(e={}),!this.ended){if(this.ended=!0,this.finalSizeCallback=r,this.forceZip64Eocd=!!e.forceZip64Format,e.comment){if(typeof e.comment==\"string\"?this.comment=St(e.comment):this.comment=e.comment,this.comment.length>65535)throw new Error(\"comment is too large\");if(te(this.comment,Ct))throw new Error(\"comment contains end of central directory record signature\")}else this.comment=me;M(this)}};function Z(e,r){e.outputStream.write(r),e.outputStreamCursor+=r.length}function lr(e,r,t){var n=new He,i=new le,o=r.compress?new cr.DeflateRaw:new ur,s=new le;t.pipe(n).pipe(i).pipe(o).pipe(s).pipe(e.outputStream,{end:!1}),s.on(\"end\",function(){if(r.crc32=n.crc32,r.uncompressedSize==null)r.uncompressedSize=i.byteCount;else if(r.uncompressedSize!==i.byteCount)return e.emit(\"error\",new Error(\"file data stream has unexpected number of bytes\"));r.compressedSize=s.byteCount,e.outputStreamCursor+=r.compressedSize,Z(e,r.getDataDescriptor()),r.state=m.FILE_DATA_DONE,M(e)})}function M(e){if(e.allDone)return;if(e.ended&&e.finalSizeCallback!=null){var r=bt(e);r!=null&&(e.finalSizeCallback(r),e.finalSizeCallback=null)}var t=n();function n(){for(var o=0;o<e.entries.length;o++){var s=e.entries[o];if(s.state<m.FILE_DATA_DONE)return s}return null}if(t!=null){if(t.state<m.READY_TO_PUMP_FILE_DATA||t.state===m.FILE_DATA_IN_PROGRESS)return;t.relativeOffsetOfLocalHeader=e.outputStreamCursor;var i=t.getLocalFileHeader();Z(e,i),t.doFileDataPump()}else e.ended&&(e.offsetOfStartOfCentralDirectory=e.outputStreamCursor,e.entries.forEach(function(o){var s=o.getCentralDirectoryRecord();Z(e,s)}),Z(e,Ft(e)),e.outputStream.end(),e.allDone=!0)}function bt(e){for(var r=0,t=0,n=0;n<e.entries.length;n++){var i=e.entries[n];if(i.compress)return-1;if(i.state>=m.READY_TO_PUMP_FILE_DATA){if(i.uncompressedSize==null)return-1}else if(i.uncompressedSize==null)return null;i.relativeOffsetOfLocalHeader=r;var o=i.useZip64Format();r+=hr+i.utf8FileName.length,r+=i.uncompressedSize,i.crcAndFileSizeKnown||(o?r+=gr:r+=wr),t+=yr+i.utf8FileName.length+i.fileComment.length,o&&(t+=Pe)}var s=0;return(e.forceZip64Eocd||e.entries.length>=65535||t>=65535||r>=4294967295)&&(s+=ce+qe),s+=de+e.comment.length,r+t+s}var ce=56,qe=20,de=22;function Ft(e,r){var t=!1,n=e.entries.length;(e.forceZip64Eocd||e.entries.length>=65535)&&(n=65535,t=!0);var i=e.outputStreamCursor-e.offsetOfStartOfCentralDirectory,o=i;(e.forceZip64Eocd||i>=4294967295)&&(o=4294967295,t=!0);var s=e.offsetOfStartOfCentralDirectory;if((e.forceZip64Eocd||e.offsetOfStartOfCentralDirectory>=4294967295)&&(s=4294967295,t=!0),r)return t?ce+qe+de:de;var f=F(de+e.comment.length);if(f.writeUInt32LE(101010256,0),f.writeUInt16LE(0,4),f.writeUInt16LE(0,6),f.writeUInt16LE(n,8),f.writeUInt16LE(n,10),f.writeUInt32LE(o,12),f.writeUInt32LE(s,16),f.writeUInt16LE(e.comment.length,20),e.comment.copy(f,22),!t)return f;var u=F(ce);u.writeUInt32LE(101075792,0),I(u,ce-12,4),u.writeUInt16LE(xr,12),u.writeUInt16LE(mr,14),u.writeUInt32LE(0,16),u.writeUInt32LE(0,20),I(u,e.entries.length,24),I(u,e.entries.length,32),I(u,i,40),I(u,e.offsetOfStartOfCentralDirectory,48);var d=F(qe);return d.writeUInt32LE(117853008,0),d.writeUInt32LE(0,4),I(d,e.outputStreamCursor,8),d.writeUInt32LE(1,16),Buffer.concat([u,d,f])}function pe(e,r){if(e===\"\")throw new Error(\"empty metadataPath\");if(e=e.replace(/\\\\/g,\"/\"),/^[a-zA-Z]:/.test(e)||/^\\//.test(e))throw new Error(\"absolute path: \"+e);if(e.split(\"/\").indexOf(\"..\")!==-1)throw new Error(\"invalid relative path: \"+e);var t=/\\/$/.test(e);if(r)t||(e+=\"/\");else if(t)throw new Error(\"file path cannot end with '/': \"+e);return e}var me=F(0);function m(e,r,t){if(this.utf8FileName=N(e),this.utf8FileName.length>65535)throw new Error(\"utf8 file name too long. \"+utf8FileName.length+\" > \"+65535);if(this.isDirectory=r,this.state=m.WAITING_FOR_METADATA,this.setLastModDate(t.mtime!=null?t.mtime:new Date),t.mode!=null?this.setFileAttributesMode(t.mode):this.setFileAttributesMode(r?16893:33204),r?(this.crcAndFileSizeKnown=!0,this.crc32=0,this.uncompressedSize=0,this.compressedSize=0):(this.crcAndFileSizeKnown=!1,this.crc32=null,this.uncompressedSize=null,this.compressedSize=null,t.size!=null&&(this.uncompressedSize=t.size)),r?this.compress=!1:(this.compress=!0,t.compress!=null&&(this.compress=!!t.compress)),this.forceZip64Format=!!t.forceZip64Format,t.fileComment){if(typeof t.fileComment==\"string\"?this.fileComment=N(t.fileComment,\"utf-8\"):this.fileComment=t.fileComment,this.fileComment.length>65535)throw new Error(\"fileComment is too large\")}else this.fileComment=me}m.WAITING_FOR_METADATA=0;m.READY_TO_PUMP_FILE_DATA=1;m.FILE_DATA_IN_PROGRESS=2;m.FILE_DATA_DONE=3;m.prototype.setLastModDate=function(e){var r=Cr(e);this.lastModFileTime=r.time,this.lastModFileDate=r.date};m.prototype.setFileAttributesMode=function(e){if((e&65535)!==e)throw new Error(\"invalid mode. expected: 0 <= \"+e+\" <= \"+65535);this.externalFileAttributes=e<<16>>>0};m.prototype.setFileDataPumpFunction=function(e){this.doFileDataPump=e,this.state=m.READY_TO_PUMP_FILE_DATA};m.prototype.useZip64Format=function(){return this.forceZip64Format||this.uncompressedSize!=null&&this.uncompressedSize>4294967294||this.compressedSize!=null&&this.compressedSize>4294967294||this.relativeOffsetOfLocalHeader!=null&&this.relativeOffsetOfLocalHeader>4294967294};var hr=30,pr=20,mr=45,xr=3<<8|63,vr=1<<11,Er=1<<3;m.prototype.getLocalFileHeader=function(){var e=0,r=0,t=0;this.crcAndFileSizeKnown&&(e=this.crc32,r=this.compressedSize,t=this.uncompressedSize);var n=F(hr),i=vr;return this.crcAndFileSizeKnown||(i|=Er),n.writeUInt32LE(67324752,0),n.writeUInt16LE(pr,4),n.writeUInt16LE(i,6),n.writeUInt16LE(this.getCompressionMethod(),8),n.writeUInt16LE(this.lastModFileTime,10),n.writeUInt16LE(this.lastModFileDate,12),n.writeUInt32LE(e,14),n.writeUInt32LE(r,18),n.writeUInt32LE(t,22),n.writeUInt16LE(this.utf8FileName.length,26),n.writeUInt16LE(0,28),Buffer.concat([n,this.utf8FileName])};var wr=16,gr=24;m.prototype.getDataDescriptor=function(){if(this.crcAndFileSizeKnown)return me;if(this.useZip64Format()){var e=F(gr);return e.writeUInt32LE(134695760,0),e.writeUInt32LE(this.crc32,4),I(e,this.compressedSize,8),I(e,this.uncompressedSize,16),e}else{var e=F(wr);return e.writeUInt32LE(134695760,0),e.writeUInt32LE(this.crc32,4),e.writeUInt32LE(this.compressedSize,8),e.writeUInt32LE(this.uncompressedSize,12),e}};var yr=46,Pe=28;m.prototype.getCentralDirectoryRecord=function(){var e=F(yr),r=vr;this.crcAndFileSizeKnown||(r|=Er);var t=this.compressedSize,n=this.uncompressedSize,i=this.relativeOffsetOfLocalHeader,o,s;return this.useZip64Format()?(t=4294967295,n=4294967295,i=4294967295,o=mr,s=F(Pe),s.writeUInt16LE(1,0),s.writeUInt16LE(Pe-4,2),I(s,this.uncompressedSize,4),I(s,this.compressedSize,12),I(s,this.relativeOffsetOfLocalHeader,20)):(o=pr,s=me),e.writeUInt32LE(33639248,0),e.writeUInt16LE(xr,4),e.writeUInt16LE(o,6),e.writeUInt16LE(r,8),e.writeUInt16LE(this.getCompressionMethod(),10),e.writeUInt16LE(this.lastModFileTime,12),e.writeUInt16LE(this.lastModFileDate,14),e.writeUInt32LE(this.crc32,16),e.writeUInt32LE(t,20),e.writeUInt32LE(n,24),e.writeUInt16LE(this.utf8FileName.length,28),e.writeUInt16LE(s.length,30),e.writeUInt16LE(this.fileComment.length,32),e.writeUInt16LE(0,34),e.writeUInt16LE(0,36),e.writeUInt32LE(this.externalFileAttributes,38),e.writeUInt32LE(i,42),Buffer.concat([e,this.utf8FileName,s,this.fileComment])};m.prototype.getCompressionMethod=function(){var e=0,r=8;return this.compress?r:e};function Cr(e){var r=0;r|=e.getDate()&31,r|=(e.getMonth()+1&15)<<5,r|=(e.getFullYear()-1980&127)<<9;var t=0;return t|=Math.floor(e.getSeconds()/2),t|=(e.getMinutes()&63)<<5,t|=(e.getHours()&31)<<11,{date:r,time:t}}function I(e,r,t){var n=Math.floor(r/4294967296),i=r%4294967296;e.writeUInt32LE(i,t),e.writeUInt32LE(n,t+4)}We.inherits(le,he);function le(e){he.call(this,e),this.byteCount=0}le.prototype._transform=function(e,r,t){this.byteCount+=e.length,t(null,e)};We.inherits(He,he);function He(e){he.call(this,e),this.crc32=0}He.prototype._transform=function(e,r,t){this.crc32=dr.unsigned(e,this.crc32),t(null,e)};var Ze=\"\\0\\u263A\\u263B\\u2665\\u2666\\u2663\\u2660\\u2022\\u25D8\\u25CB\\u25D9\\u2642\\u2640\\u266A\\u266B\\u263C\\u25BA\\u25C4\\u2195\\u203C\\xB6\\xA7\\u25AC\\u21A8\\u2191\\u2193\\u2192\\u2190\\u221F\\u2194\\u25B2\\u25BC !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\u2302\\xC7\\xFC\\xE9\\xE2\\xE4\\xE0\\xE5\\xE7\\xEA\\xEB\\xE8\\xEF\\xEE\\xEC\\xC4\\xC5\\xC9\\xE6\\xC6\\xF4\\xF6\\xF2\\xFB\\xF9\\xFF\\xD6\\xDC\\xA2\\xA3\\xA5\\u20A7\\u0192\\xE1\\xED\\xF3\\xFA\\xF1\\xD1\\xAA\\xBA\\xBF\\u2310\\xAC\\xBD\\xBC\\xA1\\xAB\\xBB\\u2591\\u2592\\u2593\\u2502\\u2524\\u2561\\u2562\\u2556\\u2555\\u2563\\u2551\\u2557\\u255D\\u255C\\u255B\\u2510\\u2514\\u2534\\u252C\\u251C\\u2500\\u253C\\u255E\\u255F\\u255A\\u2554\\u2569\\u2566\\u2560\\u2550\\u256C\\u2567\\u2568\\u2564\\u2565\\u2559\\u2558\\u2552\\u2553\\u256B\\u256A\\u2518\\u250C\\u2588\\u2584\\u258C\\u2590\\u2580\\u03B1\\xDF\\u0393\\u03C0\\u03A3\\u03C3\\xB5\\u03C4\\u03A6\\u0398\\u03A9\\u03B4\\u221E\\u03C6\\u03B5\\u2229\\u2261\\xB1\\u2265\\u2264\\u2320\\u2321\\xF7\\u2248\\xB0\\u2219\\xB7\\u221A\\u207F\\xB2\\u25A0\\xA0\";if(Ze.length!==256)throw new Error(\"assertion failure\");var ue=null;function St(e){if(/^[\\x20-\\x7e]*$/.test(e))return N(e,\"utf-8\");if(ue==null){ue={};for(var r=0;r<Ze.length;r++)ue[Ze[r]]=r}for(var t=F(e.length),r=0;r<e.length;r++){var n=ue[e[r]];if(n==null)throw new Error(\"character not encodable in CP437: \"+JSON.stringify(e[r]));t[r]=n}return t}function F(e){F=r;try{return F(e)}catch{return F=t,F(e)}function r(n){return Buffer.allocUnsafe(n)}function t(n){return new Buffer(n)}}function N(e,r){N=t;try{return N(e,r)}catch{return N=n,N(e,r)}function t(i,o){return Buffer.from(i,o)}function n(i,o){return new Buffer(i,o)}}function te(e,r){te=t;try{return te(e,r)}catch{return te=n,te(e,r)}function t(i,o){return i.includes(o)}function n(i,o){for(var s=0;s<=i.length-o.length;s++)for(var f=0;;f++){if(f===o.length)return!0;if(i[s+f]!==o[f])break}return!1}}});var Lr=E((Dn,Ir)=>{Ir.exports=xe;function xe(){this.pending=0,this.max=1/0,this.listeners=[],this.waiting=[],this.error=null}xe.prototype.go=function(e){this.pending<this.max?Sr(this,e):this.waiting.push(e)};xe.prototype.wait=function(e){this.pending===0?e(this.error):this.listeners.push(e)};xe.prototype.hold=function(){return Fr(this)};function Fr(e){e.pending+=1;var r=!1;return t;function t(i){if(r)throw new Error(\"callback called twice\");if(r=!0,e.error=e.error||i,e.pending-=1,e.waiting.length>0&&e.pending<e.max)Sr(e,e.waiting.shift());else if(e.pending===0){var o=e.listeners;e.listeners=[],o.forEach(n)}}function n(i){i(e.error)}}function Sr(e,r){r(Fr(e))}});var zr=E(ie=>{var ne=require(\"fs\"),ve=require(\"util\"),Ye=require(\"stream\"),Or=Ye.Readable,$e=Ye.Writable,It=Ye.PassThrough,Lt=Lr(),Ee=require(\"events\").EventEmitter;ie.createFromBuffer=Ot;ie.createFromFd=zt;ie.BufferSlicer=D;ie.FdSlicer=R;ve.inherits(R,Ee);function R(e,r){r=r||{},Ee.call(this),this.fd=e,this.pend=new Lt,this.pend.max=1,this.refCount=0,this.autoClose=!!r.autoClose}R.prototype.read=function(e,r,t,n,i){var o=this;o.pend.go(function(s){ne.read(o.fd,e,r,t,n,function(f,u,d){s(),i(f,u,d)})})};R.prototype.write=function(e,r,t,n,i){var o=this;o.pend.go(function(s){ne.write(o.fd,e,r,t,n,function(f,u,d){s(),i(f,u,d)})})};R.prototype.createReadStream=function(e){return new we(this,e)};R.prototype.createWriteStream=function(e){return new ge(this,e)};R.prototype.ref=function(){this.refCount+=1};R.prototype.unref=function(){var e=this;if(e.refCount-=1,e.refCount>0)return;if(e.refCount<0)throw new Error(\"invalid unref\");e.autoClose&&ne.close(e.fd,r);function r(t){t?e.emit(\"error\",t):e.emit(\"close\")}};ve.inherits(we,Or);function we(e,r){r=r||{},Or.call(this,r),this.context=e,this.context.ref(),this.start=r.start||0,this.endOffset=r.end,this.pos=this.start,this.destroyed=!1}we.prototype._read=function(e){var r=this;if(!r.destroyed){var t=Math.min(r._readableState.highWaterMark,e);if(r.endOffset!=null&&(t=Math.min(t,r.endOffset-r.pos)),t<=0){r.destroyed=!0,r.push(null),r.context.unref();return}r.context.pend.go(function(n){if(r.destroyed)return n();var i=Buffer.alloc(t);ne.read(r.context.fd,i,0,t,r.pos,function(o,s){o?r.destroy(o):s===0?(r.destroyed=!0,r.push(null),r.context.unref()):(r.pos+=s,r.push(i.slice(0,s))),n()})})}};we.prototype.destroy=function(e){this.destroyed||(e=e||new Error(\"stream destroyed\"),this.destroyed=!0,this.emit(\"error\",e),this.context.unref())};ve.inherits(ge,$e);function ge(e,r){r=r||{},$e.call(this,r),this.context=e,this.context.ref(),this.start=r.start||0,this.endOffset=r.end==null?1/0:+r.end,this.bytesWritten=0,this.pos=this.start,this.destroyed=!1,this.on(\"finish\",this.destroy.bind(this))}ge.prototype._write=function(e,r,t){var n=this;if(!n.destroyed){if(n.pos+e.length>n.endOffset){var i=new Error(\"maximum file length exceeded\");i.code=\"ETOOBIG\",n.destroy(),t(i);return}n.context.pend.go(function(o){if(n.destroyed)return o();ne.write(n.context.fd,e,0,e.length,n.pos,function(s,f){s?(n.destroy(),o(),t(s)):(n.bytesWritten+=f,n.pos+=f,n.emit(\"progress\"),o(),t())})})}};ge.prototype.destroy=function(){this.destroyed||(this.destroyed=!0,this.context.unref())};ve.inherits(D,Ee);function D(e,r){Ee.call(this),r=r||{},this.refCount=0,this.buffer=e,this.maxChunkSize=r.maxChunkSize||Number.MAX_SAFE_INTEGER}D.prototype.read=function(e,r,t,n,i){var o=n+t,s=o-this.buffer.length,f=s>0?s:t;this.buffer.copy(e,r,n,o),setImmediate(function(){i(null,f)})};D.prototype.write=function(e,r,t,n,i){e.copy(this.buffer,n,r,r+t),setImmediate(function(){i(null,t,e)})};D.prototype.createReadStream=function(e){e=e||{};var r=new It(e);r.destroyed=!1,r.start=e.start||0,r.endOffset=e.end,r.pos=r.endOffset||this.buffer.length;for(var t=this.buffer.slice(r.start,r.pos),n=0;;){var i=n+this.maxChunkSize;if(i>=t.length){n<t.length&&r.write(t.slice(n,t.length));break}r.write(t.slice(n,i)),n=i}return r.end(),r.destroy=function(){r.destroyed=!0},r};D.prototype.createWriteStream=function(e){var r=this;e=e||{};var t=new $e(e);return t.start=e.start||0,t.endOffset=e.end==null?this.buffer.length:+e.end,t.bytesWritten=0,t.pos=t.start,t.destroyed=!1,t._write=function(n,i,o){if(!t.destroyed){var s=t.pos+n.length;if(s>t.endOffset){var f=new Error(\"maximum file length exceeded\");f.code=\"ETOOBIG\",t.destroyed=!0,o(f);return}n.copy(r.buffer,t.pos,0,n.length),t.bytesWritten+=n.length,t.pos=s,t.emit(\"progress\"),o()}},t.destroy=function(){t.destroyed=!0},t};D.prototype.ref=function(){this.refCount+=1};D.prototype.unref=function(){if(this.refCount-=1,this.refCount<0)throw new Error(\"invalid unref\")};function Ot(e,r){return new D(e,r)}function zt(e,r){return new R(e,r)}});var Xe=E(A=>{var je=require(\"fs\"),_t=require(\"zlib\"),_r=zr(),At=Be(),be=require(\"util\"),Fe=require(\"events\").EventEmitter,Ar=require(\"stream\").Transform,Ve=require(\"stream\").PassThrough,Rt=require(\"stream\").Writable;A.open=Dt;A.fromFd=Rr;A.fromBuffer=Ut;A.fromRandomAccessReader=Ke;A.dosDateTimeToDate=Ur;A.validateFileName=Tr;A.ZipFile=B;A.Entry=oe;A.RandomAccessReader=q;function Dt(e,r,t){typeof r==\"function\"&&(t=r,r=null),r==null&&(r={}),r.autoClose==null&&(r.autoClose=!0),r.lazyEntries==null&&(r.lazyEntries=!1),r.decodeStrings==null&&(r.decodeStrings=!0),r.validateEntrySizes==null&&(r.validateEntrySizes=!0),r.strictFileNames==null&&(r.strictFileNames=!1),t==null&&(t=Ce),je.open(e,\"r\",function(n,i){if(n)return t(n);Rr(i,r,function(o,s){o&&je.close(i,Ce),t(o,s)})})}function Rr(e,r,t){typeof r==\"function\"&&(t=r,r=null),r==null&&(r={}),r.autoClose==null&&(r.autoClose=!1),r.lazyEntries==null&&(r.lazyEntries=!1),r.decodeStrings==null&&(r.decodeStrings=!0),r.validateEntrySizes==null&&(r.validateEntrySizes=!0),r.strictFileNames==null&&(r.strictFileNames=!1),t==null&&(t=Ce),je.fstat(e,function(n,i){if(n)return t(n);var o=_r.createFromFd(e,{autoClose:!0});Ke(o,i.size,r,t)})}function Ut(e,r,t){typeof r==\"function\"&&(t=r,r=null),r==null&&(r={}),r.autoClose=!1,r.lazyEntries==null&&(r.lazyEntries=!1),r.decodeStrings==null&&(r.decodeStrings=!0),r.validateEntrySizes==null&&(r.validateEntrySizes=!0),r.strictFileNames==null&&(r.strictFileNames=!1);var n=_r.createFromBuffer(e,{maxChunkSize:65536});Ke(n,e.length,r,t)}function Ke(e,r,t,n){typeof t==\"function\"&&(n=t,t=null),t==null&&(t={}),t.autoClose==null&&(t.autoClose=!0),t.lazyEntries==null&&(t.lazyEntries=!1),t.decodeStrings==null&&(t.decodeStrings=!0);var i=!!t.decodeStrings;if(t.validateEntrySizes==null&&(t.validateEntrySizes=!0),t.strictFileNames==null&&(t.strictFileNames=!1),n==null&&(n=Ce),typeof r!=\"number\")throw new Error(\"expected totalSize parameter to be a number\");if(r>Number.MAX_SAFE_INTEGER)throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");e.ref();var o=22,s=65535,f=Math.min(o+s,r),u=_(f),d=r-u.length;$(e,u,0,f,d,function(a){if(a)return n(a);for(var c=f-o;c>=0;c-=1)if(u.readUInt32LE(c)===101010256){var l=u.slice(c),x=l.readUInt16LE(4);if(x!==0)return n(new Error(\"multi-disk zip files are not supported: found disk number: \"+x));var g=l.readUInt16LE(10),p=l.readUInt32LE(16),h=l.readUInt16LE(20),v=l.length-o;if(h!==v)return n(new Error(\"invalid comment length. expected: \"+v+\". found: \"+h));var w=i?ye(l,22,l.length,!1):l.slice(22);if(!(g===65535||p===4294967295))return n(null,new B(e,p,r,g,w,t.autoClose,t.lazyEntries,i,t.validateEntrySizes,t.strictFileNames));var b=_(20),U=d+c-b.length;$(e,b,0,b.length,U,function(Y){if(Y)return n(Y);if(b.readUInt32LE(0)!==117853008)return n(new Error(\"invalid zip64 end of central directory locator signature\"));var ee=j(b,8),P=_(56);$(e,P,0,P.length,ee,function(re){return re?n(re):P.readUInt32LE(0)!==101075792?n(new Error(\"invalid zip64 end of central directory record signature\")):(g=j(P,32),p=j(P,48),n(null,new B(e,p,r,g,w,t.autoClose,t.lazyEntries,i,t.validateEntrySizes,t.strictFileNames)))})});return}n(new Error(\"end of central directory record signature not found\"))})}be.inherits(B,Fe);function B(e,r,t,n,i,o,s,f,u,d){var a=this;Fe.call(a),a.reader=e,a.reader.on(\"error\",function(c){Dr(a,c)}),a.reader.once(\"close\",function(){a.emit(\"close\")}),a.readEntryCursor=r,a.fileSize=t,a.entryCount=n,a.comment=i,a.entriesRead=0,a.autoClose=!!o,a.lazyEntries=!!s,a.decodeStrings=!!f,a.validateEntrySizes=!!u,a.strictFileNames=!!d,a.isOpen=!0,a.emittedError=!1,a.lazyEntries||a._readEntry()}B.prototype.close=function(){!this.isOpen||(this.isOpen=!1,this.reader.unref())};function L(e,r){e.autoClose&&e.close(),Dr(e,r)}function Dr(e,r){e.emittedError||(e.emittedError=!0,e.emit(\"error\",r))}B.prototype.readEntry=function(){if(!this.lazyEntries)throw new Error(\"readEntry() called without lazyEntries:true\");this._readEntry()};B.prototype._readEntry=function(){var e=this;if(e.entryCount===e.entriesRead){setImmediate(function(){e.autoClose&&e.close(),!e.emittedError&&e.emit(\"end\")});return}if(!e.emittedError){var r=_(46);$(e.reader,r,0,r.length,e.readEntryCursor,function(t){if(t)return L(e,t);if(!e.emittedError){var n=new oe,i=r.readUInt32LE(0);if(i!==33639248)return L(e,new Error(\"invalid central directory file header signature: 0x\"+i.toString(16)));if(n.versionMadeBy=r.readUInt16LE(4),n.versionNeededToExtract=r.readUInt16LE(6),n.generalPurposeBitFlag=r.readUInt16LE(8),n.compressionMethod=r.readUInt16LE(10),n.lastModFileTime=r.readUInt16LE(12),n.lastModFileDate=r.readUInt16LE(14),n.crc32=r.readUInt32LE(16),n.compressedSize=r.readUInt32LE(20),n.uncompressedSize=r.readUInt32LE(24),n.fileNameLength=r.readUInt16LE(28),n.extraFieldLength=r.readUInt16LE(30),n.fileCommentLength=r.readUInt16LE(32),n.internalFileAttributes=r.readUInt16LE(36),n.externalFileAttributes=r.readUInt32LE(38),n.relativeOffsetOfLocalHeader=r.readUInt32LE(42),n.generalPurposeBitFlag&64)return L(e,new Error(\"strong encryption is not supported\"));e.readEntryCursor+=46,r=_(n.fileNameLength+n.extraFieldLength+n.fileCommentLength),$(e.reader,r,0,r.length,e.readEntryCursor,function(o){if(o)return L(e,o);if(!e.emittedError){var s=(n.generalPurposeBitFlag&2048)!==0;n.fileName=e.decodeStrings?ye(r,0,n.fileNameLength,s):r.slice(0,n.fileNameLength);var f=n.fileNameLength+n.extraFieldLength,u=r.slice(n.fileNameLength,f);n.extraFields=[];for(var d=0;d<u.length-3;){var a=u.readUInt16LE(d+0),c=u.readUInt16LE(d+2),l=d+4,x=l+c;if(x>u.length)return L(e,new Error(\"extra field length exceeds extra field buffer size\"));var g=_(c);u.copy(g,0,l,x),n.extraFields.push({id:a,data:g}),d=x}if(n.fileComment=e.decodeStrings?ye(r,f,f+n.fileCommentLength,s):r.slice(f,f+n.fileCommentLength),n.comment=n.fileComment,e.readEntryCursor+=r.length,e.entriesRead+=1,n.uncompressedSize===4294967295||n.compressedSize===4294967295||n.relativeOffsetOfLocalHeader===4294967295){for(var p=null,d=0;d<n.extraFields.length;d++){var h=n.extraFields[d];if(h.id===1){p=h.data;break}}if(p==null)return L(e,new Error(\"expected zip64 extended information extra field\"));var v=0;if(n.uncompressedSize===4294967295){if(v+8>p.length)return L(e,new Error(\"zip64 extended information extra field does not include uncompressed size\"));n.uncompressedSize=j(p,v),v+=8}if(n.compressedSize===4294967295){if(v+8>p.length)return L(e,new Error(\"zip64 extended information extra field does not include compressed size\"));n.compressedSize=j(p,v),v+=8}if(n.relativeOffsetOfLocalHeader===4294967295){if(v+8>p.length)return L(e,new Error(\"zip64 extended information extra field does not include relative header offset\"));n.relativeOffsetOfLocalHeader=j(p,v),v+=8}}if(e.decodeStrings)for(var d=0;d<n.extraFields.length;d++){var h=n.extraFields[d];if(h.id===28789){if(h.data.length<6||h.data.readUInt8(0)!==1)continue;var w=h.data.readUInt32LE(1);if(At.unsigned(r.slice(0,n.fileNameLength))!==w)continue;n.fileName=ye(h.data,5,h.data.length,!0);break}}if(e.validateEntrySizes&&n.compressionMethod===0){var b=n.uncompressedSize;if(n.isEncrypted()&&(b+=12),n.compressedSize!==b){var U=\"compressed/uncompressed size mismatch for stored file: \"+n.compressedSize+\" != \"+n.uncompressedSize;return L(e,new Error(U))}}if(e.decodeStrings){e.strictFileNames||(n.fileName=n.fileName.replace(/\\\\/g,\"/\"));var Y=Tr(n.fileName,e.validateFileNameOptions);if(Y!=null)return L(e,new Error(Y))}e.emit(\"entry\",n),e.lazyEntries||e._readEntry()}})}})}};B.prototype.openReadStream=function(e,r,t){var n=this,i=0,o=e.compressedSize;if(t==null)t=r,r={};else{if(r.decrypt!=null){if(!e.isEncrypted())throw new Error(\"options.decrypt can only be specified for encrypted entries\");if(r.decrypt!==!1)throw new Error(\"invalid options.decrypt value: \"+r.decrypt);if(e.isCompressed()&&r.decompress!==!1)throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\")}if(r.decompress!=null){if(!e.isCompressed())throw new Error(\"options.decompress can only be specified for compressed entries\");if(!(r.decompress===!1||r.decompress===!0))throw new Error(\"invalid options.decompress value: \"+r.decompress)}if(r.start!=null||r.end!=null){if(e.isCompressed()&&r.decompress!==!1)throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");if(e.isEncrypted()&&r.decrypt!==!1)throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\")}if(r.start!=null){if(i=r.start,i<0)throw new Error(\"options.start < 0\");if(i>e.compressedSize)throw new Error(\"options.start > entry.compressedSize\")}if(r.end!=null){if(o=r.end,o<0)throw new Error(\"options.end < 0\");if(o>e.compressedSize)throw new Error(\"options.end > entry.compressedSize\");if(o<i)throw new Error(\"options.end < options.start\")}}if(!n.isOpen)return t(new Error(\"closed\"));if(e.isEncrypted()&&r.decrypt!==!1)return t(new Error(\"entry is encrypted, and options.decrypt !== false\"));n.reader.ref();var s=_(30);$(n.reader,s,0,s.length,e.relativeOffsetOfLocalHeader,function(f){try{if(f)return t(f);var u=s.readUInt32LE(0);if(u!==67324752)return t(new Error(\"invalid local file header signature: 0x\"+u.toString(16)));var d=s.readUInt16LE(26),a=s.readUInt16LE(28),c=e.relativeOffsetOfLocalHeader+s.length+d+a,l;if(e.compressionMethod===0)l=!1;else if(e.compressionMethod===8)l=r.decompress!=null?r.decompress:!0;else return t(new Error(\"unsupported compression method: \"+e.compressionMethod));var x=c,g=x+e.compressedSize;if(e.compressedSize!==0&&g>n.fileSize)return t(new Error(\"file data overflows file bounds: \"+x+\" + \"+e.compressedSize+\" > \"+n.fileSize));var p=n.reader.createReadStream({start:x+i,end:x+o}),h=p;if(l){var v=!1,w=_t.createInflateRaw();p.on(\"error\",function(b){setImmediate(function(){v||w.emit(\"error\",b)})}),p.pipe(w),n.validateEntrySizes?(h=new se(e.uncompressedSize),w.on(\"error\",function(b){setImmediate(function(){v||h.emit(\"error\",b)})}),w.pipe(h)):h=w,h.destroy=function(){v=!0,w!==h&&w.unpipe(h),p.unpipe(w),p.destroy()}}t(null,h)}finally{n.reader.unref()}})};function oe(){}oe.prototype.getLastModDate=function(){return Ur(this.lastModFileDate,this.lastModFileTime)};oe.prototype.isEncrypted=function(){return(this.generalPurposeBitFlag&1)!==0};oe.prototype.isCompressed=function(){return this.compressionMethod===8};function Ur(e,r){var t=e&31,n=(e>>5&15)-1,i=(e>>9&127)+1980,o=0,s=(r&31)*2,f=r>>5&63,u=r>>11&31;return new Date(i,n,t,u,f,s,o)}function Tr(e){return e.indexOf(\"\\\\\")!==-1?\"invalid characters in fileName: \"+e:/^[a-zA-Z]:/.test(e)||/^\\//.test(e)?\"absolute path: \"+e:e.split(\"/\").indexOf(\"..\")!==-1?\"invalid relative path: \"+e:null}function $(e,r,t,n,i,o){if(n===0)return setImmediate(function(){o(null,_(0))});e.read(r,t,n,i,function(s,f){if(s)return o(s);if(f<n)return o(new Error(\"unexpected EOF\"));o()})}be.inherits(se,Ar);function se(e){Ar.call(this),this.actualByteCount=0,this.expectedByteCount=e}se.prototype._transform=function(e,r,t){if(this.actualByteCount+=e.length,this.actualByteCount>this.expectedByteCount){var n=\"too many bytes in the stream. expected \"+this.expectedByteCount+\". got at least \"+this.actualByteCount;return t(new Error(n))}t(null,e)};se.prototype._flush=function(e){if(this.actualByteCount<this.expectedByteCount){var r=\"not enough bytes in the stream. expected \"+this.expectedByteCount+\". got only \"+this.actualByteCount;return e(new Error(r))}e()};be.inherits(q,Fe);function q(){Fe.call(this),this.refCount=0}q.prototype.ref=function(){this.refCount+=1};q.prototype.unref=function(){var e=this;if(e.refCount-=1,e.refCount>0)return;if(e.refCount<0)throw new Error(\"invalid unref\");e.close(r);function r(t){if(t)return e.emit(\"error\",t);e.emit(\"close\")}};q.prototype.createReadStream=function(e){var r=e.start,t=e.end;if(r===t){var n=new Ve;return setImmediate(function(){n.end()}),n}var i=this._readStreamForRange(r,t),o=!1,s=new Se(this);i.on(\"error\",function(u){setImmediate(function(){o||s.emit(\"error\",u)})}),s.destroy=function(){i.unpipe(s),s.unref(),i.destroy()};var f=new se(t-r);return s.on(\"error\",function(u){setImmediate(function(){o||f.emit(\"error\",u)})}),f.destroy=function(){o=!0,s.unpipe(f),s.destroy()},i.pipe(s).pipe(f)};q.prototype._readStreamForRange=function(e,r){throw new Error(\"not implemented\")};q.prototype.read=function(e,r,t,n,i){var o=this.createReadStream({start:n,end:n+t}),s=new Rt,f=0;s._write=function(u,d,a){u.copy(e,r+f,0,u.length),f+=u.length,a()},s.on(\"finish\",i),o.on(\"error\",function(u){i(u)}),o.pipe(s)};q.prototype.close=function(e){setImmediate(e)};be.inherits(Se,Ve);function Se(e){Ve.call(this),this.context=e,this.context.ref(),this.unreffedYet=!1}Se.prototype._flush=function(e){this.unref(),e()};Se.prototype.unref=function(e){this.unreffedYet||(this.unreffedYet=!0,this.context.unref())};var Tt=\"\\0\\u263A\\u263B\\u2665\\u2666\\u2663\\u2660\\u2022\\u25D8\\u25CB\\u25D9\\u2642\\u2640\\u266A\\u266B\\u263C\\u25BA\\u25C4\\u2195\\u203C\\xB6\\xA7\\u25AC\\u21A8\\u2191\\u2193\\u2192\\u2190\\u221F\\u2194\\u25B2\\u25BC !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\u2302\\xC7\\xFC\\xE9\\xE2\\xE4\\xE0\\xE5\\xE7\\xEA\\xEB\\xE8\\xEF\\xEE\\xEC\\xC4\\xC5\\xC9\\xE6\\xC6\\xF4\\xF6\\xF2\\xFB\\xF9\\xFF\\xD6\\xDC\\xA2\\xA3\\xA5\\u20A7\\u0192\\xE1\\xED\\xF3\\xFA\\xF1\\xD1\\xAA\\xBA\\xBF\\u2310\\xAC\\xBD\\xBC\\xA1\\xAB\\xBB\\u2591\\u2592\\u2593\\u2502\\u2524\\u2561\\u2562\\u2556\\u2555\\u2563\\u2551\\u2557\\u255D\\u255C\\u255B\\u2510\\u2514\\u2534\\u252C\\u251C\\u2500\\u253C\\u255E\\u255F\\u255A\\u2554\\u2569\\u2566\\u2560\\u2550\\u256C\\u2567\\u2568\\u2564\\u2565\\u2559\\u2558\\u2552\\u2553\\u256B\\u256A\\u2518\\u250C\\u2588\\u2584\\u258C\\u2590\\u2580\\u03B1\\xDF\\u0393\\u03C0\\u03A3\\u03C3\\xB5\\u03C4\\u03A6\\u0398\\u03A9\\u03B4\\u221E\\u03C6\\u03B5\\u2229\\u2261\\xB1\\u2265\\u2264\\u2320\\u2321\\xF7\\u2248\\xB0\\u2219\\xB7\\u221A\\u207F\\xB2\\u25A0\\xA0\";function ye(e,r,t,n){if(n)return e.toString(\"utf8\",r,t);for(var i=\"\",o=r;o<t;o++)i+=Tt[e[o]];return i}function j(e,r){var t=e.readUInt32LE(r),n=e.readUInt32LE(r+4);return n*4294967296+t}var _;typeof Buffer.allocUnsafe==\"function\"?_=function(e){return Buffer.allocUnsafe(e)}:_=function(e){return new Buffer(e)};function Ce(e){if(e)throw e}});var Mr=E((Nn,Nr)=>{var V=1e3,K=V*60,X=K*60,H=X*24,Nt=H*7,Mt=H*365.25;Nr.exports=function(e,r){r=r||{};var t=typeof e;if(t===\"string\"&&e.length>0)return Bt(e);if(t===\"number\"&&isFinite(e))return r.long?Pt(e):qt(e);throw new Error(\"val is not a non-empty string or a valid number. val=\"+JSON.stringify(e))};function Bt(e){if(e=String(e),!(e.length>100)){var r=/^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!!r){var t=parseFloat(r[1]),n=(r[2]||\"ms\").toLowerCase();switch(n){case\"years\":case\"year\":case\"yrs\":case\"yr\":case\"y\":return t*Mt;case\"weeks\":case\"week\":case\"w\":return t*Nt;case\"days\":case\"day\":case\"d\":return t*H;case\"hours\":case\"hour\":case\"hrs\":case\"hr\":case\"h\":return t*X;case\"minutes\":case\"minute\":case\"mins\":case\"min\":case\"m\":return t*K;case\"seconds\":case\"second\":case\"secs\":case\"sec\":case\"s\":return t*V;case\"milliseconds\":case\"millisecond\":case\"msecs\":case\"msec\":case\"ms\":return t;default:return}}}}function qt(e){var r=Math.abs(e);return r>=H?Math.round(e/H)+\"d\":r>=X?Math.round(e/X)+\"h\":r>=K?Math.round(e/K)+\"m\":r>=V?Math.round(e/V)+\"s\":e+\"ms\"}function Pt(e){var r=Math.abs(e);return r>=H?Ie(e,r,H,\"day\"):r>=X?Ie(e,r,X,\"hour\"):r>=K?Ie(e,r,K,\"minute\"):r>=V?Ie(e,r,V,\"second\"):e+\" ms\"}function Ie(e,r,t,n){var i=r>=t*1.5;return Math.round(e/t)+\" \"+n+(i?\"s\":\"\")}});var Je=E((Mn,Br)=>{function Zt(e){t.debug=t,t.default=t,t.coerce=u,t.disable=o,t.enable=i,t.enabled=s,t.humanize=Mr(),t.destroy=d,Object.keys(e).forEach(a=>{t[a]=e[a]}),t.names=[],t.skips=[],t.formatters={};function r(a){let c=0;for(let l=0;l<a.length;l++)c=(c<<5)-c+a.charCodeAt(l),c|=0;return t.colors[Math.abs(c)%t.colors.length]}t.selectColor=r;function t(a){let c,l=null,x,g;function p(...h){if(!p.enabled)return;let v=p,w=Number(new Date),b=w-(c||w);v.diff=b,v.prev=c,v.curr=w,c=w,h[0]=t.coerce(h[0]),typeof h[0]!=\"string\"&&h.unshift(\"%O\");let U=0;h[0]=h[0].replace(/%([a-zA-Z%])/g,(ee,P)=>{if(ee===\"%%\")return\"%\";U++;let re=t.formatters[P];if(typeof re==\"function\"){let lt=h[U];ee=re.call(v,lt),h.splice(U,1),U--}return ee}),t.formatArgs.call(v,h),(v.log||t.log).apply(v,h)}return p.namespace=a,p.useColors=t.useColors(),p.color=t.selectColor(a),p.extend=n,p.destroy=t.destroy,Object.defineProperty(p,\"enabled\",{enumerable:!0,configurable:!1,get:()=>l!==null?l:(x!==t.namespaces&&(x=t.namespaces,g=t.enabled(a)),g),set:h=>{l=h}}),typeof t.init==\"function\"&&t.init(p),p}function n(a,c){let l=t(this.namespace+(typeof c==\"undefined\"?\":\":c)+a);return l.log=this.log,l}function i(a){t.save(a),t.namespaces=a,t.names=[],t.skips=[];let c,l=(typeof a==\"string\"?a:\"\").split(/[\\s,]+/),x=l.length;for(c=0;c<x;c++)!l[c]||(a=l[c].replace(/\\*/g,\".*?\"),a[0]===\"-\"?t.skips.push(new RegExp(\"^\"+a.slice(1)+\"$\")):t.names.push(new RegExp(\"^\"+a+\"$\")))}function o(){let a=[...t.names.map(f),...t.skips.map(f).map(c=>\"-\"+c)].join(\",\");return t.enable(\"\"),a}function s(a){if(a[a.length-1]===\"*\")return!0;let c,l;for(c=0,l=t.skips.length;c<l;c++)if(t.skips[c].test(a))return!1;for(c=0,l=t.names.length;c<l;c++)if(t.names[c].test(a))return!0;return!1}function f(a){return a.toString().substring(2,a.toString().length-2).replace(/\\.\\*\\?$/,\"*\")}function u(a){return a instanceof Error?a.stack||a.message:a}function d(){console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\")}return t.enable(t.load()),t}Br.exports=Zt});var qr=E((S,Le)=>{S.formatArgs=Ht;S.save=Gt;S.load=Yt;S.useColors=Wt;S.storage=$t();S.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"))}})();S.colors=[\"#0000CC\",\"#0000FF\",\"#0033CC\",\"#0033FF\",\"#0066CC\",\"#0066FF\",\"#0099CC\",\"#0099FF\",\"#00CC00\",\"#00CC33\",\"#00CC66\",\"#00CC99\",\"#00CCCC\",\"#00CCFF\",\"#3300CC\",\"#3300FF\",\"#3333CC\",\"#3333FF\",\"#3366CC\",\"#3366FF\",\"#3399CC\",\"#3399FF\",\"#33CC00\",\"#33CC33\",\"#33CC66\",\"#33CC99\",\"#33CCCC\",\"#33CCFF\",\"#6600CC\",\"#6600FF\",\"#6633CC\",\"#6633FF\",\"#66CC00\",\"#66CC33\",\"#9900CC\",\"#9900FF\",\"#9933CC\",\"#9933FF\",\"#99CC00\",\"#99CC33\",\"#CC0000\",\"#CC0033\",\"#CC0066\",\"#CC0099\",\"#CC00CC\",\"#CC00FF\",\"#CC3300\",\"#CC3333\",\"#CC3366\",\"#CC3399\",\"#CC33CC\",\"#CC33FF\",\"#CC6600\",\"#CC6633\",\"#CC9900\",\"#CC9933\",\"#CCCC00\",\"#CCCC33\",\"#FF0000\",\"#FF0033\",\"#FF0066\",\"#FF0099\",\"#FF00CC\",\"#FF00FF\",\"#FF3300\",\"#FF3333\",\"#FF3366\",\"#FF3399\",\"#FF33CC\",\"#FF33FF\",\"#FF6600\",\"#FF6633\",\"#FF9900\",\"#FF9933\",\"#FFCC00\",\"#FFCC33\"];function Wt(){return typeof window!=\"undefined\"&&window.process&&(window.process.type===\"renderer\"||window.process.__nwjs)?!0:typeof navigator!=\"undefined\"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)?!1:typeof document!=\"undefined\"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window!=\"undefined\"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator!=\"undefined\"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator!=\"undefined\"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/)}function Ht(e){if(e[0]=(this.useColors?\"%c\":\"\")+this.namespace+(this.useColors?\" %c\":\" \")+e[0]+(this.useColors?\"%c \":\" \")+\"+\"+Le.exports.humanize(this.diff),!this.useColors)return;let r=\"color: \"+this.color;e.splice(1,0,r,\"color: inherit\");let t=0,n=0;e[0].replace(/%[a-zA-Z%]/g,i=>{i!==\"%%\"&&(t++,i===\"%c\"&&(n=t))}),e.splice(n,0,r)}S.log=console.debug||console.log||(()=>{});function Gt(e){try{e?S.storage.setItem(\"debug\",e):S.storage.removeItem(\"debug\")}catch{}}function Yt(){let e;try{e=S.storage.getItem(\"debug\")}catch{}return!e&&typeof process!=\"undefined\"&&\"env\"in process&&(e=process.env.DEBUG),e}function $t(){try{return localStorage}catch{}}Le.exports=Je()(S);var{formatters:jt}=Le.exports;jt.j=function(e){try{return JSON.stringify(e)}catch(r){return\"[UnexpectedJSONParseError]: \"+r.message}}});var Zr=E((Bn,Pr)=>{\"use strict\";Pr.exports=(e,r)=>{r=r||process.argv;let t=e.startsWith(\"-\")?\"\":e.length===1?\"-\":\"--\",n=r.indexOf(t+e),i=r.indexOf(\"--\");return n!==-1&&(i===-1?!0:n<i)}});var Hr=E((qn,Wr)=>{\"use strict\";var Vt=require(\"os\"),O=Zr(),C=process.env,J;O(\"no-color\")||O(\"no-colors\")||O(\"color=false\")?J=!1:(O(\"color\")||O(\"colors\")||O(\"color=true\")||O(\"color=always\"))&&(J=!0);\"FORCE_COLOR\"in C&&(J=C.FORCE_COLOR.length===0||parseInt(C.FORCE_COLOR,10)!==0);function Kt(e){return e===0?!1:{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function Xt(e){if(J===!1)return 0;if(O(\"color=16m\")||O(\"color=full\")||O(\"color=truecolor\"))return 3;if(O(\"color=256\"))return 2;if(e&&!e.isTTY&&J!==!0)return 0;let r=J?1:0;if(process.platform===\"win32\"){let t=Vt.release().split(\".\");return Number(process.versions.node.split(\".\")[0])>=8&&Number(t[0])>=10&&Number(t[2])>=10586?Number(t[2])>=14931?3:2:1}if(\"CI\"in C)return[\"TRAVIS\",\"CIRCLECI\",\"APPVEYOR\",\"GITLAB_CI\"].some(t=>t in C)||C.CI_NAME===\"codeship\"?1:r;if(\"TEAMCITY_VERSION\"in C)return/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(C.TEAMCITY_VERSION)?1:0;if(C.COLORTERM===\"truecolor\")return 3;if(\"TERM_PROGRAM\"in C){let t=parseInt((C.TERM_PROGRAM_VERSION||\"\").split(\".\")[0],10);switch(C.TERM_PROGRAM){case\"iTerm.app\":return t>=3?3:2;case\"Apple_Terminal\":return 2}}return/-256(color)?$/i.test(C.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(C.TERM)||\"COLORTERM\"in C?1:(C.TERM===\"dumb\",r)}function Qe(e){let r=Xt(e);return Kt(r)}Wr.exports={supportsColor:Qe,stdout:Qe(process.stdout),stderr:Qe(process.stderr)}});var Yr=E((y,ze)=>{var Jt=require(\"tty\"),Oe=require(\"util\");y.init=on;y.log=rn;y.formatArgs=kt;y.save=tn;y.load=nn;y.useColors=Qt;y.destroy=Oe.deprecate(()=>{},\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");y.colors=[6,2,3,4,5,1];try{let e=Hr();e&&(e.stderr||e).level>=2&&(y.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221])}catch{}y.inspectOpts=Object.keys(process.env).filter(e=>/^debug_/i.test(e)).reduce((e,r)=>{let t=r.substring(6).toLowerCase().replace(/_([a-z])/g,(i,o)=>o.toUpperCase()),n=process.env[r];return/^(yes|on|true|enabled)$/i.test(n)?n=!0:/^(no|off|false|disabled)$/i.test(n)?n=!1:n===\"null\"?n=null:n=Number(n),e[t]=n,e},{});function Qt(){return\"colors\"in y.inspectOpts?Boolean(y.inspectOpts.colors):Jt.isatty(process.stderr.fd)}function kt(e){let{namespace:r,useColors:t}=this;if(t){let n=this.color,i=\"\\x1B[3\"+(n<8?n:\"8;5;\"+n),o=`  ${i};1m${r} \\x1B[0m`;e[0]=o+e[0].split(`\n`).join(`\n`+o),e.push(i+\"m+\"+ze.exports.humanize(this.diff)+\"\\x1B[0m\")}else e[0]=en()+r+\" \"+e[0]}function en(){return y.inspectOpts.hideDate?\"\":new Date().toISOString()+\" \"}function rn(...e){return process.stderr.write(Oe.format(...e)+`\n`)}function tn(e){e?process.env.DEBUG=e:delete process.env.DEBUG}function nn(){return process.env.DEBUG}function on(e){e.inspectOpts={};let r=Object.keys(y.inspectOpts);for(let t=0;t<r.length;t++)e.inspectOpts[r[t]]=y.inspectOpts[r[t]]}ze.exports=Je()(y);var{formatters:Gr}=ze.exports;Gr.o=function(e){return this.inspectOpts.colors=this.useColors,Oe.inspect(e,this.inspectOpts).split(`\n`).map(r=>r.trim()).join(\" \")};Gr.O=function(e){return this.inspectOpts.colors=this.useColors,Oe.inspect(e,this.inspectOpts)}});var $r=E((Pn,ke)=>{typeof process==\"undefined\"||process.type===\"renderer\"||process.browser===!0||process.__nwjs?ke.exports=qr():ke.exports=Yr()});var Kr=E((Zn,Vr)=>{Vr.exports=jr;function jr(e,r){if(e&&r)return jr(e)(r);if(typeof e!=\"function\")throw new TypeError(\"need wrapper function\");return Object.keys(e).forEach(function(n){t[n]=e[n]}),t;function t(){for(var n=new Array(arguments.length),i=0;i<n.length;i++)n[i]=arguments[i];var o=e.apply(this,n),s=n[n.length-1];return typeof o==\"function\"&&o!==s&&Object.keys(s).forEach(function(f){o[f]=s[f]}),o}}});var rr=E((Wn,er)=>{var Xr=Kr();er.exports=Xr(_e);er.exports.strict=Xr(Jr);_e.proto=_e(function(){Object.defineProperty(Function.prototype,\"once\",{value:function(){return _e(this)},configurable:!0}),Object.defineProperty(Function.prototype,\"onceStrict\",{value:function(){return Jr(this)},configurable:!0})});function _e(e){var r=function(){return r.called?r.value:(r.called=!0,r.value=e.apply(this,arguments))};return r.called=!1,r}function Jr(e){var r=function(){if(r.called)throw new Error(r.onceError);return r.called=!0,r.value=e.apply(this,arguments)},t=e.name||\"Function wrapped with `once`\";return r.onceError=t+\" shouldn't be called more than once\",r.called=!1,r}});var et=E((Hn,kr)=>{var sn=rr(),fn=function(){},an=function(e){return e.setHeader&&typeof e.abort==\"function\"},un=function(e){return e.stdio&&Array.isArray(e.stdio)&&e.stdio.length===3},Qr=function(e,r,t){if(typeof r==\"function\")return Qr(e,null,r);r||(r={}),t=sn(t||fn);var n=e._writableState,i=e._readableState,o=r.readable||r.readable!==!1&&e.readable,s=r.writable||r.writable!==!1&&e.writable,f=!1,u=function(){e.writable||d()},d=function(){s=!1,o||t.call(e)},a=function(){o=!1,s||t.call(e)},c=function(h){t.call(e,h?new Error(\"exited with error code: \"+h):null)},l=function(h){t.call(e,h)},x=function(){process.nextTick(g)},g=function(){if(!f){if(o&&!(i&&i.ended&&!i.destroyed))return t.call(e,new Error(\"premature close\"));if(s&&!(n&&n.ended&&!n.destroyed))return t.call(e,new Error(\"premature close\"))}},p=function(){e.req.on(\"finish\",d)};return an(e)?(e.on(\"complete\",d),e.on(\"abort\",x),e.req?p():e.on(\"request\",p)):s&&!n&&(e.on(\"end\",u),e.on(\"close\",u)),un(e)&&e.on(\"exit\",c),e.on(\"end\",a),e.on(\"finish\",d),r.error!==!1&&e.on(\"error\",l),e.on(\"close\",x),function(){f=!0,e.removeListener(\"complete\",d),e.removeListener(\"abort\",x),e.removeListener(\"request\",p),e.req&&e.req.removeListener(\"finish\",d),e.removeListener(\"end\",u),e.removeListener(\"close\",u),e.removeListener(\"finish\",d),e.removeListener(\"exit\",c),e.removeListener(\"end\",a),e.removeListener(\"error\",l),e.removeListener(\"close\",x)}};kr.exports=Qr});var nt=E((Gn,tt)=>{var cn=rr(),dn=et(),tr=require(\"fs\"),fe=function(){},ln=/^v?\\.0/.test(process.version),Ae=function(e){return typeof e==\"function\"},hn=function(e){return!ln||!tr?!1:(e instanceof(tr.ReadStream||fe)||e instanceof(tr.WriteStream||fe))&&Ae(e.close)},pn=function(e){return e.setHeader&&Ae(e.abort)},mn=function(e,r,t,n){n=cn(n);var i=!1;e.on(\"close\",function(){i=!0}),dn(e,{readable:r,writable:t},function(s){if(s)return n(s);i=!0,n()});var o=!1;return function(s){if(!i&&!o){if(o=!0,hn(e))return e.close(fe);if(pn(e))return e.abort();if(Ae(e.destroy))return e.destroy();n(s||new Error(\"stream was destroyed\"))}}},rt=function(e){e()},xn=function(e,r){return e.pipe(r)},vn=function(){var e=Array.prototype.slice.call(arguments),r=Ae(e[e.length-1]||fe)&&e.pop()||fe;if(Array.isArray(e[0])&&(e=e[0]),e.length<2)throw new Error(\"pump requires two streams per minimum\");var t,n=e.map(function(i,o){var s=o<e.length-1,f=o>0;return mn(i,s,f,function(u){t||(t=u),u&&n.forEach(rt),!s&&(n.forEach(rt),r(t))})});return e.reduce(xn)};tt.exports=vn});var ot=E((Yn,it)=>{\"use strict\";var{PassThrough:En}=require(\"stream\");it.exports=e=>{e={...e};let{array:r}=e,{encoding:t}=e,n=t===\"buffer\",i=!1;r?i=!(t||n):t=t||\"utf8\",n&&(t=null);let o=new En({objectMode:i});t&&o.setEncoding(t);let s=0,f=[];return o.on(\"data\",u=>{f.push(u),i?s=f.length:s+=u.length}),o.getBufferedValue=()=>r?f:n?Buffer.concat(f,s):f.join(\"\"),o.getBufferedLength=()=>s,o}});var st=E(($n,Q)=>{\"use strict\";var{constants:wn}=require(\"buffer\"),gn=nt(),yn=ot(),Re=class extends Error{constructor(){super(\"maxBuffer exceeded\"),this.name=\"MaxBufferError\"}};async function De(e,r){if(!e)return Promise.reject(new Error(\"Expected a stream\"));r={maxBuffer:1/0,...r};let{maxBuffer:t}=r,n;return await new Promise((i,o)=>{let s=f=>{f&&n.getBufferedLength()<=wn.MAX_LENGTH&&(f.bufferedData=n.getBufferedValue()),o(f)};n=gn(e,yn(r),f=>{if(f){s(f);return}i()}),n.on(\"data\",()=>{n.getBufferedLength()>t&&s(new Re)})}),n.getBufferedValue()}Q.exports=De;Q.exports.default=De;Q.exports.buffer=(e,r)=>De(e,{...r,encoding:\"buffer\"});Q.exports.array=(e,r)=>De(e,{...r,array:!0});Q.exports.MaxBufferError=Re});var at=E((jn,ft)=>{var z=$r()(\"extract-zip\"),{createWriteStream:Cn,promises:k}=require(\"fs\"),bn=st(),G=require(\"path\"),{promisify:ir}=require(\"util\"),Fn=require(\"stream\"),Sn=Xe(),In=ir(Sn.open),Ln=ir(Fn.pipeline),nr=class{constructor(r,t){this.zipPath=r,this.opts=t}async extract(){return z(\"opening\",this.zipPath,\"with opts\",this.opts),this.zipfile=await In(this.zipPath,{lazyEntries:!0}),this.canceled=!1,new Promise((r,t)=>{this.zipfile.on(\"error\",n=>{this.canceled=!0,t(n)}),this.zipfile.readEntry(),this.zipfile.on(\"close\",()=>{this.canceled||(z(\"zip extraction complete\"),r())}),this.zipfile.on(\"entry\",async n=>{if(this.canceled){z(\"skipping entry\",n.fileName,{cancelled:this.canceled});return}if(z(\"zipfile entry\",n.fileName),n.fileName.startsWith(\"__MACOSX/\")){this.zipfile.readEntry();return}let i=G.dirname(G.join(this.opts.dir,n.fileName));try{await k.mkdir(i,{recursive:!0});let o=await k.realpath(i);if(G.relative(this.opts.dir,o).split(G.sep).includes(\"..\"))throw new Error(`Out of bound path \"${o}\" found while processing file ${n.fileName}`);await this.extractEntry(n),z(\"finished processing\",n.fileName),this.zipfile.readEntry()}catch(o){this.canceled=!0,this.zipfile.close(),t(o)}})})}async extractEntry(r){if(this.canceled){z(\"skipping entry extraction\",r.fileName,{cancelled:this.canceled});return}this.opts.onEntry&&this.opts.onEntry(r,this.zipfile);let t=G.join(this.opts.dir,r.fileName),n=r.externalFileAttributes>>16&65535,i=61440,o=16384,s=40960,f=(n&i)===s,u=(n&i)===o;!u&&r.fileName.endsWith(\"/\")&&(u=!0);let d=r.versionMadeBy>>8;u||(u=d===0&&r.externalFileAttributes===16),z(\"extracting entry\",{filename:r.fileName,isDir:u,isSymlink:f});let a=this.getExtractedMode(n,u)&511,c=u?t:G.dirname(t),l={recursive:!0};if(u&&(l.mode=a),z(\"mkdir\",{dir:c,...l}),await k.mkdir(c,l),u)return;z(\"opening read stream\",t);let x=await ir(this.zipfile.openReadStream.bind(this.zipfile))(r);if(f){let g=await bn(x);z(\"creating symlink\",g,t),await k.symlink(g,t)}else await Ln(x,Cn(t,{mode:a}))}getExtractedMode(r,t){let n=r;return n===0&&(t?(this.opts.defaultDirMode&&(n=parseInt(this.opts.defaultDirMode,10)),n||(n=493)):(this.opts.defaultFileMode&&(n=parseInt(this.opts.defaultFileMode,10)),n||(n=420))),n}};ft.exports=async function(e,r){if(z(\"creating target directory\",r.dir),!G.isAbsolute(r.dir))throw new Error(\"Target directory is expected to be absolute\");return await k.mkdir(r.dir,{recursive:!0}),r.dir=await k.realpath(r.dir),new nr(e,r).extract()}});var zn={};Et(zn,{extract:()=>On,yauzl:()=>dt,yazl:()=>ct});module.exports=wt(zn);var ct=Ue(br()),dt=Ue(Xe()),ut=Ue(at()),On=ut.default;0&&(module.exports={extract,yauzl,yazl});\n","/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nmodule.exports = require('playwright-core');\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction getUserAgent() {\n  if (typeof navigator === \"object\" && \"userAgent\" in navigator) {\n    return navigator.userAgent;\n  }\n\n  if (typeof process === \"object\" && \"version\" in process) {\n    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;\n  }\n\n  return \"<environment undetectable>\";\n}\n\nexports.getUserAgent = getUserAgent;\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n",null,"function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 7292;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"inspector\");","module.exports = require(\"module\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"punycode\");","module.exports = require(\"readline\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3109);\n",""],"names":[],"sourceRoot":""}